package rimportv2

import (
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	apiv1 "the-dev-tools/spec/dist/buf/go/api/import/v1"

	"connectrpc.com/connect"
)

// TestImportV2_DeltaE2E tests the complete import flow and verifies
// that Base and Delta records are correctly streamed.
func TestImportV2_DeltaE2E(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	fixture := newIntegrationTestFixture(t)

	// 1. Create HAR with Dependency
	// Request A: Returns token (>= 8 chars for depfinder matching)
	// Request B: Uses token
	harData := []byte(`{
		"log": {
			"version": "1.2",
			"creator": {"name": "Test", "version": "1.0"},
			"entries": [
				{
					"startedDateTime": "` + time.Now().UTC().Format(time.RFC3339) + `",
					"request": {
						"method": "POST",
						"url": "https://api.com/login",
						"httpVersion": "HTTP/1.1",
						"headers": []
					},
					"response": {
						"status": 200,
						"statusText": "OK",
						"httpVersion": "HTTP/1.1",
						"headers": [{"name": "Content-Type", "value": "application/json"}],
						"content": {
							"mimeType": "application/json",
							"text": "{\"token\": \"abc-12345-xyz\"}"
						}
					}
				},
				{
					"startedDateTime": "` + time.Now().Add(1*time.Second).UTC().Format(time.RFC3339) + `",
					"request": {
						"method": "GET",
						"url": "https://api.com/profile",
						"httpVersion": "HTTP/1.1",
						"headers": [
							{"name": "Authorization", "value": "Bearer abc-12345-xyz"}
						]
					},
					"response": {
						"status": 200,
						"statusText": "OK",
						"httpVersion": "HTTP/1.1",
						"headers": [],
						"content": {"size": 0, "mimeType": "application/json"}
					}
				}
			]
		}
	}`)

	// 2. Subscribe to Streams
	// We need to capture HTTP and Header events

	// We manually subscribe to the in-memory streamers in the fixture
	// The fixture uses memory.SyncStreamer which has Subscribe method.
	// But the interface is generic.
	// Let's assume we can just listen to the channels we passed to NewImportV2RPC.
	// Actually, we passed the streamers.

	// Subscribe to HTTP Stream
	httpSub, err := fixture.streamers.Http.Subscribe(fixture.ctx, nil)
	require.NoError(t, err)

	// Subscribe to Header Stream
	headerSub, err := fixture.streamers.HttpHeader.Subscribe(fixture.ctx, nil)
	require.NoError(t, err)

	// Subscribe to Node Stream to capture Node IDs
	nodeSub, err := fixture.streamers.Node.Subscribe(fixture.ctx, nil)
	require.NoError(t, err)

	// Subscribe to Edge Stream to verify dependencies
	edgeSub, err := fixture.streamers.Edge.Subscribe(fixture.ctx, nil)
	require.NoError(t, err)

	// 3. Perform Import
	req := connect.NewRequest(&apiv1.ImportRequest{
		WorkspaceId: fixture.workspaceID.Bytes(),
		Name:        "Delta E2E Test",
		Data:        harData,
		DomainData: []*apiv1.ImportDomainData{
			{Enabled: true, Domain: "api.com", Variable: "API_HOST"},
		},
	})

	resp, err := fixture.rpc.Import(fixture.ctx, req)
	require.NoError(t, err)
	require.NotNil(t, resp)

	// Capture Node IDs
	var nodeA_ID, nodeB_ID []byte
	// We expect 2 nodes (plus maybe start node)

	// Wait for nodes
	timeoutNode := time.After(2 * time.Second)
	nodesFound := 0
	for nodesFound < 2 {
		select {
		case evt := <-nodeSub:
			if evt.Payload.Node.Name == "request_1" {
				nodeA_ID = evt.Payload.Node.NodeId
				nodesFound++
			} else if evt.Payload.Node.Name == "request_2" {
				nodeB_ID = evt.Payload.Node.NodeId
				nodesFound++
			}
		case <-timeoutNode:
			// Fallback if names don't match exactly (harv2 name generation logic)
			// We can just grab the first two request nodes we see if specific names fail
			break
		}
	}

	// If names didn't match, let's try to proceed or fail if we didn't get IDs.
	// The names are generated by generateRequestName in harv2.
	// request_1 matches first entry (Login)
	// request_2 matches second entry (Profile)

	require.NotEmpty(t, nodeA_ID, "Node A (request_1) not found")
	require.NotEmpty(t, nodeB_ID, "Node B (request_2) not found")

	// 4. Verify Edge
	// Expect an edge from Node A -> Node B
	foundEdge := false
	timeoutEdge := time.After(1 * time.Second)

	for !foundEdge {
		select {
		case evt := <-edgeSub:
			edge := evt.Payload.Edge
			if string(edge.SourceId) == string(nodeA_ID) && string(edge.TargetId) == string(nodeB_ID) {
				foundEdge = true
			}
		case <-timeoutEdge:
			t.Fatal("Timed out waiting for Edge A->B")
		}
	}
	assert.True(t, foundEdge, "Dependency edge not created")

	// 5. Verify HTTP Events (Base + Delta)
	// We expect 4 HTTP events: 2 Base, 2 Delta
	var baseB_ID, deltaB_ID []byte

	timeout := time.After(2 * time.Second)
	httpEvents := 0
	expectedHttpEvents := 4 // A(Base), A(Delta), B(Base), B(Delta)

	for httpEvents < expectedHttpEvents {
		select {
		case evt := <-httpSub:
			httpEvents++
			// After import with domain variable, URL becomes {{API_HOST}}/profile
			if strings.Contains(evt.Payload.Http.Url, "profile") {
				if evt.Payload.IsDelta {
					deltaB_ID = evt.Payload.Http.HttpId
				} else {
					baseB_ID = evt.Payload.Http.HttpId
				}
			}
		case <-timeout:
			t.Fatal("Timed out waiting for HTTP events")
		}
	}

	require.NotNil(t, baseB_ID, "Base Request B ID not found")
	require.NotNil(t, deltaB_ID, "Delta Request B ID not found")
	assert.NotEqual(t, baseB_ID, deltaB_ID)

	// 5. Verify Header Events
	// We expect headers for Request B.
	// Base Header: "Bearer abc-123", IsDelta=false
	// Delta Header: "Bearer {{...}}", IsDelta=true, ParentID=BaseHeaderID

	var baseHeaderID []byte
	foundBaseHeader := false
	foundDeltaHeader := false

	// Consume header events until timeout or we find what we need
	// Note: There might be other headers (Content-Type from req A)

	timeoutHeader := time.After(2 * time.Second)

	for {
		select {
		case evt := <-headerSub:
			h := evt.Payload.HttpHeader
			if h.Key == "Authorization" {
				t.Logf("Received Auth Header: IsDelta=%v, Value=%s", evt.Payload.IsDelta, h.Value)
				if evt.Payload.IsDelta {
					// Verify Delta Header
					if assert.Contains(t, h.Value, "{{") {
						foundDeltaHeader = true
					}
				} else {
					// Verify Base Header
					// Allow failure for debugging
					if assert.Contains(t, h.Value, "abc-123") {
						baseHeaderID = h.HttpHeaderId
						foundBaseHeader = true
					}
				}
			}

			if foundBaseHeader && foundDeltaHeader {
				goto DoneHeaders
			}
		case <-timeoutHeader:
			goto DoneHeaders
		}
	}

DoneHeaders:
	assert.True(t, foundBaseHeader, "Base Authorization header not found")
	assert.NotEmpty(t, baseHeaderID, "Base Header ID should be captured")
	assert.True(t, foundDeltaHeader, "Delta Authorization header not found")
}
