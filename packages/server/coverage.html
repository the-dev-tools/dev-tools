
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">the-dev-tools/server/cmd/server/server.go (0.0%)</option>
				
				<option value="file1">the-dev-tools/server/internal/api/api.go (0.0%)</option>
				
				<option value="file2">the-dev-tools/server/internal/api/middleware/mwauth/mwauth.go (36.2%)</option>
				
				<option value="file3">the-dev-tools/server/internal/api/middleware/mwcompress/mwcompress.go (0.0%)</option>
				
				<option value="file4">the-dev-tools/server/internal/api/rbody/rbody.go (5.9%)</option>
				
				<option value="file5">the-dev-tools/server/internal/api/rcollection/rcollection.go (36.4%)</option>
				
				<option value="file6">the-dev-tools/server/internal/api/redge/redge.go (0.0%)</option>
				
				<option value="file7">the-dev-tools/server/internal/api/renv/renv.go (65.4%)</option>
				
				<option value="file8">the-dev-tools/server/internal/api/resultapi/resultapi.go (25.9%)</option>
				
				<option value="file9">the-dev-tools/server/internal/api/rexport/rexport.go (0.0%)</option>
				
				<option value="file10">the-dev-tools/server/internal/api/rflow/rflow.go (52.7%)</option>
				
				<option value="file11">the-dev-tools/server/internal/api/rflowvariable/rflowvariable.go (75.2%)</option>
				
				<option value="file12">the-dev-tools/server/internal/api/rimport/rimport.go (72.8%)</option>
				
				<option value="file13">the-dev-tools/server/internal/api/ritemapi/ritemapi.go (64.2%)</option>
				
				<option value="file14">the-dev-tools/server/internal/api/ritemapiexample/ritemapiexample.go (26.1%)</option>
				
				<option value="file15">the-dev-tools/server/internal/api/ritemfolder/ritemfolder.go (55.6%)</option>
				
				<option value="file16">the-dev-tools/server/internal/api/rlog/rlog.go (75.0%)</option>
				
				<option value="file17">the-dev-tools/server/internal/api/rnode/rnode.go (29.7%)</option>
				
				<option value="file18">the-dev-tools/server/internal/api/rnodeexecution/rnodeexecution.go (66.0%)</option>
				
				<option value="file19">the-dev-tools/server/internal/api/rreference/rreference.go (41.2%)</option>
				
				<option value="file20">the-dev-tools/server/internal/api/rrequest/rrequest.go (67.0%)</option>
				
				<option value="file21">the-dev-tools/server/internal/api/rtag/rtag.go (59.2%)</option>
				
				<option value="file22">the-dev-tools/server/internal/api/rvar/rvar.go (74.8%)</option>
				
				<option value="file23">the-dev-tools/server/internal/api/rworkspace/rworkspace.go (46.4%)</option>
				
				<option value="file24">the-dev-tools/server/pkg/assertv2/assertv2.go (24.0%)</option>
				
				<option value="file25">the-dev-tools/server/pkg/assertv2/convert.go (23.5%)</option>
				
				<option value="file26">the-dev-tools/server/pkg/assertv2/leafs/leafjson/leafjson.go (0.0%)</option>
				
				<option value="file27">the-dev-tools/server/pkg/assertv2/leafs/leafmap/leafmap.go (0.0%)</option>
				
				<option value="file28">the-dev-tools/server/pkg/assertv2/leafs/leafmock/leafmock.go (0.0%)</option>
				
				<option value="file29">the-dev-tools/server/pkg/compress/compress.go (0.0%)</option>
				
				<option value="file30">the-dev-tools/server/pkg/customerror/customerror.go (0.0%)</option>
				
				<option value="file31">the-dev-tools/server/pkg/dbtime/dbtime.go (0.0%)</option>
				
				<option value="file32">the-dev-tools/server/pkg/depfinder/depfinder.go (93.7%)</option>
				
				<option value="file33">the-dev-tools/server/pkg/expression/expression.go (41.4%)</option>
				
				<option value="file34">the-dev-tools/server/pkg/flow/edge/edge.go (0.0%)</option>
				
				<option value="file35">the-dev-tools/server/pkg/flow/node/mocknode/mocknode.go (0.0%)</option>
				
				<option value="file36">the-dev-tools/server/pkg/flow/node/nfor/nfor.go (78.5%)</option>
				
				<option value="file37">the-dev-tools/server/pkg/flow/node/nforeach/nforeach.go (70.3%)</option>
				
				<option value="file38">the-dev-tools/server/pkg/flow/node/nif/nif.go (31.9%)</option>
				
				<option value="file39">the-dev-tools/server/pkg/flow/node/njs/njs.go (0.0%)</option>
				
				<option value="file40">the-dev-tools/server/pkg/flow/node/nnoop/nnoop.go (0.0%)</option>
				
				<option value="file41">the-dev-tools/server/pkg/flow/node/node.go (73.4%)</option>
				
				<option value="file42">the-dev-tools/server/pkg/flow/node/nrequest/nrequest.go (64.0%)</option>
				
				<option value="file43">the-dev-tools/server/pkg/flow/node/nstart/nstart.go (0.0%)</option>
				
				<option value="file44">the-dev-tools/server/pkg/flow/runner/flowlocalrunner/flowlocalrunner.go (91.7%)</option>
				
				<option value="file45">the-dev-tools/server/pkg/flow/runner/runner.go (0.0%)</option>
				
				<option value="file46">the-dev-tools/server/pkg/flow/tracking/env_wrapper.go (92.9%)</option>
				
				<option value="file47">the-dev-tools/server/pkg/flow/tracking/tracker.go (97.9%)</option>
				
				<option value="file48">the-dev-tools/server/pkg/flow/tracking/tree_builder.go (70.5%)</option>
				
				<option value="file49">the-dev-tools/server/pkg/fuzzyfinder/fuzzyfinder.go (100.0%)</option>
				
				<option value="file50">the-dev-tools/server/pkg/http/request/request.go (40.9%)</option>
				
				<option value="file51">the-dev-tools/server/pkg/http/response/response.go (0.0%)</option>
				
				<option value="file52">the-dev-tools/server/pkg/httpclient/httpclient.go (13.7%)</option>
				
				<option value="file53">the-dev-tools/server/pkg/httpclient/httpmockclient/httpmockclient.go (0.0%)</option>
				
				<option value="file54">the-dev-tools/server/pkg/idwrap/idwrap.go (18.9%)</option>
				
				<option value="file55">the-dev-tools/server/pkg/io/yamlflow/yamlflowsimple/export_clean.go (82.4%)</option>
				
				<option value="file56">the-dev-tools/server/pkg/io/yamlflow/yamlflowsimple/import.go (28.7%)</option>
				
				<option value="file57">the-dev-tools/server/pkg/io/yamlflow/yamlflowsimple/positioning.go (96.2%)</option>
				
				<option value="file58">the-dev-tools/server/pkg/io/yamlflow/yamlflowsimple/variables.go (100.0%)</option>
				
				<option value="file59">the-dev-tools/server/pkg/io/yamlflow/yamlflowsimple/yamlflowsimple.go (90.3%)</option>
				
				<option value="file60">the-dev-tools/server/pkg/ioworkspace/ioworkspace.go (75.1%)</option>
				
				<option value="file61">the-dev-tools/server/pkg/logconsole/logconsole.go (0.0%)</option>
				
				<option value="file62">the-dev-tools/server/pkg/logger/mocklogger/mocklogger.go (0.0%)</option>
				
				<option value="file63">the-dev-tools/server/pkg/migrate/migrate.go (78.3%)</option>
				
				<option value="file64">the-dev-tools/server/pkg/model/massert/massert.go (0.0%)</option>
				
				<option value="file65">the-dev-tools/server/pkg/model/mbodyform/mbodyform.go (0.0%)</option>
				
				<option value="file66">the-dev-tools/server/pkg/model/mbodyurl/mbodyurl.go (0.0%)</option>
				
				<option value="file67">the-dev-tools/server/pkg/model/mcollection/mcollection.go (0.0%)</option>
				
				<option value="file68">the-dev-tools/server/pkg/model/mexampleheader/mexampleheader.go (0.0%)</option>
				
				<option value="file69">the-dev-tools/server/pkg/model/mexamplequery/mexamplequery.go (0.0%)</option>
				
				<option value="file70">the-dev-tools/server/pkg/model/mflowvariable/mflowvariable.go (0.0%)</option>
				
				<option value="file71">the-dev-tools/server/pkg/model/mitemapiexample/mitemapiexample.go (0.0%)</option>
				
				<option value="file72">the-dev-tools/server/pkg/model/mnnode/mnode.go (0.0%)</option>
				
				<option value="file73">the-dev-tools/server/pkg/model/mnodeexecution/mnodeexecution.go (0.0%)</option>
				
				<option value="file74">the-dev-tools/server/pkg/model/mworkspace/mworkspace.go (0.0%)</option>
				
				<option value="file75">the-dev-tools/server/pkg/model/result/mresultapi/mresultapi.go (0.0%)</option>
				
				<option value="file76">the-dev-tools/server/pkg/permcheck/permcheck.go (0.0%)</option>
				
				<option value="file77">the-dev-tools/server/pkg/reference/reference.go (24.3%)</option>
				
				<option value="file78">the-dev-tools/server/pkg/referencecompletion/referencecompletion.go (80.5%)</option>
				
				<option value="file79">the-dev-tools/server/pkg/service/flow/sedge/sedge.go (0.0%)</option>
				
				<option value="file80">the-dev-tools/server/pkg/service/sassert/sassert.go (0.0%)</option>
				
				<option value="file81">the-dev-tools/server/pkg/service/sassertres/sassertres.go (0.0%)</option>
				
				<option value="file82">the-dev-tools/server/pkg/service/sbodyform/sbodyform.go (0.0%)</option>
				
				<option value="file83">the-dev-tools/server/pkg/service/sbodyraw/sbodyraw.go (0.0%)</option>
				
				<option value="file84">the-dev-tools/server/pkg/service/sbodyurl/sbodyurl.go (0.0%)</option>
				
				<option value="file85">the-dev-tools/server/pkg/service/scollection/repository.go (44.0%)</option>
				
				<option value="file86">the-dev-tools/server/pkg/service/scollection/scollection.go (67.9%)</option>
				
				<option value="file87">the-dev-tools/server/pkg/service/scollectionitem/repository.go (40.9%)</option>
				
				<option value="file88">the-dev-tools/server/pkg/service/scollectionitem/service.go (31.7%)</option>
				
				<option value="file89">the-dev-tools/server/pkg/service/senv/repository.go (0.0%)</option>
				
				<option value="file90">the-dev-tools/server/pkg/service/senv/senv.go (0.0%)</option>
				
				<option value="file91">the-dev-tools/server/pkg/service/sexampleheader/sexampleheader.go (0.0%)</option>
				
				<option value="file92">the-dev-tools/server/pkg/service/sexamplequery/sexamplequery.go (0.0%)</option>
				
				<option value="file93">the-dev-tools/server/pkg/service/sexampleresp/sexampleresp.go (0.0%)</option>
				
				<option value="file94">the-dev-tools/server/pkg/service/sexamplerespheader/sexamplerespheader.go (0.0%)</option>
				
				<option value="file95">the-dev-tools/server/pkg/service/sflow/sflow.go (0.0%)</option>
				
				<option value="file96">the-dev-tools/server/pkg/service/sflowtag/sflowtag.go (0.0%)</option>
				
				<option value="file97">the-dev-tools/server/pkg/service/sflowvariable/repository.go (0.0%)</option>
				
				<option value="file98">the-dev-tools/server/pkg/service/sflowvariable/sflowvariable.go (0.0%)</option>
				
				<option value="file99">the-dev-tools/server/pkg/service/sitemapi/sitemapi.go (0.0%)</option>
				
				<option value="file100">the-dev-tools/server/pkg/service/sitemapiexample/repository.go (49.2%)</option>
				
				<option value="file101">the-dev-tools/server/pkg/service/sitemapiexample/sitemapiexample.go (20.1%)</option>
				
				<option value="file102">the-dev-tools/server/pkg/service/sitemfolder/sitemfolder.go (0.0%)</option>
				
				<option value="file103">the-dev-tools/server/pkg/service/snode/snode.go (0.0%)</option>
				
				<option value="file104">the-dev-tools/server/pkg/service/snodeexecution/snodeexecution.go (37.5%)</option>
				
				<option value="file105">the-dev-tools/server/pkg/service/snodefor/snodefor.go (0.0%)</option>
				
				<option value="file106">the-dev-tools/server/pkg/service/snodeforeach/snodeforeach.go (0.0%)</option>
				
				<option value="file107">the-dev-tools/server/pkg/service/snodeif/snodeif.go (0.0%)</option>
				
				<option value="file108">the-dev-tools/server/pkg/service/snodejs/snodejs.go (0.0%)</option>
				
				<option value="file109">the-dev-tools/server/pkg/service/snodenoop/snodenoop.go (0.0%)</option>
				
				<option value="file110">the-dev-tools/server/pkg/service/snoderequest/snoderequest.go (0.0%)</option>
				
				<option value="file111">the-dev-tools/server/pkg/service/stag/stag.go (0.0%)</option>
				
				<option value="file112">the-dev-tools/server/pkg/service/suser/suser.go (0.0%)</option>
				
				<option value="file113">the-dev-tools/server/pkg/service/svar/repository.go (0.7%)</option>
				
				<option value="file114">the-dev-tools/server/pkg/service/svar/svar.go (4.2%)</option>
				
				<option value="file115">the-dev-tools/server/pkg/service/sworkspace/repository.go (0.7%)</option>
				
				<option value="file116">the-dev-tools/server/pkg/service/sworkspace/sworkspace.go (25.7%)</option>
				
				<option value="file117">the-dev-tools/server/pkg/service/sworkspacesusers/sworkspaceusers.go (0.0%)</option>
				
				<option value="file118">the-dev-tools/server/pkg/sort/sortenabled/sortenabled.go (100.0%)</option>
				
				<option value="file119">the-dev-tools/server/pkg/stoken/stoken.go (84.0%)</option>
				
				<option value="file120">the-dev-tools/server/pkg/testutil/testutil.go (0.0%)</option>
				
				<option value="file121">the-dev-tools/server/pkg/translate/tassert/tassert.go (0.0%)</option>
				
				<option value="file122">the-dev-tools/server/pkg/translate/tbodyform/tbodyform.go (0.0%)</option>
				
				<option value="file123">the-dev-tools/server/pkg/translate/tbodyurl/tbodyurl.go (0.0%)</option>
				
				<option value="file124">the-dev-tools/server/pkg/translate/tbreadcrumbs/tbreadcrumbs.go (0.0%)</option>
				
				<option value="file125">the-dev-tools/server/pkg/translate/tcollection/tcollection.go (0.0%)</option>
				
				<option value="file126">the-dev-tools/server/pkg/translate/tcondition/tcondition.go (0.0%)</option>
				
				<option value="file127">the-dev-tools/server/pkg/translate/tcurl/tcurl.go (81.0%)</option>
				
				<option value="file128">the-dev-tools/server/pkg/translate/tenv/tenv.go (0.0%)</option>
				
				<option value="file129">the-dev-tools/server/pkg/translate/texample/texample.go (0.0%)</option>
				
				<option value="file130">the-dev-tools/server/pkg/translate/texampleresp/texampleresp.go (0.0%)</option>
				
				<option value="file131">the-dev-tools/server/pkg/translate/texampleversion/texampleversion.go (0.0%)</option>
				
				<option value="file132">the-dev-tools/server/pkg/translate/tflow/tflow.go (0.0%)</option>
				
				<option value="file133">the-dev-tools/server/pkg/translate/tflowvariable/tflowvariable.go (0.0%)</option>
				
				<option value="file134">the-dev-tools/server/pkg/translate/tflowversion/tflowversion.go (0.0%)</option>
				
				<option value="file135">the-dev-tools/server/pkg/translate/tfolder/tfolder.go (0.0%)</option>
				
				<option value="file136">the-dev-tools/server/pkg/translate/tgeneric/tgeneric.go (0.0%)</option>
				
				<option value="file137">the-dev-tools/server/pkg/translate/thar/thar.go (83.4%)</option>
				
				<option value="file138">the-dev-tools/server/pkg/translate/theader/theader.go (0.0%)</option>
				
				<option value="file139">the-dev-tools/server/pkg/translate/titemapi/titemapi.go (0.0%)</option>
				
				<option value="file140">the-dev-tools/server/pkg/translate/tnodeexecution/tnodeexecution.go (0.0%)</option>
				
				<option value="file141">the-dev-tools/server/pkg/translate/tpostman/tpostman.go (65.0%)</option>
				
				<option value="file142">the-dev-tools/server/pkg/translate/tquery/tquery.go (0.0%)</option>
				
				<option value="file143">the-dev-tools/server/pkg/translate/ttag/ttag.go (0.0%)</option>
				
				<option value="file144">the-dev-tools/server/pkg/translate/tvar/tvar.go (0.0%)</option>
				
				<option value="file145">the-dev-tools/server/pkg/translate/tworkspace/tworkspace.go (0.0%)</option>
				
				<option value="file146">the-dev-tools/server/pkg/varsystem/varsystem.go (73.4%)</option>
				
				<option value="file147">the-dev-tools/server/pkg/zstdcompress/zstdcompress.go (7.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "log"
        "log/slog"
        "os"
        "os/signal"
        "syscall"
        devtoolsdb "the-dev-tools/db"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/db/pkg/tursolocal"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/middleware/mwauth"
        "the-dev-tools/server/internal/api/middleware/mwcompress"
        "the-dev-tools/server/internal/api/rbody"
        "the-dev-tools/server/internal/api/rcollection"
        "the-dev-tools/server/internal/api/rcollectionitem"
        "the-dev-tools/server/internal/api/redge"
        "the-dev-tools/server/internal/api/renv"
        "the-dev-tools/server/internal/api/resultapi"
        "the-dev-tools/server/internal/api/rexport"
        "the-dev-tools/server/internal/api/rflow"
        "the-dev-tools/server/internal/api/rflowvariable"
        "the-dev-tools/server/internal/api/rimport"
        "the-dev-tools/server/internal/api/ritemapi"
        "the-dev-tools/server/internal/api/ritemapiexample"
        "the-dev-tools/server/internal/api/ritemfolder"
        "the-dev-tools/server/internal/api/rlog"
        "the-dev-tools/server/internal/api/rnode"
        "the-dev-tools/server/internal/api/rnodeexecution"
        "the-dev-tools/server/internal/api/rreference"
        "the-dev-tools/server/internal/api/rrequest"
        "the-dev-tools/server/internal/api/rtag"
        "the-dev-tools/server/internal/api/rvar"
        "the-dev-tools/server/internal/api/rworkspace"
        "the-dev-tools/server/pkg/logconsole"
        "the-dev-tools/server/pkg/model/muser"
        "the-dev-tools/server/pkg/service/flow/sedge"
        "the-dev-tools/server/pkg/service/sassert"
        "the-dev-tools/server/pkg/service/sassertres"
        "the-dev-tools/server/pkg/service/sbodyform"
        "the-dev-tools/server/pkg/service/sbodyraw"
        "the-dev-tools/server/pkg/service/sbodyurl"
        "the-dev-tools/server/pkg/service/scollection"
        "the-dev-tools/server/pkg/service/scollectionitem"
        "the-dev-tools/server/pkg/service/senv"
        "the-dev-tools/server/pkg/service/sexampleheader"
        "the-dev-tools/server/pkg/service/sexamplequery"
        "the-dev-tools/server/pkg/service/sexampleresp"
        "the-dev-tools/server/pkg/service/sexamplerespheader"
        "the-dev-tools/server/pkg/service/sflow"
        "the-dev-tools/server/pkg/service/sflowtag"
        "the-dev-tools/server/pkg/service/sflowvariable"
        "the-dev-tools/server/pkg/service/sitemapi"
        "the-dev-tools/server/pkg/service/sitemapiexample"
        "the-dev-tools/server/pkg/service/sitemfolder"
        "the-dev-tools/server/pkg/service/snode"
        "the-dev-tools/server/pkg/service/snodeexecution"
        "the-dev-tools/server/pkg/service/snodefor"
        "the-dev-tools/server/pkg/service/snodeforeach"
        "the-dev-tools/server/pkg/service/snodeif"
        "the-dev-tools/server/pkg/service/snodejs"
        "the-dev-tools/server/pkg/service/snodenoop"
        "the-dev-tools/server/pkg/service/snoderequest"
        "the-dev-tools/server/pkg/service/stag"
        "the-dev-tools/server/pkg/service/suser"
        "the-dev-tools/server/pkg/service/svar"
        "the-dev-tools/server/pkg/service/sworkspace"
        "the-dev-tools/server/pkg/service/sworkspacesusers"

        "connectrpc.com/connect"
)

func main() <span class="cov0" title="0">{
        sc := make(chan os.Signal, 1)
        signal.Notify(sc, syscall.SIGINT, syscall.SIGTERM, os.Interrupt)

        var logLevel slog.Level
        logLevelStr := os.Getenv("LOG_LEVEL")
        switch logLevelStr </span>{
        case "DEBUG":<span class="cov0" title="0">
                logLevel = slog.LevelDebug</span>
        case "INFO":<span class="cov0" title="0">
                logLevel = slog.LevelInfo</span>
        case "WARNING":<span class="cov0" title="0">
                logLevel = slog.LevelWarn</span>
        case "ERROR":<span class="cov0" title="0">
                logLevel = slog.LevelError</span>
        default:<span class="cov0" title="0">
                logLevel = slog.LevelError</span>
        }

        <span class="cov0" title="0">loggerHandler := slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{
                Level: logLevel,
        })

        logger := slog.New(loggerHandler)

        ctx := context.Background()
        ctx, cancel := context.WithCancel(ctx)
        defer cancel()

        // Environment variables
        port := os.Getenv("PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "8080"
        }</span>

        <span class="cov0" title="0">hmacSecret := os.Getenv("HMAC_SECRET")
        if hmacSecret == "" </span><span class="cov0" title="0">{
                log.Fatal(errors.New("HMAC_SECRET env var is required"))
        }</span>

        <span class="cov0" title="0">dbMode := os.Getenv("DB_MODE")
        if dbMode == "" </span><span class="cov0" title="0">{
                log.Fatal(errors.New("DB_MODE env var is required"))
        }</span>
        <span class="cov0" title="0">fmt.Println("DB_MODE: ", dbMode)

        var currentDB *sql.DB
        var dbCloseFunc func()
        var err error
        switch dbMode </span>{
        case devtoolsdb.LOCAL:<span class="cov0" title="0">
                currentDB, dbCloseFunc, err = GetDBLocal(ctx)</span>
        default:<span class="cov0" title="0">
                err = errors.New("invalid db mode")</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer dbCloseFunc()

        queries, err := gen.Prepare(ctx, currentDB)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">collectionService := scollection.New(queries, logger)
        collectionItemService := scollectionitem.New(queries, logger)
        workspaceService := sworkspace.New(queries)
        workspaceUserService := sworkspacesusers.New(queries)
        userService := suser.New(queries)
        endpointService := sitemapi.New(queries)
        folderService := sitemfolder.New(queries)
        exampleService := sitemapiexample.New(queries)
        exampleHeaderService := sexampleheader.New(queries)
        exampleQueryService := sexamplequery.New(queries)
        bodyRawService := sbodyraw.New(queries)
        bodyFormService := sbodyform.New(queries)
        bodyUrlService := sbodyurl.New(queries)
        exampleResponseService := sexampleresp.New(queries)
        exampleResponseHeaderService := sexamplerespheader.New(queries)
        assertService := sassert.New(queries)
        assertResultService := sassertres.New(queries)
        variableService := svar.New(queries, logger)
        environmentService := senv.New(queries, logger)
        tagService := stag.New(queries)

        // Flow
        flowService := sflow.New(queries)
        flowTagService := sflowtag.New(queries)
        flowEdgeService := sedge.New(queries)
        flowVariableService := sflowvariable.New(queries)

        // nodes
        flowNodeService := snode.New(queries)
        flowNodeRequestSevice := snoderequest.New(queries)
        flowNodeForService := snodefor.New(queries)
        flowNodeForeachService := snodeforeach.New(queries)
        flowNodeCondition := snodeif.New(queries)
        flowNodeNoOpService := snodenoop.New(queries)
        flowNodeJsService := snodejs.New(queries)
        nodeExecutionService := snodeexecution.New(queries)

        // log/console
        logMap := logconsole.NewLogChanMap()

        var optionsCompress, optionsAuth, opitonsAll []connect.HandlerOption
        optionsCompress = append(optionsCompress, connect.WithCompression("zstd", mwcompress.NewDecompress, mwcompress.NewCompress))
        optionsCompress = append(optionsCompress, connect.WithCompression("gzip", nil, nil))
        _, err = userService.GetUser(ctx, mwauth.LocalDummyID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, suser.ErrUserNotFound) </span><span class="cov0" title="0">{
                        defaultUser := &amp;muser.User{
                                ID: mwauth.LocalDummyID,
                        }
                        err = userService.CreateUser(ctx, defaultUser)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        log.Fatal(err)
                }</span>
        }

        <span class="cov0" title="0">optionsAuth = append(optionsCompress, connect.WithInterceptors(mwauth.NewAuthInterceptor()))
        opitonsAll = append(optionsAuth, optionsCompress...)

        // Services Connect RPC
        newServiceManager := NewServiceManager(30)

        workspaceSrv := rworkspace.New(currentDB, workspaceService, workspaceUserService, userService, environmentService)
        newServiceManager.AddService(rworkspace.CreateService(workspaceSrv, opitonsAll))

        // Collection Service
        collectionSrv := rcollection.New(currentDB, collectionService, workspaceService,
                userService)
        newServiceManager.AddService(rcollection.CreateService(collectionSrv, opitonsAll))

        // Collection Item Service
        collectionItemSrv := rcollectionitem.New(currentDB, collectionService, collectionItemService, userService, folderService, endpointService, exampleService, exampleResponseService)
        newServiceManager.AddService(rcollectionitem.CreateService(collectionItemSrv, opitonsAll))

        // Result API Service
        resultapiSrv := resultapi.New(currentDB, userService, collectionService, endpointService, exampleService, workspaceService, exampleResponseService, exampleResponseHeaderService, assertService, assertResultService)
        newServiceManager.AddService(resultapi.CreateService(resultapiSrv, opitonsAll))

        // Item API Service
        itemapiSrv := ritemapi.New(currentDB, endpointService, collectionService,
                folderService, userService, exampleService, exampleResponseService, collectionItemService)
        newServiceManager.AddService(ritemapi.CreateService(itemapiSrv, opitonsAll))

        // Folder API Service
        folderItemSrv := ritemfolder.New(currentDB, folderService, userService, collectionService, collectionItemService)
        newServiceManager.AddService(ritemfolder.CreateService(folderItemSrv, opitonsAll))

        // Api Item Example
        itemApiExampleSrv := ritemapiexample.New(currentDB, exampleService, endpointService, folderService,
                workspaceService, collectionService, userService, exampleHeaderService, exampleQueryService, bodyFormService, bodyUrlService,
                bodyRawService, exampleResponseHeaderService, exampleResponseService, environmentService, variableService, assertService, assertResultService, logMap)
        newServiceManager.AddService(ritemapiexample.CreateService(itemApiExampleSrv, opitonsAll))

        requestSrv := rrequest.New(currentDB, collectionService, userService, endpointService, exampleService, exampleHeaderService, exampleQueryService, assertService)
        newServiceManager.AddService(rrequest.CreateService(requestSrv, opitonsAll))

        // BodyRaw Service
        bodySrv := rbody.New(currentDB, collectionService, exampleService, userService, bodyFormService, bodyUrlService, bodyRawService)
        newServiceManager.AddService(rbody.CreateService(bodySrv, opitonsAll))

        // Env Service
        envSrv := renv.New(currentDB, environmentService, variableService, userService)
        newServiceManager.AddService(renv.CreateService(envSrv, opitonsAll))

        // Var Service
        varSrv := rvar.New(currentDB, userService, environmentService, variableService)
        newServiceManager.AddService(rvar.CreateService(varSrv, opitonsAll))

        tagSrv := rtag.New(currentDB, workspaceService, userService, tagService)
        newServiceManager.AddService(rtag.CreateService(tagSrv, opitonsAll))

        // Flow Service
        flowSrv := rflow.New(currentDB, workspaceService, userService, tagService,
                // flow
                flowService, flowTagService, flowEdgeService, flowVariableService,
                // req
                endpointService, exampleService, exampleQueryService, exampleHeaderService,
                // body
                bodyRawService, bodyFormService, bodyUrlService,
                // resp
                exampleResponseService, exampleResponseHeaderService, assertService, assertResultService,
                // subnodes
                flowNodeService, flowNodeRequestSevice, flowNodeForService, flowNodeForeachService,
                flowNodeNoOpService, *flowNodeCondition, flowNodeJsService, nodeExecutionService, logMap)
        newServiceManager.AddService(rflow.CreateService(flowSrv, opitonsAll))

        // Node Service
        nodeSrv := rnode.NewNodeServiceRPC(currentDB, userService,
                flowService, *flowNodeCondition,
                flowNodeRequestSevice, flowNodeForService, flowNodeForeachService, flowNodeService, flowNodeNoOpService, flowNodeJsService,
                endpointService, exampleService, exampleQueryService, exampleHeaderService, bodyRawService, bodyFormService, bodyUrlService,
                nodeExecutionService)
        newServiceManager.AddService(rnode.CreateService(nodeSrv, opitonsAll))

        // NodeExecution Service
        nodeExecutionSrv := rnodeexecution.New(&amp;nodeExecutionService, &amp;flowNodeService, &amp;flowService, &amp;userService, &amp;exampleResponseService, &amp;flowNodeRequestSevice)
        nodeExecutionService_svc, err := rnodeexecution.CreateService(nodeExecutionSrv, opitonsAll)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">newServiceManager.AddService(nodeExecutionService_svc, err)

        // Edge Service
        edgeSrv := redge.NewEdgeServiceRPC(currentDB, flowService, userService, flowEdgeService, flowNodeService)
        newServiceManager.AddService(redge.CreateService(edgeSrv, opitonsAll))

        // Log Service
        logSrv := rlog.NewRlogRPC(logMap)
        newServiceManager.AddService(rlog.CreateService(logSrv, opitonsAll))

        // Refernce Service
        refServiceRPC := rreference.NewNodeServiceRPC(currentDB, userService, workspaceService, environmentService, variableService, exampleResponseService, exampleResponseHeaderService,
                flowService, flowNodeService, flowNodeRequestSevice, flowVariableService, flowEdgeService, nodeExecutionService)
        newServiceManager.AddService(rreference.CreateService(refServiceRPC, opitonsAll))

        importServiceRPC := rimport.New(currentDB, workspaceService, collectionService, userService, folderService, endpointService, exampleService, exampleResponseService, assertService)
        importService, err := rimport.CreateService(importServiceRPC, opitonsAll)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">newServiceManager.AddService(importService, err)

        flowServiceRPC := rflowvariable.New(currentDB, flowService, userService, flowVariableService)
        newServiceManager.AddService(rflowvariable.CreateService(flowServiceRPC, opitonsAll))

        exportServiceRPC := rexport.New(
                currentDB,
                workspaceService, collectionService, folderService,
                endpointService, exampleService, exampleHeaderService, exampleQueryService, assertService,
                bodyRawService, bodyFormService, bodyUrlService,
                exampleResponseService, exampleResponseHeaderService, assertResultService,
                // flow
                flowService,
                // nodes
                flowNodeService, flowEdgeService, flowVariableService, flowNodeRequestSevice,
                *flowNodeCondition, flowNodeNoOpService,
                flowNodeForService, flowNodeForeachService, flowNodeJsService,
                environmentService, variableService,
        )
        exportService, err := rexport.CreateService(exportServiceRPC, opitonsAll)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">newServiceManager.AddService(exportService, err)

        // Start services
        go func() </span><span class="cov0" title="0">{
                err := api.ListenServices(newServiceManager.GetServices(), port)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
        }()

        // Wait for signal
        <span class="cov0" title="0">&lt;-sc</span>
}

type ServiceManager struct {
        s []api.Service
}

// size is not max size, but initial allocation size for the slice
func NewServiceManager(size int) *ServiceManager <span class="cov0" title="0">{
        return &amp;ServiceManager{
                s: make([]api.Service, 0, size),
        }
}</span>

func (sm *ServiceManager) AddService(s *api.Service, e error) <span class="cov0" title="0">{
        if e != nil </span><span class="cov0" title="0">{
                log.Fatalf("error: %v on %s", e, s.Path)
        }</span>
        <span class="cov0" title="0">if s == nil </span><span class="cov0" title="0">{
                log.Fatalf("service is nil on %d", len(sm.s))
        }</span>
        <span class="cov0" title="0">sm.s = append(sm.s, *s)</span>
}

func (sm *ServiceManager) GetServices() []api.Service <span class="cov0" title="0">{
        return sm.s
}</span>

func GetDBLocal(ctx context.Context) (*sql.DB, func(), error) <span class="cov0" title="0">{
        dbName := os.Getenv("DB_NAME")
        if dbName == "" </span><span class="cov0" title="0">{
                return nil, nil, errors.New("DB_NAME env var is required")
        }</span>
        <span class="cov0" title="0">dbPath := os.Getenv("DB_PATH")
        if dbPath == "" </span><span class="cov0" title="0">{
                return nil, nil, errors.New("DB_PATH env var is required")
        }</span>
        <span class="cov0" title="0">encryptKey := os.Getenv("DB_ENCRYPTION_KEY")
        if encryptKey == "" </span><span class="cov0" title="0">{
                return nil, nil, errors.New("DB_ENCRYPT_KEY env var is required")
        }</span>
        <span class="cov0" title="0">db, a, err := tursolocal.NewTursoLocal(ctx, dbName, dbPath, encryptKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return db, a, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "log"
        "net/http"
        "time"

        "github.com/rs/cors"
        "golang.org/x/net/http2"
        "golang.org/x/net/http2/h2c"
)

type Service struct {
        Handler http.Handler
        Path    string
}

type ServerStreamAdHoc[Res any] interface {
        Send(*Res) error
}

type ClientStreamAdHoc[Req any] interface {
        Receive() (*Req, error)
}

type FullStreamAdHoc[Req, Res any] interface {
        Send(*Res) error
        Receive() (*Req, error)
}

func newCORS() *cors.Cors <span class="cov0" title="0">{
        return cors.New(cors.Options{
                AllowedMethods: []string{
                        http.MethodHead,
                        http.MethodGet,
                        http.MethodPost,
                        http.MethodPut,
                        http.MethodPatch,
                        http.MethodDelete,
                },
                AllowOriginFunc: func(origin string) bool </span><span class="cov0" title="0">{
                        return true
                }</span>,
                AllowedHeaders: []string{"*"},
                ExposedHeaders: []string{
                        "Accept",
                        "Accept-Encoding",
                        "Accept-Post",
                        "Connect-Accept-Encoding",
                        "Connect-Content-Encoding",
                        "Content-Encoding",
                        "Grpc-Accept-Encoding",
                        "Grpc-Encoding",
                        "Grpc-Message",
                        "Grpc-Status",
                        "Grpc-Status-Details-Bin",
                },
                MaxAge: int(time.Second),
        })
}

func ListenServices(services []Service, port string) error <span class="cov0" title="0">{
        mux := http.NewServeMux()

        for _, service := range services </span><span class="cov0" title="0">{
                log.Printf("Registering service %s", service.Path)
                mux.Handle(service.Path, service.Handler)
        }</span>

        <span class="cov0" title="0">return http.ListenAndServe(
                ":"+port,
                // INFO: Use h2c so we can serve HTTP/2 without TLS.
                h2c.NewHandler(newCORS().Handler(mux), &amp;http2.Server{
                        IdleTimeout:          0,
                        MaxConcurrentStreams: 100000,
                        MaxHandlers:          0,
                }),
        )</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package mwauth

import (
        "context"
        "errors"
        "log"
        "strings"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/stoken"

        "connectrpc.com/connect"
)

type ContextKey int

const (
        UserIDKeyCtx ContextKey = iota
        WorkspaceIDKeyCtx
)

const LocalDummyIDStr = "00000000000000000000000000"

var LocalDummyID = idwrap.NewTextMust(LocalDummyIDStr)

type authInterceptor struct{}

func NewAuthInterceptor() *authInterceptor <span class="cov0" title="0">{
        return &amp;authInterceptor{}
}</span>

func (i *authInterceptor) WrapUnary(next connect.UnaryFunc) connect.UnaryFunc <span class="cov0" title="0">{
        // Same as previous UnaryInterceptorFunc.
        return connect.UnaryFunc(func(
                ctx context.Context,
                req connect.AnyRequest,
        ) (connect.AnyResponse, error) </span><span class="cov0" title="0">{
                return next(CreateAuthedContext(ctx, LocalDummyID), req)
        }</span>)
}

func (*authInterceptor) WrapStreamingClient(next connect.StreamingClientFunc) connect.StreamingClientFunc <span class="cov0" title="0">{
        return connect.StreamingClientFunc(func(
                ctx context.Context,
                spec connect.Spec,
        ) connect.StreamingClientConn </span><span class="cov0" title="0">{
                conn := next(CreateAuthedContext(ctx, LocalDummyID), spec)
                return conn
        }</span>)
}

func (i *authInterceptor) WrapStreamingHandler(next connect.StreamingHandlerFunc) connect.StreamingHandlerFunc <span class="cov0" title="0">{
        return connect.StreamingHandlerFunc(func(
                ctx context.Context,
                conn connect.StreamingHandlerConn,
        ) error </span><span class="cov0" title="0">{
                return next(CreateAuthedContext(ctx, LocalDummyID), conn)
        }</span>)
}

func NewAuthInterceptorOne(secret []byte) connect.UnaryInterceptorFunc <span class="cov8" title="1">{
        data := AuthInterceptorData{secret: secret}
        interceptor := func(next connect.UnaryFunc) connect.UnaryFunc </span><span class="cov8" title="1">{
                return connect.UnaryFunc(func(
                        ctx context.Context,
                        req connect.AnyRequest,
                ) (connect.AnyResponse, error) </span><span class="cov8" title="1">{
                        return data.AuthInterceptor(ctx, req, next)
                }</span>)
        }
        <span class="cov8" title="1">return connect.UnaryInterceptorFunc(interceptor)</span>
}

func NewAuthInterceptorLocal() connect.UnaryInterceptorFunc <span class="cov0" title="0">{
        interceptor := func(next connect.UnaryFunc) connect.UnaryFunc </span><span class="cov0" title="0">{
                return connect.UnaryFunc(func(
                        ctx context.Context,
                        req connect.AnyRequest,
                ) (connect.AnyResponse, error) </span><span class="cov0" title="0">{
                        return AuthInterceptorLocal(ctx, req, next)
                }</span>)
        }
        <span class="cov0" title="0">return connect.UnaryInterceptorFunc(interceptor)</span>
}

type AuthInterceptorData struct {
        secret []byte
}

func CreateAuthedContext(ctx context.Context, userID idwrap.IDWrap) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, UserIDKeyCtx, userID)
}</span>

func (authData AuthInterceptorData) AuthInterceptor(ctx context.Context, req connect.AnyRequest, next connect.UnaryFunc) (connect.AnyResponse, error) <span class="cov8" title="1">{
        headerValue := req.Header().Get(stoken.TokenHeaderKey)
        if headerValue == "" </span><span class="cov8" title="1">{
                // Check token in handlers.
                return nil, connect.NewError(
                        connect.CodeUnauthenticated,
                        errors.New("no token provided"),
                )
        }</span>

        <span class="cov8" title="1">tokenRaw := strings.Split(headerValue, "Bearer ")
        if len(tokenRaw) != 2 </span><span class="cov8" title="1">{
                return nil, connect.NewError(
                        connect.CodeUnauthenticated, errors.New("invalid token"))
        }</span>

        <span class="cov8" title="1">claims, err := stoken.ValidateJWT(tokenRaw[1], stoken.AccessToken, authData.secret)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Error validating JWT token:", err)
                return nil, connect.NewError(connect.CodeUnauthenticated, err)
        }</span>

        <span class="cov8" title="1">ID, err := idwrap.NewText(claims.Subject)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Error creating ID from claims.Subject:", err)
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">return next(CreateAuthedContext(ctx, ID), req)</span>
}

func AuthInterceptorLocal(ctx context.Context, req connect.AnyRequest, next connect.UnaryFunc) (connect.AnyResponse, error) <span class="cov0" title="0">{
        return next(CreateAuthedContext(ctx, LocalDummyID), req)
}</span>

func AuthInterceptorLocalStreamHandlerLocal(next connect.StreamingHandlerFunc) connect.StreamingHandlerFunc <span class="cov0" title="0">{
        return connect.StreamingHandlerFunc(func(
                ctx context.Context,
                conn connect.StreamingHandlerConn,
        ) error </span><span class="cov0" title="0">{
                return next(CreateAuthedContext(ctx, LocalDummyID), conn)
        }</span>)
}

func CrashInterceptor(ctx context.Context, req connect.AnyRequest, next connect.UnaryFunc) (resp connect.AnyResponse, err error) <span class="cov0" title="0">{
        if req.Spec().IsClient </span><span class="cov0" title="0">{
                return next(ctx, req)
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                // recover from panic if one occurred and return an error
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = connect.NewError(connect.CodeInternal, err)
                        resp = nil
                }</span>
        }()
        <span class="cov0" title="0">return next(ctx, req)</span>
}

func GetContextUserID(ctx context.Context) (idwrap.IDWrap, error) <span class="cov0" title="0">{
        ulidID, ok := ctx.Value(UserIDKeyCtx).(idwrap.IDWrap)
        if !ok </span><span class="cov0" title="0">{
                return ulidID, errors.New("user id not found in context")
        }</span>
        <span class="cov0" title="0">return ulidID, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package mwcompress

import (
        "the-dev-tools/server/pkg/zstdcompress"

        "connectrpc.com/connect"
)

func NewCompress() connect.Compressor <span class="cov0" title="0">{
        return zstdcompress.NewZstdCompressor()
}</span>

func NewDecompress() connect.Decompressor <span class="cov0" title="0">{
        return zstdcompress.NewZstdDecompressor()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package rbody

import (
        "context"
        "database/sql"
        "errors"
        "sort"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/ritemapiexample"
        "the-dev-tools/server/pkg/compress"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mbodyform"
        "the-dev-tools/server/pkg/model/mbodyraw"
        "the-dev-tools/server/pkg/model/mbodyurl"
        "the-dev-tools/server/pkg/permcheck"
        "the-dev-tools/server/pkg/service/sbodyform"
        "the-dev-tools/server/pkg/service/sbodyraw"
        "the-dev-tools/server/pkg/service/sbodyurl"
        "the-dev-tools/server/pkg/service/scollection"
        "the-dev-tools/server/pkg/service/sitemapiexample"
        "the-dev-tools/server/pkg/service/suser"
        "the-dev-tools/server/pkg/translate/tbodyform"
        "the-dev-tools/server/pkg/translate/tbodyurl"
        "the-dev-tools/server/pkg/translate/tgeneric"
        "the-dev-tools/server/pkg/zstdcompress"
        bodyv1 "the-dev-tools/spec/dist/buf/go/collection/item/body/v1"
        "the-dev-tools/spec/dist/buf/go/collection/item/body/v1/bodyv1connect"

        "connectrpc.com/connect"
)

type BodyRPC struct {
        DB *sql.DB

        cs   scollection.CollectionService
        iaes sitemapiexample.ItemApiExampleService
        us   suser.UserService

        bfs  sbodyform.BodyFormService
        bues sbodyurl.BodyURLEncodedService
        brs  sbodyraw.BodyRawService
}

func New(db *sql.DB, cs scollection.CollectionService, iaes sitemapiexample.ItemApiExampleService,
        us suser.UserService, bfs sbodyform.BodyFormService, bues sbodyurl.BodyURLEncodedService, brs sbodyraw.BodyRawService,
) BodyRPC <span class="cov8" title="1">{
        return BodyRPC{
                DB: db,
                // root
                cs:   cs,
                iaes: iaes,
                us:   us,
                // body services
                bfs:  bfs,
                bues: bues,
                brs:  brs,
        }
}</span>

func CreateService(srv BodyRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := bodyv1connect.NewBodyServiceHandler(&amp;srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

// isExampleDelta checks if an example has a VersionParentID (making it a delta example)
func (c *BodyRPC) isExampleDelta(ctx context.Context, exampleID idwrap.IDWrap) (bool, error) <span class="cov0" title="0">{
        example, err := c.iaes.GetApiExample(ctx, exampleID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return example.VersionParentID != nil, nil</span>
}

func (c *BodyRPC) BodyFormList(ctx context.Context, req *connect.Request[bodyv1.BodyFormListRequest]) (*connect.Response[bodyv1.BodyFormListResponse], error) <span class="cov8" title="1">{
        ExampleID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, ExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">bodyForms, err := c.bfs.GetBodyFormsByExampleID(ctx, ExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">rpcBodyForms := tgeneric.MassConvert(bodyForms, tbodyform.SerializeFormModelToRPCItem)
        return connect.NewResponse(&amp;bodyv1.BodyFormListResponse{
                ExampleId: req.Msg.ExampleId,
                Items:     rpcBodyForms,
        }), nil</span>
}

func (c *BodyRPC) BodyFormCreate(ctx context.Context, req *connect.Request[bodyv1.BodyFormCreateRequest]) (*connect.Response[bodyv1.BodyFormCreateResponse], error) <span class="cov0" title="0">{
        ExampleID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcBody := &amp;bodyv1.BodyForm{
                Key:         req.Msg.GetKey(),
                Enabled:     req.Msg.GetEnabled(),
                Value:       req.Msg.GetValue(),
                Description: req.Msg.GetDescription(),
        }

        var deltaParentIDPtr *idwrap.IDWrap

        bodyForm, err := tbodyform.SeralizeFormRPCToModelWithoutID(rpcBody, ExampleID, deltaParentIDPtr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">bodyForm.ID = idwrap.NewNow()

        ok, err := ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, bodyForm.ExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeNotFound, errors.New("no example found"))
        }</span>
        <span class="cov0" title="0">err = c.bfs.CreateBodyForm(ctx, bodyForm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;bodyv1.BodyFormCreateResponse{BodyId: bodyForm.ID.Bytes()}), nil</span>
}

func (c *BodyRPC) BodyFormUpdate(ctx context.Context, req *connect.Request[bodyv1.BodyFormUpdateRequest]) (*connect.Response[bodyv1.BodyFormUpdateResponse], error) <span class="cov0" title="0">{
        ID, err := idwrap.NewFromBytes(req.Msg.GetBodyId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">bodyFormPtr, err := c.bfs.GetBodyForm(ctx, ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">bodyForm := *bodyFormPtr

        rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, bodyForm.ExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">rpcBody := &amp;bodyv1.BodyForm{
                BodyId:      req.Msg.GetBodyId(),
                Key:         req.Msg.GetKey(),
                Enabled:     req.Msg.GetEnabled(),
                Value:       req.Msg.GetValue(),
                Description: req.Msg.GetDescription(),
        }
        updated, err := tbodyform.SerializeFormRPCtoModel(rpcBody, idwrap.IDWrap{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">updated.ExampleID = bodyForm.ExampleID

        if err := c.bfs.UpdateBodyForm(ctx, updated); err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Check if example has version parent
        <span class="cov0" title="0">exampleIsDelta, err := c.isExampleDelta(ctx, bodyForm.ExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Propagate changes to delta bodyforms if this is an origin bodyform
        <span class="cov0" title="0">if bodyForm.DetermineDeltaType(exampleIsDelta) == mbodyform.BodyFormSourceOrigin </span><span class="cov0" title="0">{
                if err := c.propagateBodyFormChangesToDeltas(ctx, *updated); err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov0" title="0">return connect.NewResponse(&amp;bodyv1.BodyFormUpdateResponse{}), nil</span>
}

func (c *BodyRPC) BodyFormDelete(ctx context.Context, req *connect.Request[bodyv1.BodyFormDeleteRequest]) (*connect.Response[bodyv1.BodyFormDeleteResponse], error) <span class="cov0" title="0">{
        ID, err := idwrap.NewFromBytes(req.Msg.GetBodyId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">bodyFormPtr, err := c.bfs.GetBodyForm(ctx, ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">bodyForm := *bodyFormPtr

        rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, bodyForm.ExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">if err := c.bfs.DeleteBodyForm(ctx, ID); err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Check if example has version parent
        <span class="cov0" title="0">exampleIsDelta, err := c.isExampleDelta(ctx, bodyForm.ExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // If deleting an origin bodyform, also delete associated delta bodyforms
        <span class="cov0" title="0">if bodyForm.DetermineDeltaType(exampleIsDelta) == mbodyform.BodyFormSourceOrigin </span><span class="cov0" title="0">{
                if err := c.deleteDeltaBodyFormsForOrigin(ctx, bodyForm); err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov0" title="0">return connect.NewResponse(&amp;bodyv1.BodyFormDeleteResponse{}), nil</span>
}

func (c *BodyRPC) BodyUrlEncodedList(ctx context.Context, req *connect.Request[bodyv1.BodyUrlEncodedListRequest]) (*connect.Response[bodyv1.BodyUrlEncodedListResponse], error) <span class="cov8" title="1">{
        exampleID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, exampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">bodyURLs, err := c.bues.GetBodyURLEncodedByExampleID(ctx, exampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">rpcBodyURLs := tgeneric.MassConvert(bodyURLs, tbodyurl.SerializeURLModelToRPCItem)
        return connect.NewResponse(&amp;bodyv1.BodyUrlEncodedListResponse{Items: rpcBodyURLs, ExampleId: req.Msg.ExampleId}), nil</span>
}

func (c BodyRPC) BodyUrlEncodedCreate(ctx context.Context, req *connect.Request[bodyv1.BodyUrlEncodedCreateRequest]) (*connect.Response[bodyv1.BodyUrlEncodedCreateResponse], error) <span class="cov0" title="0">{
        exampleID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">bodyData := &amp;bodyv1.BodyUrlEncoded{
                Key:         req.Msg.GetKey(),
                Enabled:     req.Msg.GetEnabled(),
                Value:       req.Msg.GetValue(),
                Description: req.Msg.GetDescription(),
        }
        var deltaParentIDPtr *idwrap.IDWrap

        bodyUrl, err := tbodyurl.SeralizeURLRPCToModelWithoutID(bodyData, exampleID, deltaParentIDPtr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">bodyUrl.ID = idwrap.NewNow()

        rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, exampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov0" title="0">err = c.bues.CreateBodyURLEncoded(ctx, bodyUrl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;bodyv1.BodyUrlEncodedCreateResponse{BodyId: bodyUrl.ID.Bytes()}), nil</span>
}

func (c BodyRPC) BodyUrlEncodedUpdate(ctx context.Context, req *connect.Request[bodyv1.BodyUrlEncodedUpdateRequest]) (*connect.Response[bodyv1.BodyUrlEncodedUpdateResponse], error) <span class="cov0" title="0">{
        bodyData := &amp;bodyv1.BodyUrlEncoded{
                BodyId:      req.Msg.GetBodyId(),
                Key:         req.Msg.GetKey(),
                Enabled:     req.Msg.GetEnabled(),
                Value:       req.Msg.GetValue(),
                Description: req.Msg.GetDescription(),
        }
        bodyURL, err := tbodyurl.SerializeURLRPCtoModel(bodyData, idwrap.IDWrap{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">bodyURLDB, err := c.bues.GetBodyURLEncoded(ctx, bodyURL.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">bodyURL.ExampleID = bodyURLDB.ExampleID
        rpcErr := permcheck.CheckPerm(CheckOwnerBodyUrlEncoded(ctx, c.bues, c.iaes, c.cs, c.us, bodyURL.ID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov0" title="0">rpcErr = permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, bodyURL.ExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">err = c.bues.UpdateBodyURLEncoded(ctx, bodyURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;bodyv1.BodyUrlEncodedUpdateResponse{}), nil</span>
}

func (c *BodyRPC) BodyUrlEncodedDelete(ctx context.Context, req *connect.Request[bodyv1.BodyUrlEncodedDeleteRequest]) (*connect.Response[bodyv1.BodyUrlEncodedDeleteResponse], error) <span class="cov0" title="0">{
        ID, err := idwrap.NewFromBytes(req.Msg.GetBodyId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">bodyURLEncodedPtr, err := c.bues.GetBodyURLEncoded(ctx, ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">bodyURLEncoded := *bodyURLEncodedPtr

        rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, bodyURLEncoded.ExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">if err := c.bues.DeleteBodyURLEncoded(ctx, ID); err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // TODO: Add delta deletion functionality after code regeneration
        // If deleting an origin body URL encoded, also delete associated delta body URL encodeds
        // if bodyURLEncoded.Source == mbodyurl.BodyURLEncodedSourceOrigin {
        //        if err := c.deleteDeltaBodyURLEncodedForOrigin(ctx, bodyURLEncoded); err != nil {
        //                return nil, connect.NewError(connect.CodeInternal, err)
        //        }
        // }

        <span class="cov0" title="0">return connect.NewResponse(&amp;bodyv1.BodyUrlEncodedDeleteResponse{}), nil</span>
}

func (c BodyRPC) BodyRawGet(ctx context.Context, req *connect.Request[bodyv1.BodyRawGetRequest]) (*connect.Response[bodyv1.BodyRawGetResponse], error) <span class="cov8" title="1">{
        exampleID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, exampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">bodyRaw, err := c.brs.GetBodyRawByExampleID(ctx, exampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">var bodyRawData []byte
        if bodyRaw.CompressType == compress.CompressTypeNone </span><span class="cov8" title="1">{
                bodyRawData = bodyRaw.Data
        }</span>
        <span class="cov8" title="1">switch bodyRaw.CompressType </span>{
        case compress.CompressTypeNone:<span class="cov8" title="1">
                bodyRawData = bodyRaw.Data</span>
        case compress.CompressTypeZstd:<span class="cov0" title="0">
                bodyRawData, err = zstdcompress.Decompress(bodyRaw.Data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        case compress.CompressTypeGzip:<span class="cov0" title="0">
                return nil, connect.NewError(connect.CodeUnimplemented, errors.New("gzip not supported"))</span>
        }
        <span class="cov8" title="1">return connect.NewResponse(&amp;bodyv1.BodyRawGetResponse{ExampleId: req.Msg.GetExampleId(), Data: bodyRawData}), nil</span>
}

func (c *BodyRPC) BodyRawUpdate(ctx context.Context, req *connect.Request[bodyv1.BodyRawUpdateRequest]) (*connect.Response[bodyv1.BodyRawUpdateResponse], error) <span class="cov0" title="0">{
        exampleID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, exampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov0" title="0">bodyRawID, err := c.brs.GetBodyRawByExampleID(ctx, exampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">rawBody := mbodyraw.ExampleBodyRaw{
                ID:           bodyRawID.ID,
                CompressType: compress.CompressTypeNone,
                Data:         req.Msg.GetData(),
        }
        if len(rawBody.Data) &gt; zstdcompress.CompressThreshold </span><span class="cov0" title="0">{
                rawBody.CompressType = compress.CompressTypeZstd
                rawBody.Data = zstdcompress.Compress(rawBody.Data)
        }</span>

        <span class="cov0" title="0">err = c.brs.UpdateBodyRawBody(ctx, rawBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">return connect.NewResponse(&amp;bodyv1.BodyRawUpdateResponse{}), nil</span>
}

func (c *BodyRPC) BodyFormDeltaList(ctx context.Context, req *connect.Request[bodyv1.BodyFormDeltaListRequest]) (*connect.Response[bodyv1.BodyFormDeltaListResponse], error) <span class="cov0" title="0">{
        // Parse both example IDs
        deltaExampleID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">originExampleID, err := idwrap.NewFromBytes(req.Msg.GetOriginId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // Check permissions for both examples
        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, deltaExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov0" title="0">rpcErr = permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, originExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Get body forms from both origin and delta examples
        <span class="cov0" title="0">originBodyForms, err := c.bfs.GetBodyFormsByExampleID(ctx, originExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">deltaBodyForms, err := c.bfs.GetBodyFormsByExampleID(ctx, deltaExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Check if delta example has version parent
        <span class="cov0" title="0">deltaExampleIsDelta, err := c.isExampleDelta(ctx, deltaExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Combine all body forms and build maps for lookup
        <span class="cov0" title="0">allBodyForms := append(originBodyForms, deltaBodyForms...)
        bodyFormMap := make(map[idwrap.IDWrap]mbodyform.BodyForm)
        originMap := make(map[idwrap.IDWrap]*bodyv1.BodyForm)
        replacedOrigins := make(map[idwrap.IDWrap]bool)

        for _, bodyForm := range allBodyForms </span><span class="cov0" title="0">{
                bodyFormMap[bodyForm.ID] = bodyForm
                originMap[bodyForm.ID] = tbodyform.SerializeFormModelToRPC(bodyForm)

                // Determine the delta type for this body form
                exampleIsDelta := bodyForm.ExampleID.Compare(deltaExampleID) == 0 &amp;&amp; deltaExampleIsDelta
                deltaType := bodyForm.DetermineDeltaType(exampleIsDelta)

                // Mark origin body forms that have been replaced by mixed body forms
                if deltaType == mbodyform.BodyFormSourceMixed &amp;&amp; bodyForm.DeltaParentID != nil </span><span class="cov0" title="0">{
                        replacedOrigins[*bodyForm.DeltaParentID] = true
                }</span>
        }

        // Create result slice maintaining order from allBodyForms
        <span class="cov0" title="0">var rpcBodyForms []*bodyv1.BodyFormDeltaListItem
        for _, bodyForm := range allBodyForms </span><span class="cov0" title="0">{
                // Determine the delta type for this body form
                exampleIsDelta := bodyForm.ExampleID.Compare(deltaExampleID) == 0 &amp;&amp; deltaExampleIsDelta
                deltaType := bodyForm.DetermineDeltaType(exampleIsDelta)

                // Skip origin body forms that have been replaced by mixed body forms
                if deltaType == mbodyform.BodyFormSourceOrigin &amp;&amp; replacedOrigins[bodyForm.ID] </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">sourceKind := deltaType.ToSourceKind()
                var origin *bodyv1.BodyForm
                var key, value, description string
                var enabled bool

                if deltaType == mbodyform.BodyFormSourceOrigin </span><span class="cov0" title="0">{
                        // For origin items, put the data in origin field and leave main fields empty
                        origin = tbodyform.SerializeFormModelToRPC(bodyForm)
                        key = ""
                        value = ""
                        description = ""
                        enabled = false
                }</span> else<span class="cov0" title="0"> {
                        // For delta/mixed items, use the current values and find the origin if it has a parent
                        key = bodyForm.BodyKey
                        value = bodyForm.Value
                        description = bodyForm.Description
                        enabled = bodyForm.Enable

                        if bodyForm.DeltaParentID != nil </span><span class="cov0" title="0">{
                                if originRPC, exists := originMap[*bodyForm.DeltaParentID]; exists </span><span class="cov0" title="0">{
                                        origin = originRPC
                                }</span>
                        }
                }

                <span class="cov0" title="0">rpcBodyForm := &amp;bodyv1.BodyFormDeltaListItem{
                        BodyId:      bodyForm.ID.Bytes(),
                        Key:         key,
                        Enabled:     enabled,
                        Value:       value,
                        Description: description,
                        Origin:      origin,
                        Source:      &amp;sourceKind,
                }
                rpcBodyForms = append(rpcBodyForms, rpcBodyForm)</span>
        }

        // Sort rpcBodyForms by ID, but if it has DeltaParentID use that ID instead
        <span class="cov0" title="0">sort.Slice(rpcBodyForms, func(i, j int) bool </span><span class="cov0" title="0">{
                idI, _ := idwrap.NewFromBytes(rpcBodyForms[i].BodyId)
                idJ, _ := idwrap.NewFromBytes(rpcBodyForms[j].BodyId)

                // Determine the ID to use for sorting for item i
                sortIDI := idI
                if rpcBodyForms[i].Origin != nil &amp;&amp; len(rpcBodyForms[i].Origin.BodyId) &gt; 0 </span><span class="cov0" title="0">{
                        if parentID, err := idwrap.NewFromBytes(rpcBodyForms[i].Origin.BodyId); err == nil </span><span class="cov0" title="0">{
                                sortIDI = parentID
                        }</span>
                }

                // Determine the ID to use for sorting for item j
                <span class="cov0" title="0">sortIDJ := idJ
                if rpcBodyForms[j].Origin != nil &amp;&amp; len(rpcBodyForms[j].Origin.BodyId) &gt; 0 </span><span class="cov0" title="0">{
                        if parentID, err := idwrap.NewFromBytes(rpcBodyForms[j].Origin.BodyId); err == nil </span><span class="cov0" title="0">{
                                sortIDJ = parentID
                        }</span>
                }

                <span class="cov0" title="0">return sortIDI.Compare(sortIDJ) &lt; 0</span>
        })

        <span class="cov0" title="0">resp := &amp;bodyv1.BodyFormDeltaListResponse{
                ExampleId: deltaExampleID.Bytes(),
                Items:     rpcBodyForms,
        }
        return connect.NewResponse(resp), nil</span>
}

func (c *BodyRPC) BodyFormDeltaCreate(ctx context.Context, req *connect.Request[bodyv1.BodyFormDeltaCreateRequest]) (*connect.Response[bodyv1.BodyFormDeltaCreateResponse], error) <span class="cov0" title="0">{
        exampleID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcBody := &amp;bodyv1.BodyForm{
                Key:         req.Msg.GetKey(),
                Enabled:     req.Msg.GetEnabled(),
                Value:       req.Msg.GetValue(),
                Description: req.Msg.GetDescription(),
        }

        var deltaParentIDPtr *idwrap.IDWrap

        bodyForm, err := tbodyform.SeralizeFormRPCToModelWithoutID(rpcBody, exampleID, deltaParentIDPtr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">bodyForm.ID = idwrap.NewNow()

        ok, err := ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, bodyForm.ExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeNotFound, errors.New("no example found"))
        }</span>
        <span class="cov0" title="0">err = c.bfs.CreateBodyForm(ctx, bodyForm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;bodyv1.BodyFormDeltaCreateResponse{BodyId: bodyForm.ID.Bytes()}), nil</span>
}

func (c *BodyRPC) BodyFormDeltaUpdate(ctx context.Context, req *connect.Request[bodyv1.BodyFormDeltaUpdateRequest]) (*connect.Response[bodyv1.BodyFormDeltaUpdateResponse], error) <span class="cov0" title="0">{
        ID, err := idwrap.NewFromBytes(req.Msg.GetBodyId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">bodyFormPtr, err := c.bfs.GetBodyForm(ctx, ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">bodyForm := *bodyFormPtr

        rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, bodyForm.ExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">rpcBody := &amp;bodyv1.BodyForm{
                BodyId:      req.Msg.GetBodyId(),
                Key:         req.Msg.GetKey(),
                Enabled:     req.Msg.GetEnabled(),
                Value:       req.Msg.GetValue(),
                Description: req.Msg.GetDescription(),
        }
        updated, err := tbodyform.SerializeFormRPCtoModel(rpcBody, idwrap.IDWrap{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">updated.ExampleID = bodyForm.ExampleID

        // Check if example has version parent
        exampleIsDelta, err := c.isExampleDelta(ctx, bodyForm.ExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Determine the delta type for this body form
        <span class="cov0" title="0">deltaType := bodyForm.DetermineDeltaType(exampleIsDelta)

        // If it's an origin bodyform, create a mixed bodyform instead
        if deltaType == mbodyform.BodyFormSourceOrigin </span><span class="cov0" title="0">{
                updated.DeltaParentID = &amp;bodyForm.ID
                updated.ID = idwrap.NewNow()

                if err := c.bfs.CreateBodyForm(ctx, updated); err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        } else<span class="cov0" title="0"> {
                updated.DeltaParentID = bodyForm.DeltaParentID

                if err := c.bfs.UpdateBodyForm(ctx, updated); err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov0" title="0">return connect.NewResponse(&amp;bodyv1.BodyFormDeltaUpdateResponse{}), nil</span>
}

func (c *BodyRPC) BodyFormDeltaDelete(ctx context.Context, req *connect.Request[bodyv1.BodyFormDeltaDeleteRequest]) (*connect.Response[bodyv1.BodyFormDeltaDeleteResponse], error) <span class="cov0" title="0">{
        ID, err := idwrap.NewFromBytes(req.Msg.GetBodyId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(CheckOwnerBodyForm(ctx, c.bfs, c.iaes, c.cs, c.us, ID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">err = c.bfs.DeleteBodyForm(ctx, ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;bodyv1.BodyFormDeltaDeleteResponse{}), nil</span>
}

func (c *BodyRPC) BodyFormDeltaReset(ctx context.Context, req *connect.Request[bodyv1.BodyFormDeltaResetRequest]) (*connect.Response[bodyv1.BodyFormDeltaResetResponse], error) <span class="cov0" title="0">{
        ID, err := idwrap.NewFromBytes(req.Msg.GetBodyId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">bodyFormPtr, err := c.bfs.GetBodyForm(ctx, ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">bodyForm := *bodyFormPtr

        rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, bodyForm.ExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">if bodyForm.DeltaParentID != nil </span><span class="cov0" title="0">{
                // Get parent bodyform and restore values
                parentBodyFormPtr, err := c.bfs.GetBodyForm(ctx, *bodyForm.DeltaParentID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">parentBodyForm := *parentBodyFormPtr

                bodyForm.BodyKey = parentBodyForm.BodyKey
                bodyForm.Value = parentBodyForm.Value
                bodyForm.Enable = parentBodyForm.Enable</span>
        } else<span class="cov0" title="0"> {
                // Clear the values
                bodyForm.BodyKey = ""
                bodyForm.Value = ""
                bodyForm.Enable = false
        }</span>

        <span class="cov0" title="0">if err := c.bfs.UpdateBodyForm(ctx, &amp;bodyForm); err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;bodyv1.BodyFormDeltaResetResponse{}), nil</span>
}

func (c *BodyRPC) BodyUrlEncodedDeltaList(ctx context.Context, req *connect.Request[bodyv1.BodyUrlEncodedDeltaListRequest]) (*connect.Response[bodyv1.BodyUrlEncodedDeltaListResponse], error) <span class="cov0" title="0">{
        // Parse both example IDs
        deltaExampleID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">originExampleID, err := idwrap.NewFromBytes(req.Msg.GetOriginId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // Check permissions for both examples
        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, deltaExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov0" title="0">rpcErr = permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, originExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Check if delta example has version parent
        <span class="cov0" title="0">deltaExampleIsDelta, err := c.isExampleDelta(ctx, deltaExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Get body URL encodeds from both origin and delta examples
        <span class="cov0" title="0">originBodyURLEncodeds, err := c.bues.GetBodyURLEncodedByExampleID(ctx, originExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">deltaBodyURLEncodeds, err := c.bues.GetBodyURLEncodedByExampleID(ctx, deltaExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Combine all body URL encodeds and build maps for lookup
        <span class="cov0" title="0">allBodyURLEncodeds := append(originBodyURLEncodeds, deltaBodyURLEncodeds...)
        bodyURLEncodedMap := make(map[idwrap.IDWrap]mbodyurl.BodyURLEncoded)
        originMap := make(map[idwrap.IDWrap]*bodyv1.BodyUrlEncoded)
        replacedOrigins := make(map[idwrap.IDWrap]bool)

        for _, bodyURLEncoded := range allBodyURLEncodeds </span><span class="cov0" title="0">{
                bodyURLEncodedMap[bodyURLEncoded.ID] = bodyURLEncoded
                originMap[bodyURLEncoded.ID] = tbodyurl.SerializeURLModelToRPC(bodyURLEncoded)

                // Determine the delta type for this body URL encoded
                exampleIsDelta := bodyURLEncoded.ExampleID.Compare(deltaExampleID) == 0 &amp;&amp; deltaExampleIsDelta
                deltaType := bodyURLEncoded.DetermineDeltaType(exampleIsDelta)

                // Mark origin body URL encodeds that have been replaced by mixed body URL encodeds
                if deltaType == mbodyurl.BodyURLEncodedSourceMixed &amp;&amp; bodyURLEncoded.DeltaParentID != nil </span><span class="cov0" title="0">{
                        replacedOrigins[*bodyURLEncoded.DeltaParentID] = true
                }</span>
        }

        // Create result slice maintaining order from allBodyURLEncodeds
        <span class="cov0" title="0">var rpcBodyURLEncodeds []*bodyv1.BodyUrlEncodedDeltaListItem
        for _, bodyURLEncoded := range allBodyURLEncodeds </span><span class="cov0" title="0">{
                // Determine the delta type for this body URL encoded
                exampleIsDelta := bodyURLEncoded.ExampleID.Compare(deltaExampleID) == 0 &amp;&amp; deltaExampleIsDelta
                deltaType := bodyURLEncoded.DetermineDeltaType(exampleIsDelta)

                // Skip origin body URL encodeds that have been replaced by mixed body URL encodeds
                if deltaType == mbodyurl.BodyURLEncodedSourceOrigin &amp;&amp; replacedOrigins[bodyURLEncoded.ID] </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">sourceKind := deltaType.ToSourceKind()
                var origin *bodyv1.BodyUrlEncoded
                var key, value, description string
                var enabled bool

                if deltaType == mbodyurl.BodyURLEncodedSourceOrigin </span><span class="cov0" title="0">{
                        // For origin items, put the data in origin field and leave main fields empty
                        origin = tbodyurl.SerializeURLModelToRPC(bodyURLEncoded)
                        key = ""
                        value = ""
                        description = ""
                        enabled = false
                }</span> else<span class="cov0" title="0"> {
                        // For delta/mixed items, use the current values and find the origin if it has a parent
                        key = bodyURLEncoded.BodyKey
                        value = bodyURLEncoded.Value
                        description = bodyURLEncoded.Description
                        enabled = bodyURLEncoded.Enable

                        if bodyURLEncoded.DeltaParentID != nil </span><span class="cov0" title="0">{
                                if originRPC, exists := originMap[*bodyURLEncoded.DeltaParentID]; exists </span><span class="cov0" title="0">{
                                        origin = originRPC
                                }</span>
                        }
                }

                <span class="cov0" title="0">rpcBodyURLEncoded := &amp;bodyv1.BodyUrlEncodedDeltaListItem{
                        BodyId:      bodyURLEncoded.ID.Bytes(),
                        Key:         key,
                        Enabled:     enabled,
                        Value:       value,
                        Description: description,
                        Origin:      origin,
                        Source:      &amp;sourceKind,
                }
                rpcBodyURLEncodeds = append(rpcBodyURLEncodeds, rpcBodyURLEncoded)</span>
        }

        // Sort rpcBodyURLEncodeds by ID, but if it has DeltaParentID use that ID instead
        <span class="cov0" title="0">sort.Slice(rpcBodyURLEncodeds, func(i, j int) bool </span><span class="cov0" title="0">{
                idI, _ := idwrap.NewFromBytes(rpcBodyURLEncodeds[i].BodyId)
                idJ, _ := idwrap.NewFromBytes(rpcBodyURLEncodeds[j].BodyId)

                // Determine the ID to use for sorting for item i
                sortIDI := idI
                if rpcBodyURLEncodeds[i].Origin != nil &amp;&amp; len(rpcBodyURLEncodeds[i].Origin.BodyId) &gt; 0 </span><span class="cov0" title="0">{
                        if parentID, err := idwrap.NewFromBytes(rpcBodyURLEncodeds[i].Origin.BodyId); err == nil </span><span class="cov0" title="0">{
                                sortIDI = parentID
                        }</span>
                }

                // Determine the ID to use for sorting for item j
                <span class="cov0" title="0">sortIDJ := idJ
                if rpcBodyURLEncodeds[j].Origin != nil &amp;&amp; len(rpcBodyURLEncodeds[j].Origin.BodyId) &gt; 0 </span><span class="cov0" title="0">{
                        if parentID, err := idwrap.NewFromBytes(rpcBodyURLEncodeds[j].Origin.BodyId); err == nil </span><span class="cov0" title="0">{
                                sortIDJ = parentID
                        }</span>
                }

                <span class="cov0" title="0">return sortIDI.Compare(sortIDJ) &lt; 0</span>
        })

        <span class="cov0" title="0">resp := &amp;bodyv1.BodyUrlEncodedDeltaListResponse{
                ExampleId: deltaExampleID.Bytes(),
                Items:     rpcBodyURLEncodeds,
        }
        return connect.NewResponse(resp), nil</span>
}

func (c *BodyRPC) BodyUrlEncodedDeltaCreate(ctx context.Context, req *connect.Request[bodyv1.BodyUrlEncodedDeltaCreateRequest]) (*connect.Response[bodyv1.BodyUrlEncodedDeltaCreateResponse], error) <span class="cov0" title="0">{
        exampleID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcBody := &amp;bodyv1.BodyUrlEncoded{
                Key:         req.Msg.GetKey(),
                Enabled:     req.Msg.GetEnabled(),
                Value:       req.Msg.GetValue(),
                Description: req.Msg.GetDescription(),
        }

        var deltaParentIDPtr *idwrap.IDWrap

        bodyUrl, err := tbodyurl.SeralizeURLRPCToModelWithoutIDForDelta(rpcBody, exampleID, deltaParentIDPtr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">bodyUrl.ID = idwrap.NewNow()

        ok, err := ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, exampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeNotFound, errors.New("no example found"))
        }</span>
        <span class="cov0" title="0">err = c.bues.CreateBodyURLEncoded(ctx, bodyUrl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;bodyv1.BodyUrlEncodedDeltaCreateResponse{BodyId: bodyUrl.ID.Bytes()}), nil</span>
}

func (c *BodyRPC) BodyUrlEncodedDeltaUpdate(ctx context.Context, req *connect.Request[bodyv1.BodyUrlEncodedDeltaUpdateRequest]) (*connect.Response[bodyv1.BodyUrlEncodedDeltaUpdateResponse], error) <span class="cov0" title="0">{
        ID, err := idwrap.NewFromBytes(req.Msg.GetBodyId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">bodyURLEncodedPtr, err := c.bues.GetBodyURLEncoded(ctx, ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">bodyURLEncoded := *bodyURLEncodedPtr

        rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, bodyURLEncoded.ExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">rpcBody := &amp;bodyv1.BodyUrlEncoded{
                BodyId:      req.Msg.GetBodyId(),
                Key:         req.Msg.GetKey(),
                Enabled:     req.Msg.GetEnabled(),
                Value:       req.Msg.GetValue(),
                Description: req.Msg.GetDescription(),
        }
        updated, err := tbodyurl.SerializeURLRPCtoModel(rpcBody, idwrap.IDWrap{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">updated.ExampleID = bodyURLEncoded.ExampleID

        // Check if example has version parent
        exampleIsDelta, err := c.isExampleDelta(ctx, bodyURLEncoded.ExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Determine the delta type for this body URL encoded
        <span class="cov0" title="0">deltaType := bodyURLEncoded.DetermineDeltaType(exampleIsDelta)

        // If it's an origin body URL encoded, create a mixed body URL encoded instead
        if deltaType == mbodyurl.BodyURLEncodedSourceOrigin </span><span class="cov0" title="0">{
                updated.DeltaParentID = &amp;bodyURLEncoded.ID
                updated.ID = idwrap.NewNow()

                if err := c.bues.CreateBodyURLEncoded(ctx, updated); err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        } else<span class="cov0" title="0"> {
                updated.DeltaParentID = bodyURLEncoded.DeltaParentID

                if err := c.bues.UpdateBodyURLEncoded(ctx, updated); err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov0" title="0">return connect.NewResponse(&amp;bodyv1.BodyUrlEncodedDeltaUpdateResponse{}), nil</span>
}

func (c *BodyRPC) BodyUrlEncodedDeltaDelete(ctx context.Context, req *connect.Request[bodyv1.BodyUrlEncodedDeltaDeleteRequest]) (*connect.Response[bodyv1.BodyUrlEncodedDeltaDeleteResponse], error) <span class="cov0" title="0">{
        ID, err := idwrap.NewFromBytes(req.Msg.GetBodyId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(CheckOwnerBodyUrlEncoded(ctx, c.bues, c.iaes, c.cs, c.us, ID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov0" title="0">err = c.bues.DeleteBodyURLEncoded(ctx, ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;bodyv1.BodyUrlEncodedDeltaDeleteResponse{}), nil</span>
}

func (c *BodyRPC) BodyUrlEncodedDeltaReset(ctx context.Context, req *connect.Request[bodyv1.BodyUrlEncodedDeltaResetRequest]) (*connect.Response[bodyv1.BodyUrlEncodedDeltaResetResponse], error) <span class="cov0" title="0">{
        ID, err := idwrap.NewFromBytes(req.Msg.GetBodyId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(CheckOwnerBodyUrlEncoded(ctx, c.bues, c.iaes, c.cs, c.us, ID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov0" title="0">err = c.bues.ResetBodyURLEncodedDelta(ctx, ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;bodyv1.BodyUrlEncodedDeltaResetResponse{}), nil</span>
}

func CheckOwnerBodyForm(ctx context.Context, bfs sbodyform.BodyFormService, iaes sitemapiexample.ItemApiExampleService, cs scollection.CollectionService, us suser.UserService, bodyFormUlid idwrap.IDWrap) (bool, error) <span class="cov0" title="0">{
        bodyForm, err := bfs.GetBodyForm(ctx, bodyFormUlid)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return ritemapiexample.CheckOwnerExample(ctx, iaes, cs, us, bodyForm.ExampleID)</span>
}

func CheckOwnerBodyUrlEncoded(ctx context.Context, bues sbodyurl.BodyURLEncodedService, iaes sitemapiexample.ItemApiExampleService, cs scollection.CollectionService, us suser.UserService, bodyUrlUlid idwrap.IDWrap) (bool, error) <span class="cov0" title="0">{
        bodyUrl, err := bues.GetBodyURLEncoded(ctx, bodyUrlUlid)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return ritemapiexample.CheckOwnerExample(ctx, iaes, cs, us, bodyUrl.ExampleID)</span>
}

// Helper functions
func (s *BodyRPC) propagateBodyFormChangesToDeltas(ctx context.Context, originBodyForm mbodyform.BodyForm) error <span class="cov0" title="0">{
        // Find all delta bodyforms that reference this origin bodyform
        deltaBodyForms, err := s.bfs.GetBodyFormsByDeltaParentID(ctx, originBodyForm.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, deltaBodyForm := range deltaBodyForms </span><span class="cov0" title="0">{
                // Check if example has version parent
                exampleIsDelta, err := s.isExampleDelta(ctx, deltaBodyForm.ExampleID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Determine the delta type for this body form
                <span class="cov0" title="0">deltaType := deltaBodyForm.DetermineDeltaType(exampleIsDelta)

                // Only update if it's still a delta (not mixed)
                if deltaType == mbodyform.BodyFormSourceDelta </span><span class="cov0" title="0">{
                        deltaBodyForm.BodyKey = originBodyForm.BodyKey
                        deltaBodyForm.Value = originBodyForm.Value
                        deltaBodyForm.Enable = originBodyForm.Enable

                        if err := s.bfs.UpdateBodyForm(ctx, &amp;deltaBodyForm); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *BodyRPC) deleteDeltaBodyFormsForOrigin(ctx context.Context, originBodyForm mbodyform.BodyForm) error <span class="cov0" title="0">{
        deltaBodyForms, err := s.bfs.GetBodyFormsByDeltaParentID(ctx, originBodyForm.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, deltaBodyForm := range deltaBodyForms </span><span class="cov0" title="0">{
                if err := s.bfs.DeleteBodyForm(ctx, deltaBodyForm.ID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// TODO: implement move RPC
func (c *BodyRPC) BodyFormMove(ctx context.Context, req *connect.Request[bodyv1.BodyFormMoveRequest]) (*connect.Response[bodyv1.BodyFormMoveResponse], error) <span class="cov0" title="0">{
        return connect.NewResponse(&amp;bodyv1.BodyFormMoveResponse{}), nil
}</span>

// TODO: implement move RPC
func (c *BodyRPC) BodyFormDeltaMove(ctx context.Context, req *connect.Request[bodyv1.BodyFormDeltaMoveRequest]) (*connect.Response[bodyv1.BodyFormDeltaMoveResponse], error) <span class="cov0" title="0">{
        return connect.NewResponse(&amp;bodyv1.BodyFormDeltaMoveResponse{}), nil
}</span>

// TODO: implement move RPC
func (c *BodyRPC) BodyUrlEncodedMove(ctx context.Context, req *connect.Request[bodyv1.BodyUrlEncodedMoveRequest]) (*connect.Response[bodyv1.BodyUrlEncodedMoveResponse], error) <span class="cov0" title="0">{
        return connect.NewResponse(&amp;bodyv1.BodyUrlEncodedMoveResponse{}), nil
}</span>

// TODO: implement move RPC
func (c *BodyRPC) BodyUrlEncodedDeltaMove(ctx context.Context, req *connect.Request[bodyv1.BodyUrlEncodedDeltaMoveRequest]) (*connect.Response[bodyv1.BodyUrlEncodedDeltaMoveResponse], error) <span class="cov0" title="0">{
        return connect.NewResponse(&amp;bodyv1.BodyUrlEncodedDeltaMoveResponse{}), nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package rcollection

import (
        "context"
        "database/sql"
        "errors"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/middleware/mwauth"
        "the-dev-tools/server/pkg/dbtime"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mcollection"
        "the-dev-tools/server/pkg/permcheck"
        "the-dev-tools/server/pkg/service/scollection"
        "the-dev-tools/server/pkg/service/suser"
        "the-dev-tools/server/pkg/service/sworkspace"
        "the-dev-tools/server/pkg/translate/tcollection"
        "the-dev-tools/server/pkg/translate/tgeneric"
        collectionv1 "the-dev-tools/spec/dist/buf/go/collection/v1"
        "the-dev-tools/spec/dist/buf/go/collection/v1/collectionv1connect"
        resourcesv1 "the-dev-tools/spec/dist/buf/go/resources/v1"

        "connectrpc.com/connect"
)

type CollectionServiceRPC struct {
        DB *sql.DB
        cs scollection.CollectionService
        ws sworkspace.WorkspaceService
        us suser.UserService
}

func New(db *sql.DB, cs scollection.CollectionService, ws sworkspace.WorkspaceService,
        us suser.UserService,
) CollectionServiceRPC <span class="cov8" title="1">{
        return CollectionServiceRPC{
                DB: db,
                cs: cs,
                ws: ws,
                us: us,
        }
}</span>

func CreateService(deps CollectionServiceRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := collectionv1connect.NewCollectionServiceHandler(&amp;deps, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

func (c *CollectionServiceRPC) CollectionList(ctx context.Context, req *connect.Request[collectionv1.CollectionListRequest]) (*connect.Response[collectionv1.CollectionListResponse], error) <span class="cov8" title="1">{
        workspaceUlid, err := idwrap.NewFromBytes(req.Msg.GetWorkspaceId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerWorkspace(ctx, c.us, workspaceUlid))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">workspaceID, err := c.ws.Get(ctx, workspaceUlid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeNotFound, err)
        }</span>

        <span class="cov8" title="1">simpleCollections, err := c.cs.GetCollectionsOrdered(ctx, workspaceID.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">respRaw := &amp;collectionv1.CollectionListResponse{
                WorkspaceId: req.Msg.WorkspaceId,
                Items:       tgeneric.MassConvert(simpleCollections, tcollection.SerializeCollectionModelToRPC),
        }
        return connect.NewResponse(respRaw), nil</span>
}

func (c *CollectionServiceRPC) CollectionCreate(ctx context.Context, req *connect.Request[collectionv1.CollectionCreateRequest]) (*connect.Response[collectionv1.CollectionCreateResponse], error) <span class="cov0" title="0">{
        workspaceUlid, err := idwrap.NewFromBytes(req.Msg.GetWorkspaceId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(CheckOwnerWorkspace(ctx, c.us, workspaceUlid))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">ws, err := c.ws.Get(ctx, workspaceUlid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">name := req.Msg.GetName()
        if name == "" </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("name is empty"))
        }</span>
        <span class="cov0" title="0">collectionID := idwrap.NewNow()
        collection := mcollection.Collection{
                ID:          collectionID,
                WorkspaceID: workspaceUlid,
                Name:        name,
                Updated:     dbtime.DBNow(),
        }
        err = c.cs.CreateCollection(ctx, &amp;collection)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">ws.CollectionCount++
        ws.Updated = dbtime.DBNow()
        err = c.ws.Update(ctx, ws)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;collectionv1.CollectionCreateResponse{
                CollectionId: collectionID.Bytes(),
        }), nil</span>
}

func (c *CollectionServiceRPC) CollectionGet(ctx context.Context, req *connect.Request[collectionv1.CollectionGetRequest]) (*connect.Response[collectionv1.CollectionGetResponse], error) <span class="cov0" title="0">{
        idWrap, err := idwrap.NewFromBytes(req.Msg.GetCollectionId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(CheckOwnerCollection(ctx, c.cs, c.us, idWrap))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">collection, err := c.cs.GetCollection(ctx, idWrap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">respRaw := &amp;collectionv1.CollectionGetResponse{
                CollectionId: collection.ID.Bytes(),
                Name:         collection.Name,
        }

        return connect.NewResponse(respRaw), nil</span>
}

func (c *CollectionServiceRPC) CollectionUpdate(ctx context.Context, req *connect.Request[collectionv1.CollectionUpdateRequest]) (*connect.Response[collectionv1.CollectionUpdateResponse], error) <span class="cov0" title="0">{
        idWrap, err := idwrap.NewFromBytes(req.Msg.GetCollectionId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(CheckOwnerCollection(ctx, c.cs, c.us, idWrap))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">collectionOld, err := c.cs.GetCollection(ctx, idWrap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">collection := mcollection.Collection{
                ID:          idWrap,
                Name:        req.Msg.GetName(),
                WorkspaceID: collectionOld.WorkspaceID,
        }
        err = c.cs.UpdateCollection(ctx, &amp;collection)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;collectionv1.CollectionUpdateResponse{}), nil</span>
}

func (c *CollectionServiceRPC) CollectionDelete(ctx context.Context, req *connect.Request[collectionv1.CollectionDeleteRequest]) (*connect.Response[collectionv1.CollectionDeleteResponse], error) <span class="cov0" title="0">{
        idWrap, err := idwrap.NewFromBytes(req.Msg.GetCollectionId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(CheckOwnerCollection(ctx, c.cs, c.us, idWrap))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">cs, err := c.cs.GetCollection(ctx, idWrap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ws, err := c.ws.Get(ctx, cs.WorkspaceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ws.CollectionCount--
        ws.Updated = dbtime.DBNow()
        err = c.ws.Update(ctx, ws)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">err = c.cs.DeleteCollection(ctx, idWrap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">return connect.NewResponse(&amp;collectionv1.CollectionDeleteResponse{}), nil</span>
}

func CheckOwnerWorkspace(ctx context.Context, us suser.UserService, workspaceID idwrap.IDWrap) (bool, error) <span class="cov8" title="1">{
        userUlid, err := mwauth.GetContextUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return false, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">ok, err := us.CheckUserBelongsToWorkspace(ctx, userUlid, workspaceID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        // INFO: this mean that workspace not belong to user
                        // So for avoid information leakage, we should return not found
                        return false, connect.NewError(connect.CodeNotFound, errors.New("workspace not found"))
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov8" title="1">return ok, nil</span>
}

func CheckOwnerCollection(ctx context.Context, cs scollection.CollectionService, us suser.UserService, collectionID idwrap.IDWrap) (bool, error) <span class="cov8" title="1">{
        workspaceID, err := cs.GetWorkspaceID(ctx, collectionID)
        if err != nil </span><span class="cov8" title="1">{
                if err == scollection.ErrNoCollectionFound </span><span class="cov8" title="1">{
                        // Return CodeNotFound for non-existent collections
                        return false, connect.NewError(connect.CodeNotFound, errors.New("collection not found"))
                }</span>
                <span class="cov0" title="0">return false, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov8" title="1">return CheckOwnerWorkspace(ctx, us, workspaceID)</span>
}

func (c *CollectionServiceRPC) CollectionMove(ctx context.Context, req *connect.Request[collectionv1.CollectionMoveRequest]) (*connect.Response[collectionv1.CollectionMoveResponse], error) <span class="cov8" title="1">{
        // Validate collection ID
        collectionID, err := idwrap.NewFromBytes(req.Msg.GetCollectionId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // Check permissions for the collection being moved
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerCollection(ctx, c.cs, c.us, collectionID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Validate workspace ID if provided (for additional permission checking)
        <span class="cov8" title="1">if len(req.Msg.GetWorkspaceId()) &gt; 0 </span><span class="cov8" title="1">{
                workspaceID, err := idwrap.NewFromBytes(req.Msg.GetWorkspaceId())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>
                
                <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerWorkspace(ctx, c.us, workspaceID))
                if rpcErr != nil </span><span class="cov0" title="0">{
                        return nil, rpcErr
                }</span>

                // Verify collection belongs to the specified workspace
                <span class="cov8" title="1">collectionWorkspaceID, err := c.cs.GetWorkspaceID(ctx, collectionID)
                if err != nil </span><span class="cov0" title="0">{
                        if err == scollection.ErrNoCollectionFound </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeNotFound, errors.New("collection not found"))
                        }</span>
                        <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
                }
                
                <span class="cov8" title="1">if collectionWorkspaceID.Compare(workspaceID) != 0 </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("collection does not belong to specified workspace"))
                }</span>
        }

        // Validate position first (before checking permissions)
        <span class="cov8" title="1">position := req.Msg.GetPosition()
        if position == resourcesv1.MovePosition_MOVE_POSITION_UNSPECIFIED </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("position must be specified"))
        }</span>

        // Validate target collection ID
        <span class="cov8" title="1">targetCollectionID, err := idwrap.NewFromBytes(req.Msg.GetTargetCollectionId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // Prevent moving collection relative to itself (before checking permissions)
        <span class="cov8" title="1">if collectionID.Compare(targetCollectionID) == 0 </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("cannot move collection relative to itself"))
        }</span>

        // Check permissions for target collection (must be in same workspace)
        <span class="cov8" title="1">rpcErr = permcheck.CheckPerm(CheckOwnerCollection(ctx, c.cs, c.us, targetCollectionID))
        if rpcErr != nil </span><span class="cov8" title="1">{
                return nil, rpcErr
        }</span>

        // Verify both collections are in the same workspace
        <span class="cov8" title="1">sourceWorkspaceID, err := c.cs.GetWorkspaceID(ctx, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                if err == scollection.ErrNoCollectionFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, errors.New("collection not found"))
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov8" title="1">targetWorkspaceID, err := c.cs.GetWorkspaceID(ctx, targetCollectionID)
        if err != nil </span><span class="cov0" title="0">{
                if err == scollection.ErrNoCollectionFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, errors.New("target collection not found"))
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov8" title="1">if sourceWorkspaceID.Compare(targetWorkspaceID) != 0 </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("collections must be in the same workspace"))
        }</span>

        // Execute the move operation
        <span class="cov8" title="1">switch position </span>{
        case resourcesv1.MovePosition_MOVE_POSITION_AFTER:<span class="cov8" title="1">
                err = c.cs.MoveCollectionAfter(ctx, collectionID, targetCollectionID)</span>
        case resourcesv1.MovePosition_MOVE_POSITION_BEFORE:<span class="cov8" title="1">
                err = c.cs.MoveCollectionBefore(ctx, collectionID, targetCollectionID)</span>
        default:<span class="cov0" title="0">
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid position"))</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;collectionv1.CollectionMoveResponse{}), nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package redge

import (
        "context"
        "database/sql"
        "errors"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/rflow"
        "the-dev-tools/server/pkg/flow/edge"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/permcheck"
        "the-dev-tools/server/pkg/service/flow/sedge"
        "the-dev-tools/server/pkg/service/sflow"
        "the-dev-tools/server/pkg/service/snode"
        "the-dev-tools/server/pkg/service/suser"
        edgev1 "the-dev-tools/spec/dist/buf/go/flow/edge/v1"
        "the-dev-tools/spec/dist/buf/go/flow/edge/v1/edgev1connect"

        "connectrpc.com/connect"
)

type EdgeServiceRPC struct {
        DB *sql.DB

        // parent
        fs sflow.FlowService
        us suser.UserService

        es sedge.EdgeService
        ns snode.NodeService
}

func NewEdgeServiceRPC(db *sql.DB, fs sflow.FlowService, us suser.UserService, es sedge.EdgeService, ns snode.NodeService) *EdgeServiceRPC <span class="cov0" title="0">{
        return &amp;EdgeServiceRPC{
                DB: db,
                fs: fs,
                us: us,
                es: es,
                ns: ns,
        }
}</span>

func CreateService(srv *EdgeServiceRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := edgev1connect.NewEdgeServiceHandler(srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

func (c *EdgeServiceRPC) EdgeList(ctx context.Context, req *connect.Request[edgev1.EdgeListRequest]) (*connect.Response[edgev1.EdgeListResponse], error) <span class="cov0" title="0">{
        flowID, err := idwrap.NewFromBytes(req.Msg.FlowId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(rflow.CheckOwnerFlow(ctx, c.fs, c.us, flowID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">edges, err := c.es.GetEdgesByFlowID(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">rpcItems := make([]*edgev1.EdgeListItem, len(edges))
        for i, edge := range edges </span><span class="cov0" title="0">{
                rpcItems[i] = &amp;edgev1.EdgeListItem{
                        EdgeId:       edge.ID.Bytes(),
                        SourceId:     edge.SourceID.Bytes(),
                        TargetId:     edge.TargetID.Bytes(),
                        SourceHandle: edgev1.Handle(edge.SourceHandler),
                        Kind:         edgev1.EdgeKind(edge.Kind),
                }
        }</span>

        <span class="cov0" title="0">resp := &amp;edgev1.EdgeListResponse{
                Items: rpcItems,
        }

        return connect.NewResponse(resp), nil</span>
}

func (c *EdgeServiceRPC) EdgeGet(ctx context.Context, req *connect.Request[edgev1.EdgeGetRequest]) (*connect.Response[edgev1.EdgeGetResponse], error) <span class="cov0" title="0">{
        EdgeID, err := idwrap.NewFromBytes(req.Msg.EdgeId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(CheckOwnerEdge(ctx, c.fs, c.us, c.es, EdgeID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">edge, err := c.es.GetEdge(ctx, EdgeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">resp := &amp;edgev1.EdgeGetResponse{
                EdgeId:       edge.ID.Bytes(),
                Kind:         edgev1.EdgeKind(edge.Kind),
                SourceId:     edge.SourceID.Bytes(),
                TargetId:     edge.TargetID.Bytes(),
                SourceHandle: edgev1.Handle(edge.SourceHandler),
        }

        return connect.NewResponse(resp), nil</span>
}

func (c *EdgeServiceRPC) EdgeCreate(ctx context.Context, req *connect.Request[edgev1.EdgeCreateRequest]) (*connect.Response[edgev1.EdgeCreateResponse], error) <span class="cov0" title="0">{
        flowID, err := idwrap.NewFromBytes(req.Msg.FlowId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">a, b := rflow.CheckOwnerFlow(ctx, c.fs, c.us, flowID)
        rpcErr := permcheck.CheckPerm(a, b)
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">flow, err := c.fs.GetFlow(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">latestFlowID := flow.ID

        sourceID, err := idwrap.NewFromBytes(req.Msg.SourceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">targetID, err := idwrap.NewFromBytes(req.Msg.TargetId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">sourceNode, err := c.ns.GetNode(ctx, sourceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">targetNode, err := c.ns.GetNode(ctx, targetID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">if sourceNode.FlowID != latestFlowID || targetNode.FlowID != latestFlowID </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("source and target nodes must be in the same flow"))
        }</span>

        <span class="cov0" title="0">edgeID := idwrap.NewNow()
        modelEdge := &amp;edge.Edge{
                ID:            edgeID,
                FlowID:        latestFlowID,
                SourceID:      sourceID,
                TargetID:      targetID,
                SourceHandler: edge.EdgeHandle(req.Msg.SourceHandle),
                Kind:          int32(req.Msg.Kind),
        }

        err = c.es.CreateEdge(ctx, *modelEdge)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">resp := &amp;edgev1.EdgeCreateResponse{
                EdgeId: edgeID.Bytes(),
        }
        return connect.NewResponse(resp), nil</span>
}

func (c *EdgeServiceRPC) EdgeUpdate(ctx context.Context, req *connect.Request[edgev1.EdgeUpdateRequest]) (*connect.Response[edgev1.EdgeUpdateResponse], error) <span class="cov0" title="0">{
        EdgeID, err := idwrap.NewFromBytes(req.Msg.EdgeId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(CheckOwnerEdge(ctx, c.fs, c.us, c.es, EdgeID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">requestedEdge, err := c.es.GetEdge(ctx, EdgeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">flowID := requestedEdge.FlowID

        sourceID, err := idwrap.NewFromBytes(req.Msg.SourceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">targetID, err := idwrap.NewFromBytes(req.Msg.TargetId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">sourceNode, err := c.ns.GetNode(ctx, sourceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">targetNode, err := c.ns.GetNode(ctx, targetID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">if sourceNode.FlowID != flowID || targetNode.FlowID != flowID </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("source and target nodes must be in the same flow"))
        }</span>
        <span class="cov0" title="0">if sourceID.Bytes() != nil </span><span class="cov0" title="0">{
                requestedEdge.SourceID = sourceID
        }</span>
        <span class="cov0" title="0">if targetID.Bytes() != nil </span><span class="cov0" title="0">{
                requestedEdge.TargetID = targetID
        }</span>
        <span class="cov0" title="0">if req.Msg.Kind != nil </span><span class="cov0" title="0">{
                requestedEdge.Kind = int32(*req.Msg.Kind)
        }</span>
        <span class="cov0" title="0">err = c.es.UpdateEdge(ctx, *requestedEdge)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;edgev1.EdgeUpdateResponse{}), nil</span>
}

func (c *EdgeServiceRPC) EdgeDelete(ctx context.Context, req *connect.Request[edgev1.EdgeDeleteRequest]) (*connect.Response[edgev1.EdgeDeleteResponse], error) <span class="cov0" title="0">{
        EdgeID, err := idwrap.NewFromBytes(req.Msg.EdgeId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(CheckOwnerEdge(ctx, c.fs, c.us, c.es, EdgeID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov0" title="0">err = c.es.DeleteEdge(ctx, EdgeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;edgev1.EdgeDeleteResponse{}), nil</span>
}

func CheckOwnerEdge(ctx context.Context, fs sflow.FlowService, us suser.UserService, es sedge.EdgeService, edgeID idwrap.IDWrap) (bool, error) <span class="cov0" title="0">{
        edge, err := es.GetEdge(ctx, edgeID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return rflow.CheckOwnerFlow(ctx, fs, us, edge.FlowID)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package renv

import (
        "context"
        "database/sql"
        "errors"
        "log/slog"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/middleware/mwauth"
        "the-dev-tools/server/internal/api/rworkspace"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/menv"
        "the-dev-tools/server/pkg/permcheck"
        "the-dev-tools/server/pkg/service/senv"
        "the-dev-tools/server/pkg/service/suser"
        "the-dev-tools/server/pkg/service/svar"
        "the-dev-tools/server/pkg/translate/tenv"
        "the-dev-tools/server/pkg/translate/tgeneric"
        environmentv1 "the-dev-tools/spec/dist/buf/go/environment/v1"
        "the-dev-tools/spec/dist/buf/go/environment/v1/environmentv1connect"
        resourcesv1 "the-dev-tools/spec/dist/buf/go/resources/v1"
        "time"

        "connectrpc.com/connect"
)

type EnvRPC struct {
        DB *sql.DB

        es senv.EnvService
        vs svar.VarService
        us suser.UserService
}

func New(db *sql.DB, es senv.EnvService, vs svar.VarService, us suser.UserService) EnvRPC <span class="cov8" title="1">{
        return EnvRPC{
                DB: db,
                es: es,
                vs: vs,
                us: us,
        }
}</span>

func CreateService(srv EnvRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := environmentv1connect.NewEnvironmentServiceHandler(&amp;srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

func (e *EnvRPC) EnvironmentCreate(ctx context.Context, req *connect.Request[environmentv1.EnvironmentCreateRequest]) (*connect.Response[environmentv1.EnvironmentCreateResponse], error) <span class="cov8" title="1">{
        ReqEnv := req.Msg
        workspaceID, err := idwrap.NewFromBytes(ReqEnv.WorkspaceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">envReq := menv.Env{
                ID:          idwrap.NewNow(),
                WorkspaceID: workspaceID,
                Type:        menv.EnvNormal,
                Description: ReqEnv.Description,
                Name:        ReqEnv.Name,
                Updated:     time.Now(),
        }

        rpcErr := permcheck.CheckPerm(rworkspace.CheckOwnerWorkspace(ctx, e.us, envReq.WorkspaceID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">err = e.es.Create(ctx, envReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">envResp := &amp;environmentv1.EnvironmentCreateResponse{
                EnvironmentId: envReq.ID.Bytes(),
        }

        return connect.NewResponse(envResp), nil</span>
}

func (e *EnvRPC) EnvironmentList(ctx context.Context, req *connect.Request[environmentv1.EnvironmentListRequest]) (*connect.Response[environmentv1.EnvironmentListResponse], error) <span class="cov0" title="0">{
        workspaceID, err := idwrap.NewFromBytes(req.Msg.WorkspaceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(rworkspace.CheckOwnerWorkspace(ctx, e.us, workspaceID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov0" title="0">envs, err := e.es.GetByWorkspace(ctx, workspaceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">items := tgeneric.MassConvert(envs, tenv.SeralizeModelToRPCItem)
        resp := &amp;environmentv1.EnvironmentListResponse{
                WorkspaceId: req.Msg.WorkspaceId,
                Items:       items,
        }

        return connect.NewResponse(resp), nil</span>
}

func (e *EnvRPC) EnvironmentGet(ctx context.Context, req *connect.Request[environmentv1.EnvironmentGetRequest]) (*connect.Response[environmentv1.EnvironmentGetResponse], error) <span class="cov8" title="1">{
        id, err := idwrap.NewFromBytes(req.Msg.EnvironmentId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerEnv(ctx, e.us, e.es, id))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">ok, err := CheckOwnerEnv(ctx, e.us, e.es, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodePermissionDenied, nil)
        }</span>
        <span class="cov8" title="1">env, err := e.es.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">resp := tenv.SeralizeModelToRPC(*env)
        respRaw := &amp;environmentv1.EnvironmentGetResponse{
                EnvironmentId: resp.EnvironmentId,
                Name:          resp.Name,
                Description:   resp.Description,
                Updated:       resp.Updated,
                IsGlobal:      resp.IsGlobal,
        }
        return connect.NewResponse(respRaw), nil</span>
}

func (e *EnvRPC) EnvironmentUpdate(ctx context.Context, req *connect.Request[environmentv1.EnvironmentUpdateRequest]) (*connect.Response[environmentv1.EnvironmentUpdateResponse], error) <span class="cov8" title="1">{
        msg := req.Msg
        envID, err := idwrap.NewFromBytes(msg.EnvironmentId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerEnv(ctx, e.us, e.es, envID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">if msg.EnvironmentId == nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("environment id is required"))
        }</span>
        <span class="cov8" title="1">env, err := e.es.Get(ctx, envID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">if msg.Name != nil </span><span class="cov8" title="1">{
                env.Name = *msg.Name
        }</span>
        <span class="cov8" title="1">if msg.Description != nil </span><span class="cov8" title="1">{
                env.Description = *msg.Description
        }</span>
        <span class="cov8" title="1">err = e.es.Update(ctx, env)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;environmentv1.EnvironmentUpdateResponse{}), nil</span>
}

func (e *EnvRPC) EnvironmentDelete(ctx context.Context, req *connect.Request[environmentv1.EnvironmentDeleteRequest]) (*connect.Response[environmentv1.EnvironmentDeleteResponse], error) <span class="cov8" title="1">{
        id, err := idwrap.NewFromBytes(req.Msg.EnvironmentId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerEnv(ctx, e.us, e.es, id))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">err = e.es.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">return connect.NewResponse(&amp;environmentv1.EnvironmentDeleteResponse{}), nil</span>
}

func CheckOwnerEnv(ctx context.Context, su suser.UserService, es senv.EnvService, envid idwrap.IDWrap) (bool, error) <span class="cov8" title="1">{
        userID, err := mwauth.GetContextUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">env, err := es.Get(ctx, envid)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">return su.CheckUserBelongsToWorkspace(ctx, userID, env.WorkspaceID)</span>
}

func (c *EnvRPC) EnvironmentMove(ctx context.Context, req *connect.Request[environmentv1.EnvironmentMoveRequest]) (*connect.Response[environmentv1.EnvironmentMoveResponse], error) <span class="cov8" title="1">{
        // Validate environment ID
        environmentID, err := idwrap.NewFromBytes(req.Msg.GetEnvironmentId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // Check permissions for the environment being moved
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerEnv(ctx, c.us, c.es, environmentID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Validate workspace ID if provided (for additional permission checking)
        <span class="cov8" title="1">if len(req.Msg.GetWorkspaceId()) &gt; 0 </span><span class="cov8" title="1">{
                workspaceID, err := idwrap.NewFromBytes(req.Msg.GetWorkspaceId())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>
                
                <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(rworkspace.CheckOwnerWorkspace(ctx, c.us, workspaceID))
                if rpcErr != nil </span><span class="cov0" title="0">{
                        return nil, rpcErr
                }</span>

                // Verify environment belongs to the specified workspace
                <span class="cov8" title="1">environmentWorkspaceID, err := c.es.GetWorkspaceID(ctx, environmentID)
                if err != nil </span><span class="cov0" title="0">{
                        if err == senv.ErrNoEnvironmentFound </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeNotFound, errors.New("environment not found"))
                        }</span>
                        <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
                }
                
                <span class="cov8" title="1">if environmentWorkspaceID.Compare(workspaceID) != 0 </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("environment does not belong to specified workspace"))
                }</span>
        }

        // Validate target environment ID
        <span class="cov8" title="1">targetEnvironmentID, err := idwrap.NewFromBytes(req.Msg.GetTargetEnvironmentId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // Check permissions for target environment (must be in same workspace)
        <span class="cov8" title="1">rpcErr = permcheck.CheckPerm(CheckOwnerEnv(ctx, c.us, c.es, targetEnvironmentID))
        if rpcErr != nil </span><span class="cov8" title="1">{
                return nil, rpcErr
        }</span>

        // Validate position
        <span class="cov8" title="1">position := req.Msg.GetPosition()
        if position == resourcesv1.MovePosition_MOVE_POSITION_UNSPECIFIED </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("position must be specified"))
        }</span>

        // Prevent moving environment relative to itself
        <span class="cov8" title="1">if environmentID.Compare(targetEnvironmentID) == 0 </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("cannot move environment relative to itself"))
        }</span>

        // Verify both environments are in the same workspace
        <span class="cov8" title="1">sourceWorkspaceID, err := c.es.GetWorkspaceID(ctx, environmentID)
        if err != nil </span><span class="cov0" title="0">{
                if err == senv.ErrNoEnvironmentFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, errors.New("environment not found"))
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov8" title="1">targetWorkspaceID, err := c.es.GetWorkspaceID(ctx, targetEnvironmentID)
        if err != nil </span><span class="cov0" title="0">{
                if err == senv.ErrNoEnvironmentFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, errors.New("target environment not found"))
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov8" title="1">if sourceWorkspaceID.Compare(targetWorkspaceID) != 0 </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("environments must be in the same workspace"))
        }</span>

        // Add debug logging for move operations
        <span class="cov8" title="1">slog.DebugContext(ctx, "EnvironmentMove request",
                "environment_id", environmentID.String(),
                "target_environment_id", targetEnvironmentID.String(),
                "position", position.String(),
                "workspace_id", sourceWorkspaceID.String())

        // Execute the move operation
        switch position </span>{
        case resourcesv1.MovePosition_MOVE_POSITION_AFTER:<span class="cov8" title="1">
                err = c.es.MoveEnvironmentAfter(ctx, environmentID, targetEnvironmentID)</span>
        case resourcesv1.MovePosition_MOVE_POSITION_BEFORE:<span class="cov8" title="1">
                err = c.es.MoveEnvironmentBefore(ctx, environmentID, targetEnvironmentID)</span>
        default:<span class="cov0" title="0">
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid position"))</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;environmentv1.EnvironmentMoveResponse{}), nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package resultapi

import (
        "context"
        "database/sql"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/ritemapiexample"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/permcheck"
        "the-dev-tools/server/pkg/service/sassert"
        "the-dev-tools/server/pkg/service/sassertres"
        "the-dev-tools/server/pkg/service/scollection"
        "the-dev-tools/server/pkg/service/sexampleresp"
        "the-dev-tools/server/pkg/service/sexamplerespheader"
        "the-dev-tools/server/pkg/service/sitemapi"
        "the-dev-tools/server/pkg/service/sitemapiexample"
        "the-dev-tools/server/pkg/service/suser"
        "the-dev-tools/server/pkg/service/sworkspace"
        "the-dev-tools/server/pkg/translate/tassert"
        "the-dev-tools/server/pkg/translate/texampleresp"
        responsev1 "the-dev-tools/spec/dist/buf/go/collection/item/response/v1"
        "the-dev-tools/spec/dist/buf/go/collection/item/response/v1/responsev1connect"

        "connectrpc.com/connect"
)

type ResultService struct {
        DB   *sql.DB
        us   suser.UserService
        cs   scollection.CollectionService
        ias  sitemapi.ItemApiService
        iaes sitemapiexample.ItemApiExampleService
        ws   sworkspace.WorkspaceService

        // Response
        ers  sexampleresp.ExampleRespService
        erhs sexamplerespheader.ExampleRespHeaderService

        // Assert
        as   sassert.AssertService
        asrs sassertres.AssertResultService
}

func New(db *sql.DB, us suser.UserService, cs scollection.CollectionService, ias sitemapi.ItemApiService,
        iaes sitemapiexample.ItemApiExampleService, ws sworkspace.WorkspaceService,
        ers sexampleresp.ExampleRespService, erhs sexamplerespheader.ExampleRespHeaderService,
        as sassert.AssertService, asrs sassertres.AssertResultService,
) ResultService <span class="cov8" title="1">{
        return ResultService{
                DB:   db,
                us:   us,
                cs:   cs,
                ias:  ias,
                iaes: iaes,
                ws:   ws,
                ers:  ers,
                erhs: erhs,
                as:   as,
                asrs: asrs,
        }
}</span>

func CreateService(srv ResultService, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := responsev1connect.NewResponseServiceHandler(&amp;srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

func (c *ResultService) ResponseGet(ctx context.Context, req *connect.Request[responsev1.ResponseGetRequest]) (*connect.Response[responsev1.ResponseGetResponse], error) <span class="cov8" title="1">{
        ResponseID, err := idwrap.NewFromBytes(req.Msg.ResponseId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerResp(ctx, ResponseID, c.ers, c.iaes, c.cs, c.us))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">result, err := c.ers.GetExampleResp(ctx, ResponseID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">rpcResp, err := texampleresp.SeralizeModelToRPC(*result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">size := int32(len(rpcResp.Body))

        resp := &amp;responsev1.ResponseGetResponse{
                ResponseId: rpcResp.ResponseId,
                Status:     rpcResp.Status,
                Body:       rpcResp.Body,
                Time:       rpcResp.Time,
                Duration:   rpcResp.Duration,
                Size:       size,
        }

        return connect.NewResponse(resp), nil</span>
}

func (c *ResultService) ResponseHeaderList(ctx context.Context, req *connect.Request[responsev1.ResponseHeaderListRequest]) (*connect.Response[responsev1.ResponseHeaderListResponse], error) <span class="cov0" title="0">{
        ResponseID, err := idwrap.NewFromBytes(req.Msg.ResponseId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(CheckOwnerResp(ctx, ResponseID, c.ers, c.iaes, c.cs, c.us))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">headers, err := c.erhs.GetHeaderByRespID(ctx, ResponseID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // TODO: move to translate package
        <span class="cov0" title="0">var rpcHeaders []*responsev1.ResponseHeaderListItem
        for _, header := range headers </span><span class="cov0" title="0">{
                rpcHeader := &amp;responsev1.ResponseHeaderListItem{
                        ResponseHeaderId: header.ID.Bytes(),
                        Key:              header.HeaderKey,
                        Value:            header.Value,
                }
                rpcHeaders = append(rpcHeaders, rpcHeader)
        }</span>

        <span class="cov0" title="0">resp := &amp;responsev1.ResponseHeaderListResponse{
                ResponseId: req.Msg.ResponseId,
                Items:      rpcHeaders,
        }

        return connect.NewResponse(resp), nil</span>
}

func (c *ResultService) ResponseAssertList(ctx context.Context, req *connect.Request[responsev1.ResponseAssertListRequest]) (*connect.Response[responsev1.ResponseAssertListResponse], error) <span class="cov0" title="0">{
        ResponseID, err := idwrap.NewFromBytes(req.Msg.ResponseId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(CheckOwnerResp(ctx, ResponseID, c.ers, c.iaes, c.cs, c.us))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">assertResponse, err := c.asrs.GetAssertResultsByResponseID(ctx, ResponseID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // TODO: move to translate package
        <span class="cov0" title="0">var rpcAssertResponses []*responsev1.ResponseAssertListItem
        for _, assertResp := range assertResponse </span><span class="cov0" title="0">{
                assert, err := c.as.GetAssert(ctx, assertResp.AssertID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov0" title="0">a, err := tassert.SerializeAssertModelToRPC(*assert)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov0" title="0">rpcAssertResp := &amp;responsev1.ResponseAssertListItem{
                        Assert: a,
                        Result: assertResp.Result,
                }
                rpcAssertResponses = append(rpcAssertResponses, rpcAssertResp)</span>
        }

        <span class="cov0" title="0">resp := &amp;responsev1.ResponseAssertListResponse{
                Items:      rpcAssertResponses,
                ResponseId: req.Msg.ResponseId,
        }

        return connect.NewResponse(resp), nil</span>
}

func CheckOwnerResp(ctx context.Context, respID idwrap.IDWrap, ers sexampleresp.ExampleRespService,
        iaes sitemapiexample.ItemApiExampleService, cs scollection.CollectionService, us suser.UserService,
) (bool, error) <span class="cov8" title="1">{
        resp, err := ers.GetExampleResp(ctx, respID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">return ritemapiexample.CheckOwnerExample(ctx, iaes, cs, us, resp.ExampleID)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package rexport

import (
        "context"
        "database/sql"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/pkg/idwrap"
        yamlflowsimple "the-dev-tools/server/pkg/io/yamlflow/yamlflowsimple"
        "the-dev-tools/server/pkg/ioworkspace"
        "the-dev-tools/server/pkg/service/flow/sedge"
        "the-dev-tools/server/pkg/service/sassert"
        "the-dev-tools/server/pkg/service/sassertres"
        "the-dev-tools/server/pkg/service/sbodyform"
        "the-dev-tools/server/pkg/service/sbodyraw"
        "the-dev-tools/server/pkg/service/sbodyurl"
        "the-dev-tools/server/pkg/service/scollection"
        "the-dev-tools/server/pkg/service/senv"
        "the-dev-tools/server/pkg/service/sexampleheader"
        "the-dev-tools/server/pkg/service/sexamplequery"
        "the-dev-tools/server/pkg/service/sexampleresp"
        "the-dev-tools/server/pkg/service/sexamplerespheader"
        "the-dev-tools/server/pkg/service/sflow"
        "the-dev-tools/server/pkg/service/sflowvariable"
        "the-dev-tools/server/pkg/service/sitemapi"
        "the-dev-tools/server/pkg/service/sitemapiexample"
        "the-dev-tools/server/pkg/service/sitemfolder"
        "the-dev-tools/server/pkg/service/snode"
        "the-dev-tools/server/pkg/service/snodefor"
        "the-dev-tools/server/pkg/service/snodeforeach"
        "the-dev-tools/server/pkg/service/snodeif"
        "the-dev-tools/server/pkg/service/snodejs"
        "the-dev-tools/server/pkg/service/snodenoop"
        "the-dev-tools/server/pkg/service/snoderequest"
        "the-dev-tools/server/pkg/service/svar"
        "the-dev-tools/server/pkg/service/sworkspace"
        exportv1 "the-dev-tools/spec/dist/buf/go/export/v1"
        "the-dev-tools/spec/dist/buf/go/export/v1/exportv1connect"

        "connectrpc.com/connect"
)

type ExportRPC struct {
        DB *sql.DB

        workspaceService sworkspace.WorkspaceService

        collectionService scollection.CollectionService
        folderservice     sitemfolder.ItemFolderService
        endpointService   sitemapi.ItemApiService
        exampleService    sitemapiexample.ItemApiExampleService

        exampleHeaderService sexampleheader.HeaderService
        exampleQueryService  sexamplequery.ExampleQueryService
        exampleAssertService sassert.AssertService

        rawBodyService  sbodyraw.BodyRawService
        formBodyService sbodyform.BodyFormService
        urlBodyService  sbodyurl.BodyURLEncodedService

        responseService       sexampleresp.ExampleRespService
        responseHeaderService sexamplerespheader.ExampleRespHeaderService
        responseAssertService sassertres.AssertResultService

        flowService         sflow.FlowService
        flowNodeService     snode.NodeService
        flowEdgeService     sedge.EdgeService
        flowVariableService sflowvariable.FlowVariableService

        flowRequestService   snoderequest.NodeRequestService
        flowConditionService snodeif.NodeIfService
        flowNoopService      snodenoop.NodeNoopService
        flowForService       snodefor.NodeForService
        flowForEachService   snodeforeach.NodeForEachService
        flowJSService        snodejs.NodeJSService

        envService senv.EnvService
        varService svar.VarService
}

func New(
        DB *sql.DB,
        workspaceService sworkspace.WorkspaceService,
        collectionService scollection.CollectionService,
        folderservice sitemfolder.ItemFolderService,
        endpointService sitemapi.ItemApiService,
        exampleService sitemapiexample.ItemApiExampleService,
        exampleHeaderService sexampleheader.HeaderService,
        exampleQueryService sexamplequery.ExampleQueryService,
        exampleAssertService sassert.AssertService,
        rawBodyService sbodyraw.BodyRawService,
        formBodyService sbodyform.BodyFormService,
        urlBodyService sbodyurl.BodyURLEncodedService,
        responseService sexampleresp.ExampleRespService,
        responseHeaderService sexamplerespheader.ExampleRespHeaderService,
        responseAssertService sassertres.AssertResultService,
        flowService sflow.FlowService,
        flowNodeService snode.NodeService,
        flowEdgeService sedge.EdgeService,
        flowVariableService sflowvariable.FlowVariableService,

        flowRequestService snoderequest.NodeRequestService,
        flowConditionService snodeif.NodeIfService,
        flowNoopService snodenoop.NodeNoopService,
        flowForService snodefor.NodeForService,
        flowForEachService snodeforeach.NodeForEachService,
        flowJSService snodejs.NodeJSService,
        envService senv.EnvService,
        varService svar.VarService,
) ExportRPC <span class="cov0" title="0">{
        return ExportRPC{
                DB:                    DB,
                workspaceService:      workspaceService,
                collectionService:     collectionService,
                folderservice:         folderservice,
                endpointService:       endpointService,
                exampleService:        exampleService,
                exampleHeaderService:  exampleHeaderService,
                exampleQueryService:   exampleQueryService,
                exampleAssertService:  exampleAssertService,
                rawBodyService:        rawBodyService,
                formBodyService:       formBodyService,
                urlBodyService:        urlBodyService,
                responseService:       responseService,
                responseHeaderService: responseHeaderService,
                responseAssertService: responseAssertService,
                flowService:           flowService,
                flowNodeService:       flowNodeService,
                flowEdgeService:       flowEdgeService,
                flowVariableService:   flowVariableService,
                flowRequestService:    flowRequestService,
                flowConditionService:  flowConditionService,
                flowNoopService:       flowNoopService,
                flowForService:        flowForService,
                flowForEachService:    flowForEachService,
                flowJSService:         flowJSService,
                envService:            envService,
                varService:            varService,
        }
}</span>

func CreateService(srv ExportRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := exportv1connect.NewExportServiceHandler(&amp;srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

func (c *ExportRPC) Export(ctx context.Context, req *connect.Request[exportv1.ExportRequest]) (*connect.Response[exportv1.ExportResponse], error) <span class="cov0" title="0">{

        workspaceID, err := idwrap.NewFromBytes(req.Msg.WorkspaceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">filterExport := ioworkspace.FilterExport{}
        if len(req.Msg.FlowIds) != 0 </span><span class="cov0" title="0">{
                filterIds := []idwrap.IDWrap{}
                for _, flowId := range req.Msg.FlowIds </span><span class="cov0" title="0">{
                        filterID, err := idwrap.NewFromBytes(flowId)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInvalidArgument, err)
                        }</span>
                        <span class="cov0" title="0">filterIds = append(filterIds, filterID)</span>
                }
                <span class="cov0" title="0">filterExport.FilterFlowIds = &amp;filterIds</span>
        }

        <span class="cov0" title="0">if len(req.Msg.ExampleIds) != 0 </span><span class="cov0" title="0">{
                exampleIds := []idwrap.IDWrap{}
                for _, exampleId := range req.Msg.ExampleIds </span><span class="cov0" title="0">{
                        exampleId, err := idwrap.NewFromBytes(exampleId)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInvalidArgument, err)
                        }</span>
                        <span class="cov0" title="0">exampleIds = append(exampleIds, exampleId)</span>
                }
                <span class="cov0" title="0">filterExport.FilterExampleIds = &amp;exampleIds</span>
        }

        <span class="cov0" title="0">ioWorkspace := ioworkspace.NewIOWorkspaceService(
                c.DB,
                c.workspaceService,
                c.collectionService,
                c.folderservice,
                c.endpointService,
                c.exampleService,
                c.exampleHeaderService,
                c.exampleQueryService,
                c.exampleAssertService,
                c.rawBodyService,
                c.formBodyService,
                c.urlBodyService,
                c.responseService,
                c.responseHeaderService,
                c.responseAssertService,
                c.flowService,
                c.flowNodeService,
                c.flowEdgeService,
                c.flowVariableService,
                c.flowRequestService,
                c.flowConditionService,
                c.flowNoopService,
                c.flowForService,
                c.flowForEachService,
                c.flowJSService,
                c.envService,
                c.varService,
        )

        workspaceData, err := ioWorkspace.ExportWorkspace(ctx, workspaceID, filterExport)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // Use simplified YAML format by default
        <span class="cov0" title="0">simplifiedYAML, err := yamlflowsimple.ExportYamlFlowYAML(workspaceData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">resp := &amp;exportv1.ExportResponse{
                Name: workspaceData.Workspace.Name + ".yaml",
                Data: simplifiedYAML,
        }

        return connect.NewResponse(resp), nil</span>
}

// ExportSimplified exports workspace in simplified YAML format
func (c *ExportRPC) ExportSimplified(ctx context.Context, req *connect.Request[exportv1.ExportRequest]) (*connect.Response[exportv1.ExportResponse], error) <span class="cov0" title="0">{
        workspaceID, err := idwrap.NewFromBytes(req.Msg.WorkspaceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">filterExport := ioworkspace.FilterExport{}
        if len(req.Msg.FlowIds) != 0 </span><span class="cov0" title="0">{
                filterIds := []idwrap.IDWrap{}
                for _, flowId := range req.Msg.FlowIds </span><span class="cov0" title="0">{
                        filterID, err := idwrap.NewFromBytes(flowId)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInvalidArgument, err)
                        }</span>
                        <span class="cov0" title="0">filterIds = append(filterIds, filterID)</span>
                }
                <span class="cov0" title="0">filterExport.FilterFlowIds = &amp;filterIds</span>
        }

        <span class="cov0" title="0">ioWorkspace := ioworkspace.NewIOWorkspaceService(
                c.DB,
                c.workspaceService,
                c.collectionService,
                c.folderservice,
                c.endpointService,
                c.exampleService,
                c.exampleHeaderService,
                c.exampleQueryService,
                c.exampleAssertService,
                c.rawBodyService,
                c.formBodyService,
                c.urlBodyService,
                c.responseService,
                c.responseHeaderService,
                c.responseAssertService,
                c.flowService,
                c.flowNodeService,
                c.flowEdgeService,
                c.flowVariableService,
                c.flowRequestService,
                c.flowConditionService,
                c.flowNoopService,
                c.flowForService,
                c.flowForEachService,
                c.flowJSService,
                c.envService,
                c.varService,
        )

        workspaceData, err := ioWorkspace.ExportWorkspace(ctx, workspaceID, filterExport)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // Convert to simplified format
        <span class="cov0" title="0">simplifiedYAML, err := yamlflowsimple.ExportYamlFlowYAML(workspaceData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">resp := &amp;exportv1.ExportResponse{
                Name: workspaceData.Workspace.Name + "_simplified.yaml",
                Data: simplifiedYAML,
        }

        return connect.NewResponse(resp), nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package rflow

import (
        "bytes"
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "sort"
        "strings"
        "sync"
        "sync/atomic"
        devtoolsdb "the-dev-tools/db"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/ritemapiexample"
        "the-dev-tools/server/internal/api/rtag"
        "the-dev-tools/server/internal/api/rworkspace"
        "the-dev-tools/server/pkg/compress"
        "the-dev-tools/server/pkg/dbtime"
        "the-dev-tools/server/pkg/flow/edge"
        "the-dev-tools/server/pkg/flow/node"
        "the-dev-tools/server/pkg/flow/node/nfor"
        "the-dev-tools/server/pkg/flow/node/nforeach"
        "the-dev-tools/server/pkg/flow/node/nif"
        "the-dev-tools/server/pkg/flow/node/njs"
        "the-dev-tools/server/pkg/flow/node/nnoop"
        "the-dev-tools/server/pkg/flow/node/nrequest"
        "the-dev-tools/server/pkg/flow/runner"
        "the-dev-tools/server/pkg/flow/runner/flowlocalrunner"
        "the-dev-tools/server/pkg/http/request"
        "the-dev-tools/server/pkg/httpclient"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/logconsole"
        "the-dev-tools/server/pkg/model/massert"
        "the-dev-tools/server/pkg/model/massertres"
        "the-dev-tools/server/pkg/model/mexampleresp"
        "the-dev-tools/server/pkg/model/mflow"
        "the-dev-tools/server/pkg/model/mnnode"
        "the-dev-tools/server/pkg/model/mnnode/mnfor"
        "the-dev-tools/server/pkg/model/mnnode/mnforeach"
        "the-dev-tools/server/pkg/model/mnnode/mnif"
        "the-dev-tools/server/pkg/model/mnnode/mnjs"
        "the-dev-tools/server/pkg/model/mnnode/mnnoop"
        "the-dev-tools/server/pkg/model/mnnode/mnrequest"
        "the-dev-tools/server/pkg/model/mnodeexecution"
        "the-dev-tools/server/pkg/permcheck"
        "the-dev-tools/server/pkg/reference"
        "the-dev-tools/server/pkg/service/flow/sedge"
        "the-dev-tools/server/pkg/service/sassert"
        "the-dev-tools/server/pkg/service/sassertres"
        "the-dev-tools/server/pkg/service/sbodyform"
        "the-dev-tools/server/pkg/service/sbodyraw"
        "the-dev-tools/server/pkg/service/sbodyurl"
        "the-dev-tools/server/pkg/service/sexampleheader"
        "the-dev-tools/server/pkg/service/sexamplequery"
        "the-dev-tools/server/pkg/service/sexampleresp"
        "the-dev-tools/server/pkg/service/sexamplerespheader"
        "the-dev-tools/server/pkg/service/sflow"
        "the-dev-tools/server/pkg/service/sflowtag"
        "the-dev-tools/server/pkg/service/sflowvariable"
        "the-dev-tools/server/pkg/service/sitemapi"
        "the-dev-tools/server/pkg/service/sitemapiexample"
        "the-dev-tools/server/pkg/service/snode"
        "the-dev-tools/server/pkg/service/snodeexecution"
        "the-dev-tools/server/pkg/service/snodefor"
        "the-dev-tools/server/pkg/service/snodeforeach"
        "the-dev-tools/server/pkg/service/snodeif"
        "the-dev-tools/server/pkg/service/snodejs"
        "the-dev-tools/server/pkg/service/snodenoop"
        "the-dev-tools/server/pkg/service/snoderequest"
        "the-dev-tools/server/pkg/service/stag"
        "the-dev-tools/server/pkg/service/suser"
        "the-dev-tools/server/pkg/service/sworkspace"
        "the-dev-tools/server/pkg/translate/tflow"
        "the-dev-tools/server/pkg/translate/tflowversion"
        "the-dev-tools/server/pkg/translate/tgeneric"
        nodev1 "the-dev-tools/spec/dist/buf/go/flow/node/v1"
        flowv1 "the-dev-tools/spec/dist/buf/go/flow/v1"
        "the-dev-tools/spec/dist/buf/go/flow/v1/flowv1connect"
        "the-dev-tools/spec/dist/buf/go/nodejs_executor/v1/nodejs_executorv1connect"
        "time"

        "connectrpc.com/connect"
)

// preRegisteredRequestNode wraps a REQUEST node to handle pre-registration of ExecutionIDs
// This fixes the race condition where responses arrive before ExecutionID is added to pendingNodeExecutions
type preRegisteredRequestNode struct {
        nodeRequest             node.FlowNode
        preRegisteredExecutions map[idwrap.IDWrap]struct{}
        preRegisteredMutex      *sync.RWMutex
}

// Implement node.FlowNode interface
func (p *preRegisteredRequestNode) GetID() idwrap.IDWrap <span class="cov0" title="0">{
        return p.nodeRequest.GetID()
}</span>

func (p *preRegisteredRequestNode) GetName() string <span class="cov0" title="0">{
        return p.nodeRequest.GetName()
}</span>

func (p *preRegisteredRequestNode) RunSync(ctx context.Context, req *node.FlowNodeRequest) node.FlowNodeResult <span class="cov0" title="0">{
        // Pre-register the ExecutionID before running the request
        if req.ExecutionID != (idwrap.IDWrap{}) </span><span class="cov0" title="0">{
                p.preRegisteredMutex.Lock()
                p.preRegisteredExecutions[req.ExecutionID] = struct{}{}
                p.preRegisteredMutex.Unlock()
                log.Printf("🔄 Pre-registered ExecutionID %s for REQUEST node", req.ExecutionID.String())
        }</span>

        // Run the actual request node
        <span class="cov0" title="0">return p.nodeRequest.RunSync(ctx, req)</span>
}

func (p *preRegisteredRequestNode) RunAsync(ctx context.Context, req *node.FlowNodeRequest, resultChan chan node.FlowNodeResult) <span class="cov0" title="0">{
        // Pre-register the ExecutionID before running the request
        if req.ExecutionID != (idwrap.IDWrap{}) </span><span class="cov0" title="0">{
                p.preRegisteredMutex.Lock()
                p.preRegisteredExecutions[req.ExecutionID] = struct{}{}
                p.preRegisteredMutex.Unlock()
                log.Printf("🔄 Pre-registered ExecutionID %s for REQUEST node (async)", req.ExecutionID.String())
        }</span>

        // Run the actual request node
        <span class="cov0" title="0">p.nodeRequest.RunAsync(ctx, req, resultChan)</span>
}

// CorrelationMetrics tracks correlation effectiveness and performance
type CorrelationMetrics struct {
        // Counters
        successfulCorrelations int64 // Successful immediate correlations
        orphanedResponses      int64 // Responses that arrived before ExecutionID registration
        delayedCorrelations    int64 // Orphaned responses later correlated successfully
        failedCorrelations     int64 // Failed to correlate after timeout
        preRegistrations       int64 // ExecutionIDs pre-registered
        deregistrations        int64 // ExecutionIDs removed from pending map
        cleanupOperations      int64 // Memory cleanup operations
        retryAttempts          int64 // Correlation retry attempts

        // Timing metrics (in milliseconds)
        totalCorrelationDelay int64 // Total delay for all correlations
        maxCorrelationDelay   int64 // Maximum delay observed
        minCorrelationDelay   int64 // Minimum delay observed (initialized to max value)

        // Map sizes for memory monitoring
        maxPendingMapSize      int64 // Maximum pending executions map size
        maxOrphanedMapSize     int64 // Maximum orphaned responses map size
        currentPendingMapSize  int64 // Current pending executions map size
        currentOrphanedMapSize int64 // Current orphaned responses map size

        // Performance thresholds
        delayWarningThreshold  int64 // 100ms default
        memoryWarningThreshold int   // 1000 entries default

        mu sync.RWMutex // Protects all metrics
}

// NewCorrelationMetrics creates a new metrics tracker
func NewCorrelationMetrics() *CorrelationMetrics <span class="cov8" title="1">{
        return &amp;CorrelationMetrics{
                minCorrelationDelay:    9223372036854775807, // max int64
                delayWarningThreshold:  100,                 // 100ms
                memoryWarningThreshold: 1000,                // 1000 entries
        }
}</span>

// RecordSuccessfulCorrelation records an immediate correlation success
func (cm *CorrelationMetrics) RecordSuccessfulCorrelation(delayMs int64) <span class="cov0" title="0">{
        cm.mu.Lock()
        defer cm.mu.Unlock()
        cm.successfulCorrelations++
        cm.updateDelayMetrics(delayMs)
}</span>

// RecordOrphanedResponse records when a response arrives before ExecutionID registration
func (cm *CorrelationMetrics) RecordOrphanedResponse() <span class="cov0" title="0">{
        cm.mu.Lock()
        defer cm.mu.Unlock()
        cm.orphanedResponses++
}</span>

// RecordDelayedCorrelation records when an orphaned response is later correlated
func (cm *CorrelationMetrics) RecordDelayedCorrelation(delayMs int64) <span class="cov0" title="0">{
        cm.mu.Lock()
        defer cm.mu.Unlock()
        cm.delayedCorrelations++
        cm.updateDelayMetrics(delayMs)
}</span>

// RecordFailedCorrelation records when correlation fails after timeout
func (cm *CorrelationMetrics) RecordFailedCorrelation() <span class="cov0" title="0">{
        cm.mu.Lock()
        defer cm.mu.Unlock()
        cm.failedCorrelations++
}</span>

// RecordPreRegistration records when an ExecutionID is pre-registered
func (cm *CorrelationMetrics) RecordPreRegistration() <span class="cov8" title="1">{
        cm.mu.Lock()
        defer cm.mu.Unlock()
        cm.preRegistrations++
}</span>

// RecordDeregistration records when an ExecutionID is removed from pending map
func (cm *CorrelationMetrics) RecordDeregistration() <span class="cov8" title="1">{
        cm.mu.Lock()
        defer cm.mu.Unlock()
        cm.deregistrations++
}</span>

// RecordCleanupOperation records memory cleanup operations
func (cm *CorrelationMetrics) RecordCleanupOperation() <span class="cov0" title="0">{
        cm.mu.Lock()
        defer cm.mu.Unlock()
        cm.cleanupOperations++
}</span>

// RecordRetryAttempt records correlation retry attempts
func (cm *CorrelationMetrics) RecordRetryAttempt() <span class="cov0" title="0">{
        cm.mu.Lock()
        defer cm.mu.Unlock()
        cm.retryAttempts++
}</span>

// UpdateMapSizes updates current map sizes and tracks maximums
func (cm *CorrelationMetrics) UpdateMapSizes(pendingSize, orphanedSize int) <span class="cov8" title="1">{
        cm.mu.Lock()
        defer cm.mu.Unlock()
        cm.currentPendingMapSize = int64(pendingSize)
        cm.currentOrphanedMapSize = int64(orphanedSize)
        if int64(pendingSize) &gt; cm.maxPendingMapSize </span><span class="cov8" title="1">{
                cm.maxPendingMapSize = int64(pendingSize)
        }</span>
        <span class="cov8" title="1">if int64(orphanedSize) &gt; cm.maxOrphanedMapSize </span><span class="cov0" title="0">{
                cm.maxOrphanedMapSize = int64(orphanedSize)
        }</span>
}

// updateDelayMetrics updates delay timing metrics (must be called with lock held)
func (cm *CorrelationMetrics) updateDelayMetrics(delayMs int64) <span class="cov0" title="0">{
        cm.totalCorrelationDelay += delayMs
        if delayMs &gt; cm.maxCorrelationDelay </span><span class="cov0" title="0">{
                cm.maxCorrelationDelay = delayMs
        }</span>
        <span class="cov0" title="0">if delayMs &lt; cm.minCorrelationDelay </span><span class="cov0" title="0">{
                cm.minCorrelationDelay = delayMs
        }</span>
}

// GetAverageCorrelationDelay returns the average correlation delay
func (cm *CorrelationMetrics) GetAverageCorrelationDelay() float64 <span class="cov0" title="0">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()
        totalCorrelations := cm.successfulCorrelations + cm.delayedCorrelations
        if totalCorrelations == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return float64(cm.totalCorrelationDelay) / float64(totalCorrelations)</span>
}

// GetMetricsSummary returns a formatted summary of all metrics
func (cm *CorrelationMetrics) GetMetricsSummary() string <span class="cov8" title="1">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()
        totalCorrelations := cm.successfulCorrelations + cm.delayedCorrelations
        avgDelay := float64(0)
        if totalCorrelations &gt; 0 </span><span class="cov0" title="0">{
                avgDelay = float64(cm.totalCorrelationDelay) / float64(totalCorrelations)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf(
                "📊 Correlation Metrics Summary: "+
                        "✅ Successful: %d, "+
                        "🔄 Orphaned: %d, "+
                        "⏰ Delayed: %d, "+
                        "❌ Failed: %d, "+
                        "📝 Pre-reg: %d, "+
                        "🗑️ Dereg: %d, "+
                        "🧹 Cleanup: %d, "+
                        "🔁 Retries: %d, "+
                        "⏱️ Avg Delay: %.1fms, "+
                        "⏱️ Max Delay: %dms, "+
                        "📈 Max Pending: %d, "+
                        "📈 Max Orphaned: %d",
                cm.successfulCorrelations,
                cm.orphanedResponses,
                cm.delayedCorrelations,
                cm.failedCorrelations,
                cm.preRegistrations,
                cm.deregistrations,
                cm.cleanupOperations,
                cm.retryAttempts,
                avgDelay,
                cm.maxCorrelationDelay,
                cm.maxPendingMapSize,
                cm.maxOrphanedMapSize,
        )</span>
}

// ShouldWarnAboutDelay returns true if the delay exceeds the warning threshold
func (cm *CorrelationMetrics) ShouldWarnAboutDelay(delayMs int64) bool <span class="cov0" title="0">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()
        return delayMs &gt; cm.delayWarningThreshold
}</span>

// ShouldWarnAboutMemory returns true if map sizes exceed warning thresholds
func (cm *CorrelationMetrics) ShouldWarnAboutMemory(pendingSize, orphanedSize int) bool <span class="cov0" title="0">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()
        return pendingSize &gt; cm.memoryWarningThreshold || orphanedSize &gt; cm.memoryWarningThreshold
}</span>

// formatIterationContext formats the iteration context into hierarchical format with node names
func formatIterationContext(ctx *runner.IterationContext, nodeNameMap map[idwrap.IDWrap]string, nodeID idwrap.IDWrap, parentNodes []idwrap.IDWrap, isLoopNode bool, executionCount int) string <span class="cov8" title="1">{
        if ctx == nil || len(ctx.IterationPath) == 0 </span><span class="cov0" title="0">{
                // For non-loop nodes without iteration context, add execution number
                if !isLoopNode </span><span class="cov0" title="0">{
                        nodeName := nodeNameMap[nodeID]
                        if nodeName != "" </span><span class="cov0" title="0">{
                                return fmt.Sprintf("%s - Execution %d", nodeName, executionCount)
                        }</span>
                }
                <span class="cov0" title="0">return "Execution 1"</span>
        }

        // Use parent nodes from the IterationContext if available, otherwise fall back to passed parentNodes
        <span class="cov8" title="1">actualParentNodes := ctx.ParentNodes
        if len(actualParentNodes) == 0 </span><span class="cov0" title="0">{
                actualParentNodes = parentNodes
        }</span>

        // Build hierarchical format with pipe separators (no "Execution 1" prefix for loop iterations)
        <span class="cov8" title="1">var parts []string

        // Add parent loop nodes with their iteration numbers (deepest to shallowest)
        for i := len(ctx.IterationPath) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if i &lt; len(actualParentNodes) </span><span class="cov8" title="1">{
                        parentName := nodeNameMap[actualParentNodes[i]]
                        if parentName != "" </span><span class="cov8" title="1">{
                                parts = append(parts, fmt.Sprintf("%s iteration %d", parentName, ctx.IterationPath[i]+1))
                        }</span>
                }
        }

        // For non-loop nodes, add the current node name with execution number (shallowest level)
        <span class="cov8" title="1">if !isLoopNode </span><span class="cov8" title="1">{
                currentNodeName := nodeNameMap[nodeID]
                if currentNodeName != "" </span><span class="cov8" title="1">{
                        // Use ExecutionIndex from context if available (for child nodes in loops)
                        // Otherwise use the global execution count
                        execNum := executionCount
                        if ctx != nil &amp;&amp; len(ctx.IterationPath) &gt; 0 </span><span class="cov8" title="1">{
                                // For child nodes within loops, use ExecutionIndex + 1 (1-based)
                                execNum = ctx.ExecutionIndex + 1
                        }</span>
                        <span class="cov8" title="1">parts = append(parts, fmt.Sprintf("%s - Execution %d", currentNodeName, execNum))</span>
                }
        }

        // Join with pipe separator
        <span class="cov8" title="1">if len(parts) &gt; 0 </span><span class="cov8" title="1">{
                return strings.Join(parts, " | ")
        }</span>

        // Fallback if no parent nodes found
        <span class="cov0" title="0">return "Execution 1"</span>
}

type FlowServiceRPC struct {
        DB *sql.DB
        ws sworkspace.WorkspaceService
        us suser.UserService
        ts stag.TagService

        // flow
        fs  sflow.FlowService
        fts sflowtag.FlowTagService
        fes sedge.EdgeService
        fvs sflowvariable.FlowVariableService

        // request
        ias sitemapi.ItemApiService
        es  sitemapiexample.ItemApiExampleService
        qs  sexamplequery.ExampleQueryService
        hs  sexampleheader.HeaderService

        // body
        brs  sbodyraw.BodyRawService
        bfs  sbodyform.BodyFormService
        bues sbodyurl.BodyURLEncodedService

        // response
        ers  sexampleresp.ExampleRespService
        erhs sexamplerespheader.ExampleRespHeaderService
        as   sassert.AssertService
        ars  sassertres.AssertResultService

        // sub nodes
        ns   snode.NodeService
        rns  snoderequest.NodeRequestService
        fns  snodefor.NodeForService
        fens snodeforeach.NodeForEachService
        sns  snodenoop.NodeNoopService
        ins  snodeif.NodeIfService
        jsns snodejs.NodeJSService

        // node execution
        nes snodeexecution.NodeExecutionService

        logChanMap logconsole.LogChanMap
}

func New(db *sql.DB, ws sworkspace.WorkspaceService, us suser.UserService, ts stag.TagService,
        // flow
        fs sflow.FlowService, fts sflowtag.FlowTagService, fes sedge.EdgeService, fvs sflowvariable.FlowVariableService,
        // req
        ias sitemapi.ItemApiService, es sitemapiexample.ItemApiExampleService, qs sexamplequery.ExampleQueryService, hs sexampleheader.HeaderService,
        // body
        brs sbodyraw.BodyRawService, bfs sbodyform.BodyFormService, bues sbodyurl.BodyURLEncodedService,
        // resp
        ers sexampleresp.ExampleRespService, erhs sexamplerespheader.ExampleRespHeaderService, as sassert.AssertService, ars sassertres.AssertResultService,
        // sub nodes
        ns snode.NodeService, rns snoderequest.NodeRequestService, flns snodefor.NodeForService, fens snodeforeach.NodeForEachService,
        sns snodenoop.NodeNoopService, ins snodeif.NodeIfService, jsns snodejs.NodeJSService,
        // node execution
        nes snodeexecution.NodeExecutionService,
        logChanMap logconsole.LogChanMap,
) FlowServiceRPC <span class="cov8" title="1">{
        return FlowServiceRPC{
                DB: db,
                ws: ws,
                us: us,
                ts: ts,

                // flow
                fs:  fs,
                fes: fes,
                fts: fts,
                fvs: fvs,

                // request
                ias: ias,
                es:  es,
                qs:  qs,
                hs:  hs,

                // body
                brs:  brs,
                bfs:  bfs,
                bues: bues,

                // resp
                ers:  ers,
                erhs: erhs,
                as:   as,
                ars:  ars,

                // sub nodes
                ns:   ns,
                rns:  rns,
                fns:  flns,
                fens: fens,
                sns:  sns,
                ins:  ins,
                jsns: jsns,

                // node execution
                nes: nes,

                logChanMap: logChanMap,
        }
}</span>

func CreateService(srv FlowServiceRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := flowv1connect.NewFlowServiceHandler(&amp;srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

func (c *FlowServiceRPC) FlowList(ctx context.Context, req *connect.Request[flowv1.FlowListRequest]) (*connect.Response[flowv1.FlowListResponse], error) <span class="cov8" title="1">{
        workspaceID, err := idwrap.NewFromBytes(req.Msg.WorkspaceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">var tagIDPtr *idwrap.IDWrap
        if len(req.Msg.TagId) &gt; 0 </span><span class="cov8" title="1">{
                tagID, err := idwrap.NewFromBytes(req.Msg.TagId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>
                <span class="cov8" title="1">tagIDPtr = &amp;tagID</span>
        }

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(rworkspace.CheckOwnerWorkspace(ctx, c.us, workspaceID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">var rpcFlows []*flowv1.FlowListItem

        if tagIDPtr == nil </span><span class="cov8" title="1">{
                flow, err := c.fs.GetFlowsByWorkspaceID(ctx, workspaceID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov8" title="1">rpcFlows = append(rpcFlows, tgeneric.MassConvert(flow, tflow.SeralizeModelToRPCItem)...)</span>

        } else<span class="cov8" title="1"> {
                rpcErr := permcheck.CheckPerm(rtag.CheckOwnerTag(ctx, c.ts, c.us, *tagIDPtr))
                if rpcErr != nil </span><span class="cov0" title="0">{
                        return nil, rpcErr
                }</span>
                <span class="cov8" title="1">tagFlows, err := c.fts.GetFlowTagsByTagID(ctx, *tagIDPtr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>

                // TODO: make this one query
                <span class="cov8" title="1">for _, tagFlow := range tagFlows </span><span class="cov8" title="1">{
                        latestFlow, err := c.fs.GetFlow(ctx, tagFlow.FlowID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>

                        <span class="cov8" title="1">rpcFlow := tflow.SeralizeModelToRPCItem(latestFlow)
                        rpcFlows = append(rpcFlows, rpcFlow)</span>
                }
        }

        <span class="cov8" title="1">rpcResp := &amp;flowv1.FlowListResponse{
                WorkspaceId: req.Msg.WorkspaceId,
                TagId:       req.Msg.TagId,
                Items:       rpcFlows,
        }
        return connect.NewResponse(rpcResp), nil</span>
}

func (c *FlowServiceRPC) FlowGet(ctx context.Context, req *connect.Request[flowv1.FlowGetRequest]) (*connect.Response[flowv1.FlowGetResponse], error) <span class="cov8" title="1">{
        if len(req.Msg.FlowId) == 0 </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("flow id is required"))
        }</span>
        <span class="cov8" title="1">flowID, err := idwrap.NewFromBytes(req.Msg.FlowId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerFlow(ctx, c.fs, c.us, flowID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">flow, err := c.fs.GetFlow(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">rpcFlow := tflow.SeralizeModelToRPC(flow)
        rpcResp := &amp;flowv1.FlowGetResponse{
                FlowId: rpcFlow.FlowId,
                Name:   rpcFlow.Name,
        }
        return connect.NewResponse(rpcResp), nil</span>
}

func (c *FlowServiceRPC) FlowCreate(ctx context.Context, req *connect.Request[flowv1.FlowCreateRequest]) (*connect.Response[flowv1.FlowCreateResponse], error) <span class="cov8" title="1">{
        workspaceID, err := idwrap.NewFromBytes(req.Msg.WorkspaceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(rworkspace.CheckOwnerWorkspace(ctx, c.us, workspaceID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">ws, err := c.ws.Get(ctx, workspaceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">name := req.Msg.Name

        flowID := idwrap.NewNow()

        flow := mflow.Flow{
                ID:          flowID,
                WorkspaceID: workspaceID,
                Name:        name,
        }

        nodeNoopID := idwrap.NewNow()

        tx, err := c.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">defer devtoolsdb.TxnRollback(tx)

        txFlow, err := sflow.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">txNode, err := snode.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">txNoopNode, err := snodenoop.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">err = txFlow.CreateFlow(ctx, flow)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = txNode.CreateNode(ctx, mnnode.MNode{
                ID:        nodeNoopID,
                FlowID:    flowID,
                Name:      "Default Start Node",
                NodeKind:  mnnode.NODE_KIND_NO_OP,
                PositionX: float64(0),
                PositionY: float64(0),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = txNoopNode.CreateNodeNoop(ctx, mnnoop.NoopNode{
                FlowNodeID: nodeNoopID,
                Type:       mnnoop.NODE_NO_OP_KIND_START,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">ws.FlowCount++
        ws.Updated = dbtime.DBNow()
        err = c.ws.Update(ctx, ws)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;flowv1.FlowCreateResponse{
                FlowId: flowID.Bytes(),
        }), nil</span>
}

func (c *FlowServiceRPC) FlowUpdate(ctx context.Context, req *connect.Request[flowv1.FlowUpdateRequest]) (*connect.Response[flowv1.FlowUpdateResponse], error) <span class="cov8" title="1">{
        msg := req.Msg
        if msg.FlowId == nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("flow id is required"))
        }</span>
        <span class="cov8" title="1">if msg.Name == nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("name is required"))
        }</span>

        <span class="cov8" title="1">flowID, err := idwrap.NewFromBytes(msg.FlowId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerFlow(ctx, c.fs, c.us, flowID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">flow, err := c.fs.GetFlow(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">flow.Name = *msg.Name

        err = c.fs.UpdateFlow(ctx, flow)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;flowv1.FlowUpdateResponse{}), nil</span>
}

func (c *FlowServiceRPC) FlowDelete(ctx context.Context, req *connect.Request[flowv1.FlowDeleteRequest]) (*connect.Response[flowv1.FlowDeleteResponse], error) <span class="cov8" title="1">{
        flowID, err := idwrap.NewFromBytes(req.Msg.FlowId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerFlow(ctx, c.fs, c.us, flowID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">flow, err := c.fs.GetFlow(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = c.fs.DeleteFlow(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ws, err := c.ws.Get(ctx, flow.WorkspaceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ws.FlowCount--
        ws.Updated = dbtime.DBNow()
        err = c.ws.Update(ctx, ws)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">return connect.NewResponse(&amp;flowv1.FlowDeleteResponse{}), nil</span>
}

func (c *FlowServiceRPC) cleanupNodeExecutions(ctx context.Context, flowID idwrap.IDWrap) error <span class="cov8" title="1">{
        // Get all nodes for this flow
        nodes, err := c.ns.GetNodesByFlowID(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("get nodes: %w", err)
        }</span>

        // Collect node IDs for batch delete
        <span class="cov8" title="1">nodeIDs := make([]idwrap.IDWrap, len(nodes))
        for i, node := range nodes </span><span class="cov8" title="1">{
                nodeIDs[i] = node.ID
        }</span>

        // Single batch delete - fast and simple
        <span class="cov8" title="1">return c.nes.DeleteNodeExecutionsByNodeIDs(ctx, nodeIDs)</span>
}

func (c *FlowServiceRPC) FlowRun(ctx context.Context, req *connect.Request[flowv1.FlowRunRequest], stream *connect.ServerStream[flowv1.FlowRunResponse]) error <span class="cov0" title="0">{
        return c.FlowRunAdHoc(ctx, req, stream)
}</span>

func (c *FlowServiceRPC) FlowRunAdHoc(ctx context.Context, req *connect.Request[flowv1.FlowRunRequest], stream api.ServerStreamAdHoc[flowv1.FlowRunResponse]) error <span class="cov8" title="1">{
        flowID, err := idwrap.NewFromBytes(req.Msg.FlowId)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerFlow(ctx, c.fs, c.us, flowID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return rpcErr
        }</span>

        <span class="cov8" title="1">flow, err := c.fs.GetFlow(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">flowVars, err := c.fvs.GetFlowVariablesByFlowID(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">latestFlowID := flow.ID

        // Clean up old executions before starting
        cleanupCtx, cleanupCancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cleanupCancel()

        if err := c.cleanupNodeExecutions(cleanupCtx, flowID); err != nil </span><span class="cov0" title="0">{
                // Log but don't fail the run
                log.Printf("Warning: Failed to cleanup old executions for flow %s: %v", flowID, err)
        }</span>

        <span class="cov8" title="1">nodes, err := c.ns.GetNodesByFlowID(ctx, latestFlowID)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, errors.New("get nodes"))
        }</span>

        <span class="cov8" title="1">edges, err := c.fes.GetEdgesByFlowID(ctx, latestFlowID)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, errors.New("get edges"))
        }</span>
        <span class="cov8" title="1">edgeMap := edge.NewEdgesMap(edges)

        var requestNodes []mnrequest.MNRequest
        var forNodes []mnfor.MNFor
        var forEachNodes []mnforeach.MNForEach
        var ifNodes []mnif.MNIF
        var noopNodes []mnnoop.NoopNode
        var jsNodes []mnjs.MNJS
        var startNodeID idwrap.IDWrap

        nodeNameMap := make(map[idwrap.IDWrap]string, len(nodes))

        for _, node := range nodes </span><span class="cov8" title="1">{
                nodeNameMap[node.ID] = node.Name

                switch node.NodeKind </span>{
                case mnnode.NODE_KIND_REQUEST:<span class="cov8" title="1">
                        rn, err := c.rns.GetNodeRequest(ctx, node.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, fmt.Errorf("get node request: %w", err))
                        }</span>
                        <span class="cov8" title="1">requestNodes = append(requestNodes, *rn)</span>
                case mnnode.NODE_KIND_FOR:<span class="cov8" title="1">
                        fn, err := c.fns.GetNodeFor(ctx, node.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, fmt.Errorf("get node for: %w", err))
                        }</span>
                        <span class="cov8" title="1">forNodes = append(forNodes, *fn)</span>
                case mnnode.NODE_KIND_FOR_EACH:<span class="cov8" title="1">
                        fen, err := c.fens.GetNodeForEach(ctx, node.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, fmt.Errorf("get node for each: %w", err))
                        }</span>
                        <span class="cov8" title="1">forEachNodes = append(forEachNodes, *fen)</span>
                case mnnode.NODE_KIND_NO_OP:<span class="cov8" title="1">
                        sn, err := c.sns.GetNodeNoop(ctx, node.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, fmt.Errorf("get node start: %w", err))
                        }</span>
                        <span class="cov8" title="1">noopNodes = append(noopNodes, *sn)</span>
                case mnnode.NODE_KIND_CONDITION:<span class="cov0" title="0">
                        in, err := c.ins.GetNodeIf(ctx, node.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, errors.New("get node if"))
                        }</span>
                        <span class="cov0" title="0">ifNodes = append(ifNodes, *in)</span>
                case mnnode.NODE_KIND_JS:<span class="cov8" title="1">
                        jsn, err := c.jsns.GetNodeJS(ctx, node.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, fmt.Errorf("get node js: %w", err))
                        }</span>
                        <span class="cov8" title="1">jsNodes = append(jsNodes, jsn)</span>
                default:<span class="cov0" title="0">
                        return connect.NewError(connect.CodeInternal, errors.New("not supported node"))</span>
                }
        }

        <span class="cov8" title="1">var foundStartNode bool
        for _, node := range noopNodes </span><span class="cov8" title="1">{
                if node.Type == mnnoop.NODE_NO_OP_KIND_START </span><span class="cov8" title="1">{
                        if foundStartNode </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, errors.New("multiple start nodes"))
                        }</span>
                        <span class="cov8" title="1">foundStartNode = true
                        startNodeID = node.FlowNodeID</span>
                }
        }
        <span class="cov8" title="1">if !foundStartNode </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, errors.New("no start node"))
        }</span>

        // Get flow variables first to check for timeout override
        <span class="cov8" title="1">flowVarsMap := make(map[string]any, len(flowVars))
        for _, flowVar := range flowVars </span><span class="cov8" title="1">{
                if flowVar.Enabled </span><span class="cov0" title="0">{
                        flowVarsMap[flowVar.Name] = flowVar.Value
                }</span>
        }

        // Create temporary request to safely read timeout variable
        <span class="cov8" title="1">tempReq := &amp;node.FlowNodeRequest{
                VarMap:        flowVarsMap,
                ReadWriteLock: &amp;sync.RWMutex{},
        }

        // Set default timeout to 60 seconds, check for timeout variable override
        nodeTimeout := time.Second * 60
        if timeoutVar, err := node.ReadVarRaw(tempReq, "timeout"); err == nil </span><span class="cov0" title="0">{
                if timeoutSeconds, ok := timeoutVar.(float64); ok &amp;&amp; timeoutSeconds &gt; 0 </span><span class="cov0" title="0">{
                        nodeTimeout = time.Duration(timeoutSeconds) * time.Second
                }</span> else<span class="cov0" title="0"> if timeoutSecondsInt, ok := timeoutVar.(int); ok &amp;&amp; timeoutSecondsInt &gt; 0 </span><span class="cov0" title="0">{
                        nodeTimeout = time.Duration(timeoutSecondsInt) * time.Second
                }</span>
        }

        <span class="cov8" title="1">flowNodeMap := make(map[idwrap.IDWrap]node.FlowNode, 0)

        // Pre-registration system to fix REQUEST node response_id race condition
        preRegisteredExecutions := make(map[idwrap.IDWrap]struct{})
        preRegisteredMutex := sync.RWMutex{}

        for _, forNode := range forNodes </span><span class="cov8" title="1">{
                name := nodeNameMap[forNode.FlowNodeID]

                // Use the condition directly - no need to parse it here
                if forNode.Condition.Comparisons.Expression != "" </span><span class="cov0" title="0">{
                        log.Printf("📝 DEBUG: Creating FOR node '%s' with condition: '%s'", name, forNode.Condition.Comparisons.Expression)
                        flowNodeMap[forNode.FlowNodeID] = nfor.NewWithCondition(forNode.FlowNodeID, name, forNode.IterCount, nodeTimeout, forNode.ErrorHandling, forNode.Condition)
                }</span> else<span class="cov8" title="1"> {
                        flowNodeMap[forNode.FlowNodeID] = nfor.New(forNode.FlowNodeID, name, forNode.IterCount, nodeTimeout, forNode.ErrorHandling)
                }</span>
        }

        <span class="cov8" title="1">requestNodeRespChan := make(chan nrequest.NodeRequestSideResp, len(requestNodes))
        for _, requestNode := range requestNodes </span><span class="cov8" title="1">{

                // Base Request
                if requestNode.EndpointID == nil || requestNode.ExampleID == nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, fmt.Errorf("endpoint or example not found for %s", requestNode.FlowNodeID))
                }</span>
                <span class="cov8" title="1">endpoint, err := c.ias.GetItemApi(ctx, *requestNode.EndpointID)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov8" title="1">example, err := c.es.GetApiExample(ctx, *requestNode.ExampleID)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov8" title="1">if example.ItemApiID != endpoint.ID </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, errors.New("example and endpoint not match"))
                }</span>
                <span class="cov8" title="1">headers, err := c.hs.GetHeaderByExampleID(ctx, example.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, errors.New("get headers"))
                }</span>
                <span class="cov8" title="1">queries, err := c.qs.GetExampleQueriesByExampleID(ctx, example.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, errors.New("get queries"))
                }</span>

                <span class="cov8" title="1">rawBody, err := c.brs.GetBodyRawByExampleID(ctx, example.ID)
                if err != nil </span><span class="cov8" title="1">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov0" title="0">formBody, err := c.bfs.GetBodyFormsByExampleID(ctx, example.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov0" title="0">urlBody, err := c.bues.GetBodyURLEncodedByExampleID(ctx, example.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov0" title="0">exampleResp, err := c.ers.GetExampleRespByExampleIDLatest(ctx, example.ID)
                if err != nil </span><span class="cov0" title="0">{
                        if err == sexampleresp.ErrNoRespFound </span><span class="cov0" title="0">{
                                exampleResp = &amp;mexampleresp.ExampleResp{
                                        ID:        idwrap.NewNow(),
                                        ExampleID: example.ID,
                                }
                                err = c.ers.CreateExampleResp(ctx, *exampleResp)
                                if err != nil </span><span class="cov0" title="0">{
                                        return connect.NewError(connect.CodeInternal, errors.New("create example resp"))
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return connect.NewError(connect.CodeInternal, err)
                        }</span>
                }

                <span class="cov0" title="0">exampleRespHeader, err := c.erhs.GetHeaderByRespID(ctx, exampleResp.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, errors.New("get example resp header"))
                }</span>

                <span class="cov0" title="0">asserts, err := c.as.GetAssertByExampleID(ctx, example.ID)
                if err != nil &amp;&amp; err != sassert.ErrNoAssertFound </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>

                // Delta Request
                <span class="cov0" title="0">if requestNode.DeltaExampleID != nil </span><span class="cov0" title="0">{
                        deltaExample, err := c.es.GetApiExample(ctx, *requestNode.DeltaExampleID)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, err)
                        }</span>

                        // Delta Endpoint
                        <span class="cov0" title="0">if requestNode.DeltaEndpointID != nil </span><span class="cov0" title="0">{
                                deltaEndpoint, err := c.ias.GetItemApi(ctx, *requestNode.DeltaEndpointID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return connect.NewError(connect.CodeInternal, err)
                                }</span>
                                <span class="cov0" title="0">if deltaEndpoint.Url != "" </span><span class="cov0" title="0">{
                                        endpoint.Url = deltaEndpoint.Url
                                }</span>
                                <span class="cov0" title="0">if deltaEndpoint.Method != "" </span><span class="cov0" title="0">{
                                        endpoint.Method = deltaEndpoint.Method
                                }</span>
                        }

                        <span class="cov0" title="0">deltaHeaders, err := c.hs.GetHeaderByExampleID(ctx, deltaExample.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, err)
                        }</span>

                        <span class="cov0" title="0">deltaQueries, err := c.qs.GetExampleQueriesByExampleID(ctx, deltaExample.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, err)
                        }</span>

                        <span class="cov0" title="0">rawBodyDelta, err := c.brs.GetBodyRawByExampleID(ctx, deltaExample.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, errors.New("delta raw body not found"))
                        }</span>

                        <span class="cov0" title="0">formBodyDelta, err := c.bfs.GetBodyFormsByExampleID(ctx, deltaExample.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, errors.New("delta form body not found"))
                        }</span>

                        <span class="cov0" title="0">urlBodyDelta, err := c.bues.GetBodyURLEncodedByExampleID(ctx, deltaExample.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, errors.New("delta url body not found"))
                        }</span>

                        <span class="cov0" title="0">mergeExamplesInput := request.MergeExamplesInput{
                                Base:  *example,
                                Delta: *deltaExample,

                                BaseQueries:  queries,
                                DeltaQueries: deltaQueries,

                                BaseHeaders:  headers,
                                DeltaHeaders: deltaHeaders,

                                BaseRawBody:  *rawBody,
                                DeltaRawBody: *rawBodyDelta,

                                BaseFormBody:  formBody,
                                DeltaFormBody: formBodyDelta,

                                BaseUrlEncodedBody:  urlBody,
                                DeltaUrlEncodedBody: urlBodyDelta,
                        }

                        mergeExampleOutput := request.MergeExamples(mergeExamplesInput)
                        example = &amp;mergeExampleOutput.Merged

                        headers = mergeExampleOutput.MergeHeaders
                        queries = mergeExampleOutput.MergeQueries

                        rawBody = &amp;mergeExampleOutput.MergeRawBody
                        formBody = mergeExampleOutput.MergeFormBody
                        urlBody = mergeExampleOutput.MergeUrlEncodedBody</span>
                }

                <span class="cov0" title="0">httpClient := httpclient.New()

                name := nodeNameMap[requestNode.FlowNodeID]

                // Create wrapped REQUEST node with pre-registration capability
                requestNodeInstance := nrequest.New(requestNode.FlowNodeID, name, *endpoint, *example, queries, headers, *rawBody, formBody, urlBody,
                        *exampleResp, exampleRespHeader, asserts, httpClient, requestNodeRespChan)

                // Wrap with pre-registration logic
                wrappedNode := &amp;preRegisteredRequestNode{
                        nodeRequest:             requestNodeInstance,
                        preRegisteredExecutions: preRegisteredExecutions,
                        preRegisteredMutex:      &amp;preRegisteredMutex,
                }

                flowNodeMap[requestNode.FlowNodeID] = wrappedNode</span>
        }

        <span class="cov8" title="1">for _, ifNode := range ifNodes </span><span class="cov0" title="0">{
                comp := ifNode.Condition
                name := nodeNameMap[ifNode.FlowNodeID]
                flowNodeMap[ifNode.FlowNodeID] = nif.New(ifNode.FlowNodeID, name, comp)
        }</span>

        <span class="cov8" title="1">for _, noopNode := range noopNodes </span><span class="cov8" title="1">{
                name := nodeNameMap[noopNode.FlowNodeID]
                flowNodeMap[noopNode.FlowNodeID] = nnoop.New(noopNode.FlowNodeID, name)
        }</span>

        <span class="cov8" title="1">for _, forEachNode := range forEachNodes </span><span class="cov8" title="1">{
                name := nodeNameMap[forEachNode.FlowNodeID]
                flowNodeMap[forEachNode.FlowNodeID] = nforeach.New(forEachNode.FlowNodeID, name, forEachNode.IterExpression, nodeTimeout,
                        forEachNode.Condition, forEachNode.ErrorHandling)
        }</span>

        <span class="cov8" title="1">var clientPtr *nodejs_executorv1connect.NodeJSExecutorServiceClient
        for i, jsNode := range jsNodes </span><span class="cov8" title="1">{
                if i == 0 </span><span class="cov8" title="1">{
                        client := nodejs_executorv1connect.NewNodeJSExecutorServiceClient(httpclient.New(), "http://localhost:9090")
                        clientPtr = &amp;client
                }</span>

                <span class="cov8" title="1">if jsNode.CodeCompressType != compress.CompressTypeNone </span><span class="cov0" title="0">{
                        jsNode.Code, err = compress.Decompress(jsNode.Code, jsNode.CodeCompressType)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, err)
                        }</span>
                }

                <span class="cov8" title="1">name := nodeNameMap[jsNode.FlowNodeID]

                flowNodeMap[jsNode.FlowNodeID] = njs.New(jsNode.FlowNodeID, name, string(jsNode.Code), *clientPtr)</span>
        }

        // Use the same timeout for the flow runner
        <span class="cov8" title="1">runnerID := idwrap.NewNow()
        runnerInst := flowlocalrunner.CreateFlowRunner(runnerID, latestFlowID, startNodeID, flowNodeMap, edgeMap, nodeTimeout)

        // Calculate buffer size based on expected load
        // For large iteration counts, we need bigger buffers to prevent blocking
        bufferSize := 10000
        if forNodeCount := len(forNodes); forNodeCount &gt; 0 </span><span class="cov8" title="1">{
                // Estimate based on for node iterations
                var maxIterations int64
                for _, fn := range forNodes </span><span class="cov8" title="1">{
                        if fn.IterCount &gt; maxIterations </span><span class="cov8" title="1">{
                                maxIterations = fn.IterCount
                        }</span>
                }
                // Buffer should handle at least all iterations * nodes
                <span class="cov8" title="1">estimatedSize := int(maxIterations) * len(nodes) * 2
                if estimatedSize &gt; bufferSize </span><span class="cov0" title="0">{
                        bufferSize = estimatedSize
                }</span>
        }

        <span class="cov8" title="1">flowNodeStatusChan := make(chan runner.FlowNodeStatus, bufferSize)
        flowStatusChan := make(chan runner.FlowStatus, 100)

        // Create a new context without the gRPC deadline for flow execution
        // The flow runner will apply its own timeout (nodeTimeout)
        subCtx, cancel := context.WithCancel(context.Background())
        defer cancel()

        done := make(chan error, 1)
        nodeExecutionChan := make(chan mnodeexecution.NodeExecution, bufferSize)

        // Collector goroutine for node executions
        var nodeExecutions []mnodeexecution.NodeExecution
        nodeExecutionsDone := make(chan struct{})

        // Track execution counts per node for naming
        nodeExecutionCounts := make(map[idwrap.IDWrap]int) // nodeID -&gt; execution count
        executionIDToCount := make(map[idwrap.IDWrap]int)  // executionID -&gt; execution number
        nodeExecutionCountsMutex := sync.Mutex{}

        // Map to store node executions by execution ID for state transitions
        pendingNodeExecutions := make(map[idwrap.IDWrap]*mnodeexecution.NodeExecution)

        // Map to store orphaned responses that arrive before ExecutionID is registered
        orphanedResponses := make(map[idwrap.IDWrap]struct {
                ResponseID idwrap.IDWrap
                Timestamp  int64
        })

        pendingMutex := sync.Mutex{}

        // Initialize correlation metrics tracking
        correlationMetrics := NewCorrelationMetrics()

        // Log flow execution start with initial metrics setup
        log.Printf("🚀 Flow execution started for FlowID %s with correlation metrics tracking enabled", flowID.String())

        // WaitGroup to track all goroutines that send to channels
        var goroutineWg sync.WaitGroup

        // WaitGroup specifically for nested logging goroutines
        var loggingWg sync.WaitGroup

        // Channel to signal that sending should stop
        stopSending := make(chan struct{})

        // Atomic flag to prevent sends after closure initiated
        var channelsClosed atomic.Bool

        // Collector goroutine for node executions
        goroutineWg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer goroutineWg.Done()
                defer close(nodeExecutionsDone)
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case execution, ok := &lt;-nodeExecutionChan:<span class="cov8" title="1">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov8" title="1">nodeExecutions = append(nodeExecutions, execution)</span>
                        case &lt;-stopSending:<span class="cov8" title="1">
                                // Drain remaining messages
                                for </span><span class="cov8" title="1">{
                                        select </span>{
                                        case execution, ok := &lt;-nodeExecutionChan:<span class="cov8" title="1">
                                                if !ok </span><span class="cov0" title="0">{
                                                        return
                                                }</span>
                                                <span class="cov8" title="1">nodeExecutions = append(nodeExecutions, execution)</span>
                                        default:<span class="cov8" title="1">
                                                return</span>
                                        }
                                }
                        }
                }
        }()

        // Timeout handler for REQUEST nodes that don't receive responses
        <span class="cov8" title="1">goroutineWg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer goroutineWg.Done()
                ticker := time.NewTicker(30 * time.Second) // Check every 30 seconds
                defer ticker.Stop()

                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                // Check if we should stop sending
                                if channelsClosed.Load() </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                <span class="cov0" title="0">pendingMutex.Lock()
                                var timedOutExecutions []mnodeexecution.NodeExecution

                                for execID, nodeExec := range pendingNodeExecutions </span><span class="cov0" title="0">{
                                        // Check if it's a completed node without ResponseID that's been waiting too long
                                        if nodeExec.CompletedAt != nil &amp;&amp;
                                                nodeExec.ResponseID == nil &amp;&amp;
                                                (nodeExec.State == mnnode.NODE_STATE_SUCCESS || nodeExec.State == mnnode.NODE_STATE_FAILURE) &amp;&amp;
                                                time.Now().UnixMilli()-*nodeExec.CompletedAt &gt; 120000 </span><span class="cov0" title="0">{ // 120 seconds timeout (increased from 30s)

                                                // Check if this is a REQUEST node by checking the node type
                                                node, err := c.ns.GetNode(ctx, nodeExec.NodeID)
                                                if err == nil &amp;&amp; node.NodeKind == mnnode.NODE_KIND_REQUEST </span><span class="cov0" title="0">{
                                                        // Log timeout to help diagnose issues
                                                        log.Printf("⏰ REQUEST node execution %s timed out after 120s without ResponseID - removing from pending map", execID.String())
                                                        timedOutExecutions = append(timedOutExecutions, *nodeExec)
                                                        delete(pendingNodeExecutions, execID)
                                                        correlationMetrics.RecordFailedCorrelation()
                                                        correlationMetrics.RecordDeregistration()
                                                }</span>
                                        }
                                }

                                // Clean up old orphaned responses (older than 5 minutes)
                                <span class="cov0" title="0">currentTime := time.Now().UnixMilli()
                                var cleanedCount int
                                for execID, orphaned := range orphanedResponses </span><span class="cov0" title="0">{
                                        if currentTime-orphaned.Timestamp &gt; 300000 </span><span class="cov0" title="0">{ // 5 minutes
                                                log.Printf("🧹 Cleaning up old orphaned response for ExecutionID %s (age: %dms)",
                                                        execID.String(), currentTime-orphaned.Timestamp)
                                                delete(orphanedResponses, execID)
                                                correlationMetrics.RecordFailedCorrelation()
                                                cleanedCount++
                                        }</span>
                                }
                                <span class="cov0" title="0">if cleanedCount &gt; 0 </span><span class="cov0" title="0">{
                                        correlationMetrics.RecordCleanupOperation()
                                        correlationMetrics.UpdateMapSizes(len(pendingNodeExecutions), len(orphanedResponses))
                                        log.Printf("🧹 Cleanup completed: removed %d orphaned responses (remaining orphaned: %d, pending: %d)",
                                                cleanedCount, len(orphanedResponses), len(pendingNodeExecutions))
                                }</span>
                                <span class="cov0" title="0">pendingMutex.Unlock()

                                // Clean up old pre-registered executions that never moved to pending (older than 10 minutes)
                                // This prevents memory leaks from ExecutionIDs that were pre-registered but never executed
                                preRegisteredMutex.Lock()
                                cleanedPreRegistered := 0
                                // NOTE: We don't have timestamps for pre-registered executions, but we can clean them up
                                // after a reasonable time if they're still in the map and not in pending
                                if len(preRegisteredExecutions) &gt; 100 </span><span class="cov0" title="0">{ // Only clean if we have many entries
                                        pendingMutex.Lock()
                                        for execID := range preRegisteredExecutions </span><span class="cov0" title="0">{
                                                // If it's not in pending map after 30 seconds, it's likely orphaned
                                                if _, isPending := pendingNodeExecutions[execID]; !isPending </span><span class="cov0" title="0">{
                                                        delete(preRegisteredExecutions, execID)
                                                        cleanedPreRegistered++
                                                        if cleanedPreRegistered &gt;= 50 </span><span class="cov0" title="0">{ // Clean in batches to avoid long locks
                                                                break</span>
                                                        }
                                                }
                                        }
                                        <span class="cov0" title="0">pendingMutex.Unlock()</span>
                                }
                                <span class="cov0" title="0">if cleanedPreRegistered &gt; 0 </span><span class="cov0" title="0">{
                                        log.Printf("🧹 Cleaned up %d old pre-registered executions", cleanedPreRegistered)
                                }</span>
                                <span class="cov0" title="0">preRegisteredMutex.Unlock()

                                // Send timed out executions to channel without ResponseID (with safety check)
                                for _, exec := range timedOutExecutions </span><span class="cov0" title="0">{
                                        if !channelsClosed.Load() </span><span class="cov0" title="0">{
                                                select </span>{
                                                case nodeExecutionChan &lt;- exec:<span class="cov0" title="0"></span>
                                                case &lt;-stopSending:<span class="cov0" title="0">
                                                        return</span>
                                                }
                                        }
                                }

                        case &lt;-stopSending:<span class="cov8" title="1">
                                return</span>
                        case &lt;-subCtx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        // Main status processing goroutine
        <span class="cov8" title="1">goroutineWg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer goroutineWg.Done()
                defer func() </span><span class="cov8" title="1">{
                        // Wait for all logging goroutines to finish before closing done channel
                        loggingWg.Wait()
                        close(done)
                }</span>()
                <span class="cov8" title="1">nodeStatusFunc := func(flowNodeStatus runner.FlowNodeStatus) </span><span class="cov8" title="1">{
                        // Check if we should stop processing
                        if channelsClosed.Load() </span><span class="cov8" title="1">{
                                return
                        }</span>

                        <span class="cov8" title="1">id := flowNodeStatus.NodeID
                        name := flowNodeStatus.Name
                        idStr := id.String()
                        stateStr := mnnode.StringNodeState(flowNodeStatus.State)
                        executionID := flowNodeStatus.ExecutionID

                        // Handle NodeExecution creation/updates based on state
                        switch flowNodeStatus.State </span>{
                        case mnnode.NODE_STATE_RUNNING:<span class="cov8" title="1">
                                // Check if this is an iteration tracking record (has iteration data in OutputData)
                                isIterationRecord := false
                                if flowNodeStatus.OutputData != nil </span><span class="cov8" title="1">{
                                        if outputMap, ok := flowNodeStatus.OutputData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                                isIterationRecord = outputMap["index"] != nil ||
                                                        outputMap["key"] != nil
                                        }</span>
                                }

                                // Create new NodeExecution for RUNNING state
                                <span class="cov8" title="1">pendingMutex.Lock()
                                if _, exists := pendingNodeExecutions[executionID]; !exists </span><span class="cov8" title="1">{
                                        // Record pre-registration metrics
                                        correlationMetrics.RecordPreRegistration()
                                        // Generate execution name with hierarchical format for loop iterations
                                        var execName string
                                        if flowNodeStatus.IterationContext != nil &amp;&amp; len(flowNodeStatus.IterationContext.IterationPath) &gt; 0 </span><span class="cov8" title="1">{
                                                // For loop executions, build hierarchical name using the full parent chain
                                                var parentNodes []idwrap.IDWrap // Empty fallback

                                                // Check if this is a loop node (FOR or FOR_EACH) by checking if it's in the parent chain
                                                isLoopNode := false
                                                if flowNodeStatus.IterationContext.ParentNodes != nil </span><span class="cov8" title="1">{
                                                        for _, parentNodeID := range flowNodeStatus.IterationContext.ParentNodes </span><span class="cov8" title="1">{
                                                                if parentNodeID == id </span><span class="cov8" title="1">{
                                                                        isLoopNode = true
                                                                        break</span>
                                                                }
                                                        }
                                                }

                                                // Get execution count for non-loop nodes (only increment once per ExecutionID)
                                                <span class="cov8" title="1">nodeExecutionCountsMutex.Lock()
                                                if _, exists := executionIDToCount[executionID]; !exists </span><span class="cov8" title="1">{
                                                        // First time seeing this ExecutionID, increment the node's counter
                                                        nodeExecutionCounts[id]++
                                                        executionIDToCount[executionID] = nodeExecutionCounts[id] // Store the execution number for this ExecutionID
                                                }</span>
                                                <span class="cov8" title="1">execCount := executionIDToCount[executionID]
                                                nodeExecutionCountsMutex.Unlock()

                                                execName = formatIterationContext(flowNodeStatus.IterationContext, nodeNameMap, id, parentNodes, isLoopNode, execCount)</span>
                                        } else<span class="cov8" title="1"> if flowNodeStatus.Name != "" </span><span class="cov8" title="1">{
                                                // For non-loop executions, add execution number (only increment once per ExecutionID)
                                                nodeExecutionCountsMutex.Lock()
                                                if _, exists := executionIDToCount[executionID]; !exists </span><span class="cov8" title="1">{
                                                        // First time seeing this ExecutionID, increment the node's counter
                                                        if nodeExecutionCounts == nil </span><span class="cov0" title="0">{
                                                                nodeExecutionCounts = make(map[idwrap.IDWrap]int)
                                                        }</span>
                                                        <span class="cov8" title="1">if executionIDToCount == nil </span><span class="cov0" title="0">{
                                                                executionIDToCount = make(map[idwrap.IDWrap]int)
                                                        }</span>
                                                        <span class="cov8" title="1">nodeExecutionCounts[id]++
                                                        executionIDToCount[executionID] = nodeExecutionCounts[id]</span> // Store the execution number for this ExecutionID
                                                }
                                                <span class="cov8" title="1">execCount := executionIDToCount[executionID]
                                                nodeExecutionCountsMutex.Unlock()
                                                execName = fmt.Sprintf("%s - Execution %d", flowNodeStatus.Name, execCount)</span>
                                        } else<span class="cov8" title="1"> {
                                                // Fallback to execution count
                                                nodeExecutionCountsMutex.Lock()
                                                nodeExecutionCounts[id]++
                                                execCount := nodeExecutionCounts[id]
                                                nodeExecutionCountsMutex.Unlock()
                                                execName = fmt.Sprintf("Execution %d", execCount)
                                        }</span>

                                        <span class="cov8" title="1">nodeExecution := mnodeexecution.NodeExecution{
                                                ID:                     executionID, // Use executionID as the record ID
                                                NodeID:                 id,
                                                Name:                   execName,
                                                State:                  flowNodeStatus.State,
                                                Error:                  nil,
                                                InputData:              []byte("{}"),
                                                InputDataCompressType:  0,
                                                OutputData:             []byte("{}"),
                                                OutputDataCompressType: 0,
                                                ResponseID:             nil,
                                                CompletedAt:            nil,
                                        }

                                        // Set output data for iteration tracking records
                                        if isIterationRecord &amp;&amp; flowNodeStatus.OutputData != nil </span><span class="cov8" title="1">{
                                                if outputJSON, err := json.Marshal(flowNodeStatus.OutputData); err == nil </span><span class="cov8" title="1">{
                                                        if err := nodeExecution.SetOutputJSON(outputJSON); err != nil </span><span class="cov0" title="0">{
                                                                nodeExecution.OutputData = outputJSON
                                                                nodeExecution.OutputDataCompressType = 0
                                                        }</span>
                                                }
                                        }

                                        // For iteration tracking records, create immediately to avoid race condition
                                        // Save ALL iterations to database (both successful and failed)
                                        <span class="cov8" title="1">if isIterationRecord </span><span class="cov8" title="1">{
                                                // ALWAYS save ALL iteration records to database
                                                if err := c.nes.UpsertNodeExecution(ctx, nodeExecution); err != nil </span><span class="cov8" title="1">{
                                                        log.Printf("Failed to upsert iteration record %s: %v", executionID.String(), err)
                                                }</span>
                                        } else<span class="cov8" title="1"> {
                                                // Check if this is a FOR/FOREACH loop node main execution
                                                isLoopNode := false
                                                node, err := c.ns.GetNode(ctx, id)
                                                if err == nil </span><span class="cov8" title="1">{
                                                        isLoopNode = node.NodeKind == mnnode.NODE_KIND_FOR || node.NodeKind == mnnode.NODE_KIND_FOR_EACH
                                                }</span>

                                                <span class="cov8" title="1">if isLoopNode </span><span class="cov8" title="1">{
                                                        // Skip loop main execution in RUNNING state - don't save to DB or send to UI
                                                        log.Printf("📝 Skipping loop main execution %s in RUNNING state (only iterations and failures are saved)", executionID.String())
                                                }</span> else<span class="cov8" title="1"> {
                                                        // Store in pending map for completion (normal flow execution - will be sent to UI)
                                                        pendingNodeExecutions[executionID] = &amp;nodeExecution
                                                        correlationMetrics.UpdateMapSizes(len(pendingNodeExecutions), len(orphanedResponses))
                                                        log.Printf("📝 Pre-registered ExecutionID %s in pending map (state: %d, name: %s, pending_count: %d)",
                                                                executionID.String(), nodeExecution.State, nodeExecution.Name, len(pendingNodeExecutions))
                                                }</span>

                                                // Only handle orphaned responses for non-loop nodes (loop nodes don't use pending system)
                                                <span class="cov8" title="1">if !isLoopNode </span><span class="cov8" title="1">{
                                                        // Check if there's an orphaned response waiting for this ExecutionID
                                                        if orphaned, exists := orphanedResponses[executionID]; exists </span><span class="cov0" title="0">{
                                                                // Calculate correlation delay
                                                                correlationDelay := time.Now().UnixMilli() - orphaned.Timestamp
                                                                correlationMetrics.RecordDelayedCorrelation(correlationDelay)

                                                                // Log with timing information
                                                                if correlationMetrics.ShouldWarnAboutDelay(correlationDelay) </span><span class="cov0" title="0">{
                                                                        log.Printf("⚠️ Delayed correlation for ExecutionID %s after %dms (above %dms threshold)",
                                                                                executionID.String(), correlationDelay, correlationMetrics.delayWarningThreshold)
                                                                }</span> else<span class="cov0" title="0"> {
                                                                        log.Printf("🔄 Correlating orphaned response for ExecutionID %s (delay: %dms)",
                                                                                executionID.String(), correlationDelay)
                                                                }</span>

                                                                <span class="cov0" title="0">nodeExecution.ResponseID = &amp;orphaned.ResponseID

                                                                // Update in database immediately
                                                                go func(exec mnodeexecution.NodeExecution, delay int64) </span><span class="cov0" title="0">{
                                                                        dbCtx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
                                                                        defer cancel()
                                                                        if err := c.nes.UpsertNodeExecution(dbCtx, exec); err != nil </span><span class="cov0" title="0">{
                                                                                log.Printf("❌ Failed to upsert delayed correlation %s: %v", exec.ID, err)
                                                                        }</span> else<span class="cov0" title="0"> {
                                                                                log.Printf("✅ Successfully correlated orphaned response for ExecutionID %s (delay: %dms)",
                                                                                        exec.ID.String(), delay)
                                                                        }</span>
                                                                }(nodeExecution, correlationDelay)

                                                                // Remove from orphaned responses and update metrics
                                                                <span class="cov0" title="0">delete(orphanedResponses, executionID)
                                                                correlationMetrics.UpdateMapSizes(len(pendingNodeExecutions), len(orphanedResponses))</span>
                                                        }

                                                        // Also save to DB immediately (non-blocking) for non-loop nodes
                                                        <span class="cov8" title="1">go func(exec mnodeexecution.NodeExecution) </span><span class="cov8" title="1">{
                                                                dbCtx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
                                                                defer cancel()
                                                                if err := c.nes.UpsertNodeExecution(dbCtx, exec); err != nil </span><span class="cov8" title="1">{
                                                                        log.Printf("Failed to upsert node execution %s: %v", exec.ID, err)
                                                                }</span>
                                                        }(nodeExecution)
                                                }
                                        }
                                }
                                <span class="cov8" title="1">pendingMutex.Unlock()</span>

                        case mnnode.NODE_STATE_SUCCESS, mnnode.NODE_STATE_FAILURE, mnnode.NODE_STATE_CANCELED:<span class="cov8" title="1">
                                // Check if this is an iteration tracking record (has iteration data in OutputData)
                                isIterationRecord := false
                                if flowNodeStatus.OutputData != nil </span><span class="cov8" title="1">{
                                        if outputMap, ok := flowNodeStatus.OutputData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                                isIterationRecord = outputMap["index"] != nil ||
                                                        outputMap["key"] != nil ||
                                                        outputMap["completed"] != nil
                                        }</span>
                                }

                                // Get node type for REQUEST node detection
                                <span class="cov8" title="1">node, err := c.ns.GetNode(ctx, flowNodeStatus.NodeID)
                                if err != nil </span><span class="cov0" title="0">{
                                        // Log error but continue - we'll treat as non-REQUEST node
                                        log.Printf("Could not get node type for %s: %v", flowNodeStatus.NodeID.String(), err)
                                }</span>

                                // Handle iteration records separately (they need updates, not pending lookups)
                                <span class="cov8" title="1">if isIterationRecord </span><span class="cov8" title="1">{
                                        // Create update record for ALL iterations (both successful and failed)
                                        completedAt := time.Now().UnixMilli()
                                        nodeExecution := mnodeexecution.NodeExecution{
                                                ID:          executionID, // Use same ExecutionID for update
                                                State:       flowNodeStatus.State,
                                                CompletedAt: &amp;completedAt,
                                        }

                                        // Set error if present
                                        if flowNodeStatus.Error != nil </span><span class="cov0" title="0">{
                                                errorStr := flowNodeStatus.Error.Error()
                                                nodeExecution.Error = &amp;errorStr
                                        }</span>

                                        // Compress and store output data
                                        <span class="cov8" title="1">if flowNodeStatus.OutputData != nil </span><span class="cov8" title="1">{
                                                if outputJSON, err := json.Marshal(flowNodeStatus.OutputData); err == nil </span><span class="cov8" title="1">{
                                                        if err := nodeExecution.SetOutputJSON(outputJSON); err != nil </span><span class="cov0" title="0">{
                                                                nodeExecution.OutputData = outputJSON
                                                                nodeExecution.OutputDataCompressType = 0
                                                        }</span>
                                                }
                                        }

                                        // Upsert ALL iteration records immediately (non-blocking)
                                        <span class="cov8" title="1">go func(exec mnodeexecution.NodeExecution) </span><span class="cov8" title="1">{
                                                dbCtx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
                                                defer cancel()
                                                if err := c.nes.UpsertNodeExecution(dbCtx, exec); err != nil </span><span class="cov8" title="1">{
                                                        log.Printf("Failed to upsert iteration record %s: %v", exec.ID.String(), err)
                                                }</span>
                                        }(nodeExecution)
                                        // ALL iterations are now persisted to database
                                } else<span class="cov8" title="1"> {
                                        // Update existing NodeExecution with final state (normal flow)
                                        pendingMutex.Lock()
                                        if nodeExec, exists := pendingNodeExecutions[executionID]; exists </span><span class="cov8" title="1">{
                                                // Update final state
                                                nodeExec.State = flowNodeStatus.State
                                                completedAt := time.Now().UnixMilli()
                                                nodeExec.CompletedAt = &amp;completedAt

                                                // Set error if present
                                                if flowNodeStatus.Error != nil </span><span class="cov0" title="0">{
                                                        errorStr := flowNodeStatus.Error.Error()
                                                        nodeExec.Error = &amp;errorStr
                                                }</span>

                                                // Compress and store input data
                                                <span class="cov8" title="1">if flowNodeStatus.InputData != nil </span><span class="cov8" title="1">{
                                                        if inputJSON, err := json.Marshal(flowNodeStatus.InputData); err == nil </span><span class="cov8" title="1">{
                                                                if err := nodeExec.SetInputJSON(inputJSON); err != nil </span><span class="cov0" title="0">{
                                                                        nodeExec.InputData = inputJSON
                                                                        nodeExec.InputDataCompressType = 0
                                                                }</span>
                                                        }
                                                }

                                                // Compress and store output data
                                                <span class="cov8" title="1">if flowNodeStatus.OutputData != nil </span><span class="cov8" title="1">{
                                                        if outputJSON, err := json.Marshal(flowNodeStatus.OutputData); err == nil </span><span class="cov8" title="1">{
                                                                if err := nodeExec.SetOutputJSON(outputJSON); err != nil </span><span class="cov0" title="0">{
                                                                        nodeExec.OutputData = outputJSON
                                                                        nodeExec.OutputDataCompressType = 0
                                                                }</span>
                                                        }
                                                }

                                                // Upsert execution in DB immediately (non-blocking)
                                                <span class="cov8" title="1">go func(exec mnodeexecution.NodeExecution) </span><span class="cov8" title="1">{
                                                        dbCtx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
                                                        defer cancel()
                                                        if err := c.nes.UpsertNodeExecution(dbCtx, exec); err != nil </span><span class="cov8" title="1">{
                                                                log.Printf("Failed to upsert node execution %s: %v", exec.ID, err)
                                                        }</span>
                                                }(*nodeExec)

                                                // For REQUEST nodes, wait for response before sending to channel
                                                <span class="cov8" title="1">if node != nil &amp;&amp; node.NodeKind == mnnode.NODE_KIND_REQUEST </span>{<span class="cov0" title="0">
                                                        // Mark as completed but keep in pending map for response handling
                                                        // Don't send to channel yet - wait for response
                                                }</span> else<span class="cov8" title="1"> {
                                                        // For non-REQUEST nodes, send immediately (with safety check)
                                                        if !channelsClosed.Load() </span><span class="cov8" title="1">{
                                                                select </span>{
                                                                case nodeExecutionChan &lt;- *nodeExec:<span class="cov8" title="1">
                                                                        delete(pendingNodeExecutions, executionID)
                                                                        correlationMetrics.RecordDeregistration()
                                                                        correlationMetrics.UpdateMapSizes(len(pendingNodeExecutions), len(orphanedResponses))
                                                                        log.Printf("🗑️ Deregistered ExecutionID %s from pending map (non-REQUEST node completion, pending_count: %d)",
                                                                                executionID.String(), len(pendingNodeExecutions))</span>
                                                                case &lt;-stopSending:<span class="cov0" title="0"></span>
                                                                        // Channel closed, don't send
                                                                }
                                                        }
                                                }
                                        } else<span class="cov8" title="1"> if flowNodeStatus.State == mnnode.NODE_STATE_CANCELED </span><span class="cov0" title="0">{
                                                // Handle the case where we receive a CANCELED status without a prior RUNNING status
                                                // This can happen when nodes are canceled before they start executing
                                                completedAt := time.Now().UnixMilli()

                                                // Get execution name
                                                var execName string
                                                if flowNodeStatus.Name != "" </span><span class="cov0" title="0">{
                                                        nodeExecutionCountsMutex.Lock()
                                                        // Check if we already have a count for this execution ID
                                                        if _, exists := executionIDToCount[executionID]; !exists </span><span class="cov0" title="0">{
                                                                nodeExecutionCounts[flowNodeStatus.NodeID]++
                                                                executionIDToCount[executionID] = nodeExecutionCounts[flowNodeStatus.NodeID]
                                                        }</span>
                                                        <span class="cov0" title="0">execCount := executionIDToCount[executionID]
                                                        nodeExecutionCountsMutex.Unlock()
                                                        execName = fmt.Sprintf("%s - Execution %d", flowNodeStatus.Name, execCount)</span>
                                                } else<span class="cov0" title="0"> {
                                                        execName = "Canceled Node"
                                                }</span>

                                                <span class="cov0" title="0">nodeExecution := mnodeexecution.NodeExecution{
                                                        ID:                     executionID,
                                                        NodeID:                 flowNodeStatus.NodeID,
                                                        Name:                   execName,
                                                        State:                  mnnode.NODE_STATE_CANCELED,
                                                        Error:                  nil,
                                                        InputData:              []byte("{}"),
                                                        InputDataCompressType:  0,
                                                        OutputData:             []byte("{}"),
                                                        OutputDataCompressType: 0,
                                                        ResponseID:             nil,
                                                        CompletedAt:            &amp;completedAt,
                                                }

                                                // Set error if present
                                                if flowNodeStatus.Error != nil </span><span class="cov0" title="0">{
                                                        errorStr := flowNodeStatus.Error.Error()
                                                        nodeExecution.Error = &amp;errorStr
                                                }</span>

                                                // Compress and store input data if available
                                                <span class="cov0" title="0">if flowNodeStatus.InputData != nil </span><span class="cov0" title="0">{
                                                        if inputJSON, err := json.Marshal(flowNodeStatus.InputData); err == nil </span><span class="cov0" title="0">{
                                                                if err := nodeExecution.SetInputJSON(inputJSON); err != nil </span><span class="cov0" title="0">{
                                                                        nodeExecution.InputData = inputJSON
                                                                        nodeExecution.InputDataCompressType = 0
                                                                }</span>
                                                        }
                                                }

                                                // Compress and store output data if available
                                                <span class="cov0" title="0">if flowNodeStatus.OutputData != nil </span><span class="cov0" title="0">{
                                                        if outputJSON, err := json.Marshal(flowNodeStatus.OutputData); err == nil </span><span class="cov0" title="0">{
                                                                if err := nodeExecution.SetOutputJSON(outputJSON); err != nil </span><span class="cov0" title="0">{
                                                                        nodeExecution.OutputData = outputJSON
                                                                        nodeExecution.OutputDataCompressType = 0
                                                                }</span>
                                                        }
                                                }

                                                // Upsert to DB immediately (non-blocking)
                                                <span class="cov0" title="0">go func(exec mnodeexecution.NodeExecution) </span><span class="cov0" title="0">{
                                                        dbCtx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
                                                        defer cancel()
                                                        if err := c.nes.UpsertNodeExecution(dbCtx, exec); err != nil </span><span class="cov0" title="0">{
                                                                log.Printf("Failed to upsert canceled node execution %s: %v", exec.ID, err)
                                                        }</span>
                                                }(nodeExecution)

                                                // Send immediately for canceled nodes (with safety check)
                                                <span class="cov0" title="0">if !channelsClosed.Load() </span><span class="cov0" title="0">{
                                                        select </span>{
                                                        case nodeExecutionChan &lt;- nodeExecution:<span class="cov0" title="0"></span>
                                                                // Successfully sent
                                                        case &lt;-stopSending:<span class="cov0" title="0"></span>
                                                                // Channel closed, don't send
                                                        }
                                                }
                                        } else<span class="cov8" title="1"> {
                                                // Handle failed loop nodes that weren't in pending (because we skip successful loops)
                                                if node != nil &amp;&amp; (node.NodeKind == mnnode.NODE_KIND_FOR || node.NodeKind == mnnode.NODE_KIND_FOR_EACH) &amp;&amp;
                                                        flowNodeStatus.State == mnnode.NODE_STATE_FAILURE </span><span class="cov0" title="0">{

                                                        // Create execution record for failed loop nodes (these should be visible in UI)
                                                        completedAt := time.Now().UnixMilli()

                                                        // Get execution name
                                                        var execName string
                                                        if flowNodeStatus.Name != "" </span><span class="cov0" title="0">{
                                                                nodeExecutionCountsMutex.Lock()
                                                                if _, exists := executionIDToCount[executionID]; !exists </span><span class="cov0" title="0">{
                                                                        nodeExecutionCounts[flowNodeStatus.NodeID]++
                                                                        executionIDToCount[executionID] = nodeExecutionCounts[flowNodeStatus.NodeID]
                                                                }</span>
                                                                <span class="cov0" title="0">execCount := executionIDToCount[executionID]
                                                                nodeExecutionCountsMutex.Unlock()
                                                                execName = fmt.Sprintf("%s - Execution %d", flowNodeStatus.Name, execCount)</span>
                                                        } else<span class="cov0" title="0"> {
                                                                execName = "Failed Loop"
                                                        }</span>

                                                        <span class="cov0" title="0">nodeExecution := mnodeexecution.NodeExecution{
                                                                ID:                     executionID,
                                                                NodeID:                 flowNodeStatus.NodeID,
                                                                Name:                   execName,
                                                                State:                  flowNodeStatus.State,
                                                                Error:                  nil,
                                                                InputData:              []byte("{}"),
                                                                InputDataCompressType:  0,
                                                                OutputData:             []byte("{}"),
                                                                OutputDataCompressType: 0,
                                                                ResponseID:             nil,
                                                                CompletedAt:            &amp;completedAt,
                                                        }

                                                        // Set error if present
                                                        if flowNodeStatus.Error != nil </span><span class="cov0" title="0">{
                                                                errorStr := flowNodeStatus.Error.Error()
                                                                nodeExecution.Error = &amp;errorStr
                                                        }</span>

                                                        // Compress and store output data if available
                                                        <span class="cov0" title="0">if flowNodeStatus.OutputData != nil </span><span class="cov0" title="0">{
                                                                if outputJSON, err := json.Marshal(flowNodeStatus.OutputData); err == nil </span><span class="cov0" title="0">{
                                                                        if err := nodeExecution.SetOutputJSON(outputJSON); err != nil </span><span class="cov0" title="0">{
                                                                                nodeExecution.OutputData = outputJSON
                                                                                nodeExecution.OutputDataCompressType = 0
                                                                        }</span>
                                                                }
                                                        }

                                                        // Upsert to DB immediately (non-blocking)
                                                        <span class="cov0" title="0">go func(exec mnodeexecution.NodeExecution) </span><span class="cov0" title="0">{
                                                                dbCtx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
                                                                defer cancel()
                                                                if err := c.nes.UpsertNodeExecution(dbCtx, exec); err != nil </span><span class="cov0" title="0">{
                                                                        log.Printf("Failed to upsert failed loop node execution %s: %v", exec.ID, err)
                                                                }</span>
                                                        }(nodeExecution)

                                                        // Send immediately for failed loop nodes to make them visible in UI
                                                        <span class="cov0" title="0">if !channelsClosed.Load() </span><span class="cov0" title="0">{
                                                                select </span>{
                                                                case nodeExecutionChan &lt;- nodeExecution:<span class="cov0" title="0">
                                                                        log.Printf("📤 Sent failed loop execution %s to UI (state: %s)", executionID.String(), mnnode.StringNodeState(flowNodeStatus.State))</span>
                                                                case &lt;-stopSending:<span class="cov0" title="0"></span>
                                                                        // Channel closed, don't send
                                                                }
                                                        }
                                                }
                                        }
                                        <span class="cov8" title="1">pendingMutex.Unlock()</span>
                                }
                        }

                        // Handle logging for non-running states
                        <span class="cov8" title="1">if flowNodeStatus.State != mnnode.NODE_STATE_RUNNING </span><span class="cov8" title="1">{
                                // Create copies of values we need for the goroutine
                                nameForLog := name
                                idStrForLog := idStr
                                stateStrForLog := stateStr
                                nodeError := flowNodeStatus.Error

                                // Don't spawn goroutine if channels are closing
                                if !channelsClosed.Load() </span><span class="cov8" title="1">{
                                        // Use the logging WaitGroup to track this nested goroutine
                                        loggingWg.Add(1)
                                        go func() </span><span class="cov8" title="1">{
                                                defer loggingWg.Done()

                                                // Double-check channels aren't closed
                                                if channelsClosed.Load() </span><span class="cov8" title="1">{
                                                        return
                                                }</span>

                                                // Create a simple log-friendly structure without maps
                                                <span class="cov8" title="1">logData := struct {
                                                        NodeID string
                                                        Name   string
                                                        State  string
                                                        Error  error
                                                }{
                                                        NodeID: idStrForLog,
                                                        Name:   nameForLog,
                                                        State:  stateStrForLog,
                                                        Error:  nodeError,
                                                }

                                                ref := reference.NewReferenceFromInterfaceWithKey(logData, nameForLog)
                                                refs := []reference.ReferenceTreeItem{ref}

                                                // Set log level to error if there's an error, otherwise warning
                                                var logLevel logconsole.LogLevel
                                                if nodeError != nil </span><span class="cov0" title="0">{
                                                        logLevel = logconsole.LogLevelError
                                                }</span> else<span class="cov8" title="1"> {
                                                        logLevel = logconsole.LogLevelUnspecified
                                                }</span>

                                                <span class="cov8" title="1">localErr := c.logChanMap.SendMsgToUserWithContext(ctx, idwrap.NewNow(), fmt.Sprintf("Node %s:%s: %s", nameForLog, idStrForLog, stateStrForLog), logLevel, refs)
                                                if localErr != nil </span><span class="cov8" title="1">{
                                                        // Check if we should still try to send the error
                                                        if !channelsClosed.Load() </span><span class="cov8" title="1">{
                                                                select </span>{
                                                                case done &lt;- localErr:<span class="cov8" title="1"></span>
                                                                case &lt;-stopSending:<span class="cov0" title="0"></span>
                                                                        // Stop signal received, don't send
                                                                default:<span class="cov8" title="1">
                                                                        // Channel is full or closed, log the error instead
                                                                        log.Printf("Failed to send log error to done channel: %v", localErr)</span>
                                                                }
                                                        }
                                                        <span class="cov8" title="1">return</span>
                                                }
                                        }()
                                }
                        }

                        // Handle request node responses
                        <span class="cov8" title="1">select </span>{
                        case requestNodeResp := &lt;-requestNodeRespChan:<span class="cov0" title="0">
                                err = c.HandleExampleChanges(ctx, requestNodeResp)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Println("cannot update example on flow run", err)
                                }</span>

                                // Use ExecutionID from the response to find the correct execution
                                <span class="cov0" title="0">pendingMutex.Lock()
                                targetExecutionID := requestNodeResp.ExecutionID
                                responseReceivedTime := time.Now()

                                if targetExecutionID != (idwrap.IDWrap{}) &amp;&amp; requestNodeResp.Resp.ExampleResp.ID != (idwrap.IDWrap{}) </span><span class="cov0" title="0">{
                                        if nodeExec, exists := pendingNodeExecutions[targetExecutionID]; exists </span><span class="cov0" title="0">{
                                                // Calculate correlation delay (response arrived after ExecutionID registration)
                                                correlationDelay := int64(50) // Approximate immediate correlation delay (0-100ms)
                                                correlationMetrics.RecordSuccessfulCorrelation(correlationDelay)

                                                // Log with timing information
                                                if correlationMetrics.ShouldWarnAboutDelay(correlationDelay) </span><span class="cov0" title="0">{
                                                        log.Printf("⚠️ Slow correlation for ExecutionID %s (delay: %dms, above %dms threshold)",
                                                                targetExecutionID.String(), correlationDelay, correlationMetrics.delayWarningThreshold)
                                                }</span> else<span class="cov0" title="0"> {
                                                        log.Printf("✅ Immediate correlation for ExecutionID %s (delay: %dms)",
                                                                targetExecutionID.String(), correlationDelay)
                                                }</span>

                                                <span class="cov0" title="0">respID := requestNodeResp.Resp.ExampleResp.ID
                                                nodeExec.ResponseID = &amp;respID

                                                // Upsert execution in DB with ResponseID (non-blocking)
                                                go func(exec mnodeexecution.NodeExecution, delay int64) </span><span class="cov0" title="0">{
                                                        dbCtx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
                                                        defer cancel()
                                                        if err := c.nes.UpsertNodeExecution(dbCtx, exec); err != nil </span><span class="cov0" title="0">{
                                                                log.Printf("❌ Failed to upsert node execution with response %s: %v", exec.ID, err)
                                                        }</span> else<span class="cov0" title="0"> {
                                                                log.Printf("✅ Successfully saved response correlation for ExecutionID %s (delay: %dms)",
                                                                        exec.ID.String(), delay)
                                                        }</span>
                                                }(*nodeExec, correlationDelay)

                                                // Now send the completed execution with ResponseID to channel (with safety check)
                                                <span class="cov0" title="0">if !channelsClosed.Load() </span><span class="cov0" title="0">{
                                                        select </span>{
                                                        case nodeExecutionChan &lt;- *nodeExec:<span class="cov0" title="0">
                                                                delete(pendingNodeExecutions, targetExecutionID)
                                                                correlationMetrics.RecordDeregistration()
                                                                correlationMetrics.UpdateMapSizes(len(pendingNodeExecutions), len(orphanedResponses))
                                                                log.Printf("🗑️ Deregistered ExecutionID %s after successful correlation (pending_count: %d)",
                                                                        targetExecutionID.String(), len(pendingNodeExecutions))</span>
                                                        case &lt;-stopSending:<span class="cov0" title="0"></span>
                                                                // Channel closed, don't send
                                                        }
                                                } else<span class="cov0" title="0"> {
                                                        delete(pendingNodeExecutions, targetExecutionID)
                                                        correlationMetrics.RecordDeregistration()
                                                        correlationMetrics.UpdateMapSizes(len(pendingNodeExecutions), len(orphanedResponses))
                                                }</span>

                                                // Also update the corresponding entry in nodeExecutions array
                                                <span class="cov0" title="0">for i := range nodeExecutions </span><span class="cov0" title="0">{
                                                        if nodeExecutions[i].ID == targetExecutionID </span><span class="cov0" title="0">{
                                                                nodeExecutions[i].ResponseID = &amp;respID
                                                                break</span>
                                                        }
                                                }
                                        } else<span class="cov0" title="0"> {
                                                // Record orphaned response metrics
                                                correlationMetrics.RecordOrphanedResponse()
                                                correlationMetrics.UpdateMapSizes(len(pendingNodeExecutions), len(orphanedResponses)+1)

                                                log.Printf("❌ No pending execution found for ExecutionID %s (pending: %d, orphaned: %d)",
                                                        targetExecutionID.String(), len(pendingNodeExecutions), len(orphanedResponses))

                                                // RACE CONDITION FIX: Store orphaned response for later correlation
                                                respID := requestNodeResp.Resp.ExampleResp.ID
                                                log.Printf("🔄 Storing orphaned response for ExecutionID %s (ResponseID: %s, pending: %d, orphaned: %d)",
                                                        targetExecutionID.String(), respID.String(), len(pendingNodeExecutions), len(orphanedResponses)+1)

                                                orphanedResponses[targetExecutionID] = struct {
                                                        ResponseID idwrap.IDWrap
                                                        Timestamp  int64
                                                }{
                                                        ResponseID: respID,
                                                        Timestamp:  responseReceivedTime.UnixMilli(),
                                                }

                                                // Check for memory warning
                                                if correlationMetrics.ShouldWarnAboutMemory(len(pendingNodeExecutions), len(orphanedResponses)) </span><span class="cov0" title="0">{
                                                        log.Printf("⚠️ High memory usage detected: pending=%d, orphaned=%d (threshold: %d)",
                                                                len(pendingNodeExecutions), len(orphanedResponses), correlationMetrics.memoryWarningThreshold)
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">pendingMutex.Unlock()

                                example := &amp;flowv1.FlowRunExampleResponse{
                                        ExampleId:  requestNodeResp.Example.ID.Bytes(),
                                        ResponseId: requestNodeResp.Resp.ExampleResp.ID.Bytes(),
                                }

                                resp := &amp;flowv1.FlowRunResponse{
                                        Example: example,
                                }

                                localErr := stream.Send(resp)
                                if localErr != nil </span><span class="cov0" title="0">{
                                        done &lt;- localErr
                                        return
                                }</span>

                        default:<span class="cov8" title="1"></span>
                        }

                        // Send node status response
                        <span class="cov8" title="1">nodeResp := &amp;flowv1.FlowRunNodeResponse{
                                NodeId: flowNodeStatus.NodeID.Bytes(),
                                State:  nodev1.NodeState(flowNodeStatus.State),
                        }

                        // Add error information if the node failed
                        if flowNodeStatus.Error != nil </span><span class="cov0" title="0">{
                                errorMsg := flowNodeStatus.Error.Error()
                                nodeResp.Info = &amp;errorMsg
                        }</span>

                        <span class="cov8" title="1">resp := &amp;flowv1.FlowRunResponse{
                                Node: nodeResp,
                        }

                        err = stream.Send(resp)
                        if err != nil </span><span class="cov0" title="0">{
                                done &lt;- err
                                return
                        }</span>
                }

                <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                // Client disconnected, signal all goroutines to stop
                                channelsClosed.Store(true)
                                close(stopSending)

                                // Cancel the flow execution
                                cancel()

                                // DO NOT close channels here - let the runner close them
                                // The runner has deferred closes for these channels
                                done &lt;- errors.New("client disconnected")
                                return</span>
                        case &lt;-subCtx.Done():<span class="cov0" title="0">
                                // Flow execution cancelled
                                channelsClosed.Store(true)
                                close(stopSending)

                                // DO NOT close channels here - let the runner close them
                                done &lt;- errors.New("flow execution cancelled")
                                return</span>
                        case flowNodeStatus, ok := &lt;-flowNodeStatusChan:<span class="cov8" title="1">
                                if !ok </span><span class="cov8" title="1">{
                                        // Channel closed by runner
                                        return
                                }</span>
                                <span class="cov8" title="1">nodeStatusFunc(flowNodeStatus)</span>
                        case flowStatus, ok := &lt;-flowStatusChan:<span class="cov8" title="1">
                                if !ok </span><span class="cov0" title="0">{
                                        // Channel closed by runner
                                        return
                                }</span>
                                // Process any pending node status messages without blocking
                        <span class="cov8" title="1">drainLoop:
                                for len(flowNodeStatusChan) &gt; 0 </span><span class="cov8" title="1">{
                                        select </span>{
                                        case flowNodeStatus := &lt;-flowNodeStatusChan:<span class="cov8" title="1">
                                                nodeStatusFunc(flowNodeStatus)</span>
                                        default:<span class="cov0" title="0">
                                                // No more messages immediately available, exit loop
                                                break drainLoop</span>
                                        }
                                }
                                <span class="cov8" title="1">if runner.IsFlowStatusDone(flowStatus) </span><span class="cov8" title="1">{
                                        done &lt;- nil
                                        return
                                }</span>
                        }
                }
        }()

        <span class="cov8" title="1">flowRunErr := runnerInst.Run(subCtx, flowNodeStatusChan, flowStatusChan, flowVarsMap)

        // wait for the flow to finish
        flowErr := &lt;-done

        // Signal all goroutines to stop if not already done
        if !channelsClosed.Load() </span><span class="cov8" title="1">{
                channelsClosed.Store(true)
                close(stopSending)
        }</span>

        // After flow completes, flush any pending REQUEST node executions
        // that didn't receive responses yet
        <span class="cov8" title="1">pendingMutex.Lock()
        for execID, nodeExec := range pendingNodeExecutions </span><span class="cov8" title="1">{
                // Check if this is a completed REQUEST node without ResponseID
                if nodeExec.CompletedAt != nil </span><span class="cov0" title="0">{
                        // Try to send to channel (non-blocking to avoid deadlock)
                        select </span>{
                        case nodeExecutionChan &lt;- *nodeExec:<span class="cov0" title="0">
                                delete(pendingNodeExecutions, execID)</span>
                        default:<span class="cov0" title="0">
                                // Channel might be full or closed, just delete
                                delete(pendingNodeExecutions, execID)</span>
                        }
                }
        }
        <span class="cov8" title="1">pendingMutex.Unlock()

        // Log final correlation metrics summary
        log.Printf("🏁 Flow execution completed. %s", correlationMetrics.GetMetricsSummary())

        // Wait for all goroutines to finish before closing channels
        goroutineWg.Wait()

        // Now safe to close channels since all senders have stopped
        close(nodeExecutionChan)
        close(requestNodeRespChan)

        // Wait for all node executions to be collected
        &lt;-nodeExecutionsDone

        // Final cleanup of pre-registered executions
        preRegisteredMutex.Lock()
        remainingPreRegistered := len(preRegisteredExecutions)
        if remainingPreRegistered &gt; 0 </span><span class="cov0" title="0">{
                log.Printf("🧹 Cleaning up %d remaining pre-registered executions", remainingPreRegistered)
                for execID := range preRegisteredExecutions </span><span class="cov0" title="0">{
                        delete(preRegisteredExecutions, execID)
                }</span>
        }
        <span class="cov8" title="1">preRegisteredMutex.Unlock()

        flow.VersionParentID = &amp;flow.ID

        // Access nodeExecutions (safe after channel reader finished)
        nodeExecutionsCopy := make([]mnodeexecution.NodeExecution, len(nodeExecutions))
        copy(nodeExecutionsCopy, nodeExecutions)

        res, err := c.PrepareCopyFlow(ctx, flow.WorkspaceID, flow, nodeExecutionsCopy)
        if err != nil </span><span class="cov8" title="1">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">tx, err := c.DB.BeginTx(ctx, &amp;sql.TxOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("begin transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer devtoolsdb.TxnRollback(tx)

        // NOTE: Node executions are now saved in real-time during flow execution,
        // so we no longer need to batch save them at the end. The batch save has been removed.
        // The nodeExecutions array is still collected for the flow version copy in PrepareCopyFlow.

        err = c.CopyFlow(ctx, tx, res)
        if err != nil </span><span class="cov8" title="1">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("commit transaction: %w", err)
        }</span>

        <span class="cov8" title="1">resp := &amp;flowv1.FlowRunResponse{
                Version: tflowversion.ModelToRPC(res.Flow),
        }

        err = stream.Send(resp)
        if err != nil </span><span class="cov8" title="1">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">if flowErr != nil </span><span class="cov8" title="1">{
                return connect.NewError(connect.CodeInternal, flowErr)
        }</span>

        <span class="cov8" title="1">if flowRunErr != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, flowRunErr)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (c *FlowServiceRPC) HandleExampleChanges(ctx context.Context, requestNodeResp nrequest.NodeRequestSideResp) error <span class="cov0" title="0">{
        FullHeaders := append(requestNodeResp.Resp.CreateHeaders, requestNodeResp.Resp.UpdateHeaders...)

        var assertResults []massertres.AssertResult
        var assert []massert.Assert
        for _, assertCouple := range requestNodeResp.Resp.AssertCouples </span><span class="cov0" title="0">{
                assertResults = append(assertResults, assertCouple.AssertRes)
                assert = append(assert, assertCouple.Assert)
        }</span>

        <span class="cov0" title="0">example := requestNodeResp.Example
        endpoint, err := c.ias.GetItemApi(ctx, example.ItemApiID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">endpoint.VersionParentID = &amp;endpoint.ID
        endpointNewID := idwrap.NewNow()
        endpoint.ID = endpointNewID

        err = c.ias.CreateItemApi(ctx, endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">example.VersionParentID = &amp;example.ID

        // TODO: should use same transaction as flow
        tx2, err := c.DB.BeginTx(ctx, &amp;sql.TxOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer devtoolsdb.TxnRollback(tx2)

        txExampleResp, err := sexampleresp.NewTX(ctx, tx2)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = txExampleResp.CreateExampleResp(ctx, requestNodeResp.Resp.ExampleResp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">txHeaderResp, err := sexamplerespheader.NewTX(ctx, tx2)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, header := range requestNodeResp.Resp.CreateHeaders </span><span class="cov0" title="0">{
                err = txHeaderResp.CreateExampleRespHeader(ctx, header)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">for _, header := range requestNodeResp.Resp.UpdateHeaders </span><span class="cov0" title="0">{
                err = txHeaderResp.UpdateExampleRespHeader(ctx, header)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">for _, headerID := range requestNodeResp.Resp.DeleteHeaderIds </span><span class="cov0" title="0">{
                err = txHeaderResp.DeleteExampleRespHeader(ctx, headerID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Handle assert results - create/update them in the database
        <span class="cov0" title="0">if len(assertResults) &gt; 0 </span><span class="cov0" title="0">{
                txAssertRes, err := sassertres.NewTX(ctx, tx2)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for _, assertResult := range assertResults </span><span class="cov0" title="0">{
                        err = txAssertRes.CreateAssertResult(ctx, assertResult)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">res, err := ritemapiexample.PrepareCopyExampleNoService(ctx, endpointNewID, example,
                requestNodeResp.Queries, requestNodeResp.Headers, assert,
                &amp;requestNodeResp.RawBody, requestNodeResp.FormBody, requestNodeResp.UrlBody,
                &amp;requestNodeResp.Resp.ExampleResp, FullHeaders, assertResults)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = ritemapiexample.CreateCopyExample(ctx, tx2, res)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = tx2.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

type CopyFlowResult struct {
        Flow  mflow.Flow
        Nodes []mnnode.MNode
        Edges []edge.Edge

        // Specific node types
        RequestNodes []mnrequest.MNRequest
        ForNodes     []mnfor.MNFor
        ForEachNodes []mnforeach.MNForEach
        IfNodes      []mnif.MNIF
        NoopNodes    []mnnoop.NoopNode

        // Node executions for this flow run
        NodeExecutions []mnodeexecution.NodeExecution
}

func (c *FlowServiceRPC) PrepareCopyFlow(ctx context.Context, workspaceID idwrap.IDWrap, originalFlow mflow.Flow, nodeExecutions []mnodeexecution.NodeExecution) (CopyFlowResult, error) <span class="cov8" title="1">{
        result := CopyFlowResult{}

        newFlowID := idwrap.NewNow()
        oldFlowID := originalFlow.ID
        originalFlow.ID = newFlowID
        result.Flow = originalFlow

        nodes, err := c.ns.GetNodesByFlowID(ctx, oldFlowID)
        if err != nil </span><span class="cov8" title="1">{
                return result, fmt.Errorf("get nodes: %w", err)
        }</span>

        <span class="cov8" title="1">edges, err := c.fes.GetEdgesByFlowID(ctx, oldFlowID)
        if err != nil </span><span class="cov0" title="0">{
                return result, fmt.Errorf("get edges: %w", err)
        }</span>

        <span class="cov8" title="1">oldToNewIDMap := make(map[idwrap.IDWrap]idwrap.IDWrap)

        for _, node := range nodes </span><span class="cov8" title="1">{
                newNodeID := idwrap.NewNow()
                oldToNewIDMap[node.ID] = newNodeID

                newNode := node
                newNode.ID = newNodeID
                newNode.FlowID = newFlowID
                result.Nodes = append(result.Nodes, newNode)

                // Get and copy specific node data based on type
                switch node.NodeKind </span>{
                case mnnode.NODE_KIND_REQUEST:<span class="cov0" title="0">
                        rn, err := c.rns.GetNodeRequest(ctx, node.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return result, fmt.Errorf("get request node: %w", err)
                        }</span>
                        <span class="cov0" title="0">newRN := *rn
                        newRN.FlowNodeID = newNodeID
                        result.RequestNodes = append(result.RequestNodes, newRN)</span>

                case mnnode.NODE_KIND_FOR:<span class="cov8" title="1">
                        fn, err := c.fns.GetNodeFor(ctx, node.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return result, fmt.Errorf("get for node: %w", err)
                        }</span>
                        <span class="cov8" title="1">newFN := *fn
                        newFN.FlowNodeID = newNodeID
                        result.ForNodes = append(result.ForNodes, newFN)</span>

                case mnnode.NODE_KIND_FOR_EACH:<span class="cov8" title="1">
                        fen, err := c.fens.GetNodeForEach(ctx, node.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return result, fmt.Errorf("get foreach node: %w", err)
                        }</span>
                        <span class="cov8" title="1">newFEN := *fen
                        newFEN.FlowNodeID = newNodeID
                        result.ForEachNodes = append(result.ForEachNodes, newFEN)</span>

                case mnnode.NODE_KIND_CONDITION:<span class="cov0" title="0">
                        ifn, err := c.ins.GetNodeIf(ctx, node.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return result, fmt.Errorf("get if node: %w", err)
                        }</span>
                        <span class="cov0" title="0">newIFN := *ifn
                        newIFN.FlowNodeID = newNodeID
                        result.IfNodes = append(result.IfNodes, newIFN)</span>

                case mnnode.NODE_KIND_NO_OP:<span class="cov8" title="1">
                        nn, err := c.sns.GetNodeNoop(ctx, node.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return result, fmt.Errorf("get noop node: %w", err)
                        }</span>
                        <span class="cov8" title="1">newNN := *nn
                        newNN.FlowNodeID = newNodeID
                        result.NoopNodes = append(result.NoopNodes, newNN)</span>
                }
        }

        // Copy edges with new node IDs
        <span class="cov8" title="1">for _, edge := range edges </span><span class="cov8" title="1">{
                newEdge := edge
                newEdge.ID = idwrap.NewNow()
                newEdge.FlowID = newFlowID
                newEdge.SourceID = oldToNewIDMap[edge.SourceID]
                newEdge.TargetID = oldToNewIDMap[edge.TargetID]
                result.Edges = append(result.Edges, newEdge)
        }</span>

        // Copy node executions with new node IDs
        <span class="cov8" title="1">for _, execution := range nodeExecutions </span><span class="cov8" title="1">{
                newExecution := execution
                newExecution.ID = idwrap.NewNow()
                // Map to the new node ID
                if newNodeID, ok := oldToNewIDMap[execution.NodeID]; ok </span><span class="cov8" title="1">{
                        newExecution.NodeID = newNodeID
                        result.NodeExecutions = append(result.NodeExecutions, newExecution)
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

func (c *FlowServiceRPC) CopyFlow(ctx context.Context, tx *sql.Tx, copyData CopyFlowResult) error <span class="cov8" title="1">{
        // Create flow
        txFlow, err := sflow.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create flow service: %w", err)
        }</span>
        <span class="cov8" title="1">err = txFlow.CreateFlow(ctx, copyData.Flow)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("create flow: %w", err)
        }</span>

        // Create nodes
        <span class="cov8" title="1">txNode, err := snode.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create node service: %w", err)
        }</span>
        <span class="cov8" title="1">for _, node := range copyData.Nodes </span><span class="cov8" title="1">{
                err = txNode.CreateNode(ctx, node)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("create node: %w", err)
                }</span>
        }

        // Create specific node data
        <span class="cov8" title="1">txRequestNode, err := snoderequest.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create request node service: %w", err)
        }</span>
        <span class="cov8" title="1">for _, rn := range copyData.RequestNodes </span><span class="cov0" title="0">{
                err = txRequestNode.CreateNodeRequest(ctx, rn)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("create request node: %w", err)
                }</span>
        }

        <span class="cov8" title="1">txForNode, err := snodefor.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create for node service: %w", err)
        }</span>
        <span class="cov8" title="1">for _, fn := range copyData.ForNodes </span><span class="cov8" title="1">{
                err = txForNode.CreateNodeFor(ctx, fn)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("create for node: %w", err)
                }</span>
        }

        <span class="cov8" title="1">txForEachNode, err := snodeforeach.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create foreach node service: %w", err)
        }</span>
        <span class="cov8" title="1">for _, fen := range copyData.ForEachNodes </span><span class="cov8" title="1">{
                err = txForEachNode.CreateNodeForEach(ctx, fen)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("create foreach node: %w", err)
                }</span>
        }

        <span class="cov8" title="1">txIfNode, err := snodeif.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create if node service: %w", err)
        }</span>
        <span class="cov8" title="1">for _, ifn := range copyData.IfNodes </span><span class="cov0" title="0">{
                err = txIfNode.CreateNodeIf(ctx, ifn)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("create if node: %w", err)
                }</span>
        }

        <span class="cov8" title="1">txNoopNode, err := snodenoop.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create noop node service: %w", err)
        }</span>
        <span class="cov8" title="1">for _, nn := range copyData.NoopNodes </span><span class="cov8" title="1">{
                err = txNoopNode.CreateNodeNoop(ctx, nn)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("create noop node: %w", err)
                }</span>
        }

        // Create edges
        <span class="cov8" title="1">txEdge, err := sedge.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create edge service: %w", err)
        }</span>
        <span class="cov8" title="1">for _, edge := range copyData.Edges </span><span class="cov8" title="1">{
                err = txEdge.CreateEdge(ctx, edge)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("create edge: %w", err)
                }</span>
        }

        // Create node executions for this flow version
        <span class="cov8" title="1">txNodeExecution, err := snodeexecution.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create node execution service: %w", err)
        }</span>
        <span class="cov8" title="1">for _, execution := range copyData.NodeExecutions </span><span class="cov8" title="1">{
                err = txNodeExecution.CreateNodeExecution(ctx, execution)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("create node execution: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (c *FlowServiceRPC) FlowVersions(ctx context.Context, req *connect.Request[flowv1.FlowVersionsRequest]) (*connect.Response[flowv1.FlowVersionsResponse], error) <span class="cov0" title="0">{
        flowID, err := idwrap.NewFromBytes(req.Msg.FlowId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(CheckOwnerFlow(ctx, c.fs, c.us, flowID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">flows, err := c.fs.GetFlowsByVersionParentID(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">translatedFlows := tgeneric.MassConvert(flows, tflowversion.ModelToRPC)
        resp := &amp;flowv1.FlowVersionsResponse{
                Items: translatedFlows,
        }

        sort.Slice(translatedFlows, func(i, j int) bool </span><span class="cov0" title="0">{
                return bytes.Compare(translatedFlows[i].FlowId, translatedFlows[j].FlowId) &gt; 0
        }</span>)

        <span class="cov0" title="0">return connect.NewResponse(resp), nil</span>
}

func CheckOwnerFlow(ctx context.Context, fs sflow.FlowService, us suser.UserService, flowID idwrap.IDWrap) (bool, error) <span class="cov8" title="1">{
        // TODO: add sql query to make it faster
        flow, err := fs.GetFlow(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return rworkspace.CheckOwnerWorkspace(ctx, us, flow.WorkspaceID)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package rflowvariable

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "connectrpc.com/connect"

        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/rflow"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/permcheck"

        "the-dev-tools/server/pkg/model/mflowvariable"
        "the-dev-tools/server/pkg/service/sflow"
        "the-dev-tools/server/pkg/service/sflowvariable"
        "the-dev-tools/server/pkg/service/suser"

        "the-dev-tools/server/pkg/translate/tflowvariable"

        flowvariablev1 "the-dev-tools/spec/dist/buf/go/flowvariable/v1"
        "the-dev-tools/spec/dist/buf/go/flowvariable/v1/flowvariablev1connect"
        resourcesv1 "the-dev-tools/spec/dist/buf/go/resources/v1"
)

type FlowVariableServiceRPC struct {
        DB  *sql.DB
        fs  sflow.FlowService
        us  suser.UserService
        fvs sflowvariable.FlowVariableService
}

func New(db *sql.DB, fs sflow.FlowService, us suser.UserService, fvs sflowvariable.FlowVariableService) FlowVariableServiceRPC <span class="cov8" title="1">{
        return FlowVariableServiceRPC{
                DB:  db,
                fs:  fs,
                us:  us,
                fvs: fvs,
        }
}</span>

func CreateService(srv FlowVariableServiceRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := flowvariablev1connect.NewFlowVariableServiceHandler(&amp;srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

func (c *FlowVariableServiceRPC) FlowVariableList(ctx context.Context, req *connect.Request[flowvariablev1.FlowVariableListRequest]) (*connect.Response[flowvariablev1.FlowVariableListResponse], error) <span class="cov8" title="1">{
        flowID, err := idwrap.NewFromBytes(req.Msg.FlowId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(rflow.CheckOwnerFlow(ctx, c.fs, c.us, flowID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">variables, err := c.fvs.GetFlowVariablesByFlowIDOrdered(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">var items []*flowvariablev1.FlowVariableListItem
        for _, variable := range variables </span><span class="cov8" title="1">{
                items = append(items, tflowvariable.ModelToRPCListItem(variable))
        }</span>

        <span class="cov8" title="1">response := &amp;flowvariablev1.FlowVariableListResponse{
                FlowId: flowID.Bytes(),
                Items:  items,
        }

        return connect.NewResponse(response), nil</span>
}

func (c *FlowVariableServiceRPC) FlowVariableGet(ctx context.Context, req *connect.Request[flowvariablev1.FlowVariableGetRequest]) (*connect.Response[flowvariablev1.FlowVariableGetResponse], error) <span class="cov8" title="1">{
        variableID, err := idwrap.NewFromBytes(req.Msg.VariableId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">variable, err := c.fvs.GetFlowVariable(ctx, variableID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(rflow.CheckOwnerFlow(ctx, c.fs, c.us, variable.FlowID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">response := &amp;flowvariablev1.FlowVariableGetResponse{
                VariableId:  variableID.Bytes(),
                Name:        variable.Name,
                Value:       variable.Value,
                Enabled:     variable.Enabled,
                Description: variable.Description,
        }

        return connect.NewResponse(response), nil</span>
}

func (c *FlowVariableServiceRPC) FlowVariableCreate(ctx context.Context, req *connect.Request[flowvariablev1.FlowVariableCreateRequest]) (*connect.Response[flowvariablev1.FlowVariableCreateResponse], error) <span class="cov8" title="1">{
        flowID, err := idwrap.NewFromBytes(req.Msg.FlowId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(rflow.CheckOwnerFlow(ctx, c.fs, c.us, flowID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">variableID := idwrap.NewNow()
        if len(req.Msg.VariableId) &gt; 0 </span><span class="cov0" title="0">{
                variableID, err = idwrap.NewFromBytes(req.Msg.VariableId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>
        }

        <span class="cov8" title="1">if req.Msg.Name == "" </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("name is required"))
        }</span>

        <span class="cov8" title="1">variable := mflowvariable.FlowVariable{
                ID:          variableID,
                FlowID:      flowID,
                Name:        req.Msg.Name,
                Value:       req.Msg.Value,
                Enabled:     req.Msg.Enabled,
                Description: req.Msg.Description,
        }

        err = c.fvs.CreateFlowVariable(ctx, variable)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to create flow variable: %w", err))
        }</span>
        /*

                // Create an invalidation change for the flow variables list
                service := "flowvariable.v1.FlowVariableService"
                method := "FlowVariableList"
                changeKind := changev1.ChangeKind_CHANGE_KIND_INVALIDATE
                listRequest, err := anypb.New(&amp;flowvariablev1.FlowVariableListRequest{
                        FlowId: flowID.Bytes(),
                })
                if err != nil {
                        return nil, connect.NewError(connect.CodeInternal, err)
                }

                        changes := []*changev1.Change{
                                {
                                        Kind:    &amp;changeKind,
                                        Service: &amp;service,
                                        Method:  &amp;method,
                                        Data:    listRequest,
                                },
                        }
        */

        <span class="cov8" title="1">response := &amp;flowvariablev1.FlowVariableCreateResponse{
                VariableId: variableID.Bytes(),
                // Changes:    changes,
        }

        return connect.NewResponse(response), nil</span>
}

func (c *FlowVariableServiceRPC) FlowVariableUpdate(ctx context.Context, req *connect.Request[flowvariablev1.FlowVariableUpdateRequest]) (*connect.Response[flowvariablev1.FlowVariableUpdateResponse], error) <span class="cov8" title="1">{
        variableID, err := idwrap.NewFromBytes(req.Msg.VariableId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">variable, err := c.fvs.GetFlowVariable(ctx, variableID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(rflow.CheckOwnerFlow(ctx, c.fs, c.us, variable.FlowID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">if req.Msg.Name != nil </span><span class="cov8" title="1">{
                variable.Name = *req.Msg.Name
        }</span>
        <span class="cov8" title="1">if req.Msg.Value != nil </span><span class="cov8" title="1">{
                variable.Value = *req.Msg.Value
        }</span>
        <span class="cov8" title="1">if req.Msg.Enabled != nil </span><span class="cov8" title="1">{
                variable.Enabled = *req.Msg.Enabled
        }</span>
        <span class="cov8" title="1">if req.Msg.Description != nil </span><span class="cov8" title="1">{
                variable.Description = *req.Msg.Description
        }</span>

        <span class="cov8" title="1">err = c.fvs.UpdateFlowVariable(ctx, variable)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to update flow variable: %w", err))
        }</span>

        /*

                // TODO: should be just update one not invalidation all list
                // Create an invalidation change for the list and get
                service := "flowvariable.v1.FlowVariableService"
                listMethod := "FlowVariableList"
                changeKind := changev1.ChangeKind_CHANGE_KIND_INVALIDATE
                listRequest, err := anypb.New(&amp;flowvariablev1.FlowVariableListRequest{
                        FlowId: variable.FlowID.Bytes(),
                })
                if err != nil {
                        return nil, connect.NewError(connect.CodeInternal, err)
                }

                getMethod := "FlowVariableGet"
                getRequest, err := anypb.New(&amp;flowvariablev1.FlowVariableGetRequest{
                        VariableId: variableID.Bytes(),
                })
                if err != nil {
                        return nil, connect.NewError(connect.CodeInternal, err)
                }

                changes := []*changev1.Change{
                        {
                                Kind:    &amp;changeKind,
                                Service: &amp;service,
                                Method:  &amp;listMethod,
                                Data:    listRequest,
                        },
                        {
                                Kind:    &amp;changeKind,
                                Service: &amp;service,
                                Method:  &amp;getMethod,
                                Data:    getRequest,
                        },
                }

        */
        <span class="cov8" title="1">response := &amp;flowvariablev1.FlowVariableUpdateResponse{
                //         Changes: changes,
        }

        return connect.NewResponse(response), nil</span>
}

func (c *FlowVariableServiceRPC) FlowVariableDelete(ctx context.Context, req *connect.Request[flowvariablev1.FlowVariableDeleteRequest]) (*connect.Response[flowvariablev1.FlowVariableDeleteResponse], error) <span class="cov8" title="1">{
        variableID, err := idwrap.NewFromBytes(req.Msg.VariableId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">variable, err := c.fvs.GetFlowVariable(ctx, variableID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(rflow.CheckOwnerFlow(ctx, c.fs, c.us, variable.FlowID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">err = c.fvs.DeleteFlowVariable(ctx, variableID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to delete flow variable: %w", err))
        }</span>

        /*

                // Create an invalidation change for the flow variables list
                service := "flowvariable.v1.FlowVariableService"
                method := "FlowVariableList"
                changeKind := changev1.ChangeKind_CHANGE_KIND_INVALIDATE
                listRequest, err := anypb.New(&amp;flowvariablev1.FlowVariableListRequest{
                        FlowId: variable.FlowID.Bytes(),
                })
                if err != nil {
                        return nil, connect.NewError(connect.CodeInternal, err)
                }

                changes := []*changev1.Change{
                        {
                                Kind:    &amp;changeKind,
                                Service: &amp;service,
                                Method:  &amp;method,
                                Data:    listRequest,
                        },
                }
        */

        <span class="cov8" title="1">response := &amp;flowvariablev1.FlowVariableDeleteResponse{
                // Changes: changes,
        }

        return connect.NewResponse(response), nil</span>
}

func (c *FlowVariableServiceRPC) FlowVariableMove(ctx context.Context, req *connect.Request[flowvariablev1.FlowVariableMoveRequest]) (*connect.Response[flowvariablev1.FlowVariableMoveResponse], error) <span class="cov8" title="1">{
        // Validate flow ID
        flowID, err := idwrap.NewFromBytes(req.Msg.GetFlowId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // Validate variable ID
        <span class="cov8" title="1">variableID, err := idwrap.NewFromBytes(req.Msg.GetVariableId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // Validate target variable ID
        <span class="cov8" title="1">targetVariableID, err := idwrap.NewFromBytes(req.Msg.GetTargetVariableId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // Check permissions for the flow
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(rflow.CheckOwnerFlow(ctx, c.fs, c.us, flowID))
        if rpcErr != nil </span><span class="cov8" title="1">{
                return nil, rpcErr
        }</span>

        // Validate position
        <span class="cov8" title="1">position := req.Msg.GetPosition()
        if position == resourcesv1.MovePosition_MOVE_POSITION_UNSPECIFIED </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("position must be specified"))
        }</span>

        // Prevent moving variable relative to itself
        <span class="cov8" title="1">if variableID.Compare(targetVariableID) == 0 </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("cannot move flow variable relative to itself"))
        }</span>

        // Verify both variables exist and are in the same flow
        <span class="cov8" title="1">sourceVariable, err := c.fvs.GetFlowVariable(ctx, variableID)
        if err != nil </span><span class="cov8" title="1">{
                if err == sflowvariable.ErrNoFlowVariableFound </span><span class="cov8" title="1">{
                        return nil, connect.NewError(connect.CodeNotFound, errors.New("flow variable not found"))
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov8" title="1">targetVariable, err := c.fvs.GetFlowVariable(ctx, targetVariableID)
        if err != nil </span><span class="cov8" title="1">{
                if err == sflowvariable.ErrNoFlowVariableFound </span><span class="cov8" title="1">{
                        return nil, connect.NewError(connect.CodeNotFound, errors.New("target flow variable not found"))
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        // Verify both variables are in the specified flow
        <span class="cov8" title="1">if sourceVariable.FlowID.Compare(flowID) != 0 </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("flow variable does not belong to the specified flow"))
        }</span>

        <span class="cov8" title="1">if targetVariable.FlowID.Compare(flowID) != 0 </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("target flow variable does not belong to the specified flow"))
        }</span>

        <span class="cov8" title="1">if sourceVariable.FlowID.Compare(targetVariable.FlowID) != 0 </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("flow variables must be in the same flow"))
        }</span>

        // Execute the move operation
        <span class="cov8" title="1">switch position </span>{
        case resourcesv1.MovePosition_MOVE_POSITION_AFTER:<span class="cov8" title="1">
                err = c.fvs.MoveFlowVariableAfter(ctx, variableID, targetVariableID)</span>
        case resourcesv1.MovePosition_MOVE_POSITION_BEFORE:<span class="cov8" title="1">
                err = c.fvs.MoveFlowVariableBefore(ctx, variableID, targetVariableID)</span>
        default:<span class="cov0" title="0">
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid position"))</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                // Map service-level errors to appropriate Connect error codes
                if err == sflowvariable.ErrNoFlowVariableFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov8" title="1">return connect.NewResponse(&amp;flowvariablev1.FlowVariableMoveResponse{}), nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package rimport

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "net/url"
        "sort"
        devtoolsdb "the-dev-tools/db"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/rworkspace"
        "the-dev-tools/server/pkg/dbtime"
        "the-dev-tools/server/pkg/idwrap"
        yamlflowsimple "the-dev-tools/server/pkg/io/yamlflow/yamlflowsimple"
        "the-dev-tools/server/pkg/model/mcollection"
        "the-dev-tools/server/pkg/model/mflow"
        "the-dev-tools/server/pkg/model/mitemapi"
        "the-dev-tools/server/pkg/model/mitemapiexample"
        "the-dev-tools/server/pkg/model/mitemfolder"
        "the-dev-tools/server/pkg/model/mnnode/mnrequest"
        "the-dev-tools/server/pkg/model/postman/v21/mpostmancollection"
        "the-dev-tools/server/pkg/permcheck"
        "the-dev-tools/server/pkg/service/flow/sedge"
        "the-dev-tools/server/pkg/service/sassert"
        "the-dev-tools/server/pkg/service/sbodyform"
        "the-dev-tools/server/pkg/service/sbodyraw"
        "the-dev-tools/server/pkg/service/sbodyurl"
        "the-dev-tools/server/pkg/service/scollection"
        "the-dev-tools/server/pkg/service/sexampleheader"
        "the-dev-tools/server/pkg/service/sexamplequery"
        "the-dev-tools/server/pkg/service/sexampleresp"
        "the-dev-tools/server/pkg/service/sflow"
        "the-dev-tools/server/pkg/service/sflowvariable"
        "the-dev-tools/server/pkg/service/sitemapi"
        "the-dev-tools/server/pkg/service/sitemapiexample"
        "the-dev-tools/server/pkg/service/sitemfolder"
        "the-dev-tools/server/pkg/service/snode"
        "the-dev-tools/server/pkg/service/snodefor"
        "the-dev-tools/server/pkg/service/snodeforeach"
        "the-dev-tools/server/pkg/service/snodeif"
        "the-dev-tools/server/pkg/service/snodejs"
        "the-dev-tools/server/pkg/service/snodenoop"
        "the-dev-tools/server/pkg/service/snoderequest"
        "the-dev-tools/server/pkg/service/suser"
        "the-dev-tools/server/pkg/service/sworkspace"
        "the-dev-tools/server/pkg/translate/tcurl"
        "the-dev-tools/server/pkg/translate/thar"
        "the-dev-tools/server/pkg/translate/tpostman"
        flowv1 "the-dev-tools/spec/dist/buf/go/flow/v1"
        importv1 "the-dev-tools/spec/dist/buf/go/import/v1"
        "the-dev-tools/spec/dist/buf/go/import/v1/importv1connect"

        "connectrpc.com/connect"
        "gopkg.in/yaml.v3"
)

// TODO: this is need be switch to id based system later
var lastHar thar.HAR

// Custom error types to distinguish between parsing and database errors
var (
        ErrHARParsing        = errors.New("failed to parse HAR file")
        ErrPostmanParsing    = errors.New("failed to parse Postman collection")
        ErrDatabaseOperation = errors.New("database operation failed")
)

type ImportRPC struct {
        DB   *sql.DB
        ws   sworkspace.WorkspaceService
        cs   scollection.CollectionService
        us   suser.UserService
        ifs  sitemfolder.ItemFolderService
        ias  sitemapi.ItemApiService
        iaes sitemapiexample.ItemApiExampleService
        res  sexampleresp.ExampleRespService
        as   sassert.AssertService
}

func New(db *sql.DB, ws sworkspace.WorkspaceService, cs scollection.CollectionService, us suser.UserService,
        ifs sitemfolder.ItemFolderService, ias sitemapi.ItemApiService,
        iaes sitemapiexample.ItemApiExampleService, res sexampleresp.ExampleRespService,
        as sassert.AssertService,
) ImportRPC <span class="cov8" title="1">{
        return ImportRPC{
                DB:   db,
                ws:   ws,
                cs:   cs,
                us:   us,
                ifs:  ifs,
                ias:  ias,
                iaes: iaes,
                res:  res,
                as:   as,
        }
}</span>

func CreateService(srv ImportRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := importv1connect.NewImportServiceHandler(&amp;srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

func (c *ImportRPC) Import(ctx context.Context, req *connect.Request[importv1.ImportRequest]) (*connect.Response[importv1.ImportResponse], error) <span class="cov8" title="1">{
        wsUlid, err := idwrap.NewFromBytes(req.Msg.GetWorkspaceId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">if rpcErr := permcheck.CheckPerm(rworkspace.CheckOwnerWorkspace(ctx, c.us, wsUlid)); rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">data := req.Msg.Data
        textData := req.Msg.TextData
        resp := &amp;importv1.ImportResponse{}

        // Check if a collection with this name already exists in the workspace
        var collectionID idwrap.IDWrap
        // Determine collection name based on import type
        // For HAR imports (when we have data that's valid JSON), use "Imported"
        // For other imports (curl with textData), use the provided name
        collectionName := req.Msg.Name
        // Check if this is a HAR import (either initial parse or filtered import)
        isHARImport := len(textData) == 0 &amp;&amp; (json.Valid(data) || len(req.Msg.Filter) &gt; 0)
        if isHARImport </span><span class="cov8" title="1">{
                // This is a HAR import, use "Imported" as collection name
                collectionName = "Imported"
        }</span>

        <span class="cov8" title="1">existingCollection, err := c.cs.GetCollectionByWorkspaceIDAndName(ctx, wsUlid, collectionName)
        switch err </span>{
        case nil:<span class="cov8" title="1">
                // Collection exists, use its ID
                collectionID = existingCollection.ID</span>
                // Found existing collection, will merge endpoints into it
        case scollection.ErrNoCollectionFound:<span class="cov8" title="1">
                // Collection doesn't exist, generate new ID
                collectionID = idwrap.NewNow()</span>
                // Collection doesn't exist, will create new one
        default:<span class="cov0" title="0">
                // Some other error occurred
                return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        // If no filter provided, we need to parse and present filter options
        <span class="cov8" title="1">if len(req.Msg.Filter) == 0 </span><span class="cov8" title="1">{
                // Handle curl import
                if len(textData) &gt; 0 </span><span class="cov8" title="1">{
                        curlResolved, err := tcurl.ConvertCurl(textData, collectionID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">if len(curlResolved.Apis) == 0 </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("no api found"))
                        }</span>

                        <span class="cov8" title="1">err = c.ImportCurl(ctx, wsUlid, collectionID, req.Msg.Name, curlResolved)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">return connect.NewResponse(resp), nil</span>
                }

                // Try to detect simplified YAML format first
                <span class="cov8" title="1">var yamlCheck map[string]any
                if err := yaml.Unmarshal(data, &amp;yamlCheck); err == nil </span><span class="cov8" title="1">{
                        // Check if it has the markers for simplified format
                        if _, hasWorkspace := yamlCheck["workspace_name"]; hasWorkspace </span><span class="cov8" title="1">{
                                if _, hasFlows := yamlCheck["flows"]; hasFlows </span><span class="cov8" title="1">{
                                        // This appears to be a simplified workflow YAML
                                        resolvedYAML, err := yamlflowsimple.ConvertSimplifiedYAML(data, collectionID, wsUlid)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("failed to convert simplified workflow: %w", err))
                                        }</span>

                                        // Import the simplified YAML data
                                        <span class="cov8" title="1">err = c.ImportSimplifiedYAML(ctx, wsUlid, resolvedYAML)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>

                                        // Return the first flow if any
                                        <span class="cov8" title="1">if len(resolvedYAML.Flows) &gt; 0 </span><span class="cov8" title="1">{
                                                flow := resolvedYAML.Flows[0]
                                                resp.Flow = &amp;flowv1.FlowListItem{
                                                        FlowId: flow.ID.Bytes(),
                                                        Name:   flow.Name,
                                                }
                                        }</span>

                                        <span class="cov8" title="1">return connect.NewResponse(resp), nil</span>
                                }
                        }
                }

                // Handle other imports
                <span class="cov8" title="1">if !json.Valid(data) </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid json")
                }</span>

                // Determine the type of file (HAR file)
                <span class="cov8" title="1">har, err := thar.ConvertRaw(data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Extract unique domains for filtering
                <span class="cov8" title="1">domains := make(map[string]struct{}, len(har.Log.Entries))
                for _, entry := range har.Log.Entries </span><span class="cov8" title="1">{
                        if thar.IsXHRRequest(entry) </span><span class="cov8" title="1">{
                                urlData, err := url.Parse(entry.Request.URL)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">domains[urlData.Host] = struct{}{}</span>
                        }
                }

                // Return filter options to the client
                <span class="cov8" title="1">resp.Kind = importv1.ImportKind_IMPORT_KIND_FILTER
                keys := make([]string, 0, len(domains))
                for k := range domains </span><span class="cov8" title="1">{
                        keys = append(keys, k)
                }</span>
                <span class="cov8" title="1">resp.Filter = keys

                // Save HAR for subsequent filtered import
                lastHar = *har

                return connect.NewResponse(resp), nil</span>
        }

        // Process filtered entries
        <span class="cov8" title="1">var filteredEntries []thar.Entry
        urlMap := make(map[string][]thar.Entry)

        // If lastHar is empty but we have data, parse it
        // This handles cases where the filter request comes from a different context
        if len(lastHar.Log.Entries) == 0 &amp;&amp; len(data) &gt; 0 &amp;&amp; json.Valid(data) </span><span class="cov8" title="1">{
                har, err := thar.ConvertRaw(data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">lastHar = *har</span>
        }

        <span class="cov8" title="1">for _, entry := range lastHar.Log.Entries </span><span class="cov8" title="1">{
                if thar.IsXHRRequest(entry) </span><span class="cov8" title="1">{
                        urlData, err := url.Parse(entry.Request.URL)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">host := urlData.Host
                        entries, ok := urlMap[host]
                        if !ok </span><span class="cov8" title="1">{
                                entries = make([]thar.Entry, 0)
                        }</span>
                        <span class="cov8" title="1">entries = append(entries, entry)
                        urlMap[host] = entries</span>
                }
        }

        <span class="cov8" title="1">for _, filter := range req.Msg.Filter </span><span class="cov8" title="1">{
                if entries, ok := urlMap[filter]; ok </span><span class="cov8" title="1">{
                        filteredEntries = append(filteredEntries, entries...)
                }</span>
        }
        <span class="cov8" title="1">lastHar.Log.Entries = filteredEntries

        // Try to import as HAR
        // Attempt HAR import with filtered entries
        // Use "Imported" as the collection name for HAR imports
        flow, err := c.ImportHar(ctx, wsUlid, collectionID, "Imported", &amp;lastHar)
        if err == nil </span><span class="cov8" title="1">{
                // For HAR imports, we also create a flow
                if flow != nil </span><span class="cov8" title="1">{
                        resp.Flow = &amp;flowv1.FlowListItem{
                                FlowId: flow.ID.Bytes(),
                                Name:   flow.Name,
                        }
                }</span>

                <span class="cov8" title="1">return connect.NewResponse(resp), nil</span>
        }

        // Check if error is due to database operation failure
        // In this case, we should not attempt fallback
        <span class="cov8" title="1">var connectErr *connect.Error
        if errors.As(err, &amp;connectErr) &amp;&amp; connectErr.Code() == connect.CodeInternal </span><span class="cov0" title="0">{
                // Database error occurred, return immediately without fallback
                return nil, err
        }</span>

        // HAR import failed due to parsing/conversion, try Postman Collection

        // Try to import as Postman Collection
        <span class="cov8" title="1">postman, err := tpostman.ParsePostmanCollection(data)
        if err != nil </span><span class="cov0" title="0">{
                // Postman collection parsing also failed
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("failed to parse as HAR or Postman collection: %w", err))
        }</span>

        // Postman collection parsed successfully, attempting import
        // For consistency, use "Imported" collection name if this was originally a HAR import attempt
        <span class="cov8" title="1">postmanCollectionName := req.Msg.Name
        if isHARImport </span><span class="cov8" title="1">{
                postmanCollectionName = "Imported"
        }</span>
        <span class="cov8" title="1">err = c.ImportPostmanCollection(ctx, wsUlid, collectionID, postmanCollectionName, postman)
        if err == nil </span><span class="cov8" title="1">{
                // Postman collection import successful (no flow created)
                return connect.NewResponse(resp), nil
        }</span>

        // Return the actual error from import
        <span class="cov0" title="0">return nil, err</span>
}

func (c *ImportRPC) ImportCurl(ctx context.Context, workspaceID, CollectionID idwrap.IDWrap, name string, resolvedCurl tcurl.CurlResolved) error <span class="cov8" title="1">{
        collection := mcollection.Collection{
                ID:          CollectionID,
                Name:        name,
                WorkspaceID: workspaceID,
        }

        // Check if collection already exists
        collectionExists := false
        _, err := c.cs.GetCollection(ctx, CollectionID)
        if err == nil </span><span class="cov8" title="1">{
                collectionExists = true
                // Collection already exists, will merge endpoints
        }</span> else<span class="cov8" title="1"> if err != scollection.ErrNoCollectionFound </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">tx, err := c.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">defer devtoolsdb.TxnRollback(tx)

        txCollectionService, err := scollection.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        // Only create collection if it doesn't exist
        <span class="cov8" title="1">if !collectionExists </span><span class="cov8" title="1">{
                err = txCollectionService.CreateCollection(ctx, &amp;collection)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov8" title="1">txItemApiService, err := sitemapi.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txItemApiService.CreateItemApiBulk(ctx, resolvedCurl.Apis)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">txItemApiExampleService, err := sitemapiexample.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">err = txItemApiExampleService.CreateApiExampleBulk(ctx, resolvedCurl.Examples)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        // START BODY
        <span class="cov8" title="1">txBodyRawService, err := sbodyraw.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txBodyRawService.CreateBulkBodyRaw(ctx, resolvedCurl.RawBodies)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">txBodyFormService, err := sbodyform.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txBodyFormService.CreateBulkBodyForm(ctx, resolvedCurl.FormBodies)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">txBodyUrlEncodedService, err := sbodyurl.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txBodyUrlEncodedService.CreateBulkBodyURLEncoded(ctx, resolvedCurl.UrlEncodedBodies)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        // END BODY

        <span class="cov8" title="1">txHeaderService, err := sexampleheader.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txHeaderService.AppendBulkHeader(ctx, resolvedCurl.Headers)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">txQueriesService, err := sexamplequery.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txQueriesService.CreateBulkQuery(ctx, resolvedCurl.Queries)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        // Update workspace counts and timestamp inside transaction
        <span class="cov8" title="1">txWorkspaceService, err := sworkspace.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">ws, err := txWorkspaceService.Get(ctx, workspaceID)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        // Only increment collection count if we created a new collection
        <span class="cov8" title="1">if !collectionExists </span><span class="cov8" title="1">{
                ws.CollectionCount++
        }</span>
        <span class="cov8" title="1">ws.Updated = dbtime.DBNow()
        err = txWorkspaceService.Update(ctx, ws)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (c *ImportRPC) ImportPostmanCollection(ctx context.Context, workspaceID, CollectionID idwrap.IDWrap, name string, collectionData mpostmancollection.Collection) error <span class="cov8" title="1">{
        collection := mcollection.Collection{
                ID:          CollectionID,
                Name:        name,
                WorkspaceID: workspaceID,
        }

        // Check if collection already exists
        collectionExists := false
        _, err := c.cs.GetCollection(ctx, CollectionID)
        if err == nil </span><span class="cov0" title="0">{
                collectionExists = true
                // Collection already exists, will merge endpoints
        }</span> else<span class="cov8" title="1"> if err != scollection.ErrNoCollectionFound </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">items, err := tpostman.ConvertPostmanCollection(collectionData, CollectionID)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">tx, err := c.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">defer devtoolsdb.TxnRollback(tx)

        txCollectionService, err := scollection.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        // Only create collection if it doesn't exist
        <span class="cov8" title="1">if !collectionExists </span><span class="cov8" title="1">{
                err = txCollectionService.CreateCollection(ctx, &amp;collection)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov8" title="1">txItemFolderService, err := sitemfolder.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txItemFolderService.CreateItemFolderBulk(ctx, items.Folders)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">txItemApiService, err := sitemapi.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txItemApiService.CreateItemApiBulk(ctx, items.Apis)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">txItemApiExampleService, err := sitemapiexample.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">err = txItemApiExampleService.CreateApiExampleBulk(ctx, items.ApiExamples)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        // START BODY
        <span class="cov8" title="1">txBodyRawService, err := sbodyraw.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txBodyRawService.CreateBulkBodyRaw(ctx, items.BodyRaw)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">txBodyFormService, err := sbodyform.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txBodyFormService.CreateBulkBodyForm(ctx, items.BodyForm)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">txBodyUrlEncodedService, err := sbodyurl.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txBodyUrlEncodedService.CreateBulkBodyURLEncoded(ctx, items.BodyUrlEncoded)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        // END BODY

        <span class="cov8" title="1">txHeaderService, err := sexampleheader.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txHeaderService.AppendBulkHeader(ctx, items.Headers)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">txQueriesService, err := sexamplequery.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txQueriesService.CreateBulkQuery(ctx, items.Queries)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        // Update workspace counts and timestamp inside transaction
        <span class="cov8" title="1">txWorkspaceService, err := sworkspace.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">ws, err := txWorkspaceService.Get(ctx, workspaceID)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        // Only increment collection count if we created a new collection
        <span class="cov8" title="1">if !collectionExists </span><span class="cov8" title="1">{
                ws.CollectionCount++
        }</span>
        <span class="cov8" title="1">ws.Updated = dbtime.DBNow()
        err = txWorkspaceService.Update(ctx, ws)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (c *ImportRPC) ImportHar(ctx context.Context, workspaceID, CollectionID idwrap.IDWrap, name string, harData *thar.HAR) (*mflow.Flow, error) <span class="cov8" title="1">{
        // Check if collection already exists
        collectionExists := false
        _, err := c.cs.GetCollection(ctx, CollectionID)
        if err == nil </span><span class="cov8" title="1">{
                collectionExists = true
                // Collection already exists, will merge endpoints
        }</span> else<span class="cov8" title="1"> if err != scollection.ErrNoCollectionFound </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Pre-load existing folders if collection exists
        <span class="cov8" title="1">var existingFolders []mitemfolder.ItemFolder
        if collectionExists </span><span class="cov8" title="1">{
                existingFolders, err = c.ifs.GetFoldersWithCollectionID(ctx, CollectionID)
                if err != nil &amp;&amp; err != sitemfolder.ErrNoItemFolderFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        // Import HAR data into collection with existing folder info
        <span class="cov8" title="1">resolved, err := thar.ConvertHARWithExistingData(harData, CollectionID, workspaceID, existingFolders)
        if err != nil </span><span class="cov8" title="1">{
                // HAR conversion failed
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // HAR conversion successful

        <span class="cov8" title="1">if len(resolved.Apis) == 0 </span><span class="cov0" title="0">{
                // No APIs found in HAR conversion
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("no apis found to create in har"))
        }</span>

        <span class="cov8" title="1">collectionData := mcollection.Collection{
                ID:          CollectionID,
                Name:        name,
                WorkspaceID: workspaceID,
        }

        tx, err := c.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">defer devtoolsdb.TxnRollback(tx)

        txCollectionService, err := scollection.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Only create collection if it doesn't exist
        <span class="cov8" title="1">if !collectionExists </span><span class="cov8" title="1">{
                err = txCollectionService.CreateCollection(ctx, &amp;collectionData)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov8" title="1">txItemApiService, err := sitemapi.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">txItemFolderService, err := sitemfolder.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Pre-load existing folders to optimize lookup
        <span class="cov8" title="1">existingFoldersList, err := txItemFolderService.GetFoldersWithCollectionID(ctx, CollectionID)
        if err != nil &amp;&amp; err != sitemfolder.ErrNoItemFolderFound </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Build a map to track folder updates
        <span class="cov8" title="1">folderIDMapping := make(map[idwrap.IDWrap]idwrap.IDWrap) // old ID -&gt; new/existing ID

        // Create folders first (they need to exist before APIs reference them)
        if len(resolved.Folders) &gt; 0 </span><span class="cov8" title="1">{
                // Build a map of existing folders by ID for quick lookup
                existingFolderByID := make(map[idwrap.IDWrap]*mitemfolder.ItemFolder)
                for i := range existingFoldersList </span><span class="cov8" title="1">{
                        existingFolderByID[existingFoldersList[i].ID] = &amp;existingFoldersList[i]
                }</span>

                // Filter out folders that already exist and build ID mapping
                <span class="cov8" title="1">var foldersToCreate []mitemfolder.ItemFolder
                for i := range resolved.Folders </span><span class="cov8" title="1">{
                        folder := &amp;resolved.Folders[i]
                        // Check if folder already exists by name and parent
                        exists := false
                        for _, existing := range existingFoldersList </span><span class="cov8" title="1">{
                                if existing.Name == folder.Name &amp;&amp;
                                        ((existing.ParentID == nil &amp;&amp; folder.ParentID == nil) ||
                                                (existing.ParentID != nil &amp;&amp; folder.ParentID != nil &amp;&amp; existing.ParentID.Compare(*folder.ParentID) == 0)) </span><span class="cov0" title="0">{
                                        exists = true
                                        // Map old ID to existing ID
                                        folderIDMapping[folder.ID] = existing.ID
                                        // Update the folder ID in resolved.Folders to use existing ID
                                        folder.ID = existing.ID
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                                // Keep the same ID for new folders
                                folderIDMapping[folder.ID] = folder.ID
                                foldersToCreate = append(foldersToCreate, *folder)
                        }</span>
                }

                // Update parent IDs in folders to create based on mapping
                <span class="cov8" title="1">for i := range foldersToCreate </span><span class="cov8" title="1">{
                        if foldersToCreate[i].ParentID != nil </span><span class="cov8" title="1">{
                                if mappedID, ok := folderIDMapping[*foldersToCreate[i].ParentID]; ok </span><span class="cov8" title="1">{
                                        foldersToCreate[i].ParentID = &amp;mappedID
                                }</span>
                        }
                }

                // Sort folders by hierarchy depth to ensure parents are created before children
                <span class="cov8" title="1">sortFoldersByDepth(foldersToCreate)

                // Only create folders that don't exist
                if len(foldersToCreate) &gt; 0 </span><span class="cov8" title="1">{
                        // CreateItemFolderBulk expects exactly 10 items, so we need to batch or create individually
                        for i := 0; i &lt; len(foldersToCreate); i += 10 </span><span class="cov8" title="1">{
                                end := i + 10
                                if end &gt; len(foldersToCreate) </span><span class="cov8" title="1">{
                                        // Create remaining items individually
                                        for j := i; j &lt; len(foldersToCreate); j++ </span><span class="cov8" title="1">{
                                                err = txItemFolderService.CreateItemFolder(ctx, &amp;foldersToCreate[j])
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return nil, connect.NewError(connect.CodeInternal, err)
                                                }</span>
                                        }
                                } else<span class="cov8" title="1"> {
                                        // Create batch of exactly 10
                                        batch := foldersToCreate[i:end]
                                        err = txItemFolderService.CreateItemFolderBulk(ctx, batch)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, connect.NewError(connect.CodeInternal, err)
                                        }</span>
                                }
                        }
                }
        }

        // Reload folders after creation to get updated list
        <span class="cov8" title="1">existingFoldersList, err = txItemFolderService.GetFoldersWithCollectionID(ctx, CollectionID)
        if err != nil &amp;&amp; err != sitemfolder.ErrNoItemFolderFound </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Build a map for quick folder lookup by path
        <span class="cov8" title="1">existingFolderMap := make(map[string]idwrap.IDWrap)
        for _, folder := range existingFoldersList </span><span class="cov8" title="1">{
                // We'll need to reconstruct the folder path - for now just use the folder ID
                existingFolderMap[folder.Name] = folder.ID
        }</span>

        // Update API folder references based on folder mapping (if folders were processed)
        <span class="cov8" title="1">if len(resolved.Folders) &gt; 0 &amp;&amp; len(folderIDMapping) &gt; 0 </span><span class="cov8" title="1">{
                for i := range resolved.Apis </span><span class="cov8" title="1">{
                        if resolved.Apis[i].FolderID != nil </span><span class="cov8" title="1">{
                                if mappedID, ok := folderIDMapping[*resolved.Apis[i].FolderID]; ok </span><span class="cov8" title="1">{
                                        resolved.Apis[i].FolderID = &amp;mappedID
                                }</span>
                        }
                }
        }

        // Handle endpoint creation/update with duplicate checking
        <span class="cov8" title="1">apiMapping := make(map[idwrap.IDWrap]idwrap.IDWrap) // Map old API ID to new/existing API ID
        var apisToCreate []mitemapi.ItemApi
        var apisToUpdate []mitemapi.ItemApi

        // Batch load all existing endpoints for this collection
        existingApis, err := txItemApiService.GetApisWithCollectionID(ctx, CollectionID)
        if err != nil &amp;&amp; err != sitemapi.ErrNoItemApiFound </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Create a map for quick lookup
        <span class="cov8" title="1">existingApiMap := make(map[string]*mitemapi.ItemApi)
        for i := range existingApis </span><span class="cov8" title="1">{
                api := &amp;existingApis[i]
                key := api.Url + "|" + api.Method
                existingApiMap[key] = api
        }</span>

        // Check each endpoint to see if it already exists
        <span class="cov8" title="1">for _, api := range resolved.Apis </span><span class="cov8" title="1">{
                // Skip delta endpoints for now - handle them separately
                if api.DeltaParentID != nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">key := api.Url + "|" + api.Method
                existingApi := existingApiMap[key]

                if existingApi != nil </span><span class="cov8" title="1">{
                        // Endpoint exists - check if update is needed
                        needsUpdate := false
                        if existingApi.Name != api.Name </span><span class="cov0" title="0">{
                                needsUpdate = true
                                existingApi.Name = api.Name
                        }</span>
                        <span class="cov8" title="1">if (existingApi.FolderID == nil &amp;&amp; api.FolderID != nil) ||
                                (existingApi.FolderID != nil &amp;&amp; api.FolderID == nil) ||
                                (existingApi.FolderID != nil &amp;&amp; api.FolderID != nil &amp;&amp; existingApi.FolderID.Compare(*api.FolderID) != 0) </span><span class="cov0" title="0">{
                                needsUpdate = true
                                existingApi.FolderID = api.FolderID
                        }</span>

                        <span class="cov8" title="1">apiMapping[api.ID] = existingApi.ID
                        if needsUpdate </span><span class="cov0" title="0">{
                                apisToUpdate = append(apisToUpdate, *existingApi)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // New endpoint - create it
                        apiMapping[api.ID] = api.ID
                        apisToCreate = append(apisToCreate, api)
                }</span>
        }

        // Handle delta endpoints
        <span class="cov8" title="1">for _, api := range resolved.Apis </span><span class="cov8" title="1">{
                if api.DeltaParentID != nil </span><span class="cov8" title="1">{
                        // Map delta parent to the actual/existing API ID
                        if mappedID, ok := apiMapping[*api.DeltaParentID]; ok </span><span class="cov8" title="1">{
                                newDeltaParentID := mappedID
                                api.DeltaParentID = &amp;newDeltaParentID
                        }</span>
                        <span class="cov8" title="1">apisToCreate = append(apisToCreate, api)</span>
                }
        }

        // Create new endpoints
        <span class="cov8" title="1">if len(apisToCreate) &gt; 0 </span><span class="cov8" title="1">{
                // CreateItemApiBulk expects exactly 10 items, so we need to batch or create individually
                for i := 0; i &lt; len(apisToCreate); i += 10 </span><span class="cov8" title="1">{
                        end := i + 10
                        if end &gt; len(apisToCreate) </span><span class="cov8" title="1">{
                                // Create remaining items individually
                                for j := i; j &lt; len(apisToCreate); j++ </span><span class="cov8" title="1">{
                                        err = txItemApiService.CreateItemApi(ctx, &amp;apisToCreate[j])
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, connect.NewError(connect.CodeInternal, err)
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> {
                                // Create batch of exactly 10
                                batch := apisToCreate[i:end]
                                err = txItemApiService.CreateItemApiBulk(ctx, batch)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, connect.NewError(connect.CodeInternal, err)
                                }</span>
                        }
                }
        }

        // Update existing endpoints
        <span class="cov8" title="1">for _, api := range apisToUpdate </span><span class="cov0" title="0">{
                err = txItemApiService.UpdateItemApi(ctx, &amp;api)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov8" title="1">txItemApiExampleService, err := sitemapiexample.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Update example API IDs based on mapping
        <span class="cov8" title="1">var updatedExamples []mitemapiexample.ItemApiExample
        for _, example := range resolved.Examples </span><span class="cov8" title="1">{
                if mappedID, ok := apiMapping[example.ItemApiID]; ok </span><span class="cov8" title="1">{
                        example.ItemApiID = mappedID
                }</span>
                <span class="cov8" title="1">updatedExamples = append(updatedExamples, example)</span>
        }

        // TODO: For existing endpoints, we should check if we need to delete old examples
        // For now, just create new examples
        <span class="cov8" title="1">if len(updatedExamples) &gt; 0 </span><span class="cov8" title="1">{
                // CreateApiExampleBulk expects exactly 10 items, so we need to batch or create individually
                for i := 0; i &lt; len(updatedExamples); i += 10 </span><span class="cov8" title="1">{
                        end := i + 10
                        if end &gt; len(updatedExamples) </span><span class="cov8" title="1">{
                                // Create remaining items individually
                                for j := i; j &lt; len(updatedExamples); j++ </span><span class="cov8" title="1">{
                                        err = txItemApiExampleService.CreateApiExample(ctx, &amp;updatedExamples[j])
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, connect.NewError(connect.CodeInternal, err)
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> {
                                // Create batch of exactly 10
                                batch := updatedExamples[i:end]
                                err = txItemApiExampleService.CreateApiExampleBulk(ctx, batch)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, connect.NewError(connect.CodeInternal, err)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">txExampleHeaderService, err := sexampleheader.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txExampleHeaderService.AppendBulkHeader(ctx, resolved.Headers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">txExampleQueryService, err := sexamplequery.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txExampleQueryService.CreateBulkQuery(ctx, resolved.Queries)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">txBodyRawService, err := sbodyraw.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">err = txBodyRawService.CreateBulkBodyRaw(ctx, resolved.RawBodies)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">txBodyFormService, err := sbodyform.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txBodyFormService.CreateBulkBodyForm(ctx, resolved.FormBodies)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">txBodyUrlEncodedService, err := sbodyurl.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txBodyUrlEncodedService.CreateBulkBodyURLEncoded(ctx, resolved.UrlEncodedBodies)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Assertions
        <span class="cov8" title="1">if len(resolved.Asserts) &gt; 0 </span><span class="cov8" title="1">{
                txAssertService, err := sassert.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov8" title="1">err = txAssertService.CreateBulkAssert(ctx, resolved.Asserts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        // Flow Creation
        <span class="cov8" title="1">txFlowService, err := sflow.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txFlowService.CreateFlow(ctx, resolved.Flow)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Flow Node
        <span class="cov8" title="1">txFlowNodeService, err := snode.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txFlowNodeService.CreateNodeBulk(ctx, resolved.Nodes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Flow Request Nodes
        // Create flow request nodes
        <span class="cov8" title="1">txFlowRequestService, err := snoderequest.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                // Failed to create txFlowRequestService
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Update request nodes with mapped endpoint IDs
        <span class="cov8" title="1">var updatedRequestNodes []mnrequest.MNRequest
        for _, node := range resolved.RequestNodes </span><span class="cov8" title="1">{
                if node.EndpointID != nil </span><span class="cov8" title="1">{
                        if mappedID, ok := apiMapping[*node.EndpointID]; ok </span><span class="cov8" title="1">{
                                node.EndpointID = &amp;mappedID
                        }</span>
                }
                <span class="cov8" title="1">if node.DeltaEndpointID != nil </span><span class="cov8" title="1">{
                        if mappedID, ok := apiMapping[*node.DeltaEndpointID]; ok </span><span class="cov0" title="0">{
                                node.DeltaEndpointID = &amp;mappedID
                        }</span>
                }
                <span class="cov8" title="1">updatedRequestNodes = append(updatedRequestNodes, node)</span>
        }

        <span class="cov8" title="1">err = txFlowRequestService.CreateNodeRequestBulk(ctx, updatedRequestNodes)
        if err != nil </span><span class="cov0" title="0">{
                // CreateNodeRequestBulk failed
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        // Flow request nodes created successfully

        // Flow Noop Nodes
        <span class="cov8" title="1">txFlowNoopService, err := snodenoop.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txFlowNoopService.CreateNodeNoopBulk(ctx, resolved.NoopNodes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Edges
        <span class="cov8" title="1">txFlowEdgeService, err := sedge.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = txFlowEdgeService.CreateEdgeBulk(ctx, resolved.Edges)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Update workspace counts and timestamp inside transaction
        <span class="cov8" title="1">txWorkspaceService, err := sworkspace.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">ws, err := txWorkspaceService.Get(ctx, workspaceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        // Only increment collection count if we created a new collection
        <span class="cov8" title="1">if !collectionExists </span><span class="cov8" title="1">{
                ws.CollectionCount++
        }</span>
        <span class="cov8" title="1">ws.FlowCount++
        ws.Updated = dbtime.DBNow()
        err = txWorkspaceService.Update(ctx, ws)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Commit transaction
        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                // Transaction commit failed
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // HAR import completed successfully
        // Return a pointer to the Flow
        <span class="cov8" title="1">flow := resolved.Flow
        return &amp;flow, nil</span>
}

func (c *ImportRPC) ImportSimplifiedYAML(ctx context.Context, workspaceID idwrap.IDWrap, resolved yamlflowsimple.SimplifiedYAMLResolved) error <span class="cov8" title="1">{
        tx, err := c.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">defer devtoolsdb.TxnRollback(tx)

        // Import collections
        if len(resolved.Collections) &gt; 0 </span><span class="cov8" title="1">{
                txCollectionService, err := scollection.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov8" title="1">for _, collection := range resolved.Collections </span><span class="cov8" title="1">{
                        collection.WorkspaceID = workspaceID
                        err = txCollectionService.CreateCollection(ctx, &amp;collection)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, err)
                        }</span>
                }
        }

        // Import endpoints
        <span class="cov8" title="1">if len(resolved.Endpoints) &gt; 0 </span><span class="cov8" title="1">{
                txEndpointService, err := sitemapi.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov8" title="1">err = txEndpointService.CreateItemApiBulk(ctx, resolved.Endpoints)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        // Import examples
        <span class="cov8" title="1">if len(resolved.Examples) &gt; 0 </span><span class="cov8" title="1">{
                txExampleService, err := sitemapiexample.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov8" title="1">err = txExampleService.CreateApiExampleBulk(ctx, resolved.Examples)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        // Import headers
        <span class="cov8" title="1">if len(resolved.Headers) &gt; 0 </span><span class="cov0" title="0">{
                txHeaderService, err := sexampleheader.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">err = txHeaderService.AppendBulkHeader(ctx, resolved.Headers)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        // Import queries
        <span class="cov8" title="1">if len(resolved.Queries) &gt; 0 </span><span class="cov0" title="0">{
                txQueryService, err := sexamplequery.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">err = txQueryService.CreateBulkQuery(ctx, resolved.Queries)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        // Import raw bodies
        <span class="cov8" title="1">if len(resolved.RawBodies) &gt; 0 </span><span class="cov8" title="1">{
                txBodyService, err := sbodyraw.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov8" title="1">err = txBodyService.CreateBulkBodyRaw(ctx, resolved.RawBodies)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        // Import flows
        <span class="cov8" title="1">if len(resolved.Flows) &gt; 0 </span><span class="cov8" title="1">{
                txFlowService, err := sflow.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov8" title="1">for i := range resolved.Flows </span><span class="cov8" title="1">{
                        resolved.Flows[i].WorkspaceID = workspaceID
                        err = txFlowService.CreateFlow(ctx, resolved.Flows[i])
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, err)
                        }</span>
                }
        }

        // Import flow nodes
        <span class="cov8" title="1">if len(resolved.FlowNodes) &gt; 0 </span><span class="cov8" title="1">{
                txNodeService, err := snode.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov8" title="1">err = txNodeService.CreateNodeBulk(ctx, resolved.FlowNodes)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        // Import flow edges
        <span class="cov8" title="1">if len(resolved.FlowEdges) &gt; 0 </span><span class="cov8" title="1">{
                txEdgeService, err := sedge.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov8" title="1">for _, edge := range resolved.FlowEdges </span><span class="cov8" title="1">{
                        err = txEdgeService.CreateEdge(ctx, edge)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, err)
                        }</span>
                }
        }

        // Import flow variables
        <span class="cov8" title="1">if len(resolved.FlowVariables) &gt; 0 </span><span class="cov8" title="1">{
                txFlowVariableService, err := sflowvariable.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov8" title="1">for _, v := range resolved.FlowVariables </span><span class="cov8" title="1">{
                        err = txFlowVariableService.CreateFlowVariable(ctx, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, err)
                        }</span>
                }
        }

        // Import node implementations
        <span class="cov8" title="1">if len(resolved.FlowRequestNodes) &gt; 0 </span><span class="cov8" title="1">{
                txRequestService, err := snoderequest.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov8" title="1">for _, r := range resolved.FlowRequestNodes </span><span class="cov8" title="1">{
                        err = txRequestService.CreateNodeRequest(ctx, r)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(resolved.FlowConditionNodes) &gt; 0 </span><span class="cov8" title="1">{
                txConditionService, err := snodeif.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov8" title="1">for _, c := range resolved.FlowConditionNodes </span><span class="cov8" title="1">{
                        err = txConditionService.CreateNodeIf(ctx, c)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(resolved.FlowNoopNodes) &gt; 0 </span><span class="cov8" title="1">{
                txNoopService, err := snodenoop.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov8" title="1">for _, n := range resolved.FlowNoopNodes </span><span class="cov8" title="1">{
                        err = txNoopService.CreateNodeNoop(ctx, n)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(resolved.FlowForNodes) &gt; 0 </span><span class="cov0" title="0">{
                txForService, err := snodefor.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">for _, f := range resolved.FlowForNodes </span><span class="cov0" title="0">{
                        err = txForService.CreateNodeFor(ctx, f)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(resolved.FlowJSNodes) &gt; 0 </span><span class="cov0" title="0">{
                txJsService, err := snodejs.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">for _, j := range resolved.FlowJSNodes </span><span class="cov0" title="0">{
                        err = txJsService.CreateNodeJS(ctx, j)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(resolved.FlowForEachNodes) &gt; 0 </span><span class="cov0" title="0">{
                txForEachService, err := snodeforeach.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">for _, fe := range resolved.FlowForEachNodes </span><span class="cov0" title="0">{
                        err = txForEachService.CreateNodeForEach(ctx, fe)
                        if err != nil </span><span class="cov0" title="0">{
                                return connect.NewError(connect.CodeInternal, err)
                        }</span>
                }
        }

        // Update workspace counts and timestamp
        <span class="cov8" title="1">txWorkspaceService, err := sworkspace.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">ws, err := txWorkspaceService.Get(ctx, workspaceID)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">if len(resolved.Collections) &gt; 0 </span><span class="cov8" title="1">{
                ws.CollectionCount += int32(len(resolved.Collections))
        }</span>
        <span class="cov8" title="1">if len(resolved.Flows) &gt; 0 </span><span class="cov8" title="1">{
                ws.FlowCount += int32(len(resolved.Flows))
        }</span>
        <span class="cov8" title="1">ws.Updated = dbtime.DBNow()

        err = txWorkspaceService.Update(ctx, ws)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        // Commit transaction
        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// sortFoldersByDepth sorts folders so that parent folders come before their children
func sortFoldersByDepth(folders []mitemfolder.ItemFolder) <span class="cov8" title="1">{
        // Build a map of folder IDs to their indices
        folderIndex := make(map[idwrap.IDWrap]int)
        for i, folder := range folders </span><span class="cov8" title="1">{
                folderIndex[folder.ID] = i
        }</span>

        // Calculate depth for each folder
        <span class="cov8" title="1">depths := make([]int, len(folders))
        for i := range folders </span><span class="cov8" title="1">{
                depths[i] = calculateFolderDepth(&amp;folders[i], folders, folderIndex, make(map[idwrap.IDWrap]bool))
        }</span>

        // Sort by depth (parents first)
        <span class="cov8" title="1">sort.SliceStable(folders, func(i, j int) bool </span><span class="cov8" title="1">{
                return depths[i] &lt; depths[j]
        }</span>)
}

// calculateFolderDepth calculates the depth of a folder in the hierarchy
func calculateFolderDepth(folder *mitemfolder.ItemFolder, allFolders []mitemfolder.ItemFolder, folderIndex map[idwrap.IDWrap]int, visited map[idwrap.IDWrap]bool) int <span class="cov8" title="1">{
        if folder.ParentID == nil </span><span class="cov8" title="1">{
                return 0
        }</span>

        // Check for circular references
        <span class="cov8" title="1">if visited[folder.ID] </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">visited[folder.ID] = true

        // Find parent in the list
        if parentIdx, ok := folderIndex[*folder.ParentID]; ok </span><span class="cov8" title="1">{
                return 1 + calculateFolderDepth(&amp;allFolders[parentIdx], allFolders, folderIndex, visited)
        }</span>

        // Parent not in list, assume it exists in DB
        <span class="cov8" title="1">return 1</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package ritemapi

import (
        "context"
        "database/sql"
        "errors"
        devtoolsdb "the-dev-tools/db"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/rcollection"
        "the-dev-tools/server/internal/api/ritemfolder"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mbodyraw"
        "the-dev-tools/server/pkg/model/mexampleresp"
        "the-dev-tools/server/pkg/model/mitemapi"
        "the-dev-tools/server/pkg/model/mitemapiexample"
        "the-dev-tools/server/pkg/permcheck"
        "the-dev-tools/server/pkg/service/sbodyraw"
        "the-dev-tools/server/pkg/service/scollection"
        "the-dev-tools/server/pkg/service/scollectionitem"
        "the-dev-tools/server/pkg/service/sexampleresp"
        "the-dev-tools/server/pkg/service/sitemapi"
        "the-dev-tools/server/pkg/service/sitemapiexample"
        "the-dev-tools/server/pkg/service/sitemfolder"
        "the-dev-tools/server/pkg/service/suser"
        "the-dev-tools/server/pkg/translate/titemapi"
        endpointv1 "the-dev-tools/spec/dist/buf/go/collection/item/endpoint/v1"
        "the-dev-tools/spec/dist/buf/go/collection/item/endpoint/v1/endpointv1connect"

        "connectrpc.com/connect"
)

type ItemApiRPC struct {
        DB   *sql.DB
        ias  *sitemapi.ItemApiService
        ifs  *sitemfolder.ItemFolderService
        cs   *scollection.CollectionService
        us   *suser.UserService
        iaes *sitemapiexample.ItemApiExampleService
        ers *sexampleresp.ExampleRespService
        cis  *scollectionitem.CollectionItemService
}

func New(db *sql.DB, ias sitemapi.ItemApiService, cs scollection.CollectionService,
        ifs sitemfolder.ItemFolderService, us suser.UserService,
        iaes sitemapiexample.ItemApiExampleService,
        ers sexampleresp.ExampleRespService,
        cis *scollectionitem.CollectionItemService,
) ItemApiRPC <span class="cov8" title="1">{
        return ItemApiRPC{
                DB:   db,
                ias:  &amp;ias,
                ifs:  &amp;ifs,
                cs:   &amp;cs,
                us:   &amp;us,
                iaes: &amp;iaes,
                ers: &amp;ers,
                cis:  cis,
        }
}</span>

func CreateService(srv ItemApiRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := endpointv1connect.NewEndpointServiceHandler(&amp;srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

func (c *ItemApiRPC) EndpointCreate(ctx context.Context, req *connect.Request[endpointv1.EndpointCreateRequest]) (*connect.Response[endpointv1.EndpointCreateResponse], error) <span class="cov8" title="1">{
        collectionID, err := idwrap.NewFromBytes(req.Msg.GetCollectionId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">msg := req.Msg
        endpointReq := &amp;endpointv1.Endpoint{
                Name:           msg.GetName(),
                Method:         msg.GetMethod(),
                Url:            msg.GetUrl(),
                ParentFolderId: msg.GetParentFolderId(),
                Hidden:         msg.Hidden,
        }

        itemApiReq, err := titemapi.SeralizeRPCToModelWithoutID(endpointReq, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(rcollection.CheckOwnerCollection(ctx, *c.cs, *c.us, itemApiReq.CollectionID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">if itemApiReq.FolderID != nil </span><span class="cov0" title="0">{
                rpcErr := permcheck.CheckPerm(ritemfolder.CheckOwnerFolder(ctx, *c.ifs, *c.cs, *c.us, *itemApiReq.FolderID))
                if rpcErr != nil </span><span class="cov0" title="0">{
                        return nil, rpcErr
                }</span>
        }

        <span class="cov8" title="1">ID := idwrap.NewNow()
        itemApiReq.ID = ID

        exampleNanem := "Default"
        // Always create default examples, even for hidden endpoints (needed for CollectionItemList)
        isDefault := true
        example := &amp;mitemapiexample.ItemApiExample{
                ID:           idwrap.NewNow(),
                ItemApiID:    itemApiReq.ID,
                CollectionID: itemApiReq.CollectionID,
                IsDefault:    isDefault,
                Name:         exampleNanem,
                BodyType:     mitemapiexample.BodyTypeNone,
        }

        rawBody := mbodyraw.ExampleBodyRaw{
                ID:        idwrap.NewNow(),
                ExampleID: example.ID,
        }

        // Convert legacy folder ID to collection_items folder ID if needed
        if itemApiReq.FolderID != nil </span><span class="cov0" title="0">{
                collectionItemsFolderID, err := c.cis.GetCollectionItemIDByLegacyID(ctx, *itemApiReq.FolderID)
                if err != nil </span><span class="cov0" title="0">{
                        if err == scollectionitem.ErrCollectionItemNotFound </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeNotFound, errors.New("parent folder not found"))
                        }</span>
                        <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
                }
                <span class="cov0" title="0">itemApiReq.FolderID = &amp;collectionItemsFolderID</span>
        }

        <span class="cov8" title="1">tx, err := c.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">defer devtoolsdb.TxnRollback(tx)

        // Use CollectionItemService to create endpoint with unified ordering
        err = c.cis.CreateEndpointTX(ctx, tx, itemApiReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">txIaes, err := sitemapiexample.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">txRawBodyService, err := sbodyraw.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">err = txIaes.CreateApiExample(ctx, example)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">err = txRawBodyService.CreateBodyRaw(ctx, rawBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">respRaw := &amp;endpointv1.EndpointCreateResponse{
                EndpointId: itemApiReq.ID.Bytes(),
                ExampleId:  example.ID.Bytes(),
        }

        return connect.NewResponse(respRaw), nil</span>
}

func (c *ItemApiRPC) EndpointDuplicate(ctx context.Context, req *connect.Request[endpointv1.EndpointDuplicateRequest]) (*connect.Response[endpointv1.EndpointDuplicateResponse], error) <span class="cov8" title="1">{
        apiUlid, err := idwrap.NewFromBytes(req.Msg.GetEndpointId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerApi(ctx, *c.ias, *c.cs, *c.us, apiUlid))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">api, err := c.ias.GetItemApi(ctx, apiUlid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, errors.New("failed to get api"))
        }</span>

        <span class="cov8" title="1">examples, err := c.iaes.GetApiExamples(ctx, api.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, errors.New("failed to get examples"))
        }</span>

        // Try to get default example, but don't fail if it doesn't exist
        // (for backwards compatibility with endpoints created before default examples were mandatory)
        <span class="cov8" title="1">defaultExample, err := c.iaes.GetDefaultApiExample(ctx, api.ID)
        if err == nil &amp;&amp; defaultExample != nil </span><span class="cov8" title="1">{
                examples = append(examples, *defaultExample)
        }</span>
        
        // If no examples at all (not even default), create a default example for the duplicate
        <span class="cov8" title="1">if len(examples) == 0 </span><span class="cov8" title="1">{
                newDefaultExample := mitemapiexample.ItemApiExample{
                        ID:           idwrap.NewNow(),
                        ItemApiID:    idwrap.NewNow(), // Will be updated to the new API ID below
                        CollectionID: api.CollectionID,
                        IsDefault:    true,
                        Name:         "Default",
                        BodyType:     mitemapiexample.BodyTypeNone,
                }
                examples = append(examples, newDefaultExample)
        }</span>

        <span class="cov8" title="1">api.ID = idwrap.NewNow()
        api.Name = api.Name + " Copy"

        // Apply overrides from request if provided
        if req.Msg.Hidden != nil </span><span class="cov0" title="0">{
                api.Hidden = *req.Msg.Hidden
        }</span>

        <span class="cov8" title="1">var exampleResps []mexampleresp.ExampleResp
        for i, v := range examples </span><span class="cov8" title="1">{
                resp, err := c.ers.GetExampleRespByExampleIDLatest(ctx, v.ID)
                if err != nil </span><span class="cov8" title="1">{
                        if err != sexampleresp.ErrNoRespFound </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, errors.New("failed to get example response"))
                        }</span>
                }
                <span class="cov8" title="1">examples[i].ID = idwrap.NewNow()
                examples[i].ItemApiID = api.ID
                if resp != nil </span><span class="cov0" title="0">{
                        resp.ID = idwrap.NewNow()
                        resp.ExampleID = examples[i].ID
                        exampleResps = append(exampleResps, *resp)
                }</span>
        }

        <span class="cov8" title="1">tx, err := c.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">defer devtoolsdb.TxnRollback(tx)

        iaesTX, err := sitemapiexample.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">ersTX, err := sexampleresp.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Use CollectionItemService to create endpoint with unified ordering
        // This ensures the duplicated endpoint appears in CollectionItemList
        <span class="cov8" title="1">err = c.cis.CreateEndpointTX(ctx, tx, api)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">err = iaesTX.CreateApiExampleBulk(ctx, examples)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">for _, resp := range exampleResps </span><span class="cov0" title="0">{
                err = ersTX.CreateExampleResp(ctx, resp)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Find the default example ID from the duplicated examples
        <span class="cov8" title="1">var defaultExampleID []byte
        for _, ex := range examples </span><span class="cov8" title="1">{
                if ex.IsDefault </span><span class="cov8" title="1">{
                        defaultExampleID = ex.ID.Bytes()
                        break</span>
                }
        }
        // If no default example, use the first example
        <span class="cov8" title="1">if defaultExampleID == nil &amp;&amp; len(examples) &gt; 0 </span><span class="cov0" title="0">{
                defaultExampleID = examples[0].ID.Bytes()
        }</span>

        <span class="cov8" title="1">resp := &amp;endpointv1.EndpointDuplicateResponse{
                EndpointId: api.ID.Bytes(),
                ExampleId:  defaultExampleID,
        }
        return connect.NewResponse(resp), nil</span>
}

func (c *ItemApiRPC) EndpointGet(ctx context.Context, req *connect.Request[endpointv1.EndpointGetRequest]) (*connect.Response[endpointv1.EndpointGetResponse], error) <span class="cov8" title="1">{
        apiUlid, err := idwrap.NewFromBytes(req.Msg.GetEndpointId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerApi(ctx, *c.ias, *c.cs, *c.us, apiUlid))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">api, err := c.ias.GetItemApi(ctx, apiUlid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">apiCall := titemapi.DeseralizeModelToRPC(api)
        resp := &amp;endpointv1.EndpointGetResponse{
                EndpointId: apiCall.EndpointId,
                Name:       apiCall.Name,
                Method:     apiCall.Method,
                Url:        apiCall.Url,
        }
        return connect.NewResponse(resp), nil</span>
}

func (c *ItemApiRPC) EndpointUpdate(ctx context.Context, req *connect.Request[endpointv1.EndpointUpdateRequest]) (*connect.Response[endpointv1.EndpointUpdateResponse], error) <span class="cov8" title="1">{
        endpointReq := &amp;endpointv1.Endpoint{
                EndpointId:     req.Msg.GetEndpointId(),
                ParentFolderId: req.Msg.GetParentFolderId(),
                Name:           req.Msg.GetName(),
                Method:         req.Msg.GetMethod(),
                Url:            req.Msg.GetUrl(),
        }
        apiCall, err := titemapi.SeralizeRPCToModel(endpointReq, idwrap.IDWrap{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerApi(ctx, *c.ias, *c.cs, *c.us, apiCall.ID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">if apiCall.FolderID != nil </span><span class="cov0" title="0">{
                checkfolder, err := c.ifs.GetFolder(ctx, *apiCall.FolderID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">if checkfolder.CollectionID.Compare(apiCall.CollectionID) != 0 </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodePermissionDenied, errors.New("not owner"))
                }</span>
        }

        <span class="cov8" title="1">endpoint, err := c.ias.GetItemApi(ctx, apiCall.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        /*
                examples, err := c.iaes.GetApiExamplesWithDefaults(ctx, endpoint.ID)
                if err != nil {
                        return nil, connect.NewError(connect.CodeInternal, err)
                }

                        var changes []*changev1.Change
                        if apiCall.Name != "" {
                                endpoint.Name = apiCall.Name

                                HistoryChangesService := "collection.item.example.v1"
                                HistroyChangesMethod := "ExampleGet"
                                for _, example := range examples {
                                        exampleVersionChangeKind := changev1.ChangeKind_CHANGE_KIND_INVALIDATE
                                        listRequest, err := anypb.New(&amp;examplev1.ExampleGetRequest{
                                                ExampleId: example.ID.Bytes(),
                                        })
                                        if err != nil {
                                                return nil, connect.NewError(connect.CodeInternal, err)
                                        }
                                        changes = append(changes, &amp;changev1.Change{
                                                Kind:    &amp;exampleVersionChangeKind,
                                                Data:    listRequest,
                                                Service: &amp;HistoryChangesService,
                                                Method:  &amp;HistroyChangesMethod,
                                        })

                                }
                        }
        */

        <span class="cov8" title="1">if apiCall.Method != "" </span><span class="cov8" title="1">{
                endpoint.Method = apiCall.Method
        }</span>
        <span class="cov8" title="1">if apiCall.Url != "" </span><span class="cov8" title="1">{
                endpoint.Url = apiCall.Url
        }</span>
        <span class="cov8" title="1">if apiCall.FolderID != nil </span><span class="cov0" title="0">{
                endpoint.FolderID = apiCall.FolderID
        }</span>
        <span class="cov8" title="1">if apiCall.Name != "" </span><span class="cov8" title="1">{
                endpoint.Name = apiCall.Name
        }</span>

        <span class="cov8" title="1">err = c.ias.UpdateItemApi(ctx, endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">resp := &amp;endpointv1.EndpointUpdateResponse{}

        return connect.NewResponse(resp), nil</span>
}

func (c *ItemApiRPC) EndpointDelete(ctx context.Context, req *connect.Request[endpointv1.EndpointDeleteRequest]) (*connect.Response[endpointv1.EndpointDeleteResponse], error) <span class="cov8" title="1">{
        id, err := idwrap.NewFromBytes(req.Msg.GetEndpointId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerApi(ctx, *c.ias, *c.cs, *c.us, id))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">endpoint, err := c.ias.GetItemApi(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">prev, next := endpoint.Prev, endpoint.Next
        var prevEndPointPtr, nextEndPointPtr *mitemapi.ItemApi
        if prev != nil </span><span class="cov0" title="0">{
                prevEndPointPtr, err = c.ias.GetItemApi(ctx, *prev)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, errors.New("failed to get prev"))
                }</span>
        }

        <span class="cov8" title="1">if next != nil </span><span class="cov0" title="0">{
                nextEndPointPtr, err = c.ias.GetItemApi(ctx, *next)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, errors.New("failed to get next"))
                }</span>
        }

        <span class="cov8" title="1">tx, err := c.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">defer devtoolsdb.TxnRollback(tx)

        txias, err := sitemapi.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Before deletion, update the links
        <span class="cov8" title="1">if prevEndPointPtr != nil </span><span class="cov0" title="0">{
                prevEndPointPtr.Next = endpoint.Next // Point prev's next to current's next
                err = txias.UpdateItemApiOrder(ctx, prevEndPointPtr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov8" title="1">if nextEndPointPtr != nil </span><span class="cov0" title="0">{
                nextEndPointPtr.Prev = endpoint.Prev // Point next's prev to current's prev
                err = txias.UpdateItemApiOrder(ctx, nextEndPointPtr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov8" title="1">err = txias.DeleteItemApi(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;endpointv1.EndpointDeleteResponse{}), nil</span>
}

func CheckOwnerApi(ctx context.Context, ias sitemapi.ItemApiService, cs scollection.CollectionService, us suser.UserService, apiID idwrap.IDWrap) (bool, error) <span class="cov8" title="1">{
        api, err := ias.GetItemApi(ctx, apiID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">isOwner, err := rcollection.CheckOwnerCollection(ctx, cs, us, api.CollectionID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return isOwner, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package ritemapiexample

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "sort"
        devtoolsdb "the-dev-tools/db"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/rcollection"
        "the-dev-tools/server/internal/api/ritemapi"
        "the-dev-tools/server/pkg/compress"
        "the-dev-tools/server/pkg/http/request"
        "the-dev-tools/server/pkg/http/response"
        "the-dev-tools/server/pkg/httpclient"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/logconsole"
        "the-dev-tools/server/pkg/model/massert"
        "the-dev-tools/server/pkg/model/massertres"
        "the-dev-tools/server/pkg/model/mbodyform"
        "the-dev-tools/server/pkg/model/mbodyraw"
        "the-dev-tools/server/pkg/model/mbodyurl"
        "the-dev-tools/server/pkg/model/mexampleheader"
        "the-dev-tools/server/pkg/model/mexamplequery"
        "the-dev-tools/server/pkg/model/mexampleresp"
        "the-dev-tools/server/pkg/model/mexamplerespheader"
        "the-dev-tools/server/pkg/model/mitemapiexample"
        "the-dev-tools/server/pkg/permcheck"
        "the-dev-tools/server/pkg/reference"
        "the-dev-tools/server/pkg/service/sassert"
        "the-dev-tools/server/pkg/service/sassertres"
        "the-dev-tools/server/pkg/service/sbodyform"
        "the-dev-tools/server/pkg/service/sbodyraw"
        "the-dev-tools/server/pkg/service/sbodyurl"
        "the-dev-tools/server/pkg/service/scollection"
        "the-dev-tools/server/pkg/service/senv"
        "the-dev-tools/server/pkg/service/sexampleheader"
        "the-dev-tools/server/pkg/service/sexamplequery"
        "the-dev-tools/server/pkg/service/sexampleresp"
        "the-dev-tools/server/pkg/service/sexamplerespheader"
        "the-dev-tools/server/pkg/service/sitemapi"
        "the-dev-tools/server/pkg/service/sitemapiexample"
        "the-dev-tools/server/pkg/service/sitemfolder"
        "the-dev-tools/server/pkg/service/suser"
        "the-dev-tools/server/pkg/service/svar"
        "the-dev-tools/server/pkg/service/sworkspace"
        "the-dev-tools/server/pkg/translate/tbreadcrumbs"
        "the-dev-tools/server/pkg/translate/texample"
        "the-dev-tools/server/pkg/translate/texampleresp"
        "the-dev-tools/server/pkg/translate/texampleversion"
        "the-dev-tools/server/pkg/translate/tgeneric"
        "the-dev-tools/server/pkg/varsystem"
        examplev1 "the-dev-tools/spec/dist/buf/go/collection/item/example/v1"
        "the-dev-tools/spec/dist/buf/go/collection/item/example/v1/examplev1connect"
        resourcesv1 "the-dev-tools/spec/dist/buf/go/resources/v1"

        "connectrpc.com/connect"
)

type ItemAPIExampleRPC struct {
        DB   *sql.DB
        iaes *sitemapiexample.ItemApiExampleService
        ias  *sitemapi.ItemApiService
        ifs  *sitemfolder.ItemFolderService

        ws *sworkspace.WorkspaceService
        cs *scollection.CollectionService
        us *suser.UserService
        // sub
        hs   *sexampleheader.HeaderService
        qs   *sexamplequery.ExampleQueryService
        bfs  *sbodyform.BodyFormService
        bues *sbodyurl.BodyURLEncodedService
        brs  *sbodyraw.BodyRawService
        // resp sub
        erhs *sexamplerespheader.ExampleRespHeaderService
        ers  *sexampleresp.ExampleRespService
        // env
        es senv.EnvService
        vs svar.VarService

        // assert
        as  *sassert.AssertService
        ars *sassertres.AssertResultService

        logChanMap logconsole.LogChanMap
}

func New(db *sql.DB, iaes sitemapiexample.ItemApiExampleService, ias sitemapi.ItemApiService, ifs sitemfolder.ItemFolderService,
        ws sworkspace.WorkspaceService, cs scollection.CollectionService, us suser.UserService, hs sexampleheader.HeaderService, qs sexamplequery.ExampleQueryService,
        bfs sbodyform.BodyFormService, beus sbodyurl.BodyURLEncodedService, brs sbodyraw.BodyRawService, erhs sexamplerespheader.ExampleRespHeaderService,
        ers sexampleresp.ExampleRespService, es senv.EnvService, vs svar.VarService, as sassert.AssertService, ars sassertres.AssertResultService,
        logChanMap logconsole.LogChanMap,
) ItemAPIExampleRPC <span class="cov8" title="1">{
        return ItemAPIExampleRPC{
                DB:         db,
                iaes:       &amp;iaes,
                ias:        &amp;ias,
                ifs:        &amp;ifs,
                ws:         &amp;ws,
                cs:         &amp;cs,
                us:         &amp;us,
                hs:         &amp;hs,
                qs:         &amp;qs,
                bfs:        &amp;bfs,
                bues:       &amp;beus,
                brs:        &amp;brs,
                erhs:       &amp;erhs,
                ers:        &amp;ers,
                es:         es,
                vs:         vs,
                as:         &amp;as,
                ars:        &amp;ars,
                logChanMap: logChanMap,
        }
}</span>

func CreateService(srv ItemAPIExampleRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := examplev1connect.NewExampleServiceHandler(&amp;srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

func (c *ItemAPIExampleRPC) ExampleList(ctx context.Context, req *connect.Request[examplev1.ExampleListRequest]) (*connect.Response[examplev1.ExampleListResponse], error) <span class="cov8" title="1">{
        apiUlid, err := idwrap.NewFromBytes(req.Msg.GetEndpointId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid item api id"))
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(ritemapi.CheckOwnerApi(ctx, *c.ias, *c.cs, *c.us, apiUlid))
        if rpcErr != nil </span><span class="cov8" title="1">{
                return nil, rpcErr
        }</span>

        // Auto-repair any isolated examples before returning list
        // This is defensive - we log warnings but don't fail the request
        <span class="cov8" title="1">autoLinkErr := c.iaes.AutoLinkIsolatedExamples(ctx, apiUlid)
        if autoLinkErr != nil </span><span class="cov0" title="0">{
                // Log warning but continue - this is a repair operation, not critical to the user request
                fmt.Printf("Warning: auto-linking failed for endpoint %s: %v\n", apiUlid.String(), autoLinkErr)
        }</span>

        // First try to get ordered examples (preferred)
        <span class="cov8" title="1">examples, err := c.iaes.GetApiExamplesOrdered(ctx, apiUlid)
        if err != nil </span><span class="cov0" title="0">{
                // If ordered query fails, fall back to getting all examples
                if err == sitemapiexample.ErrNoItemApiExampleFound </span><span class="cov0" title="0">{
                        // Return empty list if no examples
                        resp := &amp;examplev1.ExampleListResponse{
                                EndpointId: apiUlid.Bytes(),
                                Items:      []*examplev1.ExampleListItem{},
                        }
                        return connect.NewResponse(resp), nil
                }</span>
                
                // For other errors, try fallback to all examples
                <span class="cov0" title="0">fmt.Printf("Warning: ordered query failed for endpoint %s, falling back to all examples: %v\n", apiUlid.String(), err)
                examples, err = c.iaes.GetAllApiExamples(ctx, apiUlid)
                if err != nil </span><span class="cov0" title="0">{
                        if err == sitemapiexample.ErrNoItemApiExampleFound </span><span class="cov0" title="0">{
                                // Return empty list if no examples found in fallback
                                resp := &amp;examplev1.ExampleListResponse{
                                        EndpointId: apiUlid.Bytes(),
                                        Items:      []*examplev1.ExampleListItem{},
                                }
                                return connect.NewResponse(resp), nil
                        }</span>
                        <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("both ordered and fallback queries failed: %w", err))</span>
                }
                <span class="cov0" title="0">fmt.Printf("Successfully used fallback query for endpoint %s, returned %d examples\n", apiUlid.String(), len(examples))</span>
        }

        <span class="cov8" title="1">var respsRpc []*examplev1.ExampleListItem
        for _, example := range examples </span><span class="cov8" title="1">{
                exampleResp, err := c.ers.GetExampleRespByExampleIDLatest(ctx, example.ID)
                var exampleRespID *idwrap.IDWrap
                if err != nil </span><span class="cov8" title="1">{
                        if err != sql.ErrNoRows </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        exampleRespID = &amp;exampleResp.ID
                }</span>

                <span class="cov8" title="1">respsRpc = append(respsRpc, texample.SerializeModelToRPCItem(example, exampleRespID))</span>

        }
        <span class="cov8" title="1">resp := &amp;examplev1.ExampleListResponse{
                EndpointId: apiUlid.Bytes(),
                Items:      respsRpc,
        }

        return connect.NewResponse(resp), nil</span>
}

func (c *ItemAPIExampleRPC) ExampleGet(ctx context.Context, req *connect.Request[examplev1.ExampleGetRequest]) (*connect.Response[examplev1.ExampleGetResponse], error) <span class="cov8" title="1">{
        exampleIdWrap, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid item api id"))
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerExample(ctx, *c.iaes, *c.cs, *c.us, exampleIdWrap))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">example, err := c.iaes.GetApiExample(ctx, exampleIdWrap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">exampleBreadcrumbs, err := c.iaes.GetExampleAllParents(ctx, exampleIdWrap, *c.cs, *c.ifs, *c.ias)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // TODO: this can fail fix this
        <span class="cov8" title="1">var respIdPtr *idwrap.IDWrap
        exampleResp, err := c.ers.GetExampleRespByExampleIDLatest(ctx, exampleIdWrap)
        if err != nil &amp;&amp; err != sexampleresp.ErrNoRespFound </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">if exampleResp != nil </span><span class="cov0" title="0">{
                respIdPtr = &amp;exampleResp.ID
        }</span>

        <span class="cov8" title="1">rpcBreadcrumbs := tgeneric.MassConvert(exampleBreadcrumbs, tbreadcrumbs.SerializeModelToRPC)

        rpcExample := texample.SerializeModelToRPC(*example, respIdPtr, rpcBreadcrumbs)
        resp := &amp;examplev1.ExampleGetResponse{
                ExampleId:      rpcExample.ExampleId,
                LastResponseId: rpcExample.LastResponseId,
                Name:           rpcExample.Name,
                Breadcrumbs:    rpcExample.Breadcrumbs,
                BodyKind:       rpcExample.BodyKind,
        }
        return connect.NewResponse(resp), nil</span>
}

func (c *ItemAPIExampleRPC) ExampleCreate(ctx context.Context, req *connect.Request[examplev1.ExampleCreateRequest]) (*connect.Response[examplev1.ExampleCreateResponse], error) <span class="cov8" title="1">{
        apiIDWrap, err := idwrap.NewFromBytes(req.Msg.GetEndpointId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid item api id"))
        }</span>
        <span class="cov8" title="1">ok, err := ritemapi.CheckOwnerApi(ctx, *c.ias, *c.cs, *c.us, apiIDWrap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeNotFound, errors.New("not found api"))
        }</span>

        <span class="cov8" title="1">itemApi, err := c.ias.GetItemApi(ctx, apiIDWrap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // TODO: make this a transaction
        <span class="cov8" title="1">ExampleID := idwrap.NewNow()
        ex := &amp;mitemapiexample.ItemApiExample{
                ID:           ExampleID,
                ItemApiID:    apiIDWrap,
                CollectionID: itemApi.CollectionID,
                Name:         req.Msg.Name,
                BodyType:     mitemapiexample.BodyTypeNone,
                IsDefault:    false,
        }
        err = c.iaes.CreateApiExample(ctx, ex)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">bodyRaw := mbodyraw.ExampleBodyRaw{
                ID:            idwrap.NewNow(),
                ExampleID:     ExampleID,
                VisualizeMode: mbodyraw.VisualizeModeBinary,
                CompressType:  compress.CompressTypeNone,
                Data:          []byte{},
        }

        err = c.brs.CreateBodyRaw(ctx, bodyRaw)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // TODO: refactor changes stuff
        /*
                folderChange := itemv1.CollectionItem{
                        Kind: itemv1.ItemKind_ITEM_KIND_FOLDER,
                        Example: &amp;examplev1.ExampleListItem{
                                ExampleId: ExampleID.Bytes(),
                                Name:      req.Msg.Name,
                        },
                }

                        folderChangeAny, err := anypb.New(&amp;folderChange)
                        if err != nil {
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }

                        a := &amp;examplev1.ExampleListResponse{
                                EndpointId: ExampleID.Bytes(),
                        }

                        changeAny, err := anypb.New(a)
                        if err != nil {
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }
        */

        /*
                changeKind := changev1.ListChangeKind_LIST_CHANGE_KIND_APPEND

                listChanges := []*changev1.ListChange{
                        {
                                Kind:   changeKind,
                                Parent: changeAny,
                        },
                }

                kind := changev1.ChangeKind_CHANGE_KIND_UNSPECIFIED
                change := &amp;changev1.Change{
                        Kind: &amp;kind,
                        List: listChanges,
                        Data: folderChangeAny,
                }

                changes := []*changev1.Change{
                        change,
                }
        */

        <span class="cov8" title="1">return connect.NewResponse(&amp;examplev1.ExampleCreateResponse{
                ExampleId: ExampleID.Bytes(),
        }), nil</span>
}

func (c *ItemAPIExampleRPC) ExampleUpdate(ctx context.Context, req *connect.Request[examplev1.ExampleUpdateRequest]) (*connect.Response[examplev1.ExampleUpdateResponse], error) <span class="cov8" title="1">{

        exampleIDWrap, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid item api id"))
        }</span>

        <span class="cov8" title="1">isMember, err := CheckOwnerExample(ctx, *c.iaes, *c.cs, *c.us, exampleIDWrap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">if !isMember </span><span class="cov0" title="0">{
                // return not found
                return nil, connect.NewError(connect.CodeNotFound, errors.New("not found example"))
        }</span>

        <span class="cov8" title="1">dbExample, err := c.iaes.GetApiExample(ctx, exampleIDWrap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // var changes []*changev1.Change

        <span class="cov8" title="1">var updateChange bool
        exRPC := req.Msg
        if exRPC.Name != nil </span><span class="cov8" title="1">{
                dbExample.Name = *exRPC.Name
                updateChange = true

                /*
                        folderChange := itemv1.CollectionItem{
                                Kind: itemv1.ItemKind_ITEM_KIND_FOLDER,
                                Example: &amp;examplev1.ExampleListItem{
                                        Name: dbExample.Name,
                                },
                        }

                                folderChangeAny, err := anypb.New(&amp;folderChange)
                                if err != nil {
                                        return nil, connect.NewError(connect.CodeInternal, err)
                                }

                                        kind := changev1.ChangeKind_CHANGE_KIND_UPDATE
                                        normalizationChange := &amp;changev1.Change{
                                                Kind: &amp;kind,
                                                Data: folderChangeAny,
                                        }
                                        changes = append(changes, normalizationChange)
                */
        }</span>
        <span class="cov8" title="1">if exRPC.BodyKind != nil </span><span class="cov8" title="1">{
                dbExample.BodyType = mitemapiexample.BodyType(*exRPC.BodyKind)
                updateChange = true
        }</span>

        <span class="cov8" title="1">if !updateChange </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("all fields are null"))
        }</span>

        <span class="cov8" title="1">err = c.iaes.UpdateItemApiExample(ctx, dbExample)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;examplev1.ExampleUpdateResponse{}), nil</span>
}

func (c *ItemAPIExampleRPC) ExampleDelete(ctx context.Context, req *connect.Request[examplev1.ExampleDeleteRequest]) (*connect.Response[examplev1.ExampleDeleteResponse], error) <span class="cov8" title="1">{
        exampleUlid, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid item api id"))
        }</span>

        <span class="cov8" title="1">isMember, err := CheckOwnerExample(ctx, *c.iaes, *c.cs, *c.us, exampleUlid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">if !isMember </span><span class="cov0" title="0">{
                // return not found
                return nil, connect.NewError(connect.CodeNotFound, errors.New("not found example"))
        }</span>

        <span class="cov8" title="1">example, err := c.iaes.GetApiExample(ctx, exampleUlid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">prevID, nextID := example.Prev, example.Next
        var prevExamplePtr, nextExamplePtr *mitemapiexample.ItemApiExample
        if prevID != nil </span><span class="cov0" title="0">{
                prevExamplePtr, err = c.iaes.GetApiExample(ctx, *prevID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }
        <span class="cov8" title="1">if nextID != nil </span><span class="cov0" title="0">{
                nextExamplePtr, err = c.iaes.GetApiExample(ctx, *nextID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov8" title="1">tx, err := c.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">defer devtoolsdb.TxnRollback(tx)

        txIfs, err := sitemapiexample.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">if prevExamplePtr != nil </span><span class="cov0" title="0">{
                err = txIfs.UpdateItemApiExampleOrder(ctx, prevExamplePtr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }
        <span class="cov8" title="1">if nextExamplePtr != nil </span><span class="cov0" title="0">{
                err = txIfs.UpdateItemApiExampleOrder(ctx, nextExamplePtr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov8" title="1">err = txIfs.DeleteApiExample(ctx, exampleUlid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        /*

                a := &amp;examplev1.ExampleChange{
                        ExampleId: exampleUlid.Bytes(),
                }

                changeAny, err := anypb.New(a)
                if err != nil {
                        return nil, connect.NewError(connect.CodeInternal, err)
                }

                changeKind := changev1.ChangeKind_CHANGE_KIND_DELETE

                changes := []*changev1.Change{
                        {
                                Kind: &amp;changeKind,
                                Data: changeAny,
                        },
                }
        */

        <span class="cov8" title="1">resp := &amp;examplev1.ExampleDeleteResponse{}

        return connect.NewResponse(resp), nil</span>
}

func (c *ItemAPIExampleRPC) ExampleDuplicate(ctx context.Context, req *connect.Request[examplev1.ExampleDuplicateRequest]) (*connect.Response[examplev1.ExampleDuplicateResponse], error) <span class="cov0" title="0">{
        exampleUlid, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid item api id"))
        }</span>

        <span class="cov0" title="0">isMember, err := CheckOwnerExample(ctx, *c.iaes, *c.cs, *c.us, exampleUlid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">if !isMember </span><span class="cov0" title="0">{
                // return not found
                return nil, connect.NewError(connect.CodeNotFound, errors.New("not found example"))
        }</span>

        <span class="cov0" title="0">example, err := c.iaes.GetApiExample(ctx, exampleUlid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">res, err := PrepareCopyExample(ctx, example.ItemApiID, *example, *c.hs, *c.qs, *c.brs, *c.bfs, *c.bues, *c.ers, *c.erhs, *c.as, *c.ars)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">exampleIDBytes := res.Example.ID.Bytes()
        //        exampleName := res.Example.Name
        tx, err := c.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        <span class="cov0" title="0">err = CreateCopyExample(ctx, tx, res)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        /*

                // TODO: refactor changes stuff
                folderChange := itemv1.CollectionItem{
                        Kind: itemv1.ItemKind_ITEM_KIND_FOLDER,
                        Example: &amp;examplev1.ExampleListItem{
                                ExampleId: exampleIDBytes,
                                Name:      exampleName,
                        },
                }

                folderChangeAny, err := anypb.New(&amp;folderChange)
                if err != nil {
                        return nil, connect.NewError(connect.CodeInternal, err)
                }

                a := &amp;examplev1.ExampleListResponse{
                        EndpointId: exampleIDBytes,
                }

                changeAny, err := anypb.New(a)
                if err != nil {
                        return nil, connect.NewError(connect.CodeInternal, err)
                }

                changeKind := changev1.ListChangeKind_LIST_CHANGE_KIND_APPEND

                listChanges := []*changev1.ListChange{
                        {
                                Kind:   changeKind,
                                Parent: changeAny,
                        },
                }

                kind := changev1.ChangeKind_CHANGE_KIND_UNSPECIFIED
                change := &amp;changev1.Change{
                        Kind: &amp;kind,
                        List: listChanges,
                        Data: folderChangeAny,
                }

                changes := []*changev1.Change{
                        change,
                }
        */

        <span class="cov0" title="0">resp := &amp;examplev1.ExampleDuplicateResponse{
                ExampleId: exampleIDBytes,
        }

        return connect.NewResponse(resp), nil</span>
}

type ExampleRunLog struct {
        Request  request.RequestResponseVar `json:"request"`
        Response httpclient.ResponseVar     `json:"response"`
}

func (c *ItemAPIExampleRPC) ExampleRun(ctx context.Context, req *connect.Request[examplev1.ExampleRunRequest]) (*connect.Response[examplev1.ExampleRunResponse], error) <span class="cov0" title="0">{
        exampleUlid, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">if rpcErr := permcheck.CheckPerm(CheckOwnerExample(ctx, *c.iaes, *c.cs, *c.us, exampleUlid)); rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">example, err := c.iaes.GetApiExample(ctx, exampleUlid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">itemApiCall, err := c.ias.GetItemApi(ctx, example.ItemApiID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">reqQueries, err := c.qs.GetExampleQueriesByExampleID(ctx, exampleUlid)
        if err != nil &amp;&amp; err != sexamplequery.ErrNoQueryFound </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">collection, err := c.cs.GetCollection(ctx, example.CollectionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">workspaceID := collection.WorkspaceID

        workspace, err := c.ws.Get(ctx, workspaceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">selectedEnv, err := c.es.Get(ctx, workspace.ActiveEnv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">globalEnv, err := c.es.Get(ctx, workspace.GlobalEnv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">var varMap *varsystem.VarMap
        if selectedEnv != nil </span><span class="cov0" title="0">{
                currentVars, err := c.vs.GetVariableByEnvID(ctx, selectedEnv.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">globalVars, err := c.vs.GetVariableByEnvID(ctx, globalEnv.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">tempVarMap := varsystem.NewVarMap(varsystem.MergeVars(globalVars, currentVars))
                varMap = &amp;tempVarMap</span>
        }

        <span class="cov0" title="0">if varsystem.CheckStringHasAnyVarKey(itemApiCall.Url) </span><span class="cov0" title="0">{
                itemApiCall.Url, err = varMap.ReplaceVars(itemApiCall.Url)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
        }

        <span class="cov0" title="0">reqHeaders, err := c.hs.GetHeaderByExampleID(ctx, exampleUlid)
        if err != nil &amp;&amp; err != sexampleheader.ErrNoHeaderFound </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">rawBody, err := c.brs.GetBodyRawByExampleID(ctx, exampleUlid)
        if err != nil </span><span class="cov0" title="0">{
                if err == sbodyraw.ErrNoBodyRawFound </span><span class="cov0" title="0">{

                        tempBodyRaw := mbodyraw.ExampleBodyRaw{
                                ID:            idwrap.NewNow(),
                                ExampleID:     exampleUlid,
                                VisualizeMode: mbodyraw.VisualizeModeBinary,
                                CompressType:  compress.CompressTypeNone,
                                Data:          []byte{},
                        }

                        err = c.brs.CreateBodyRaw(ctx, tempBodyRaw)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>
                        <span class="cov0" title="0">rawBody = &amp;tempBodyRaw</span>
                } else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">formBody, err := c.bfs.GetBodyFormsByExampleID(ctx, exampleUlid)
        if err != nil </span><span class="cov0" title="0">{
                if err == sbodyform.ErrNoBodyFormFound </span><span class="cov0" title="0">{
                        formBody = []mbodyform.BodyForm{}
                }</span> else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">urlBody, err := c.bues.GetBodyURLEncodedByExampleID(ctx, exampleUlid)
        if err != nil </span><span class="cov0" title="0">{
                if err == sbodyurl.ErrNoBodyUrlEncodedFound </span><span class="cov0" title="0">{
                        urlBody = []mbodyurl.BodyURLEncoded{}
                }</span> else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">client := httpclient.New()
        preparedRequest, err := request.PrepareRequest(*itemApiCall, *example, reqQueries, reqHeaders, *rawBody, formBody, urlBody, *varMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to prepare request: %w", err)
        }</span>

        <span class="cov0" title="0">requestResp, err := request.SendRequest(preparedRequest, example.ID, client)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>

        // TODO: simplify this package deps
        <span class="cov0" title="0">exampleRunLog := ExampleRunLog{
                Request:  request.ConvertRequestToVar(preparedRequest),
                Response: httpclient.ConvertResponseToVar(requestResp.HttpResp),
        }

        ref := reference.NewReferenceFromInterfaceWithKey(exampleRunLog, example.Name)
        refs := []reference.ReferenceTreeItem{ref}

        err = c.logChanMap.SendMsgToUserWithContext(ctx, idwrap.NewNow(), fmt.Sprintf("Request %s:%s", example.Name, example.ID.String()), logconsole.LogLevelUnspecified, refs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>

        <span class="cov0" title="0">exampleResp := mexampleresp.ExampleResp{
                ID:        idwrap.NewNow(),
                ExampleID: exampleUlid,
        }

        if err := c.ers.CreateExampleResp(ctx, exampleResp); err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">currentRespHeaders, err := c.erhs.GetHeaderByRespID(ctx, exampleResp.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">assertions, err := c.as.GetAssertByExampleID(ctx, example.ID)
        if err != nil &amp;&amp; err != sassert.ErrNoAssertFound </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">responseOutput, err := response.ResponseCreate(ctx, *requestResp, exampleResp, currentRespHeaders, assertions, *varMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">exampleResp = responseOutput.ExampleResp

        err = c.ers.UpdateExampleResp(ctx, responseOutput.ExampleResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // var assertResults []massertres.AssertResult
        // for _, assertion := range responseOutput.AssertCouples {
        //         assertResults = append(assertResults, assertion.AssertRes)
        // }

        <span class="cov0" title="0">taskCreateHeaders := responseOutput.CreateHeaders
        taskUpdateHeaders := responseOutput.UpdateHeaders
        taskDeleteHeaders := responseOutput.DeleteHeaderIds

        fullHeaders := append(taskCreateHeaders, taskUpdateHeaders...)
        if len(fullHeaders) &gt; 0 || len(taskDeleteHeaders) &gt; 0 </span><span class="cov0" title="0">{
                tx, err := c.DB.Begin()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">erhsTx, err := sexamplerespheader.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">if len(taskCreateHeaders) &gt; 0 </span><span class="cov0" title="0">{
                        if err := erhsTx.CreateExampleRespHeaderBulk(ctx, taskCreateHeaders); err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>
                }
                <span class="cov0" title="0">if len(taskUpdateHeaders) &gt; 0 </span><span class="cov0" title="0">{
                        if err := erhsTx.UpdateExampleRespHeaderBulk(ctx, taskUpdateHeaders); err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>
                }
                <span class="cov0" title="0">if len(taskDeleteHeaders) &gt; 0 </span><span class="cov0" title="0">{
                        if err := erhsTx.DeleteExampleRespHeaderBulk(ctx, taskDeleteHeaders); err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>
                }
                <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov0" title="0">for _, assertionCouple := range responseOutput.AssertCouples </span><span class="cov0" title="0">{
                if _, err := c.ars.GetAssertResult(ctx, assertionCouple.AssertRes.ID); err != nil </span><span class="cov0" title="0">{
                        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                                if err := c.ars.CreateAssertResult(ctx, assertionCouple.AssertRes); err != nil </span><span class="cov0" title="0">{
                                        return nil, connect.NewError(connect.CodeInternal, err)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        if err := c.ars.UpdateAssertResult(ctx, assertionCouple.AssertRes); err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>
                }
        }

        // Copy Full Item Api/Endpoint
        // TODO: make this transaction
        <span class="cov0" title="0">endpoint, err := c.ias.GetItemApi(ctx, example.ItemApiID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">endpoint.VersionParentID = &amp;endpoint.ID
        endpointNewID := idwrap.NewNow()
        endpoint.ID = endpointNewID

        err = c.ias.CreateItemApi(ctx, endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, errors.New("failed to copy endpoint"))
        }</span>

        // exampleVersionID := example.ID
        <span class="cov0" title="0">example.VersionParentID = &amp;example.ID

        res, err := PrepareCopyExample(ctx, endpointNewID, *example, *c.hs, *c.qs, *c.brs, *c.bfs, *c.bues, *c.ers, *c.erhs, *c.as, *c.ars)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to copy example: %w", err))
        }</span>

        <span class="cov0" title="0">tx, err := c.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = CreateCopyExample(ctx, tx, res)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to copy example: %w", err))
        }</span>

        <span class="cov0" title="0">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">rpcResponseGet, err := texampleresp.SeralizeModelToRPCGetResponse(exampleResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;examplev1.ExampleRunResponse{
                Response: rpcResponseGet,
                Version:  texampleversion.ModelToRPC(*example, &amp;res.Resp.ID),
        }), nil</span>
}

type CopyExampleResult struct {
        Example        mitemapiexample.ItemApiExample
        Headers        []mexampleheader.Header
        Queries        []mexamplequery.Query
        BodyRaw        *mbodyraw.ExampleBodyRaw
        BodyForms      []mbodyform.BodyForm
        BodyURLEncoded []mbodyurl.BodyURLEncoded
        Assertions     []massert.Assert

        // Resp
        Resp        mexampleresp.ExampleResp
        RespHeaders []mexamplerespheader.ExampleRespHeader
        RespAsserts []massertres.AssertResult
}

func PrepareCopyExample(ctx context.Context, itemApi idwrap.IDWrap, example mitemapiexample.ItemApiExample,
        hs sexampleheader.HeaderService, qs sexamplequery.ExampleQueryService,
        brs sbodyraw.BodyRawService, bfs sbodyform.BodyFormService, bues sbodyurl.BodyURLEncodedService,
        ers sexampleresp.ExampleRespService, erhs sexamplerespheader.ExampleRespHeaderService,
        as sassert.AssertService, ars sassertres.AssertResultService,
) (CopyExampleResult, error) <span class="cov8" title="1">{
        result := CopyExampleResult{}
        example.IsDefault = false

        // Prepare new example
        exampleIDWrapNew := idwrap.NewNow()
        newExample := example
        newExample.Name = fmt.Sprintf("%s - Copy", example.Name)
        newExample.ID = exampleIDWrapNew
        newExample.ItemApiID = itemApi
        result.Example = newExample

        // Prepare headers copy
        headers, err := hs.GetHeaderByExampleID(ctx, example.ID)
        if err != nil &amp;&amp; err != sexampleheader.ErrNoHeaderFound </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov8" title="1">for _, header := range headers </span><span class="cov8" title="1">{
                newHeader := header
                newHeader.ID = idwrap.NewNow()
                newHeader.ExampleID = exampleIDWrapNew
                result.Headers = append(result.Headers, newHeader)
        }</span>

        // Prepare queries copy
        <span class="cov8" title="1">queries, err := qs.GetExampleQueriesByExampleID(ctx, example.ID)
        if err != nil &amp;&amp; err != sexamplequery.ErrNoQueryFound </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov8" title="1">for _, query := range queries </span><span class="cov0" title="0">{
                newQuery := query
                newQuery.ID = idwrap.NewNow()
                newQuery.ExampleID = exampleIDWrapNew
                result.Queries = append(result.Queries, newQuery)
        }</span>

        // Prepare body copy based on type
        <span class="cov8" title="1">switch example.BodyType </span>{
        case mitemapiexample.BodyTypeRaw:<span class="cov8" title="1">
                bodyRaw, err := brs.GetBodyRawByExampleID(ctx, example.ID)
                if err != nil &amp;&amp; err != sbodyraw.ErrNoBodyRawFound </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov8" title="1">if bodyRaw != nil </span><span class="cov0" title="0">{
                        newBodyRaw := *bodyRaw
                        newBodyRaw.ID = idwrap.NewNow()
                        newBodyRaw.ExampleID = exampleIDWrapNew
                        result.BodyRaw = &amp;newBodyRaw
                }</span>

        case mitemapiexample.BodyTypeForm:<span class="cov0" title="0">
                forms, err := bfs.GetBodyFormsByExampleID(ctx, example.ID)
                if err != nil &amp;&amp; err != sbodyform.ErrNoBodyFormFound </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">for _, form := range forms </span><span class="cov0" title="0">{
                        newForm := form
                        newForm.ID = idwrap.NewNow()
                        newForm.ExampleID = exampleIDWrapNew
                        result.BodyForms = append(result.BodyForms, newForm)
                }</span>

        case mitemapiexample.BodyTypeUrlencoded:<span class="cov0" title="0">
                urlEncoded, err := bues.GetBodyURLEncodedByExampleID(ctx, example.ID)
                if err != nil &amp;&amp; err != sbodyurl.ErrNoBodyUrlEncodedFound </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">for _, encoded := range urlEncoded </span><span class="cov0" title="0">{
                        newEncoded := encoded
                        newEncoded.ID = idwrap.NewNow()
                        newEncoded.ExampleID = exampleIDWrapNew
                        result.BodyURLEncoded = append(result.BodyURLEncoded, newEncoded)
                }</span>
        }

        // Prepare assertions copy
        <span class="cov8" title="1">assertions, err := as.GetAssertByExampleID(ctx, example.ID)
        if err != nil &amp;&amp; err != sassert.ErrNoAssertFound </span><span class="cov0" title="0">{
                return result, err
        }</span>
        <span class="cov8" title="1">for i := range assertions </span><span class="cov0" title="0">{
                assertions[i].ID = idwrap.NewNow()
                assertions[i].ExampleID = exampleIDWrapNew
        }</span>
        <span class="cov8" title="1">result.Assertions = assertions

        resp, err := ers.GetExampleRespByExampleIDLatest(ctx, example.ID)
        if err != nil &amp;&amp; err != sexampleresp.ErrNoRespFound </span><span class="cov0" title="0">{
                return result, err
        }</span>

        <span class="cov8" title="1">if resp != nil </span><span class="cov0" title="0">{
                resp.ExampleID = exampleIDWrapNew
                oldRespID := resp.ID
                resp.ID = idwrap.NewNow()
                result.Resp = *resp

                respHeaders, err := erhs.GetHeaderByRespID(ctx, oldRespID)
                if err != nil &amp;&amp; err != sexamplerespheader.ErrNoRespHeaderFound </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">for i := range respHeaders </span><span class="cov0" title="0">{
                        respHeaders[i].ID = idwrap.NewNow()
                        respHeaders[i].ExampleRespID = resp.ID
                }</span>

                <span class="cov0" title="0">result.RespHeaders = respHeaders

                assertResp, err := ars.GetAssertResultsByResponseID(ctx, oldRespID)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>

                <span class="cov0" title="0">for i := range assertResp </span><span class="cov0" title="0">{
                        assertResp[i].ID = idwrap.NewNow()
                        assertResp[i].ResponseID = resp.ID
                }</span>

                <span class="cov0" title="0">result.RespAsserts = assertResp</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// Changes
/*
func createChangeResponse(exampleResp *mexampleresp.ExampleResp) (*responsev1.ResponseChange, error) {
        changeStatus := int32(exampleResp.Status)
        size := int32(len(exampleResp.Body))

        return &amp;responsev1.ResponseChange{
                ResponseId: exampleResp.ID.Bytes(),
                Status:     &amp;changeStatus,
                Body:       exampleResp.Body,
                Time:       timestamppb.New(time.Now()),
                Duration:   &amp;exampleResp.Duration,
                Size:       &amp;size,
        }, nil
}
*/

// func createAssertResponse(exampleResp *mexampleresp.ExampleResp, assertions []massert.Assert, resultArr []massertres.AssertResult) (*responsev1.ResponseAssertListResponse, error) {
//         response := &amp;responsev1.ResponseAssertListResponse{
//                 ResponseId: exampleResp.ID.Bytes(),
//                 Items:      make([]*responsev1.ResponseAssertListItem, len(assertions)),
//         }

//         for i := range assertions {
//                 rpcAssert, err := tassert.SerializeAssertModelToRPC(assertions[i])
//                 if err != nil {
//                         return nil, err
//                 }
//                 response.Items[i] = &amp;responsev1.ResponseAssertListItem{
//                         Assert: rpcAssert,
//                         Result: resultArr[i].Result,
//                 }
//         }
//         return response, nil
// }

func PrepareCopyExampleNoService(ctx context.Context, itemApi idwrap.IDWrap, example mitemapiexample.ItemApiExample,
        queries []mexamplequery.Query, headers []mexampleheader.Header, assertions []massert.Assert,
        bodyRaw *mbodyraw.ExampleBodyRaw, bodyForm []mbodyform.BodyForm, bodyUrl []mbodyurl.BodyURLEncoded,
        resp *mexampleresp.ExampleResp, respHeaders []mexamplerespheader.ExampleRespHeader, assertResp []massertres.AssertResult,
) (CopyExampleResult, error) <span class="cov0" title="0">{
        result := CopyExampleResult{}
        example.IsDefault = false

        // Prepare new example
        exampleIDWrapNew := idwrap.NewNow()
        newExample := example
        newExample.Name = fmt.Sprintf("%s - Copy", example.Name)
        newExample.ID = exampleIDWrapNew
        newExample.ItemApiID = itemApi
        result.Example = newExample

        // Prepare headers copy
        for _, header := range headers </span><span class="cov0" title="0">{
                newHeader := header
                newHeader.ID = idwrap.NewNow()
                newHeader.ExampleID = exampleIDWrapNew
                result.Headers = append(result.Headers, newHeader)
        }</span>

        // Prepare queries copy
        <span class="cov0" title="0">for _, query := range queries </span><span class="cov0" title="0">{
                newQuery := query
                newQuery.ID = idwrap.NewNow()
                newQuery.ExampleID = exampleIDWrapNew
                result.Queries = append(result.Queries, newQuery)
        }</span>

        // Prepare body copy based on type
        <span class="cov0" title="0">switch example.BodyType </span>{
        case mitemapiexample.BodyTypeRaw:<span class="cov0" title="0">
                if bodyRaw != nil </span><span class="cov0" title="0">{
                        newBodyRaw := *bodyRaw
                        newBodyRaw.ID = idwrap.NewNow()
                        newBodyRaw.ExampleID = exampleIDWrapNew
                        result.BodyRaw = &amp;newBodyRaw
                }</span>

        case mitemapiexample.BodyTypeForm:<span class="cov0" title="0">
                for _, form := range bodyForm </span><span class="cov0" title="0">{
                        newForm := form
                        newForm.ID = idwrap.NewNow()
                        newForm.ExampleID = exampleIDWrapNew
                        result.BodyForms = append(result.BodyForms, newForm)
                }</span>

        case mitemapiexample.BodyTypeUrlencoded:<span class="cov0" title="0">
                for _, encoded := range bodyUrl </span><span class="cov0" title="0">{
                        newEncoded := encoded
                        newEncoded.ID = idwrap.NewNow()
                        newEncoded.ExampleID = exampleIDWrapNew
                        result.BodyURLEncoded = append(result.BodyURLEncoded, newEncoded)
                }</span>
        }

        // Prepare assertions copy
        <span class="cov0" title="0">for i := range assertions </span><span class="cov0" title="0">{
                assertions[i].ID = idwrap.NewNow()
                assertions[i].ExampleID = exampleIDWrapNew
        }</span>
        <span class="cov0" title="0">result.Assertions = assertions

        if resp != nil </span><span class="cov0" title="0">{
                resp.ExampleID = exampleIDWrapNew
                resp.ID = idwrap.NewNow()
                result.Resp = *resp

                for i := range respHeaders </span><span class="cov0" title="0">{
                        respHeaders[i].ID = idwrap.NewNow()
                        respHeaders[i].ExampleRespID = resp.ID
                }</span>

                <span class="cov0" title="0">result.RespHeaders = respHeaders

                for i := range assertResp </span><span class="cov0" title="0">{
                        assertResp[i].ID = idwrap.NewNow()
                        assertResp[i].ResponseID = resp.ID
                }</span>

                <span class="cov0" title="0">result.RespAsserts = assertResp</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

/*
func createHeaderResponse(exampleResp *mexampleresp.ExampleResp, headers []mexamplerespheader.ExampleRespHeader) *responsev1.ResponseHeaderListResponse {
        response := &amp;responsev1.ResponseHeaderListResponse{
                ResponseId: exampleResp.ID.Bytes(),
                Items:      make([]*responsev1.ResponseHeaderListItem, 0),
        }

        slices.SortStableFunc(headers, func(i, j mexamplerespheader.ExampleRespHeader) int {
                return strings.Compare(i.HeaderKey, j.HeaderKey)
        })

        for _, header := range headers {
                response.Items = append(response.Items, &amp;responsev1.ResponseHeaderListItem{
                        ResponseHeaderId: header.ID.Bytes(),
                        Key:              header.HeaderKey,
                        Value:            header.Value,
                })
        }
        return response
}
*/

/*
func createChange(data proto.Message, kind changev1.ChangeKind) (*changev1.Change, error) {
        anyData, err := anypb.New(data)
        if err != nil {
                return nil, err
        }
        return &amp;changev1.Change{
                Kind: &amp;kind,
                Data: anyData,
        }, nil
}
*/

/*
func HandleResponseUpdate(exampleResp *mexampleresp.ExampleResp, assertions []massert.Assert, resultArr []massertres.AssertResult, headers []mexamplerespheader.ExampleRespHeader) ([]*changev1.Change, error) {
        // Create and add change response
        changeResp, err := createChangeResponse(exampleResp)
        if err != nil {
                return nil, connect.NewError(connect.CodeInternal, err)
        }
        change, err := createChange(changeResp, changev1.ChangeKind_CHANGE_KIND_UPDATE)
        if err != nil {
                return nil, connect.NewError(connect.CodeInternal, err)
        }

        // Create and add assert response
        assertResp, err := createAssertResponse(exampleResp, assertions, resultArr)
        if err != nil {
                return nil, connect.NewError(connect.CodeInternal, err)
        }
        assertChange, err := createChange(assertResp, changev1.ChangeKind_CHANGE_KIND_UPDATE)
        if err != nil {
                return nil, connect.NewError(connect.CodeInternal, err)
        }

        // Create and add header response
        headerResp := createHeaderResponse(exampleResp, headers)
        headerChange, err := createChange(headerResp, changev1.ChangeKind_CHANGE_KIND_UPDATE)
        if err != nil {
                return nil, connect.NewError(connect.CodeInternal, err)
        }

        return []*changev1.Change{change, assertChange, headerChange}, nil
}

func HandleResponseCreate(exampleID, exampleRespID idwrap.IDWrap) ([]*changev1.Change, error) {
        exampleChange := &amp;examplev1.ExampleChange{
                ExampleId:      exampleID.Bytes(),
                LastResponseId: exampleRespID.Bytes(),
        }

        createExampleChange, err := createChange(exampleChange, changev1.ChangeKind_CHANGE_KIND_UPDATE)
        if err != nil {
                return nil, connect.NewError(connect.CodeInternal, err)
        }

        return []*changev1.Change{createExampleChange}, nil
}
*/

// TODO: make this transaction
func CreateCopyExample(ctx context.Context, tx *sql.Tx, result CopyExampleResult) error <span class="cov0" title="0">{
        // Create the main example
        txIaes, err := sitemapiexample.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create example service: %w", err)
        }</span>
        <span class="cov0" title="0">err = txIaes.CreateApiExample(ctx, &amp;result.Example)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create example with ID %s: %w", result.Example.ID.String(), err)
        }</span>

        // Create headers
        <span class="cov0" title="0">txehs, err := sexampleheader.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = txehs.AppendBulkHeader(ctx, result.Headers)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create header: %w", err)
        }</span>

        <span class="cov0" title="0">if len(result.Queries) &gt; 0 </span><span class="cov0" title="0">{
                txQs, err := sexamplequery.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">err = txQs.CreateBulkQuery(ctx, result.Queries)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Create body based on type
        <span class="cov0" title="0">switch result.Example.BodyType </span>{
        case mitemapiexample.BodyTypeRaw:<span class="cov0" title="0">
                if result.BodyRaw != nil </span><span class="cov0" title="0">{
                        txBrs, err := sbodyraw.NewTX(ctx, tx)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create body raw: %w", err)
                        }</span>
                        <span class="cov0" title="0">err = txBrs.CreateBodyRaw(ctx, *result.BodyRaw)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create body raw: %w", err)
                        }</span>
                }
        case mitemapiexample.BodyTypeForm:<span class="cov0" title="0">
                txBfs, err := sbodyform.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create body form: %w", err)
                }</span>
                <span class="cov0" title="0">err = txBfs.CreateBulkBodyForm(ctx, result.BodyForms)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create body form: %w", err)
                }</span>

        case mitemapiexample.BodyTypeUrlencoded:<span class="cov0" title="0">
                txBues, err := sbodyurl.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create body url encoded: %w", err)
                }</span>
                <span class="cov0" title="0">err = txBues.CreateBulkBodyURLEncoded(ctx, result.BodyURLEncoded)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create body url encoded: %w", err)
                }</span>
        }

        // Create assertions
        <span class="cov0" title="0">txAs, err := sassert.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create assertion: %w", err)
        }</span>
        <span class="cov0" title="0">err = txAs.CreateAssertBulk(ctx, result.Assertions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create assertion: %w", err)
        }</span>

        // Only create response if there was one to copy
        // Check if the Resp has a valid ID (meaning it was populated from an existing response)
        <span class="cov0" title="0">if result.Resp.ID != (idwrap.IDWrap{}) &amp;&amp; result.Resp.ExampleID != (idwrap.IDWrap{}) </span><span class="cov0" title="0">{
                txErs, err := sexampleresp.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create example response service: %w", err)
                }</span>
                <span class="cov0" title="0">err = txErs.CreateExampleResp(ctx, result.Resp)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create example response (ID: %s, ExampleID: %s): %w", 
                                result.Resp.ID.String(), result.Resp.ExampleID.String(), err)
                }</span>
        }

        <span class="cov0" title="0">txErhs, err := sexamplerespheader.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create example response header: %w", err)
        }</span>
        <span class="cov0" title="0">err = txErhs.CreateExampleRespHeaderBulk(ctx, result.RespHeaders)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create example response header: %w", err)
        }</span>

        <span class="cov0" title="0">txArs, err := sassertres.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create assert result: %w", err)
        }</span>
        <span class="cov0" title="0">err = txArs.CreateAssertResultBulk(ctx, result.RespAsserts)
        return err</span>
}

func (c *ItemAPIExampleRPC) ExampleVersions(ctx context.Context, req *connect.Request[examplev1.ExampleVersionsRequest]) (*connect.Response[examplev1.ExampleVersionsResponse], error) <span class="cov0" title="0">{
        versionParentID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid item api id"))
        }</span>

        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(CheckOwnerExample(ctx, *c.iaes, *c.cs, *c.us, versionParentID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">exampleVersionItems, err := c.GetVersion(ctx, versionParentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := &amp;examplev1.ExampleVersionsResponse{
                ExampleId: req.Msg.GetExampleId(),
                Items:     exampleVersionItems,
        }

        return connect.NewResponse(resp), nil</span>
}

func (c *ItemAPIExampleRPC) GetVersion(ctx context.Context, versionParentID idwrap.IDWrap) ([]*examplev1.ExampleVersionsItem, error) <span class="cov0" title="0">{
        examples, err := c.iaes.GetApiExampleByVersionParentID(ctx, versionParentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // sort by created at
        <span class="cov0" title="0">sort.Slice(examples, func(i, j int) bool </span><span class="cov0" title="0">{
                return examples[i].ID.Compare(examples[j].ID) &gt; 0
        }</span>)
        <span class="cov0" title="0">items := make([]*examplev1.ExampleVersionsItem, len(examples))

        for i, example := range examples </span><span class="cov0" title="0">{
                a := &amp;examplev1.ExampleVersionsItem{}
                items[i] = a

                a.ExampleId = example.ID.Bytes()
                resp, err := c.ers.GetExampleRespByExampleIDLatest(ctx, example.ID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">a.LastResponseId = resp.ID.Bytes()</span>
        }

        <span class="cov0" title="0">return items, nil</span>
}

func CheckOwnerExample(ctx context.Context, iaes sitemapiexample.ItemApiExampleService, cs scollection.CollectionService, us suser.UserService, exampleUlid idwrap.IDWrap) (bool, error) <span class="cov8" title="1">{
        example, err := iaes.GetApiExample(ctx, exampleUlid)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        // INFO: this mean that workspace not belong to user
                        // So for avoid information leakage, we should return not found
                        err = connect.NewError(connect.CodeNotFound, errors.New("example not found"))
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov8" title="1">return rcollection.CheckOwnerCollection(ctx, cs, us, example.CollectionID)</span>
}

func (c *ItemAPIExampleRPC) ExampleMove(ctx context.Context, req *connect.Request[examplev1.ExampleMoveRequest]) (*connect.Response[examplev1.ExampleMoveResponse], error) <span class="cov8" title="1">{
        // 1. Parameter Validation
        endpointID, err := idwrap.NewFromBytes(req.Msg.GetEndpointId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid endpoint ID"))
        }</span>

        <span class="cov8" title="1">exampleID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid example ID"))
        }</span>

        <span class="cov8" title="1">targetExampleID, err := idwrap.NewFromBytes(req.Msg.GetTargetExampleId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid target example ID"))
        }</span>

        // Validate position
        <span class="cov8" title="1">position := req.Msg.GetPosition()
        if position != resourcesv1.MovePosition_MOVE_POSITION_AFTER &amp;&amp; position != resourcesv1.MovePosition_MOVE_POSITION_BEFORE </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid position: must be AFTER or BEFORE"))
        }</span>

        // Prevent moving example relative to itself
        <span class="cov8" title="1">if exampleID.Compare(targetExampleID) == 0 </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("cannot move example relative to itself"))
        }</span>

        // 2. Permission Check
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(ritemapi.CheckOwnerApi(ctx, *c.ias, *c.cs, *c.us, endpointID))
        if rpcErr != nil </span><span class="cov8" title="1">{
                return nil, rpcErr
        }</span>

        // 3. Move Operation
        <span class="cov8" title="1">switch position </span>{
        case resourcesv1.MovePosition_MOVE_POSITION_AFTER:<span class="cov8" title="1">
                err = c.iaes.MoveExampleAfter(ctx, endpointID, exampleID, targetExampleID)</span>
        case resourcesv1.MovePosition_MOVE_POSITION_BEFORE:<span class="cov8" title="1">
                err = c.iaes.MoveExampleBefore(ctx, endpointID, exampleID, targetExampleID)</span>
        default:<span class="cov0" title="0">
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid position"))</span>
        }

        // 4. Error Handling
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, errors.New("example or target example not found"))
                }</span>
                <span class="cov8" title="1">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov8" title="1">return connect.NewResponse(&amp;examplev1.ExampleMoveResponse{}), nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package ritemfolder

import (
        "context"
        "database/sql"
        "errors"
        "log"
        devtoolsdb "the-dev-tools/db"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/rcollection"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mitemfolder"
        "the-dev-tools/server/pkg/permcheck"
        "the-dev-tools/server/pkg/service/scollection"
        "the-dev-tools/server/pkg/service/scollectionitem"
        "the-dev-tools/server/pkg/service/sitemfolder"
        "the-dev-tools/server/pkg/service/suser"
        "the-dev-tools/server/pkg/translate/tfolder"
        folderv1 "the-dev-tools/spec/dist/buf/go/collection/item/folder/v1"
        "the-dev-tools/spec/dist/buf/go/collection/item/folder/v1/folderv1connect"

        "connectrpc.com/connect"
)

type ItemFolderRPC struct {
        DB  *sql.DB
        ifs sitemfolder.ItemFolderService
        us  suser.UserService
        cs  scollection.CollectionService
        cis *scollectionitem.CollectionItemService
}

func New(db *sql.DB, ifs sitemfolder.ItemFolderService, us suser.UserService, cs scollection.CollectionService, cis *scollectionitem.CollectionItemService) ItemFolderRPC <span class="cov8" title="1">{
        return ItemFolderRPC{
                DB:  db,
                ifs: ifs,
                us:  us,
                cs:  cs,
                cis: cis,
        }
}</span>

func CreateService(srv ItemFolderRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := folderv1connect.NewFolderServiceHandler(&amp;srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

func (c *ItemFolderRPC) FolderCreate(ctx context.Context, req *connect.Request[folderv1.FolderCreateRequest]) (*connect.Response[folderv1.FolderCreateResponse], error) <span class="cov8" title="1">{
        collectionID, err := idwrap.NewFromBytes(req.Msg.GetCollectionId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">folderConv := &amp;folderv1.Folder{
                Name:           req.Msg.GetName(),
                ParentFolderId: req.Msg.GetParentFolderId(),
        }

        reqFolder, err := tfolder.SeralizeRPCToModelWithoutID(folderConv, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">ID := idwrap.NewNow()
        reqFolder.ID = ID

        rpcErr := permcheck.CheckPerm(rcollection.CheckOwnerCollection(ctx, c.cs, c.us, reqFolder.CollectionID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">if reqFolder.ParentID != nil </span><span class="cov0" title="0">{
                rpcErr = permcheck.CheckPerm(CheckOwnerFolder(ctx, c.ifs, c.cs, c.us, *reqFolder.ParentID))
                if rpcErr != nil </span><span class="cov0" title="0">{
                        return nil, rpcErr
                }</span>
        }

        <span class="cov8" title="1">tx, err := c.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                // TODO: find a better way
                localErr := tx.Rollback()
                if localErr != nil </span><span class="cov8" title="1">{
                        log.Println(localErr)
                }</span>
        }()

        // Use CollectionItemService to create folder with unified ordering
        <span class="cov8" title="1">err = c.cis.CreateFolderTX(ctx, tx, reqFolder)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">respRaw := &amp;folderv1.FolderCreateResponse{
                FolderId: ID.Bytes(),
        }
        return connect.NewResponse(respRaw), nil</span>
}

func (c *ItemFolderRPC) FolderUpdate(ctx context.Context, req *connect.Request[folderv1.FolderUpdateRequest]) (*connect.Response[folderv1.FolderUpdateResponse], error) <span class="cov8" title="1">{
        folderID, err := idwrap.NewFromBytes(req.Msg.GetFolderId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerFolder(ctx, c.ifs, c.cs, c.us, folderID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">folder, err := c.ifs.GetFolder(ctx, folderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">msg := req.Msg
        if msg.GetName() != "" </span><span class="cov8" title="1">{
                folder.Name = req.Msg.GetName()
        }</span>
        <span class="cov8" title="1">parentID := msg.GetParentFolderId()
        if parentID != nil </span><span class="cov0" title="0">{
                if len(parentID) != 0 </span><span class="cov0" title="0">{
                        parentID, err := idwrap.NewFromBytes(msg.ParentFolderId)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInvalidArgument, err)
                        }</span>
                        <span class="cov0" title="0">rpcErr = permcheck.CheckPerm(CheckOwnerFolder(ctx, c.ifs,
                                c.cs, c.us, parentID))
                        if rpcErr != nil </span><span class="cov0" title="0">{
                                return nil, rpcErr
                        }</span>
                        <span class="cov0" title="0">_, err = c.ifs.GetFolder(ctx, parentID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>
                        <span class="cov0" title="0">folder.ParentID = &amp;parentID</span>
                }
        }

        <span class="cov8" title="1">err = c.ifs.UpdateItemFolder(ctx, folder)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;folderv1.FolderUpdateResponse{}), nil</span>
}

func (c *ItemFolderRPC) FolderDelete(ctx context.Context, req *connect.Request[folderv1.FolderDeleteRequest]) (*connect.Response[folderv1.FolderDeleteResponse], error) <span class="cov8" title="1">{
        ulidID, err := idwrap.NewFromBytes(req.Msg.GetFolderId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">isOwner, err := CheckOwnerFolder(ctx, c.ifs, c.cs, c.us, ulidID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">if !isOwner </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodePermissionDenied, errors.New("not owner"))
        }</span>

        <span class="cov8" title="1">reqFolder, err := c.ifs.GetFolder(ctx, ulidID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">prev, next := reqFolder.Prev, reqFolder.Next
        var prevFolderPtr, nextFolderPtr *mitemfolder.ItemFolder

        if prev != nil </span><span class="cov0" title="0">{
                prevFolder, err := c.ifs.GetFolder(ctx, *prev)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">prevFolderPtr = prevFolder</span>
        }
        <span class="cov8" title="1">if next != nil </span><span class="cov0" title="0">{
                nextFolder, err := c.ifs.GetFolder(ctx, *next)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">nextFolderPtr = nextFolder</span>
        }

        <span class="cov8" title="1">tx, err := c.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">defer devtoolsdb.TxnRollback(tx)

        txIfs, err := sitemfolder.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">if prevFolderPtr != nil </span><span class="cov0" title="0">{
                prevFolderPtr.Next = next
                err = txIfs.UpdateOrder(ctx, prevFolderPtr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }
        <span class="cov8" title="1">if nextFolderPtr != nil </span><span class="cov0" title="0">{
                nextFolderPtr.Prev = prev
                err = txIfs.UpdateOrder(ctx, nextFolderPtr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov8" title="1">err = txIfs.DeleteItemFolder(ctx, ulidID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;folderv1.FolderDeleteResponse{}), nil</span>
}

func CheckOwnerFolder(ctx context.Context, ifs sitemfolder.ItemFolderService, cs scollection.CollectionService, us suser.UserService, folderID idwrap.IDWrap) (bool, error) <span class="cov8" title="1">{
        folder, err := ifs.GetFolder(ctx, folderID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">isOwner, err := rcollection.CheckOwnerCollection(ctx, cs, us, folder.CollectionID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return isOwner, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package rlog

import (
        "context"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/middleware/mwauth"
        "the-dev-tools/server/pkg/logconsole"
        "the-dev-tools/server/pkg/reference"
        "the-dev-tools/server/pkg/translate/tgeneric"
        logv1 "the-dev-tools/spec/dist/buf/go/log/v1"
        "the-dev-tools/spec/dist/buf/go/log/v1/logv1connect"

        "connectrpc.com/connect"
        "google.golang.org/protobuf/types/known/emptypb"
)

type RlogRPC struct {
        logChannels logconsole.LogChanMap
}

func NewRlogRPC(logMap logconsole.LogChanMap) *RlogRPC <span class="cov8" title="1">{
        return &amp;RlogRPC{
                logChannels: logMap,
        }
}</span>

func CreateService(srv *RlogRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := logv1connect.NewLogServiceHandler(srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

func (c *RlogRPC) LogStream(ctx context.Context, req *connect.Request[emptypb.Empty], stream *connect.ServerStream[logv1.LogStreamResponse]) error <span class="cov0" title="0">{
        return c.LogStreamAdHoc(ctx, req, stream)
}</span>

func (c *RlogRPC) LogStreamAdHoc(ctx context.Context, req *connect.Request[emptypb.Empty], stream api.ServerStreamAdHoc[logv1.LogStreamResponse]) error <span class="cov8" title="1">{
        userID, err := mwauth.GetContextUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">lmc := c.logChannels.AddLogChannel(userID)

        for </span><span class="cov8" title="1">{
                select </span>{
                case logMessage := &lt;-lmc:<span class="cov8" title="1">
                        rpcRefs := tgeneric.MassConvert(logMessage.Refs, reference.ConvertPkgToRpcTree)

                        b := &amp;logv1.LogStreamResponse{
                                LogId:      logMessage.LogID.Bytes(),
                                Value:      logMessage.Value,
                                Level:      logv1.LogLevel(logMessage.Level),
                                References: rpcRefs,
                        }
                        err = stream.Send(b)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">continue</span>
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        err = ctx.Err()</span>
                }
                <span class="cov8" title="1">break</span>
        }
        <span class="cov8" title="1">c.logChannels.DeleteLogChannel(userID)
        return err</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package rnode

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        devtoolsdb "the-dev-tools/db"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/rflow"
        "the-dev-tools/server/pkg/compress"
        "the-dev-tools/server/pkg/flow/node/nrequest"
        "the-dev-tools/server/pkg/httpclient"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/massert"
        "the-dev-tools/server/pkg/model/mexampleresp"
        "the-dev-tools/server/pkg/model/mexamplerespheader"
        "the-dev-tools/server/pkg/model/mnnode"
        "the-dev-tools/server/pkg/model/mnnode/mnfor"
        "the-dev-tools/server/pkg/model/mnnode/mnforeach"
        "the-dev-tools/server/pkg/model/mnnode/mnif"
        "the-dev-tools/server/pkg/model/mnnode/mnjs"
        "the-dev-tools/server/pkg/model/mnnode/mnnoop"
        "the-dev-tools/server/pkg/model/mnnode/mnrequest"
        "the-dev-tools/server/pkg/permcheck"
        "the-dev-tools/server/pkg/service/sbodyform"
        "the-dev-tools/server/pkg/service/sbodyraw"
        "the-dev-tools/server/pkg/service/sbodyurl"
        "the-dev-tools/server/pkg/service/sexampleheader"
        "the-dev-tools/server/pkg/service/sexamplequery"
        "the-dev-tools/server/pkg/service/sflow"
        "the-dev-tools/server/pkg/service/sitemapi"
        "the-dev-tools/server/pkg/service/sitemapiexample"
        "the-dev-tools/server/pkg/service/snode"
        "the-dev-tools/server/pkg/service/snodeexecution"
        "the-dev-tools/server/pkg/service/snodefor"
        "the-dev-tools/server/pkg/service/snodeforeach"
        "the-dev-tools/server/pkg/service/snodeif"
        "the-dev-tools/server/pkg/service/snodejs"
        "the-dev-tools/server/pkg/service/snodenoop"
        "the-dev-tools/server/pkg/service/snoderequest"
        "the-dev-tools/server/pkg/service/suser"
        "the-dev-tools/server/pkg/translate/tcondition"
        nodev1 "the-dev-tools/spec/dist/buf/go/flow/node/v1"
        "the-dev-tools/spec/dist/buf/go/flow/node/v1/nodev1connect"

        "connectrpc.com/connect"
)

type NodeServiceRPC struct {
        DB *sql.DB

        // parent
        fs sflow.FlowService
        us suser.UserService

        // sub
        ns    snode.NodeService
        nis   snodeif.NodeIfService
        nrs   snoderequest.NodeRequestService
        nfls  snodefor.NodeForService
        nlfes snodeforeach.NodeForEachService
        nss   snodenoop.NodeNoopService
        njss  snodejs.NodeJSService

        // api
        ias  sitemapi.ItemApiService
        iaes sitemapiexample.ItemApiExampleService
        eqs  sexamplequery.ExampleQueryService
        ehs  sexampleheader.HeaderService

        // endpoint body
        brs  sbodyraw.BodyRawService
        bfs  sbodyform.BodyFormService
        bues sbodyurl.BodyURLEncodedService

        // node execution
        nes snodeexecution.NodeExecutionService
}

func NewNodeServiceRPC(db *sql.DB, us suser.UserService,
        fs sflow.FlowService, nis snodeif.NodeIfService, nrs snoderequest.NodeRequestService,
        nlfs snodefor.NodeForService, nlfes snodeforeach.NodeForEachService, ns snode.NodeService,
        nss snodenoop.NodeNoopService, njss snodejs.NodeJSService,
        ias sitemapi.ItemApiService, ieas sitemapiexample.ItemApiExampleService,
        eqs sexamplequery.ExampleQueryService, ehs sexampleheader.HeaderService,
        brs sbodyraw.BodyRawService, bfs sbodyform.BodyFormService, bues sbodyurl.BodyURLEncodedService,
        nes snodeexecution.NodeExecutionService,
) *NodeServiceRPC <span class="cov8" title="1">{
        return &amp;NodeServiceRPC{
                DB: db,

                us: us,
                fs: fs,

                ns:    ns,
                nis:   nis,
                nrs:   nrs,
                nfls:  nlfs,
                nlfes: nlfes,
                nss:   nss,
                njss:  njss,

                ias:  ias,
                iaes: ieas,
                eqs:  eqs,
                ehs:  ehs,

                brs:  brs,
                bfs:  bfs,
                bues: bues,

                nes: nes,
        }
}</span>

func CreateService(srv *NodeServiceRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := nodev1connect.NewNodeServiceHandler(srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

func (c *NodeServiceRPC) NodeList(ctx context.Context, req *connect.Request[nodev1.NodeListRequest]) (*connect.Response[nodev1.NodeListResponse], error) <span class="cov8" title="1">{
        flowID, err := idwrap.NewFromBytes(req.Msg.FlowId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(rflow.CheckOwnerFlow(ctx, c.fs, c.us, flowID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">nodes, err := c.ns.GetNodesByFlowID(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, errors.New("any node found"))
        }</span>

        <span class="cov8" title="1">NodeList := make([]*nodev1.NodeListItem, len(nodes))
        for i, node := range nodes </span><span class="cov8" title="1">{
                rpcNode, err := GetNodeSub(ctx, node, c.ns, c.nis, c.nrs, c.nfls, c.nlfes, c.nss, c.njss, c.nes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">convertedItem := &amp;nodev1.NodeListItem{
                        NodeId:   node.ID.Bytes(),
                        State:    rpcNode.State,
                        Position: rpcNode.Position,
                        Kind:     rpcNode.Kind,
                        NoOp:     rpcNode.NoOp,
                }

                // For request nodes, include endpoint information in the info field
                if rpcNode.Kind == nodev1.NodeKind_NODE_KIND_REQUEST &amp;&amp; rpcNode.Request != nil </span><span class="cov8" title="1">{
                        if rpcNode.Request.ExampleId != nil </span><span class="cov0" title="0">{
                                example, err := idwrap.NewFromBytes(rpcNode.Request.ExampleId)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                                }</span>
                                <span class="cov0" title="0">ex, err := c.iaes.GetApiExample(ctx, example)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, connect.NewError(connect.CodeInternal, errors.New("example not found"))
                                }</span>
                                <span class="cov0" title="0">rpcNode.Request.CollectionId = ex.CollectionID.Bytes()</span>
                        }
                }
                <span class="cov8" title="1">NodeList[i] = convertedItem</span>
        }

        <span class="cov8" title="1">resp := &amp;nodev1.NodeListResponse{
                Items: NodeList,
        }
        return connect.NewResponse(resp), nil</span>
}

func (c *NodeServiceRPC) NodeGet(ctx context.Context, req *connect.Request[nodev1.NodeGetRequest]) (*connect.Response[nodev1.NodeGetResponse], error) <span class="cov8" title="1">{
        nodeID, err := idwrap.NewFromBytes(req.Msg.NodeId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerNode(ctx, c.fs, c.us, c.ns, nodeID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">node, err := c.ns.GetNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, errors.New("root node not found"))
        }</span>
        <span class="cov8" title="1">rpcNode, err := GetNodeSub(ctx, *node, c.ns, c.nis, c.nrs, c.nfls, c.nlfes, c.nss, c.njss, c.nes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, errors.New("sub node not found"))
        }</span>
        <span class="cov8" title="1">resp := nodev1.NodeGetResponse{
                Name:      node.Name,
                NodeId:    node.ID.Bytes(),
                Kind:      rpcNode.Kind,
                Request:   rpcNode.Request,
                For:       rpcNode.For,
                ForEach:   rpcNode.ForEach,
                Condition: rpcNode.Condition,
                Js:        rpcNode.Js,
        }
        if rpcNode.Kind == nodev1.NodeKind_NODE_KIND_REQUEST </span><span class="cov8" title="1">{
                if rpcNode.Request.ExampleId != nil </span><span class="cov0" title="0">{
                        example, err := idwrap.NewFromBytes(rpcNode.Request.ExampleId)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInvalidArgument, err)
                        }</span>
                        <span class="cov0" title="0">ex, err := c.iaes.GetApiExample(ctx, example)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>
                        <span class="cov0" title="0">resp.Request.CollectionId = ex.CollectionID.Bytes()</span>
                }
                // Ensure EndpointId is properly set in the response
                <span class="cov8" title="1">if rpcNode.Request.EndpointId != nil </span><span class="cov0" title="0">{
                        resp.Request.EndpointId = rpcNode.Request.EndpointId
                }</span>
                // Ensure DeltaEndpointId is properly set in the response
                <span class="cov8" title="1">if rpcNode.Request.DeltaEndpointId != nil </span><span class="cov0" title="0">{
                        resp.Request.DeltaEndpointId = rpcNode.Request.DeltaEndpointId
                }</span>
        }

        <span class="cov8" title="1">return connect.NewResponse(&amp;resp), nil</span>
}

func (c *NodeServiceRPC) NodeCreate(ctx context.Context, req *connect.Request[nodev1.NodeCreateRequest]) (*connect.Response[nodev1.NodeCreateResponse], error) <span class="cov8" title="1">{
        flowID, err := idwrap.NewFromBytes(req.Msg.FlowId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("invalid flow id: %w", err))
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(rflow.CheckOwnerFlow(ctx, c.fs, c.us, flowID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid flow owner: %w", rpcErr)
        }</span>

        <span class="cov8" title="1">flow, err := c.fs.GetFlow(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">NodeID := idwrap.NewNow()

        RpcNodeCreated := &amp;nodev1.Node{
                NodeId:    NodeID.Bytes(),
                Name:      req.Msg.Name,
                Position:  req.Msg.Position,
                Kind:      req.Msg.Kind,
                NoOp:      req.Msg.NoOp,
                Request:   req.Msg.Request,
                For:       req.Msg.For,
                ForEach:   req.Msg.ForEach,
                Condition: req.Msg.Condition,
                Js:        req.Msg.Js,
        }

        nodeData, err := ConvertRPCNodeToModelWithoutID(ctx, RpcNodeCreated, flow.ID, NodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("invalid node: %w", err))
        }</span>

        <span class="cov8" title="1">tx, err := c.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">defer devtoolsdb.TxnRollback(tx)
        nsTX, err := snode.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = nsTX.CreateNode(ctx, *nodeData.Base)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // INFO: this is using reflection to check the type of subNode
        // in future, this should be refactored to use a more explicit way to check the type
        <span class="cov8" title="1">switch subNodeType := nodeData.SubNode.(type) </span>{
        case *mnrequest.MNRequest:<span class="cov8" title="1">
                subNodeType.FlowNodeID = nodeData.Base.ID
                nrsTX, err := snoderequest.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov8" title="1">err = nrsTX.CreateNodeRequest(ctx, *subNodeType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        case *mnfor.MNFor:<span class="cov0" title="0">
                nlfTX, err := snodefor.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">err = nlfTX.CreateNodeFor(ctx, *subNodeType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        case *mnif.MNIF:<span class="cov0" title="0">
                niTX, err := snodeif.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">err = niTX.CreateNodeIf(ctx, *subNodeType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        case *mnforeach.MNForEach:<span class="cov0" title="0">
                nlfeTX, err := snodeforeach.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">err = nlfeTX.CreateNodeForEach(ctx, *subNodeType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        case *mnnoop.NoopNode:<span class="cov0" title="0">
                noopTX, err := snodenoop.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">err = noopTX.CreateNodeNoop(ctx, *subNodeType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        case *mnjs.MNJS:<span class="cov0" title="0">
                njTX, err := snodejs.NewTX(ctx, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">err = njTX.CreateNodeJS(ctx, *subNodeType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        default:<span class="cov0" title="0">
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("unknown subNode type: %T", nodeData.SubNode))</span>
        }
        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;nodev1.NodeCreateResponse{NodeId: RpcNodeCreated.NodeId}), nil</span>
}

func (c *NodeServiceRPC) NodeUpdate(ctx context.Context, req *connect.Request[nodev1.NodeUpdateRequest]) (*connect.Response[nodev1.NodeUpdateResponse], error) <span class="cov8" title="1">{
        nodeID, err := idwrap.NewFromBytes(req.Msg.NodeId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerNode(ctx, c.fs, c.us, c.ns, nodeID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">RpcNodeUpdate := &amp;nodev1.Node{
                NodeId:    nodeID.Bytes(),
                Position:  req.Msg.Position,
                NoOp:      req.Msg.NoOp,
                Request:   req.Msg.Request,
                For:       req.Msg.For,
                ForEach:   req.Msg.ForEach,
                Condition: req.Msg.Condition,
                Js:        req.Msg.Js,
        }

        node, err := c.ns.GetNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">if req.Msg.Position != nil </span><span class="cov8" title="1">{
                node.PositionX = float64(req.Msg.Position.X)
                node.PositionY = float64(req.Msg.Position.Y)
        }</span>

        <span class="cov8" title="1">if req.Msg.Name != nil </span><span class="cov8" title="1">{
                node.Name = *req.Msg.Name
        }</span>

        <span class="cov8" title="1">RpcNodeUpdate.Kind = nodev1.NodeKind(node.NodeKind)

        switch RpcNodeUpdate.Kind </span>{
        case nodev1.NodeKind_NODE_KIND_REQUEST:<span class="cov8" title="1">
                if RpcNodeUpdate.Request != nil </span><span class="cov8" title="1">{
                        var anyUpdate bool
                        requestNode, err := c.nrs.GetNodeRequest(ctx, nodeID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>

                        <span class="cov8" title="1">if len(RpcNodeUpdate.Request.ExampleId) != 0 </span><span class="cov0" title="0">{
                                examplePtr, err := idwrap.NewFromBytes(RpcNodeUpdate.Request.ExampleId)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">requestNode.ExampleID = &amp;examplePtr
                                anyUpdate = true</span>
                        }

                        <span class="cov8" title="1">if len(RpcNodeUpdate.Request.EndpointId) != 0 </span><span class="cov0" title="0">{
                                endpointPtr, err := idwrap.NewFromBytes(RpcNodeUpdate.Request.EndpointId)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">requestNode.EndpointID = &amp;endpointPtr
                                anyUpdate = true</span>
                        }

                        <span class="cov8" title="1">if len(RpcNodeUpdate.Request.DeltaExampleId) != 0 </span><span class="cov0" title="0">{
                                deltaExamplePtr, err := idwrap.NewFromBytes(RpcNodeUpdate.Request.DeltaExampleId)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">requestNode.DeltaExampleID = &amp;deltaExamplePtr
                                anyUpdate = true</span>
                        }

                        <span class="cov8" title="1">if len(RpcNodeUpdate.Request.DeltaEndpointId) != 0 </span><span class="cov0" title="0">{
                                deltaEndpointPtr, err := idwrap.NewFromBytes(RpcNodeUpdate.Request.DeltaEndpointId)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">requestNode.DeltaEndpointID = &amp;deltaEndpointPtr
                                anyUpdate = true</span>
                        }

                        <span class="cov8" title="1">if anyUpdate </span><span class="cov0" title="0">{
                                err = c.nrs.UpdateNodeRequest(ctx, *requestNode)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, connect.NewError(connect.CodeInternal, err)
                                }</span>
                        }
                }
        case nodev1.NodeKind_NODE_KIND_FOR:<span class="cov0" title="0">
                if RpcNodeUpdate.For != nil </span><span class="cov0" title="0">{
                        var anyUpdate bool
                        forNode, err := c.nfls.GetNodeFor(ctx, nodeID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>
                        <span class="cov0" title="0">if RpcNodeUpdate.For.Condition != nil </span><span class="cov0" title="0">{
                                condition := tcondition.DeserializeConditionRPCToModel(RpcNodeUpdate.For.Condition)
                                anyUpdate = true
                                forNode.Condition = condition
                        }</span>
                        <span class="cov0" title="0">if RpcNodeUpdate.For.ErrorHandling != nodev1.ErrorHandling(mnfor.ErrorHandling_ERROR_HANDLING_UNSPECIFIED) </span><span class="cov0" title="0">{
                                errorHandling := mnfor.ErrorHandling(RpcNodeUpdate.For.ErrorHandling)
                                forNode.ErrorHandling = errorHandling
                                anyUpdate = true
                        }</span>
                        <span class="cov0" title="0">if RpcNodeUpdate.For.Iterations != 0 </span><span class="cov0" title="0">{
                                forNode.IterCount = int64(RpcNodeUpdate.For.Iterations)
                                anyUpdate = true
                        }</span>
                        <span class="cov0" title="0">if anyUpdate </span><span class="cov0" title="0">{
                                err = c.nfls.UpdateNodeFor(ctx, *forNode)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, connect.NewError(connect.CodeInternal, err)
                                }</span>
                        }
                }
        case nodev1.NodeKind_NODE_KIND_FOR_EACH:<span class="cov0" title="0">
                if RpcNodeUpdate.ForEach != nil </span><span class="cov0" title="0">{
                        forEachNode, err := c.nlfes.GetNodeForEach(ctx, nodeID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">var anyUpdate bool
                        if RpcNodeUpdate.ForEach.Condition != nil </span><span class="cov0" title="0">{
                                condition := tcondition.DeserializeConditionRPCToModel(RpcNodeUpdate.ForEach.Condition)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">forEachNode.Condition = condition
                                anyUpdate = true</span>
                        }

                        <span class="cov0" title="0">if RpcNodeUpdate.ForEach.ErrorHandling != nodev1.ErrorHandling(mnfor.ErrorHandling_ERROR_HANDLING_UNSPECIFIED) </span><span class="cov0" title="0">{
                                errorHandling := mnfor.ErrorHandling(RpcNodeUpdate.ForEach.ErrorHandling)
                                forEachNode.ErrorHandling = errorHandling
                                anyUpdate = true
                        }</span>

                        <span class="cov0" title="0">if RpcNodeUpdate.ForEach.Path != "" </span><span class="cov0" title="0">{
                                forEachNode.IterExpression = RpcNodeUpdate.ForEach.Path
                                anyUpdate = true
                        }</span>

                        <span class="cov0" title="0">if anyUpdate </span><span class="cov0" title="0">{
                                err = c.nlfes.UpdateNodeForEach(ctx, *forEachNode)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, connect.NewError(connect.CodeInternal, err)
                                }</span>
                        }
                }
        case nodev1.NodeKind_NODE_KIND_NO_OP:<span class="cov0" title="0"></span>
        case nodev1.NodeKind_NODE_KIND_CONDITION:<span class="cov0" title="0">
                if RpcNodeUpdate.Condition != nil </span><span class="cov0" title="0">{
                        nodeIf, err := c.nis.GetNodeIf(ctx, nodeID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>

                        <span class="cov0" title="0">if RpcNodeUpdate.Condition.Condition != nil </span><span class="cov0" title="0">{
                                condition := tcondition.DeserializeConditionRPCToModel(RpcNodeUpdate.Condition.Condition)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">nodeIf.Condition = condition</span>
                        }

                        <span class="cov0" title="0">err = c.nis.UpdateNodeIf(ctx, *nodeIf)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>
                }
        case nodev1.NodeKind_NODE_KIND_JS:<span class="cov0" title="0">
                if RpcNodeUpdate.Js != nil </span><span class="cov0" title="0">{
                        nodeJS, err := c.njss.GetNodeJS(ctx, nodeID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>

                        <span class="cov0" title="0">if RpcNodeUpdate.Js.Code != "" </span><span class="cov0" title="0">{
                                nodeJS.Code = []byte(RpcNodeUpdate.Js.Code)
                        }</span>

                        <span class="cov0" title="0">err = c.njss.UpdateNodeJS(ctx, nodeJS)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>
                }
        default:<span class="cov0" title="0">
                return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("unknown node kind: %s", RpcNodeUpdate.Kind))</span>
        }

        <span class="cov8" title="1">err = c.ns.UpdateNode(ctx, *node)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;nodev1.NodeUpdateResponse{}), nil</span>
}

func (c *NodeServiceRPC) NodeDelete(ctx context.Context, req *connect.Request[nodev1.NodeDeleteRequest]) (*connect.Response[nodev1.NodeDeleteResponse], error) <span class="cov8" title="1">{
        nodeID, err := idwrap.NewFromBytes(req.Msg.NodeId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerNode(ctx, c.fs, c.us, c.ns, nodeID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">node, err := c.ns.GetNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if node.NodeKind == mnnode.NODE_KIND_NO_OP </span><span class="cov0" title="0">{
                nodeNoop, err := c.nss.GetNodeNoop(ctx, node.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if nodeNoop.Type == mnnoop.NODE_NO_OP_KIND_START </span><span class="cov0" title="0">{
                        return nil, errors.New("cannot delete start node")
                }</span>
        }

        <span class="cov8" title="1">err = c.ns.DeleteNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;nodev1.NodeDeleteResponse{}), nil</span>
}

func (c *NodeServiceRPC) NodeRun(ctx context.Context, req *connect.Request[nodev1.NodeRunRequest], stream *connect.ServerStream[nodev1.NodeRunResponse]) error <span class="cov0" title="0">{
        nodeID, err := idwrap.NewFromBytes(req.Msg.NodeId)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">_, err = idwrap.NewFromBytes(req.Msg.EnvironmentId)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(CheckOwnerNode(ctx, c.fs, c.us, c.ns, nodeID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return rpcErr
        }</span>

        <span class="cov0" title="0">node, err := c.ns.GetNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">switch node.NodeKind </span>{
        case mnnode.NODE_KIND_REQUEST:<span class="cov0" title="0">
                nodeReq, err := c.nrs.GetNodeRequest(ctx, node.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov0" title="0">if nodeReq.EndpointID == nil || nodeReq.ExampleID == nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, fmt.Errorf("endpoint or example not found for %s", nodeReq.FlowNodeID))
                }</span>

                <span class="cov0" title="0">endpointID := *nodeReq.EndpointID
                exampleID := *nodeReq.ExampleID

                itemApi, err := c.ias.GetItemApi(ctx, endpointID)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov0" title="0">example, err := c.iaes.GetApiExample(ctx, exampleID)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov0" title="0">queries, err := c.eqs.GetExampleQueriesByExampleID(ctx, exampleID)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov0" title="0">headers, err := c.ehs.GetHeaderByExampleID(ctx, exampleID)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov0" title="0">rawBody, err := c.brs.GetBodyRawByExampleID(ctx, exampleID)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov0" title="0">formBody, err := c.bfs.GetBodyFormsByExampleID(ctx, exampleID)
                if err != nil </span><span class="cov0" title="0">{
                        return connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov0" title="0">urlBody, err := c.bues.GetBodyURLEncodedByExampleID(ctx, exampleID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">requestNodeRespChan := make(chan nrequest.NodeRequestSideResp, 1)

                // TODO: add proper new paramters
                exampleResp := mexampleresp.ExampleResp{}
                exampleRespHeader := []mexamplerespheader.ExampleRespHeader{}
                asserts := []massert.Assert{}

                // TODO: add name
                nrequest.New(nodeReq.FlowNodeID, "", *itemApi, *example, queries, headers, *rawBody, formBody, urlBody,
                        exampleResp, exampleRespHeader, asserts, httpclient.New(), requestNodeRespChan)</span>

        case mnnode.NODE_KIND_FOR:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return connect.NewError(connect.CodeUnimplemented, nil)</span>
        }

        <span class="cov0" title="0">return connect.NewError(connect.CodeUnimplemented, nil)</span>
}

func CheckOwnerNode(ctx context.Context, fs sflow.FlowService, us suser.UserService, ns snode.NodeService, nodeID idwrap.IDWrap) (bool, error) <span class="cov8" title="1">{
        node, err := ns.GetNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">return rflow.CheckOwnerFlow(ctx, fs, us, node.FlowID)</span>
}

func GetNodeSub(ctx context.Context, currentNode mnnode.MNode, ns snode.NodeService, nis snodeif.NodeIfService, nrs snoderequest.NodeRequestService,
        nlfs snodefor.NodeForService, nlfes snodeforeach.NodeForEachService, nss snodenoop.NodeNoopService, njss snodejs.NodeJSService,
        nes snodeexecution.NodeExecutionService,
) (*nodev1.Node, error) <span class="cov8" title="1">{
        var rpcNode *nodev1.Node

        Position := &amp;nodev1.Position{
                X: float32(currentNode.PositionX),
                Y: float32(currentNode.PositionY),
        }

        switch currentNode.NodeKind </span>{
        case mnnode.NODE_KIND_REQUEST:<span class="cov8" title="1">
                nodeReq, err := nrs.GetNodeRequest(ctx, currentNode.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">var rpcExampleID, rpcEndpointID, rpcDeltaExampleID, rpcDeltaEndpointID []byte
                if nodeReq.ExampleID != nil </span><span class="cov0" title="0">{
                        rpcExampleID = nodeReq.ExampleID.Bytes()
                }</span>
                <span class="cov8" title="1">if nodeReq.EndpointID != nil </span><span class="cov0" title="0">{
                        rpcEndpointID = nodeReq.EndpointID.Bytes()
                }</span>
                <span class="cov8" title="1">if nodeReq.DeltaExampleID != nil </span><span class="cov0" title="0">{
                        rpcDeltaExampleID = nodeReq.DeltaExampleID.Bytes()
                }</span>
                <span class="cov8" title="1">if nodeReq.DeltaEndpointID != nil </span><span class="cov0" title="0">{
                        rpcDeltaEndpointID = nodeReq.DeltaEndpointID.Bytes()
                }</span>

                <span class="cov8" title="1">nodeList := &amp;nodev1.Node{
                        NodeId:   currentNode.ID.Bytes(),
                        Kind:     nodev1.NodeKind_NODE_KIND_REQUEST,
                        Position: Position,
                        Name:     currentNode.Name,
                        Request: &amp;nodev1.NodeRequest{
                                CollectionId:    rpcExampleID,
                                ExampleId:       rpcExampleID,
                                EndpointId:      rpcEndpointID,
                                DeltaExampleId:  rpcDeltaExampleID,
                                DeltaEndpointId: rpcDeltaEndpointID,
                        },
                }
                rpcNode = nodeList</span>
        case mnnode.NODE_KIND_FOR:<span class="cov0" title="0">
                nodeFor, err := nlfs.GetNodeFor(ctx, currentNode.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">rpcCond := tcondition.SeralizeConditionModelToRPC(nodeFor.Condition)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">nodeList := &amp;nodev1.Node{
                        NodeId:   currentNode.ID.Bytes(),
                        Kind:     nodev1.NodeKind_NODE_KIND_FOR,
                        Position: Position,
                        Name:     currentNode.Name,
                        For: &amp;nodev1.NodeFor{
                                ErrorHandling: nodev1.ErrorHandling(nodeFor.ErrorHandling),
                                Iterations:    int32(nodeFor.IterCount),
                                Condition:     rpcCond,
                        },
                }
                rpcNode = nodeList</span>
        case mnnode.NODE_KIND_FOR_EACH:<span class="cov0" title="0">
                nodeForEach, err := nlfes.GetNodeForEach(ctx, currentNode.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">rpcCond := tcondition.SeralizeConditionModelToRPC(nodeForEach.Condition)

                nodeList := &amp;nodev1.Node{
                        NodeId:   currentNode.ID.Bytes(),
                        Kind:     nodev1.NodeKind_NODE_KIND_FOR_EACH,
                        Position: Position,
                        Name:     currentNode.Name,
                        ForEach: &amp;nodev1.NodeForEach{
                                ErrorHandling: nodev1.ErrorHandling(nodeForEach.ErrorHandling),
                                Condition:     rpcCond,
                                Path:          nodeForEach.IterExpression,
                        },
                }
                rpcNode = nodeList</span>
        case mnnode.NODE_KIND_NO_OP:<span class="cov0" title="0">
                nodeNoop, err := nss.GetNodeNoop(ctx, currentNode.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">NoOpKind := nodev1.NodeNoOpKind(nodeNoop.Type)

                rpcNode = &amp;nodev1.Node{
                        NodeId:   nodeNoop.FlowNodeID.Bytes(),
                        Kind:     nodev1.NodeKind_NODE_KIND_NO_OP,
                        Name:     currentNode.Name,
                        Position: Position,
                        NoOp:     &amp;NoOpKind,
                }</span>

        case mnnode.NODE_KIND_CONDITION:<span class="cov0" title="0">
                nodeCondition, err := nis.GetNodeIf(ctx, currentNode.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">rpcCondition := tcondition.SeralizeConditionModelToRPC(nodeCondition.Condition)

                rpcNode = &amp;nodev1.Node{
                        NodeId:   nodeCondition.FlowNodeID.Bytes(),
                        Position: Position,
                        Kind:     nodev1.NodeKind_NODE_KIND_CONDITION,
                        Name:     currentNode.Name,
                        Condition: &amp;nodev1.NodeCondition{
                                Condition: rpcCondition,
                        },
                }</span>
        case mnnode.NODE_KIND_JS:<span class="cov0" title="0">

                nodeJS, err := njss.GetNodeJS(ctx, currentNode.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if nodeJS.CodeCompressType != compress.CompressTypeNone </span><span class="cov0" title="0">{
                        nodeJS.Code, err = compress.Decompress(nodeJS.Code, nodeJS.CodeCompressType)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov0" title="0">rpcNode = &amp;nodev1.Node{
                        NodeId:   nodeJS.FlowNodeID.Bytes(),
                        Position: Position,
                        Kind:     nodev1.NodeKind_NODE_KIND_JS,
                        Name:     currentNode.Name,
                        Js: &amp;nodev1.NodeJS{
                                Code: string(nodeJS.Code),
                        },
                }</span>
        }

        // Get the latest execution state for this node
        <span class="cov8" title="1">latestExecution, err := nes.GetLatestNodeExecutionByNodeID(ctx, currentNode.ID)
        if err == nil &amp;&amp; latestExecution != nil </span><span class="cov0" title="0">{
                rpcNode.State = nodev1.NodeState(latestExecution.State)
                // Note: Error information from node execution is available in latestExecution.Error
                // but the Node proto doesn't have a field for it. The error is shown in execution-specific responses.
        }</span> else<span class="cov8" title="1"> {
                // Default to unspecified state if no executions found
                rpcNode.State = nodev1.NodeState_NODE_STATE_UNSPECIFIED
        }</span>

        <span class="cov8" title="1">return rpcNode, nil</span>
}

func ConvertRPCNodeToModelWithID(ctx context.Context, rpcNode *nodev1.Node, flowID idwrap.IDWrap) (*NodeData, error) <span class="cov0" title="0">{
        id, err := idwrap.NewFromBytes(rpcNode.NodeId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ConvertRPCNodeToModelWithoutID(ctx, rpcNode, flowID, id)</span>
}

type NodeData struct {
        Base    *mnnode.MNode
        SubNode any
}

func ConvertRPCNodeToModelWithoutID(ctx context.Context, rpcNode *nodev1.Node, flowID idwrap.IDWrap, nodeID idwrap.IDWrap) (*NodeData, error) <span class="cov8" title="1">{
        var subNode any

        if rpcNode.Position == nil </span><span class="cov0" title="0">{
                rpcNode.Position = &amp;nodev1.Position{}
        }</span>

        <span class="cov8" title="1">baseNode := &amp;mnnode.MNode{
                ID:        nodeID,
                FlowID:    flowID,
                Name:      rpcNode.Name,
                NodeKind:  mnnode.NodeKind(rpcNode.Kind),
                PositionX: float64(rpcNode.Position.X),
                PositionY: float64(rpcNode.Position.Y),
        }

        switch rpcNode.Kind </span>{
        case nodev1.NodeKind_NODE_KIND_REQUEST:<span class="cov8" title="1">
                var endpointIDPtr, exampleIDPtr, deltaExampleIDPtr, deltaEndpointIDPtr *idwrap.IDWrap
                if rpcNode.Request != nil </span><span class="cov8" title="1">{
                        if rpcNode.Request.EndpointId != nil </span><span class="cov0" title="0">{
                                endpointID, err := idwrap.NewFromBytes(rpcNode.Request.EndpointId)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">endpointIDPtr = &amp;endpointID</span>
                        }
                        <span class="cov8" title="1">if rpcNode.Request.ExampleId != nil </span><span class="cov0" title="0">{
                                exampleID, err := idwrap.NewFromBytes(rpcNode.Request.ExampleId)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">exampleIDPtr = &amp;exampleID</span>
                        }
                        <span class="cov8" title="1">if rpcNode.Request.DeltaExampleId != nil </span><span class="cov0" title="0">{
                                deltaExampleID, err := idwrap.NewFromBytes(rpcNode.Request.DeltaExampleId)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">deltaExampleIDPtr = &amp;deltaExampleID</span>
                        }
                        <span class="cov8" title="1">if rpcNode.Request.DeltaEndpointId != nil </span><span class="cov0" title="0">{
                                deltaEndpointID, err := idwrap.NewFromBytes(rpcNode.Request.DeltaEndpointId)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">deltaEndpointIDPtr = &amp;deltaEndpointID</span>
                        }
                }

                <span class="cov8" title="1">reqNode := &amp;mnrequest.MNRequest{
                        FlowNodeID:      nodeID,
                        EndpointID:      endpointIDPtr,
                        ExampleID:       exampleIDPtr,
                        DeltaExampleID:  deltaExampleIDPtr,
                        DeltaEndpointID: deltaEndpointIDPtr,
                }

                subNode = reqNode</span>
        case nodev1.NodeKind_NODE_KIND_FOR:<span class="cov0" title="0">
                forNode := rpcNode.For
                condition := tcondition.DeserializeConditionRPCToModel(forNode.Condition)

                forNodeConverted := &amp;mnfor.MNFor{
                        FlowNodeID:    nodeID,
                        IterCount:     int64(forNode.Iterations),
                        Condition:     condition,
                        ErrorHandling: mnfor.ErrorHandling(forNode.ErrorHandling),
                }
                subNode = forNodeConverted</span>
        case nodev1.NodeKind_NODE_KIND_FOR_EACH:<span class="cov0" title="0">
                var iterpath string

                forEach := rpcNode.ForEach
                if forEach.Path != "" </span><span class="cov0" title="0">{
                        iterpath = rpcNode.ForEach.Path
                }</span>

                <span class="cov0" title="0">condition := tcondition.DeserializeConditionRPCToModel(forEach.Condition)

                forNode := &amp;mnforeach.MNForEach{
                        FlowNodeID:     nodeID,
                        IterExpression: iterpath,
                        Condition:      condition,
                        ErrorHandling:  mnfor.ErrorHandling(forEach.ErrorHandling),
                }
                subNode = forNode</span>
        case nodev1.NodeKind_NODE_KIND_NO_OP:<span class="cov0" title="0">
                a := mnnoop.NoopTypes(*rpcNode.NoOp)
                noopNode := &amp;mnnoop.NoopNode{
                        FlowNodeID: nodeID,
                        Type:       a,
                }
                subNode = noopNode</span>
        case nodev1.NodeKind_NODE_KIND_CONDITION:<span class="cov0" title="0">
                conditionNode := rpcNode.Condition
                condition := tcondition.DeserializeConditionRPCToModel(conditionNode.Condition)

                ifNode := &amp;mnif.MNIF{
                        FlowNodeID: nodeID,
                        Condition:  condition,
                }
                subNode = ifNode</span>
        case nodev1.NodeKind_NODE_KIND_JS:<span class="cov0" title="0">
                subNode = &amp;mnjs.MNJS{
                        FlowNodeID: nodeID,
                        Code:       []byte(rpcNode.Js.Code),
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown node kind: %v", rpcNode.Kind)</span>
        }

        <span class="cov8" title="1">return &amp;NodeData{Base: baseNode, SubNode: subNode}, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package rnodeexecution

import (
        "context"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/rflow"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mnnode"
        "the-dev-tools/server/pkg/permcheck"
        "the-dev-tools/server/pkg/service/sexampleresp"
        "the-dev-tools/server/pkg/service/sflow"
        "the-dev-tools/server/pkg/service/snode"
        "the-dev-tools/server/pkg/service/snodeexecution"
        "the-dev-tools/server/pkg/service/snoderequest"
        "the-dev-tools/server/pkg/service/suser"
        "the-dev-tools/server/pkg/translate/tnodeexecution"
        nodeexecutionv1 "the-dev-tools/spec/dist/buf/go/flow/node/execution/v1"
        "the-dev-tools/spec/dist/buf/go/flow/node/execution/v1/nodeexecutionv1connect"

        "connectrpc.com/connect"
)

type NodeExecutionServiceRPC struct {
        nes *snodeexecution.NodeExecutionService
        ns  *snode.NodeService
        fs  *sflow.FlowService
        us  *suser.UserService
        ers *sexampleresp.ExampleRespService
        rns *snoderequest.NodeRequestService
}

func New(
        nes *snodeexecution.NodeExecutionService,
        ns *snode.NodeService,
        fs *sflow.FlowService,
        us *suser.UserService,
        ers *sexampleresp.ExampleRespService,
        rns *snoderequest.NodeRequestService,
) *NodeExecutionServiceRPC <span class="cov8" title="1">{
        return &amp;NodeExecutionServiceRPC{
                nes: nes,
                ns:  ns,
                fs:  fs,
                us:  us,
                ers: ers,
                rns: rns,
        }
}</span>

func CreateService(srv *NodeExecutionServiceRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := nodeexecutionv1connect.NewNodeExecutionServiceHandler(srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

func (s *NodeExecutionServiceRPC) NodeExecutionList(
        ctx context.Context,
        req *connect.Request[nodeexecutionv1.NodeExecutionListRequest],
) (*connect.Response[nodeexecutionv1.NodeExecutionListResponse], error) <span class="cov8" title="1">{
        // Parse node ID
        nodeID, err := idwrap.NewFromBytes(req.Msg.GetNodeId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // Check permissions through flow ownership
        <span class="cov8" title="1">node, err := s.ns.GetNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeNotFound, err)
        }</span>

        <span class="cov8" title="1">flow, err := s.fs.GetFlow(ctx, node.FlowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(rflow.CheckOwnerFlow(ctx, *s.fs, *s.us, flow.ID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">executions, err := s.nes.ListNodeExecutionsByNodeID(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">items := make([]*nodeexecutionv1.NodeExecutionListItem, 0, len(executions))
        for _, exec := range executions </span><span class="cov8" title="1">{
                rpcExec, err := tnodeexecution.SerializeNodeExecutionModelToRPCListItem(&amp;exec)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">items = append(items, rpcExec)</span>
        }

        <span class="cov8" title="1">resp := &amp;nodeexecutionv1.NodeExecutionListResponse{
                Items: items,
        }

        return connect.NewResponse(resp), nil</span>
}

func (s *NodeExecutionServiceRPC) NodeExecutionGet(
        ctx context.Context,
        req *connect.Request[nodeexecutionv1.NodeExecutionGetRequest],
) (*connect.Response[nodeexecutionv1.NodeExecutionGetResponse], error) <span class="cov8" title="1">{
        // Parse execution ID
        executionID, err := idwrap.NewFromBytes(req.Msg.GetNodeExecutionId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // Get execution
        <span class="cov8" title="1">execution, err := s.nes.GetNodeExecution(ctx, executionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeNotFound, err)
        }</span>

        // Check permissions through node -&gt; flow ownership
        <span class="cov8" title="1">node, err := s.ns.GetNode(ctx, execution.NodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">flow, err := s.fs.GetFlow(ctx, node.FlowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(rflow.CheckOwnerFlow(ctx, *s.fs, *s.us, flow.ID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Convert to RPC
        <span class="cov8" title="1">rpcExec, err := tnodeexecution.SerializeNodeExecutionModelToRPCGetResponse(execution)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // For REQUEST nodes, ensure ResponseID is included in RPC response
        <span class="cov8" title="1">if node.NodeKind == mnnode.NODE_KIND_REQUEST &amp;&amp; execution.ResponseID != nil </span><span class="cov0" title="0">{
                // Verify the response exists (optional validation)
                _, err := s.ers.GetExampleResp(ctx, *execution.ResponseID)
                if err != nil </span><span class="cov0" title="0">{
                        // Log validation error but don't fail the request
                        // The ResponseID will still be included in the response
                        _ = err // Acknowledge error but don't act on it
                }</span>
                // ResponseID is already included by the translation layer
                // This validation just ensures the response record exists
        }

        <span class="cov8" title="1">resp := rpcExec
        return connect.NewResponse(resp), nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package rreference

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "strings"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/rworkspace"
        "the-dev-tools/server/pkg/compress"
        "the-dev-tools/server/pkg/flow/edge"
        "the-dev-tools/server/pkg/httpclient"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/menv"
        "the-dev-tools/server/pkg/model/mexampleresp"
        "the-dev-tools/server/pkg/model/mflowvariable"
        "the-dev-tools/server/pkg/model/mnnode"
        "the-dev-tools/server/pkg/model/mnodeexecution"
        "the-dev-tools/server/pkg/model/mvar"
        "the-dev-tools/server/pkg/permcheck"
        "the-dev-tools/server/pkg/reference"
        "the-dev-tools/server/pkg/referencecompletion"
        "the-dev-tools/server/pkg/service/flow/sedge"
        "the-dev-tools/server/pkg/service/senv"
        "the-dev-tools/server/pkg/service/sexampleresp"
        "the-dev-tools/server/pkg/service/sexamplerespheader"
        "the-dev-tools/server/pkg/service/sflow"
        "the-dev-tools/server/pkg/service/sflowvariable"
        "the-dev-tools/server/pkg/service/snode"
        "the-dev-tools/server/pkg/service/snodeexecution"
        "the-dev-tools/server/pkg/service/snoderequest"
        "the-dev-tools/server/pkg/service/suser"
        "the-dev-tools/server/pkg/service/svar"
        "the-dev-tools/server/pkg/service/sworkspace"
        "the-dev-tools/server/pkg/sort/sortenabled"
        "the-dev-tools/server/pkg/zstdcompress"
        referencev1 "the-dev-tools/spec/dist/buf/go/reference/v1"
        "the-dev-tools/spec/dist/buf/go/reference/v1/referencev1connect"

        "connectrpc.com/connect"
)

type ReferenceServiceRPC struct {
        DB *sql.DB

        us suser.UserService
        ws sworkspace.WorkspaceService

        // env
        es senv.EnvService
        vs svar.VarService

        // resp
        ers  sexampleresp.ExampleRespService
        erhs sexamplerespheader.ExampleRespHeaderService

        // flow
        fs                   sflow.FlowService
        fns                  snode.NodeService
        frns                 snoderequest.NodeRequestService
        flowVariableService  sflowvariable.FlowVariableService
        flowEdgeService      sedge.EdgeService
        nodeExecutionService snodeexecution.NodeExecutionService
}

func NewNodeServiceRPC(db *sql.DB, us suser.UserService, ws sworkspace.WorkspaceService,
        es senv.EnvService, vs svar.VarService,
        ers sexampleresp.ExampleRespService, erhs sexamplerespheader.ExampleRespHeaderService,
        fs sflow.FlowService, fns snode.NodeService, frns snoderequest.NodeRequestService,
        flowVariableService sflowvariable.FlowVariableService,
        edgeService sedge.EdgeService,
        nodeExecutionService snodeexecution.NodeExecutionService,
) *ReferenceServiceRPC <span class="cov8" title="1">{
        return &amp;ReferenceServiceRPC{
                DB: db,

                us: us,
                ws: ws,

                es: es,
                vs: vs,

                ers:  ers,
                erhs: erhs,

                fs:                  fs,
                fns:                 fns,
                frns:                frns,
                flowVariableService: flowVariableService,

                flowEdgeService:      edgeService,
                nodeExecutionService: nodeExecutionService,
        }
}</span>

func CreateService(srv *ReferenceServiceRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := referencev1connect.NewReferenceServiceHandler(srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

var (
        ErrExampleNotFound   = errors.New("example not found")
        ErrNodeNotFound      = errors.New("node not found")
        ErrWorkspaceNotFound = errors.New("workspace not found")
        ErrEnvNotFound       = errors.New("env not found")
)

// isIterationExecution checks if an execution name indicates it's an iteration execution
// from a foreach/for node rather than the main node execution.
// Iteration executions have names like "Iteration 0", "Iteration 1", "Error Summary", etc.
func isIterationExecution(name string) bool <span class="cov8" title="1">{
        return strings.HasPrefix(name, "Iteration ") || name == "Error Summary"
}</span>

func (c *ReferenceServiceRPC) ReferenceTree(ctx context.Context, req *connect.Request[referencev1.ReferenceTreeRequest]) (*connect.Response[referencev1.ReferenceTreeResponse], error) <span class="cov8" title="1">{
        var Items []*referencev1.ReferenceTreeItem

        var workspaceID, exampleID, nodeIDPtr *idwrap.IDWrap
        msg := req.Msg
        if msg.WorkspaceId != nil </span><span class="cov0" title="0">{
                tempID, err := idwrap.NewFromBytes(msg.WorkspaceId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>
                <span class="cov0" title="0">workspaceID = &amp;tempID</span>
        }
        <span class="cov8" title="1">if msg.ExampleId != nil </span><span class="cov0" title="0">{
                tempID, err := idwrap.NewFromBytes(msg.ExampleId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>
                <span class="cov0" title="0">exampleID = &amp;tempID</span>
        }
        <span class="cov8" title="1">if msg.NodeId != nil </span><span class="cov8" title="1">{
                tempID, err := idwrap.NewFromBytes(msg.NodeId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>
                <span class="cov8" title="1">nodeIDPtr = &amp;tempID</span>
        }

        // Workspace
        <span class="cov8" title="1">if workspaceID != nil </span><span class="cov0" title="0">{
                wsID := *workspaceID
                rpcErr := permcheck.CheckPerm(rworkspace.CheckOwnerWorkspace(ctx, c.us, wsID))
                if rpcErr != nil </span><span class="cov0" title="0">{
                        return nil, rpcErr
                }</span>
                <span class="cov0" title="0">envs, err := c.es.GetByWorkspace(ctx, wsID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, ErrWorkspaceNotFound)
                }</span>

                <span class="cov0" title="0">present := make(map[string][]menv.Env)
                envMap := make([]*referencev1.ReferenceTreeItem, 0, len(envs))
                var allVars []mvar.Var

                for _, env := range envs </span><span class="cov0" title="0">{
                        vars, err := c.vs.GetVariableByEnvID(ctx, env.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, ErrEnvNotFound)
                        }</span>
                        <span class="cov0" title="0">for _, v := range vars </span><span class="cov0" title="0">{
                                foundEnvs := present[v.VarKey]
                                foundEnvs = append(foundEnvs, env)
                                present[v.VarKey] = foundEnvs
                        }</span>
                        <span class="cov0" title="0">allVars = append(allVars, vars...)</span>
                }

                <span class="cov0" title="0">for _, v := range allVars </span><span class="cov0" title="0">{
                        foundEnvs := present[v.VarKey]
                        var containsEnv []string
                        for _, env := range foundEnvs </span><span class="cov0" title="0">{
                                containsEnv = append(containsEnv, env.Name)
                        }</span>

                        <span class="cov0" title="0">envRef := &amp;referencev1.ReferenceTreeItem{
                                Key: &amp;referencev1.ReferenceKey{
                                        Kind: referencev1.ReferenceKeyKind_REFERENCE_KEY_KIND_KEY,
                                        Key:  &amp;v.VarKey,
                                },
                                Kind:     referencev1.ReferenceKind_REFERENCE_KIND_VARIABLE,
                                Variable: containsEnv,
                        }
                        envMap = append(envMap, envRef)</span>
                }

                <span class="cov0" title="0">groupStr := "env"
                Items = append(Items, &amp;referencev1.ReferenceTreeItem{
                        Key: &amp;referencev1.ReferenceKey{
                                Kind:  referencev1.ReferenceKeyKind_REFERENCE_KEY_KIND_GROUP,
                                Group: &amp;groupStr,
                        },
                        Kind: referencev1.ReferenceKind_REFERENCE_KIND_MAP,
                        Map:  envMap,
                })</span>
        }

        // Example
        <span class="cov8" title="1">if exampleID != nil </span><span class="cov0" title="0">{
                exID := *exampleID

                respRef, err := GetExampleRespByExampleID(ctx, c.ers, c.erhs, exID)
                if err != nil </span><span class="cov0" title="0">{
                        if err != sql.ErrNoRows </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        Items = append(Items, reference.ConvertPkgToRpcTree(*respRef))
                }</span>

        }

        // Node
        <span class="cov8" title="1">if nodeIDPtr != nil </span><span class="cov8" title="1">{
                refs, err := c.HandleNode(ctx, *nodeIDPtr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">Items = append(Items, refs...)</span>
        }

        <span class="cov8" title="1">response := &amp;referencev1.ReferenceTreeResponse{
                Items: Items,
        }
        return connect.NewResponse(response), nil</span>
}

func (c *ReferenceServiceRPC) HandleNode(ctx context.Context, nodeID idwrap.IDWrap) ([]*referencev1.ReferenceTreeItem, error) <span class="cov8" title="1">{
        nodeInst, err := c.fns.GetNode(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">flowID := nodeInst.FlowID
        nodes, err := c.fns.GetNodesByFlowID(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">var nodeRefs []*referencev1.ReferenceTreeItem
        flowVars, err := c.flowVariableService.GetFlowVariablesByFlowID(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">sortenabled.GetAllWithState(&amp;flowVars, true)
        for _, flowVar := range flowVars </span><span class="cov0" title="0">{
                flowVarRef := reference.NewReferenceFromInterfaceWithKey(flowVar.Value, flowVar.Name)
                nodeRefs = append(nodeRefs, reference.ConvertPkgToRpcTree(flowVarRef))
        }</span>

        // Edges
        <span class="cov8" title="1">edges, err := c.flowEdgeService.GetEdgesByFlowID(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">edgesMap := edge.NewEdgesMap(edges)

        beforeNodes := make([]mnnode.MNode, 0, len(nodes))
        for _, node := range nodes </span><span class="cov8" title="1">{
                if edge.IsNodeCheckTarget(edgesMap, node.ID, nodeID) == edge.NodeBefore </span><span class="cov8" title="1">{
                        beforeNodes = append(beforeNodes, node)
                }</span>
        }

        <span class="cov8" title="1">for _, node := range beforeNodes </span><span class="cov8" title="1">{
                // First, try to get execution data for ANY node type
                var nodeData interface{}
                hasExecutionData := false

                executions, err := c.nodeExecutionService.GetNodeExecutionsByNodeID(ctx, node.ID)
                if err == nil &amp;&amp; len(executions) &gt; 0 </span><span class="cov8" title="1">{
                        // Filter out iteration executions from foreach/for nodes
                        // These have names like "Iteration 0", "Iteration 1", "Error Summary" etc.
                        // We want the main node execution which contains the actual written variables
                        var latestExecution *mnodeexecution.NodeExecution
                        for _, exec := range executions </span><span class="cov8" title="1">{
                                if !isIterationExecution(exec.Name) </span><span class="cov8" title="1">{
                                        latestExecution = &amp;exec
                                        break</span>
                                }
                        }

                        // If we found a non-iteration execution, use it
                        <span class="cov8" title="1">if latestExecution != nil </span><span class="cov8" title="1">{
                                // Decompress data if needed
                                data := latestExecution.OutputData
                                if latestExecution.OutputDataCompressType != compress.CompressTypeNone </span><span class="cov0" title="0">{
                                        decompressed, err := compress.Decompress(data, latestExecution.OutputDataCompressType)
                                        if err == nil </span><span class="cov0" title="0">{
                                                data = decompressed
                                        }</span>
                                }

                                // Try to unmarshal as generic JSON
                                <span class="cov8" title="1">var genericOutput interface{}
                                if err := json.Unmarshal(data, &amp;genericOutput); err == nil </span><span class="cov8" title="1">{
                                        nodeData = genericOutput
                                        hasExecutionData = true
                                }</span>
                        }
                }

                // If we have execution data, use it
                <span class="cov8" title="1">if hasExecutionData &amp;&amp; nodeData != nil </span><span class="cov8" title="1">{
                        // The execution data contains the full tree structure from tracker.GetWrittenVarsAsTree()
                        // which already includes node names as top-level keys
                        // We need to extract just the data for this specific node
                        if nodeMap, ok := nodeData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                // Check if the data contains this node's name as a key
                                if nodeSpecificData, hasNodeKey := nodeMap[node.Name]; hasNodeKey </span><span class="cov0" title="0">{
                                        // Use the node-specific data
                                        nodeVarRef := reference.NewReferenceFromInterfaceWithKey(nodeSpecificData, node.Name)
                                        nodeRefs = append(nodeRefs, reference.ConvertPkgToRpcTree(nodeVarRef))
                                }</span> else<span class="cov8" title="1"> {
                                        // Data doesn't have the expected structure, use it as-is
                                        nodeVarRef := reference.NewReferenceFromInterfaceWithKey(nodeData, node.Name)
                                        nodeRefs = append(nodeRefs, reference.ConvertPkgToRpcTree(nodeVarRef))
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Not a map, use directly
                                nodeVarRef := reference.NewReferenceFromInterfaceWithKey(nodeData, node.Name)
                                nodeRefs = append(nodeRefs, reference.ConvertPkgToRpcTree(nodeVarRef))
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // Otherwise, provide schema for specific node types
                <span class="cov8" title="1">switch node.NodeKind </span>{
                case mnnode.NODE_KIND_FOR_EACH:<span class="cov0" title="0">
                        // For foreach loops, they write 'item' and 'key' variables
                        nodeVarsMap := map[string]interface{}{
                                "item": nil, // Can be any type from the iterated collection
                                "key":  0,   // Index for arrays, string key for maps
                        }
                        nodeVarRef := reference.NewReferenceFromInterfaceWithKey(nodeVarsMap, node.Name)
                        nodeRefs = append(nodeRefs, reference.ConvertPkgToRpcTree(nodeVarRef))</span>

                case mnnode.NODE_KIND_FOR:<span class="cov0" title="0">
                        // For for loops, they write 'index' variable
                        nodeVarsMap := map[string]interface{}{
                                "index": 0,
                        }
                        nodeVarRef := reference.NewReferenceFromInterfaceWithKey(nodeVarsMap, node.Name)
                        nodeRefs = append(nodeRefs, reference.ConvertPkgToRpcTree(nodeVarRef))</span>

                case mnnode.NODE_KIND_REQUEST:<span class="cov8" title="1">
                        // For REQUEST nodes, provide the schema structure
                        nodeVarsMap := map[string]interface{}{
                                "request": map[string]interface{}{
                                        "headers": map[string]string{},
                                        "queries": map[string]string{},
                                        "body":    "string",
                                },
                                "response": map[string]interface{}{
                                        "status":   200,
                                        "body":     map[string]interface{}{},
                                        "headers":  map[string]string{},
                                        "duration": 0,
                                },
                        }
                        nodeVarRef := reference.NewReferenceFromInterfaceWithKey(nodeVarsMap, node.Name)
                        nodeRefs = append(nodeRefs, reference.ConvertPkgToRpcTree(nodeVarRef))</span>
                }
                // Other node types (JS, CONDITION, etc.) don't have default schemas
        }

        <span class="cov8" title="1">return nodeRefs, nil</span>
}

func GetExampleRespByExampleID(ctx context.Context, ers sexampleresp.ExampleRespService, erhs sexamplerespheader.ExampleRespHeaderService, exID idwrap.IDWrap) (*reference.ReferenceTreeItem, error) <span class="cov0" title="0">{
        resp, err := ers.GetExampleRespByExampleIDLatest(ctx, exID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">respHeaders, err := erhs.GetHeaderByRespID(ctx, resp.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">headerMap := make(map[string]string)
        for _, header := range respHeaders </span><span class="cov0" title="0">{
                headerVal, ok := headerMap[header.HeaderKey]
                if ok </span><span class="cov0" title="0">{
                        headerMap[header.HeaderKey] = headerVal + ", " + header.Value
                }</span> else<span class="cov0" title="0"> {
                        headerMap[header.HeaderKey] = header.Value
                }</span>
        }

        <span class="cov0" title="0">if resp.BodyCompressType != mexampleresp.BodyCompressTypeNone </span><span class="cov0" title="0">{
                if resp.BodyCompressType == mexampleresp.BodyCompressTypeZstd </span><span class="cov0" title="0">{
                        data, err := zstdcompress.Decompress(resp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">resp.Body = data</span>
                }
        }

        // check if body seems like json; if so decode it into a map[string]interface{}, otherwise use a string.
        <span class="cov0" title="0">var body any
        if json.Valid(resp.Body) </span><span class="cov0" title="0">{
                var jsonBody map[string]any
                // If unmarshaling works, use the decoded JSON.
                if err := json.Unmarshal(resp.Body, &amp;jsonBody); err == nil </span><span class="cov0" title="0">{
                        body = jsonBody
                }</span> else<span class="cov0" title="0"> {
                        body = string(resp.Body)
                }</span>
        } else<span class="cov0" title="0"> {
                body = string(resp.Body)
        }</span>

        // check if body seems like json

        <span class="cov0" title="0">httpResp := httpclient.ResponseVar{
                StatusCode: int(resp.Status),
                Body:       body,
                Headers:    headerMap,
                Duration:   resp.Duration,
        }

        var m map[string]interface{}
        data, err := json.Marshal(httpResp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal(data, &amp;m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">localRef, err := reference.ConvertMapToReference(m, "response")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;localRef, nil</span>
}

// ReferenceCompletion calls reference.v1.ReferenceService.ReferenceCompletion.
func (c *ReferenceServiceRPC) ReferenceCompletion(ctx context.Context, req *connect.Request[referencev1.ReferenceCompletionRequest]) (*connect.Response[referencev1.ReferenceCompletionResponse], error) <span class="cov8" title="1">{

        var workspaceID, exampleID, nodeIDPtr *idwrap.IDWrap
        msg := req.Msg
        if msg.WorkspaceId != nil </span><span class="cov0" title="0">{
                tempID, err := idwrap.NewFromBytes(msg.WorkspaceId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>
                <span class="cov0" title="0">workspaceID = &amp;tempID</span>
        }
        <span class="cov8" title="1">if msg.ExampleId != nil </span><span class="cov0" title="0">{
                tempID, err := idwrap.NewFromBytes(msg.ExampleId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>
                <span class="cov0" title="0">exampleID = &amp;tempID</span>
        }
        <span class="cov8" title="1">if msg.NodeId != nil </span><span class="cov8" title="1">{
                tempID, err := idwrap.NewFromBytes(msg.NodeId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>
                <span class="cov8" title="1">nodeIDPtr = &amp;tempID</span>
        }

        <span class="cov8" title="1">creator := referencecompletion.NewReferenceCompletionCreator()

        // Workspace
        if workspaceID != nil </span><span class="cov0" title="0">{
                wsID := *workspaceID
                rpcErr := permcheck.CheckPerm(rworkspace.CheckOwnerWorkspace(ctx, c.us, wsID))
                if rpcErr != nil </span><span class="cov0" title="0">{
                        return nil, rpcErr
                }</span>
                <span class="cov0" title="0">envs, err := c.es.GetByWorkspace(ctx, wsID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, ErrWorkspaceNotFound)
                }</span>

                <span class="cov0" title="0">for _, env := range envs </span><span class="cov0" title="0">{
                        vars, err := c.vs.GetVariableByEnvID(ctx, env.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, ErrEnvNotFound)
                        }</span>

                        <span class="cov0" title="0">for _, v := range vars </span><span class="cov0" title="0">{
                                creator.AddWithKey(v.VarKey, v.Value)
                        }</span>
                }
        }

        <span class="cov8" title="1">if exampleID != nil </span><span class="cov0" title="0">{
                exID := *exampleID
                resp, err := c.ers.GetExampleRespByExampleIDLatest(ctx, exID)
                if err != nil </span><span class="cov0" title="0">{
                        if err == sexampleresp.ErrNoRespFound </span>{<span class="cov0" title="0">
                        }</span> else<span class="cov0" title="0"> {
                                return nil, err
                        }</span>
                }

                <span class="cov0" title="0">if resp != nil </span><span class="cov0" title="0">{
                        respHeaders, err := c.erhs.GetHeaderByRespID(ctx, resp.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">headerMap := make(map[string]string)
                        for _, header := range respHeaders </span><span class="cov0" title="0">{
                                headerVal, ok := headerMap[header.HeaderKey]
                                if ok </span><span class="cov0" title="0">{
                                        headerMap[header.HeaderKey] = headerVal + ", " + header.Value
                                }</span> else<span class="cov0" title="0"> {
                                        headerMap[header.HeaderKey] = header.Value
                                }</span>
                        }

                        <span class="cov0" title="0">if resp.BodyCompressType != mexampleresp.BodyCompressTypeNone </span><span class="cov0" title="0">{
                                if resp.BodyCompressType == mexampleresp.BodyCompressTypeZstd </span><span class="cov0" title="0">{
                                        data, err := zstdcompress.Decompress(resp.Body)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        <span class="cov0" title="0">resp.Body = data</span>
                                }
                        }

                        // check if body seems like json; if so decode it into a map[string]interface{}, otherwise use a string.
                        <span class="cov0" title="0">var body any
                        if json.Valid(resp.Body) </span><span class="cov0" title="0">{
                                var jsonBody map[string]any
                                // If unmarshaling works, use the decoded JSON.
                                if err := json.Unmarshal(resp.Body, &amp;jsonBody); err == nil </span><span class="cov0" title="0">{
                                        body = jsonBody
                                }</span> else<span class="cov0" title="0"> {
                                        body = string(resp.Body)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                body = string(resp.Body)
                        }</span>

                        // check if body seems like json

                        <span class="cov0" title="0">httpResp := httpclient.ResponseVar{
                                StatusCode: int(resp.Status),
                                Body:       body,
                                Headers:    headerMap,
                                Duration:   resp.Duration,
                        }

                        var m map[string]any
                        data, err := json.Marshal(httpResp)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">err = json.Unmarshal(data, &amp;m)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">creator.AddWithKey("response", m)</span>
                }

        }

        <span class="cov8" title="1">if nodeIDPtr != nil </span><span class="cov8" title="1">{
                nodeID := *nodeIDPtr
                nodeInst, err := c.fns.GetNode(ctx, nodeID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov8" title="1">flowID := nodeInst.FlowID
                nodes, err := c.fns.GetNodesByFlowID(ctx, flowID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov8" title="1">flowVars, err := c.flowVariableService.GetFlowVariablesByFlowID(ctx, flowID)
                if err != nil </span><span class="cov0" title="0">{
                        if err != sflowvariable.ErrNoFlowVariableFound </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>
                        <span class="cov0" title="0">flowVars = []mflowvariable.FlowVariable{}</span>
                }

                <span class="cov8" title="1">sortenabled.GetAllWithState(&amp;flowVars, true)
                for _, flowVar := range flowVars </span><span class="cov0" title="0">{
                        creator.AddWithKey(flowVar.Name, flowVar.Value)
                }</span>

                // Edges
                <span class="cov8" title="1">edges, err := c.flowEdgeService.GetEdgesByFlowID(ctx, flowID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov8" title="1">edgesMap := edge.NewEdgesMap(edges)

                beforeNodes := make([]mnnode.MNode, 0, len(nodes))
                for _, node := range nodes </span><span class="cov8" title="1">{
                        if edge.IsNodeCheckTarget(edgesMap, node.ID, nodeID) == edge.NodeBefore </span><span class="cov8" title="1">{
                                beforeNodes = append(beforeNodes, node)
                        }</span>
                }

                <span class="cov8" title="1">for _, node := range beforeNodes </span><span class="cov8" title="1">{
                        // First, try to get execution data for ANY node type
                        var nodeData interface{}
                        hasExecutionData := false

                        executions, err := c.nodeExecutionService.GetNodeExecutionsByNodeID(ctx, node.ID)
                        if err == nil &amp;&amp; len(executions) &gt; 0 </span><span class="cov8" title="1">{
                                // Use the latest execution (first one, as they're ordered by ID DESC)
                                latestExecution := executions[0]

                                // Decompress data if needed
                                data := latestExecution.OutputData
                                if latestExecution.OutputDataCompressType != compress.CompressTypeNone </span><span class="cov0" title="0">{
                                        decompressed, err := compress.Decompress(data, latestExecution.OutputDataCompressType)
                                        if err == nil </span><span class="cov0" title="0">{
                                                data = decompressed
                                        }</span>
                                }

                                // Try to unmarshal as generic JSON
                                <span class="cov8" title="1">var genericOutput interface{}
                                if err := json.Unmarshal(data, &amp;genericOutput); err == nil </span><span class="cov8" title="1">{
                                        nodeData = genericOutput
                                        hasExecutionData = true
                                }</span>
                        }

                        // If we have execution data, use it
                        <span class="cov8" title="1">if hasExecutionData &amp;&amp; nodeData != nil </span><span class="cov8" title="1">{
                                // The execution data contains the full tree structure from tracker.GetWrittenVarsAsTree()
                                // which already includes node names as top-level keys
                                // We need to extract just the data for this specific node
                                if nodeMap, ok := nodeData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                        // Check if the data contains this node's name as a key
                                        if nodeSpecificData, hasNodeKey := nodeMap[node.Name]; hasNodeKey </span><span class="cov0" title="0">{
                                                // Use the node-specific data
                                                creator.AddWithKey(node.Name, nodeSpecificData)
                                        }</span> else<span class="cov8" title="1"> {
                                                // Data doesn't have the expected structure, use it as-is
                                                creator.AddWithKey(node.Name, nodeData)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // Not a map, use directly
                                        creator.AddWithKey(node.Name, nodeData)
                                }</span>
                                <span class="cov8" title="1">continue</span>
                        }

                        // Otherwise, provide schema for specific node types
                        <span class="cov8" title="1">switch node.NodeKind </span>{
                        case mnnode.NODE_KIND_FOR_EACH:<span class="cov0" title="0">
                                // For foreach loops, they write 'item' and 'key' variables
                                nodeVarsMap := map[string]interface{}{
                                        "item": nil, // Can be any type from the iterated collection
                                        "key":  0,   // Index for arrays, string key for maps
                                }
                                creator.AddWithKey(node.Name, nodeVarsMap)</span>

                        case mnnode.NODE_KIND_FOR:<span class="cov0" title="0">
                                // For for loops, they write 'index' variable
                                nodeVarsMap := map[string]interface{}{
                                        "index": 0,
                                }
                                creator.AddWithKey(node.Name, nodeVarsMap)</span>

                        case mnnode.NODE_KIND_REQUEST:<span class="cov8" title="1">
                                // For REQUEST nodes, provide the schema structure
                                nodeVarsMap := map[string]interface{}{
                                        "request": map[string]interface{}{
                                                "headers": map[string]string{},
                                                "queries": map[string]string{},
                                                "body":    "string",
                                        },
                                        "response": map[string]interface{}{
                                                "status":   200,
                                                "body":     map[string]interface{}{},
                                                "headers":  map[string]string{},
                                                "duration": 0,
                                        },
                                }
                                creator.AddWithKey(node.Name, nodeVarsMap)</span>
                        }
                        // Other node types (JS, CONDITION, etc.) don't have default schemas
                }

                // Add self-reference for FOR and FOREACH nodes so they can reference their own variables
                // This enables break conditions like "if foreach_8.index &gt; 8"
                <span class="cov8" title="1">if nodeIDPtr != nil </span><span class="cov8" title="1">{
                        currentNode, err := c.fns.GetNode(ctx, *nodeIDPtr)
                        if err == nil </span><span class="cov8" title="1">{
                                switch currentNode.NodeKind </span>{
                                case mnnode.NODE_KIND_FOR:<span class="cov8" title="1">
                                        // FOR nodes can reference their own index
                                        nodeVarsMap := map[string]interface{}{
                                                "index": 0,
                                        }
                                        creator.AddWithKey(currentNode.Name, nodeVarsMap)</span>

                                case mnnode.NODE_KIND_FOR_EACH:<span class="cov8" title="1">
                                        // FOREACH nodes can reference their own item and key
                                        nodeVarsMap := map[string]interface{}{
                                                "item": nil,
                                                "key":  0,
                                        }
                                        creator.AddWithKey(currentNode.Name, nodeVarsMap)</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">items := creator.FindMatchAndCalcCompletionData(req.Msg.Start)

        var Items []*referencev1.ReferenceCompletion

        for _, item := range items </span><span class="cov8" title="1">{
                Items = append(Items, &amp;referencev1.ReferenceCompletion{
                        Kind:         referencev1.ReferenceKind(item.Kind),
                        EndToken:     item.EndToken,
                        EndIndex:     item.EndIndex,
                        ItemCount:    item.ItemCount,
                        Environments: item.Environments,
                })
        }</span>

        <span class="cov8" title="1">response := &amp;referencev1.ReferenceCompletionResponse{
                Items: Items,
        }

        return connect.NewResponse(response), nil</span>
}

// ReferenceValue calls reference.v1.ReferenceService.ReferenceValue.
func (c *ReferenceServiceRPC) ReferenceValue(ctx context.Context, req *connect.Request[referencev1.ReferenceValueRequest]) (*connect.Response[referencev1.ReferenceValueResponse], error) <span class="cov8" title="1">{
        var workspaceID, exampleID, nodeIDPtr *idwrap.IDWrap
        msg := req.Msg
        if msg.WorkspaceId != nil </span><span class="cov0" title="0">{
                tempID, err := idwrap.NewFromBytes(msg.WorkspaceId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>
                <span class="cov0" title="0">workspaceID = &amp;tempID</span>
        }
        <span class="cov8" title="1">if msg.ExampleId != nil </span><span class="cov0" title="0">{
                tempID, err := idwrap.NewFromBytes(msg.ExampleId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>
                <span class="cov0" title="0">exampleID = &amp;tempID</span>
        }
        <span class="cov8" title="1">if msg.NodeId != nil </span><span class="cov8" title="1">{
                tempID, err := idwrap.NewFromBytes(msg.NodeId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>
                <span class="cov8" title="1">nodeIDPtr = &amp;tempID</span>
        }

        <span class="cov8" title="1">lookup := referencecompletion.NewReferenceCompletionLookup()

        // Workspace
        if workspaceID != nil </span><span class="cov0" title="0">{
                wsID := *workspaceID
                rpcErr := permcheck.CheckPerm(rworkspace.CheckOwnerWorkspace(ctx, c.us, wsID))
                if rpcErr != nil </span><span class="cov0" title="0">{
                        return nil, rpcErr
                }</span>
                <span class="cov0" title="0">envs, err := c.es.GetByWorkspace(ctx, wsID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, ErrWorkspaceNotFound)
                }</span>

                <span class="cov0" title="0">for _, env := range envs </span><span class="cov0" title="0">{
                        vars, err := c.vs.GetVariableByEnvID(ctx, env.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, ErrEnvNotFound)
                        }</span>

                        <span class="cov0" title="0">for _, v := range vars </span><span class="cov0" title="0">{
                                lookup.AddWithKey(v.VarKey, v.Value)
                        }</span>
                }

        }

        <span class="cov8" title="1">if exampleID != nil </span><span class="cov0" title="0">{
                exID := *exampleID
                resp, err := c.ers.GetExampleRespByExampleIDLatest(ctx, exID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">respHeaders, err := c.erhs.GetHeaderByRespID(ctx, resp.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">headerMap := make(map[string]string)
                for _, header := range respHeaders </span><span class="cov0" title="0">{
                        headerVal, ok := headerMap[header.HeaderKey]
                        if ok </span><span class="cov0" title="0">{
                                headerMap[header.HeaderKey] = headerVal + ", " + header.Value
                        }</span> else<span class="cov0" title="0"> {
                                headerMap[header.HeaderKey] = header.Value
                        }</span>
                }

                <span class="cov0" title="0">if resp.BodyCompressType != mexampleresp.BodyCompressTypeNone </span><span class="cov0" title="0">{
                        if resp.BodyCompressType == mexampleresp.BodyCompressTypeZstd </span><span class="cov0" title="0">{
                                data, err := zstdcompress.Decompress(resp.Body)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">resp.Body = data</span>
                        }
                }

                // check if body seems like json; if so decode it into a map[string]interface{}, otherwise use a string.
                <span class="cov0" title="0">var body any
                if json.Valid(resp.Body) </span><span class="cov0" title="0">{
                        var jsonBody map[string]any
                        // If unmarshaling works, use the decoded JSON.
                        if err := json.Unmarshal(resp.Body, &amp;jsonBody); err == nil </span><span class="cov0" title="0">{
                                body = jsonBody
                        }</span> else<span class="cov0" title="0"> {
                                body = string(resp.Body)
                        }</span>
                } else<span class="cov0" title="0"> {
                        body = string(resp.Body)
                }</span>

                // check if body seems like json

                <span class="cov0" title="0">httpResp := httpclient.ResponseVar{
                        StatusCode: int(resp.Status),
                        Body:       body,
                        Headers:    headerMap,
                        Duration:   resp.Duration,
                }

                var m map[string]any
                data, err := json.Marshal(httpResp)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">err = json.Unmarshal(data, &amp;m)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">lookup.AddWithKey("response", m)</span>
        }

        <span class="cov8" title="1">if nodeIDPtr != nil </span><span class="cov8" title="1">{
                nodeID := *nodeIDPtr
                nodeInst, err := c.fns.GetNode(ctx, nodeID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov8" title="1">flowID := nodeInst.FlowID
                nodes, err := c.fns.GetNodesByFlowID(ctx, flowID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov8" title="1">flowVars, err := c.flowVariableService.GetFlowVariablesByFlowID(ctx, flowID)
                if err != nil </span><span class="cov0" title="0">{
                        if err != sflowvariable.ErrNoFlowVariableFound </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>
                        <span class="cov0" title="0">flowVars = []mflowvariable.FlowVariable{}</span>
                }

                <span class="cov8" title="1">sortenabled.GetAllWithState(&amp;flowVars, true)
                for _, flowVar := range flowVars </span><span class="cov8" title="1">{
                        lookup.AddWithKey(flowVar.Name, flowVar.Value)
                }</span>

                // Edges
                <span class="cov8" title="1">edges, err := c.flowEdgeService.GetEdgesByFlowID(ctx, flowID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov8" title="1">edgesMap := edge.NewEdgesMap(edges)

                beforeNodes := make([]mnnode.MNode, 0, len(nodes))
                for _, node := range nodes </span><span class="cov8" title="1">{
                        if edge.IsNodeCheckTarget(edgesMap, node.ID, nodeID) == edge.NodeBefore </span><span class="cov8" title="1">{
                                beforeNodes = append(beforeNodes, node)
                        }</span>
                }

                <span class="cov8" title="1">for _, node := range beforeNodes </span><span class="cov8" title="1">{
                        // First, try to get execution data for ANY node type
                        var nodeData interface{}
                        hasExecutionData := false

                        executions, err := c.nodeExecutionService.GetNodeExecutionsByNodeID(ctx, node.ID)
                        if err == nil &amp;&amp; len(executions) &gt; 0 </span><span class="cov8" title="1">{
                                // Use the latest execution (first one, as they're ordered by ID DESC)
                                latestExecution := executions[0]

                                // Decompress data if needed
                                data := latestExecution.OutputData
                                if latestExecution.OutputDataCompressType != compress.CompressTypeNone </span><span class="cov0" title="0">{
                                        decompressed, err := compress.Decompress(data, latestExecution.OutputDataCompressType)
                                        if err == nil </span><span class="cov0" title="0">{
                                                data = decompressed
                                        }</span>
                                }

                                // Try to unmarshal as generic JSON
                                <span class="cov8" title="1">var genericOutput interface{}
                                if err := json.Unmarshal(data, &amp;genericOutput); err == nil </span><span class="cov8" title="1">{
                                        nodeData = genericOutput
                                        hasExecutionData = true
                                }</span>
                        }

                        // If we have execution data, use it
                        <span class="cov8" title="1">if hasExecutionData &amp;&amp; nodeData != nil </span><span class="cov8" title="1">{
                                lookup.AddWithKey(node.Name, nodeData)
                                continue</span>
                        }

                        // Otherwise, provide schema for specific node types
                        <span class="cov0" title="0">switch node.NodeKind </span>{
                        case mnnode.NODE_KIND_FOR_EACH:<span class="cov0" title="0">
                                // For foreach loops, they write 'item' and 'key' variables
                                nodeVarsMap := map[string]interface{}{
                                        "item": nil, // Can be any type from the iterated collection
                                        "key":  0,   // Index for arrays, string key for maps
                                }
                                lookup.AddWithKey(node.Name, nodeVarsMap)</span>

                        case mnnode.NODE_KIND_FOR:<span class="cov0" title="0">
                                // For for loops, they write 'index' variable
                                nodeVarsMap := map[string]interface{}{
                                        "index": 0,
                                }
                                lookup.AddWithKey(node.Name, nodeVarsMap)</span>

                        case mnnode.NODE_KIND_REQUEST:<span class="cov0" title="0">
                                // For REQUEST nodes, provide the schema structure
                                nodeVarsMap := map[string]interface{}{
                                        "request": map[string]interface{}{
                                                "headers": map[string]string{},
                                                "queries": map[string]string{},
                                                "body":    "string",
                                        },
                                        "response": map[string]interface{}{
                                                "status":   200,
                                                "body":     map[string]interface{}{},
                                                "headers":  map[string]string{},
                                                "duration": 0,
                                        },
                                }
                                lookup.AddWithKey(node.Name, nodeVarsMap)</span>
                        }
                        // Other node types (JS, CONDITION, etc.) don't have default schemas
                }
        }

        <span class="cov8" title="1">value, err := lookup.GetValue(req.Msg.Path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">response := &amp;referencev1.ReferenceValueResponse{
                Value: value,
        }

        return connect.NewResponse(response), nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package rrequest implements the request RPC service with delta functionality
//
// Delta System Overview:
// The delta system allows versioning of API examples and their components (queries, headers, asserts).
// It tracks modifications while maintaining references to original values.
//
// Key Concepts:
// 1. Origin Example: The base version with no VersionParentID
// 2. Delta Example: A versioned copy with VersionParentID pointing to the origin
// 3. DeltaParentID: Links items in delta examples to their origin counterparts
//
// Source Types (How items are displayed in the frontend):
// - ORIGIN: Unmodified items (shown as inherited)
// - MIXED: Modified items with local changes (shown as customized deltas)
// - DELTA: New items created only in the delta example (no parent)
//
// The frontend interprets these states:
// - ORIGIN items show they inherit from the parent (grayed out, read-only feel)
// - MIXED items show they've been customized (highlighted as modified)
// - DELTA items show they're new additions (marked as new)
//
// Implementation Details:
// The DetermineDeltaType function returns:
// - ORIGIN: Items without DeltaParentID in origin examples
// - MIXED: Items with DeltaParentID in origin examples
// - DELTA: All items in delta examples (with or without DeltaParentID)
//
// For delta examples, the system cannot distinguish between:
// - Unmodified items that inherit from parent (conceptually ORIGIN)
// - Modified items with local changes (conceptually MIXED)
// Both return DELTA because DetermineDeltaType only looks at structure.
//
// The frontend is responsible for visual differentiation of these states.
// Test note: The test expects DELTA for modified items (current behavior),
// though conceptually MIXED might be more intuitive.
//
// Update Flow:
// 1. Delta example created → All items copied with DeltaParentID, source=ORIGIN
// 2. User modifies item → Source remains DELTA (but conceptually is modified)
// 3. User resets item → Values restored from parent (still DELTA structurally)
// 4. Origin item updated → Propagates to unmodified items only
// 5. Origin item deleted → Cascades to all related delta items
//
// This design allows tracking what's been modified while maintaining inheritance.
package rrequest

import (
        "context"
        "database/sql"
        "fmt"
        "sort"
        "strings"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/ritemapiexample"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/massert"
        "the-dev-tools/server/pkg/model/mexampleheader"
        "the-dev-tools/server/pkg/model/mexamplequery"
        "the-dev-tools/server/pkg/permcheck"
        "the-dev-tools/server/pkg/service/sassert"
        "the-dev-tools/server/pkg/service/scollection"
        "the-dev-tools/server/pkg/service/sexampleheader"
        "the-dev-tools/server/pkg/service/sexamplequery"
        "the-dev-tools/server/pkg/service/sitemapi"
        "the-dev-tools/server/pkg/service/sitemapiexample"
        "the-dev-tools/server/pkg/service/suser"
        "the-dev-tools/server/pkg/translate/tassert"
        "the-dev-tools/server/pkg/translate/tcondition"
        "the-dev-tools/server/pkg/translate/tgeneric"
        "the-dev-tools/server/pkg/translate/theader"
        "the-dev-tools/server/pkg/translate/tquery"
        requestv1 "the-dev-tools/spec/dist/buf/go/collection/item/request/v1"
        "the-dev-tools/spec/dist/buf/go/collection/item/request/v1/requestv1connect"
        deltav1 "the-dev-tools/spec/dist/buf/go/delta/v1"
        resourcesv1 "the-dev-tools/spec/dist/buf/go/resources/v1"

        "connectrpc.com/connect"
)

type RequestRPC struct {
        DB   *sql.DB
        cs   scollection.CollectionService
        us   suser.UserService
        iaes sitemapiexample.ItemApiExampleService
        ias  sitemapi.ItemApiService

        // Sub
        ehs sexampleheader.HeaderService
        eqs sexamplequery.ExampleQueryService

        // Assert
        as sassert.AssertService
}

func New(db *sql.DB, cs scollection.CollectionService, us suser.UserService, ias sitemapi.ItemApiService, iaes sitemapiexample.ItemApiExampleService,
        ehs sexampleheader.HeaderService, eqs sexamplequery.ExampleQueryService, as sassert.AssertService,
) RequestRPC <span class="cov8" title="1">{
        return RequestRPC{
                DB:   db,
                cs:   cs,
                us:   us,
                ias:  ias,
                iaes: iaes,
                ehs:  ehs,
                eqs:  eqs,
                as:   as,
        }
}</span>

func CreateService(srv RequestRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := requestv1connect.NewRequestServiceHandler(&amp;srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

func CheckOwnerHeader(ctx context.Context, hs sexampleheader.HeaderService, iaes sitemapiexample.ItemApiExampleService, cs scollection.CollectionService, us suser.UserService, headerUlid idwrap.IDWrap) (bool, error) <span class="cov8" title="1">{
        header, err := hs.GetHeaderByID(ctx, headerUlid)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">return ritemapiexample.CheckOwnerExample(ctx, iaes, cs, us, header.ExampleID)</span>
}

func CheckOwnerQuery(ctx context.Context, qs sexamplequery.ExampleQueryService, iaes sitemapiexample.ItemApiExampleService, cs scollection.CollectionService, us suser.UserService, queryUlid idwrap.IDWrap) (bool, error) <span class="cov8" title="1">{
        query, err := qs.GetExampleQuery(ctx, queryUlid)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return ritemapiexample.CheckOwnerExample(ctx, iaes, cs, us, query.ExampleID)</span>
}

// isExampleDelta checks if an example has a VersionParentID (making it a delta example)
// A delta example is a versioned copy of an origin example, used to track modifications
func (c *RequestRPC) isExampleDelta(ctx context.Context, exampleID idwrap.IDWrap) (bool, error) <span class="cov8" title="1">{
        example, err := c.iaes.GetApiExample(ctx, exampleID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // First check: if example has VersionParentID, it's definitely a delta
        <span class="cov8" title="1">if example.VersionParentID != nil </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        // Second check: if the example belongs to a hidden endpoint, it might be a delta
        // This handles cases where delta examples are created via API without VersionParentID
        <span class="cov8" title="1">endpoint, err := c.ias.GetItemApi(ctx, example.ItemApiID)
        if err != nil </span><span class="cov0" title="0">{
                // If we can't get the endpoint, fall back to the original check
                return false, nil
        }</span>

        // Hidden endpoints are typically delta endpoints created for nodes
        // Combined with the fact that we're calling delta APIs on them, this is a strong signal
        <span class="cov8" title="1">if endpoint.Hidden </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">return false, nil</span>
}

// propagateQueryUpdatesToDeltas finds all delta queries that inherit from the given origin
// and updates them if they haven't been modified (their values match the original values)
func (c *RequestRPC) propagateQueryUpdatesToDeltas(ctx context.Context, originQueryID idwrap.IDWrap, originalQuery, updatedQuery mexamplequery.Query) error <span class="cov8" title="1">{
        // Get the origin example to find delta examples
        originExample, err := c.iaes.GetApiExample(ctx, originalQuery.ExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil // Can't propagate if we can't find the example
        }</span>

        // Find all delta examples that have the origin example as their parent
        <span class="cov8" title="1">deltaExamples, err := c.iaes.GetApiExampleByVersionParentID(ctx, originExample.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil // No delta examples found
        }</span>

        // For each delta example, check if it has queries that reference the origin query
        <span class="cov8" title="1">for _, deltaExample := range deltaExamples </span><span class="cov8" title="1">{
                deltaQueries, err := c.eqs.GetExampleQueriesByExampleID(ctx, deltaExample.ID)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip this example if we can't get its queries
                }

                <span class="cov8" title="1">for _, deltaQuery := range deltaQueries </span><span class="cov8" title="1">{
                        // Check if this delta query references the origin query
                        if deltaQuery.DeltaParentID != nil &amp;&amp; deltaQuery.DeltaParentID.Compare(originQueryID) == 0 </span><span class="cov8" title="1">{
                                // Check if the delta query's values match the ORIGINAL values
                                // If they do, it means the delta hasn't been modified, so we should update it
                                if deltaQuery.QueryKey == originalQuery.QueryKey &amp;&amp;
                                        deltaQuery.Enable == originalQuery.Enable &amp;&amp;
                                        deltaQuery.Value == originalQuery.Value &amp;&amp;
                                        deltaQuery.Description == originalQuery.Description </span><span class="cov8" title="1">{
                                        // Update the delta query to match the new origin values
                                        deltaQuery.QueryKey = updatedQuery.QueryKey
                                        deltaQuery.Enable = updatedQuery.Enable
                                        deltaQuery.Value = updatedQuery.Value
                                        deltaQuery.Description = updatedQuery.Description

                                        err = c.eqs.UpdateExampleQuery(ctx, deltaQuery)
                                        if err != nil </span><span class="cov0" title="0">{
                                                // Continue with other queries even if one fails
                                                continue</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// determineHeaderDeltaType determines the delta type for a header based on relationships
//
// Delta Type System:
// The system uses three source types to track item states in versioned examples:
//
// 1. ORIGIN: Item has no modifications from its parent
//   - In original example: Item with no DeltaParentID (standalone item)
//   - In delta example: Item with DeltaParentID that hasn't been modified yet
//   - Frontend shows these as inherited/unmodified items
//
// 2. MIXED: Item has been modified from its parent (contains local changes)
//   - In original example: Item with DeltaParentID (references another item)
//   - In delta example: Item with DeltaParentID that has been modified
//   - Frontend shows these as modified delta items
//   - This is the expected state after updating a delta item
//
// 3. DELTA: Standalone item in a delta example (no parent reference)
//   - Only exists in delta examples
//   - Item created directly in the delta example without a parent
//   - Has no DeltaParentID
//
// Returns the appropriate HeaderSource based on these rules
func (c *RequestRPC) determineHeaderDeltaType(ctx context.Context, header mexampleheader.Header) (mexampleheader.HeaderSource, error) <span class="cov8" title="1">{
        exampleIsDelta, err := c.isExampleDelta(ctx, header.ExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return mexampleheader.HeaderSourceOrigin, err
        }</span>

        <span class="cov8" title="1">deltaType := header.DetermineDeltaType(exampleIsDelta)
        return deltaType, nil</span>
}

func CheckOwnerAssert(ctx context.Context, as sassert.AssertService, iaes sitemapiexample.ItemApiExampleService, cs scollection.CollectionService, us suser.UserService, assertUlid idwrap.IDWrap) (bool, error) <span class="cov8" title="1">{
        assert, err := as.GetAssert(ctx, assertUlid)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return ritemapiexample.CheckOwnerExample(ctx, iaes, cs, us, assert.ExampleID)</span>
}

func (c RequestRPC) QueryList(ctx context.Context, req *connect.Request[requestv1.QueryListRequest]) (*connect.Response[requestv1.QueryListResponse], error) <span class="cov0" title="0">{
        exID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(
                ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, exID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov0" title="0">allQueries, err := c.eqs.GetExampleQueriesByExampleID(ctx, exID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Check if example has a version parent
        <span class="cov0" title="0">example, err := c.iaes.GetApiExample(ctx, exID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">exampleHasVersionParent := example.VersionParentID != nil

        // Filter to only include origin queries (source = 1)
        var originQueries []mexamplequery.Query
        for _, query := range allQueries </span><span class="cov0" title="0">{
                deltaType := query.DetermineDeltaType(exampleHasVersionParent)
                if deltaType == mexamplequery.QuerySourceOrigin </span><span class="cov0" title="0">{
                        originQueries = append(originQueries, query)
                }</span>
        }

        <span class="cov0" title="0">rpcQueries := tgeneric.MassConvert(originQueries, tquery.SerializeQueryModelToRPCItem)
        resp := &amp;requestv1.QueryListResponse{
                ExampleId: exID.Bytes(),
                Items:     rpcQueries,
        }
        return connect.NewResponse(resp), nil</span>
}

func (c RequestRPC) QueryCreate(ctx context.Context, req *connect.Request[requestv1.QueryCreateRequest]) (*connect.Response[requestv1.QueryCreateResponse], error) <span class="cov8" title="1">{
        exID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(
                ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, exID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">reqQuery := requestv1.Query{
                Key:         req.Msg.GetKey(),
                Enabled:     req.Msg.GetEnabled(),
                Value:       req.Msg.GetValue(),
                Description: req.Msg.GetDescription(),
        }
        query, err := tquery.SerlializeQueryRPCtoModelNoID(&amp;reqQuery, exID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">queryID := idwrap.NewNow()
        query.ID = queryID

        err = c.eqs.CreateExampleQuery(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">return connect.NewResponse(&amp;requestv1.QueryCreateResponse{QueryId: queryID.Bytes()}), nil</span>
}

func (c RequestRPC) QueryUpdate(ctx context.Context, req *connect.Request[requestv1.QueryUpdateRequest]) (*connect.Response[requestv1.QueryUpdateResponse], error) <span class="cov8" title="1">{
        reqQuery := requestv1.Query{
                QueryId:     req.Msg.GetQueryId(),
                Key:         req.Msg.GetKey(),
                Enabled:     req.Msg.GetEnabled(),
                Value:       req.Msg.GetValue(),
                Description: req.Msg.GetDescription(),
        }
        query, err := tquery.SerlializeQueryRPCtoModel(&amp;reqQuery, idwrap.IDWrap{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerQuery(ctx, c.eqs, c.iaes, c.cs, c.us, query.ID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Get the original query values before update
        <span class="cov8" title="1">originalQuery, err := c.eqs.GetExampleQuery(ctx, query.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Update the origin query
        <span class="cov8" title="1">err = c.eqs.UpdateExampleQuery(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Find and update all delta queries that inherit from this origin
        // We need to update queries that:
        // 1. Have this query as their DeltaParentID
        // 2. Have values that match the ORIGINAL values (indicating they haven't been modified)
        // Propagate updates to delta queries
        // This is a best-effort operation - we don't fail the request if propagation fails
        <span class="cov8" title="1">_ = c.propagateQueryUpdatesToDeltas(ctx, query.ID, originalQuery, query)

        return connect.NewResponse(&amp;requestv1.QueryUpdateResponse{}), nil</span>
}

func (c RequestRPC) QueryDelete(ctx context.Context, req *connect.Request[requestv1.QueryDeleteRequest]) (*connect.Response[requestv1.QueryDeleteResponse], error) <span class="cov8" title="1">{
        queryID, err := idwrap.NewFromBytes(req.Msg.GetQueryId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerQuery(ctx, c.eqs, c.iaes, c.cs, c.us, queryID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Get the query to check if it's an origin query and get its example ID
        <span class="cov8" title="1">originQuery, err := c.eqs.GetExampleQuery(ctx, queryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Get the example to determine if it has a version parent
        <span class="cov8" title="1">example, err := c.iaes.GetApiExample(ctx, originQuery.ExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">exampleHasVersionParent := example.VersionParentID != nil

        // Determine if this is an origin query
        originDeltaType := originQuery.DetermineDeltaType(exampleHasVersionParent)
        if originDeltaType == mexamplequery.QuerySourceOrigin </span><span class="cov8" title="1">{
                // Need to find and delete delta queries in OTHER examples that reference this origin
                // Get all examples in the collection to search for delta queries
                examples, err := c.iaes.GetApiExampleByCollection(ctx, example.CollectionID)
                if err == nil </span><span class="cov8" title="1">{
                        for _, ex := range examples </span><span class="cov8" title="1">{
                                // Check all examples (both origin and delta) for queries that reference this one
                                deltaQueries, err := c.eqs.GetExampleQueriesByExampleID(ctx, ex.ID)
                                if err == nil </span><span class="cov8" title="1">{
                                        for _, deltaQuery := range deltaQueries </span><span class="cov8" title="1">{
                                                if deltaQuery.DeltaParentID != nil &amp;&amp;
                                                        deltaQuery.DeltaParentID.Compare(queryID) == 0 </span><span class="cov0" title="0">{
                                                        // Delete this delta query that references the origin being deleted
                                                        _ = c.eqs.DeleteExampleQuery(ctx, deltaQuery.ID)
                                                }</span>
                                        }
                                }
                        }
                }

                // ADDITIONAL WORKAROUND: Also check for delta examples that have this example as their parent
                // This is needed because GetApiExampleByCollection may not return all examples
                <span class="cov8" title="1">deltaExamples, err := c.iaes.GetApiExampleByVersionParentID(ctx, example.ID)
                if err == nil </span><span class="cov8" title="1">{
                        for _, deltaExample := range deltaExamples </span><span class="cov8" title="1">{
                                // Check for queries in these delta examples that reference the origin query
                                deltaQueries, err := c.eqs.GetExampleQueriesByExampleID(ctx, deltaExample.ID)
                                if err == nil </span><span class="cov8" title="1">{
                                        for _, deltaQuery := range deltaQueries </span><span class="cov8" title="1">{
                                                if deltaQuery.DeltaParentID != nil &amp;&amp;
                                                        deltaQuery.DeltaParentID.Compare(queryID) == 0 </span><span class="cov8" title="1">{
                                                        // Delete this delta query that references the origin being deleted
                                                        _ = c.eqs.DeleteExampleQuery(ctx, deltaQuery.ID)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        // Delete the origin query itself
        <span class="cov8" title="1">err = c.eqs.DeleteExampleQuery(ctx, queryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;requestv1.QueryDeleteResponse{}), nil</span>
}

// QueryDeltaExampleCopy copies all queries from an origin example to a delta example
// This implements the "Delta example create" functionality
//
// When creating a delta example, all items from the origin are copied with:
// - DeltaParentID pointing to the origin item
// - Initial source type of ORIGIN (unmodified)
// - Same values as the origin
//
// This allows the delta example to track which items have been modified later
func (c RequestRPC) QueryDeltaExampleCopy(ctx context.Context, originExampleID, deltaExampleID idwrap.IDWrap) error <span class="cov8" title="1">{
        // Check permissions for both examples
        rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, originExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return rpcErr
        }</span>
        <span class="cov8" title="1">rpcErr = permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, deltaExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return rpcErr
        }</span>

        // Get the origin example to determine if it has a version parent
        <span class="cov8" title="1">originExample, err := c.iaes.GetApiExample(ctx, originExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">originExampleHasVersionParent := originExample.VersionParentID != nil

        // Get all queries from the origin example
        originQueries, err := c.eqs.GetExampleQueriesByExampleID(ctx, originExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create corresponding queries in the delta example
        <span class="cov8" title="1">var deltaQueries []mexamplequery.Query
        for _, originQuery := range originQueries </span><span class="cov8" title="1">{
                // Only copy origin queries (not mixed or delta queries)
                originDeltaType := originQuery.DetermineDeltaType(originExampleHasVersionParent)
                if originDeltaType == mexamplequery.QuerySourceOrigin </span><span class="cov8" title="1">{
                        deltaQuery := mexamplequery.Query{
                                ID:            idwrap.NewNow(),
                                ExampleID:     deltaExampleID,
                                DeltaParentID: &amp;originQuery.ID, // Reference the origin query
                                QueryKey:      originQuery.QueryKey,
                                Enable:        originQuery.Enable,
                                Description:   originQuery.Description,
                                Value:         originQuery.Value,
                        }
                        deltaQueries = append(deltaQueries, deltaQuery)
                }</span>
        }

        // Bulk create all delta queries
        <span class="cov8" title="1">if len(deltaQueries) &gt; 0 </span><span class="cov8" title="1">{
                err = c.eqs.CreateBulkQuery(ctx, deltaQueries)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (c RequestRPC) QueryDeltaDelete(ctx context.Context, req *connect.Request[requestv1.QueryDeltaDeleteRequest]) (*connect.Response[requestv1.QueryDeltaDeleteResponse], error) <span class="cov0" title="0">{
        queryID, err := idwrap.NewFromBytes(req.Msg.GetQueryId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(CheckOwnerQuery(ctx, c.eqs, c.iaes, c.cs, c.us, queryID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov0" title="0">err = c.eqs.DeleteExampleQuery(ctx, queryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">return connect.NewResponse(&amp;requestv1.QueryDeltaDeleteResponse{}), nil</span>
}

// QueryDeltaList returns the combined view of queries in a delta example
//
// This function merges queries from both origin and delta examples to show:
// 1. Delta/Mixed items that have been modified (shown with their current values)
// 2. Origin items that haven't been touched yet (automatically created if missing)
//
// The frontend uses this to display a complete view where:
// - ORIGIN items show they're inherited (no local changes)
// - MIXED items show they've been modified (have local changes)
// - DELTA items show they're new in this version (no parent)
func (c RequestRPC) QueryDeltaList(ctx context.Context, req *connect.Request[requestv1.QueryDeltaListRequest]) (*connect.Response[requestv1.QueryDeltaListResponse], error) <span class="cov8" title="1">{
        // Parse both example IDs
        deltaExampleID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">originExampleID, err := idwrap.NewFromBytes(req.Msg.GetOriginId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // Check permissions for both examples
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, deltaExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">rpcErr = permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, originExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Check if delta example has a version parent
        <span class="cov8" title="1">deltaExample, err := c.iaes.GetApiExample(ctx, deltaExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">deltaExampleHasVersionParent := deltaExample.VersionParentID != nil

        // Get queries from both origin and delta examples
        originQueries, err := c.eqs.GetExampleQueriesByExampleID(ctx, originExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">deltaQueries, err := c.eqs.GetExampleQueriesByExampleID(ctx, deltaExampleID)
        if err != nil &amp;&amp; err != sexamplequery.ErrNoQueryFound </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">if err == sexamplequery.ErrNoQueryFound </span><span class="cov0" title="0">{
                deltaQueries = []mexamplequery.Query{}
        }</span>

        // Combine all queries and build maps for lookup
        <span class="cov8" title="1">allQueries := append(originQueries, deltaQueries...)
        queryMap := make(map[idwrap.IDWrap]mexamplequery.Query)
        originMap := make(map[idwrap.IDWrap]*requestv1.Query)

        // Build maps
        for _, query := range allQueries </span><span class="cov8" title="1">{
                queryMap[query.ID] = query
                originMap[query.ID] = tquery.SerializeQueryModelToRPC(query)
        }</span>

        // First pass: identify which origins are replaced by delta/mixed queries
        // This tracks which origin items already have corresponding delta items
        <span class="cov8" title="1">processedOrigins := make(map[idwrap.IDWrap]bool)
        for _, query := range allQueries </span><span class="cov8" title="1">{
                deltaType := query.DetermineDeltaType(deltaExampleHasVersionParent)
                if (deltaType == mexamplequery.QuerySourceDelta || deltaType == mexamplequery.QuerySourceMixed) &amp;&amp; query.DeltaParentID != nil </span><span class="cov8" title="1">{
                        processedOrigins[*query.DeltaParentID] = true
                }</span>
        }

        // Build a map of existing delta queries by key to avoid duplicates
        <span class="cov8" title="1">deltaQueriesByKey := make(map[string]bool)
        for _, query := range deltaQueries </span><span class="cov8" title="1">{
                deltaQueriesByKey[strings.ToLower(query.QueryKey)] = true
        }</span>

        // Collect origin queries that need delta entries created
        // These are origin items that don't have corresponding delta items yet
        // We'll create ORIGIN-type delta items for them to show they're inherited
        <span class="cov8" title="1">var originQueriesNeedingDeltas []mexamplequery.Query
        for _, query := range originQueries </span><span class="cov8" title="1">{ // Only check origin queries
                if !processedOrigins[query.ID] &amp;&amp; // If not already processed by a delta
                        !deltaQueriesByKey[strings.ToLower(query.QueryKey)] </span><span class="cov8" title="1">{ // And no query with same key exists
                        originQueriesNeedingDeltas = append(originQueriesNeedingDeltas, query)
                }</span>
        }

        // Create delta entries for origin queries that don't have them
        <span class="cov8" title="1">newDeltaQueries := make(map[idwrap.IDWrap]mexamplequery.Query)
        if len(originQueriesNeedingDeltas) &gt; 0 </span><span class="cov8" title="1">{
                var deltaQueriesToCreate []mexamplequery.Query
                for _, originQuery := range originQueriesNeedingDeltas </span><span class="cov8" title="1">{
                        deltaQuery := mexamplequery.Query{
                                ID:            idwrap.NewNow(),
                                ExampleID:     deltaExampleID,
                                DeltaParentID: &amp;originQuery.ID,
                                QueryKey:      originQuery.QueryKey,
                                Enable:        originQuery.Enable,
                                Description:   originQuery.Description,
                                Value:         originQuery.Value,
                        }
                        deltaQueriesToCreate = append(deltaQueriesToCreate, deltaQuery)
                        newDeltaQueries[originQuery.ID] = deltaQuery
                }</span>

                // Bulk create the delta queries
                <span class="cov8" title="1">if len(deltaQueriesToCreate) &gt; 0 </span><span class="cov8" title="1">{
                        err = c.eqs.CreateBulkQuery(ctx, deltaQueriesToCreate)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>
                        // Add newly created queries to allQueries so they're processed in the main loop
                        <span class="cov8" title="1">allQueries = append(allQueries, deltaQueriesToCreate...)</span>
                }
        }

        // Second pass: create result entries
        <span class="cov8" title="1">var rpcQueries []*requestv1.QueryDeltaListItem
        for _, query := range allQueries </span><span class="cov8" title="1">{
                // Only include queries that belong to the delta example
                if query.ExampleID.Compare(deltaExampleID) != 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">deltaType := query.DetermineDeltaType(deltaExampleHasVersionParent)
                if deltaType == mexamplequery.QuerySourceDelta || deltaType == mexamplequery.QuerySourceMixed </span><span class="cov8" title="1">{
                        if query.DeltaParentID != nil </span><span class="cov8" title="1">{
                                // This is a delta query - check if it's been modified from its parent
                                var origin *requestv1.Query
                                var actualSourceKind deltav1.SourceKind

                                if originRPC, exists := originMap[*query.DeltaParentID]; exists </span><span class="cov8" title="1">{
                                        origin = originRPC

                                        // Compare with parent to determine if modified
                                        if parentQuery, exists := queryMap[*query.DeltaParentID]; exists </span><span class="cov8" title="1">{
                                                if query.QueryKey == parentQuery.QueryKey &amp;&amp;
                                                        query.Enable == parentQuery.Enable &amp;&amp;
                                                        query.Value == parentQuery.Value &amp;&amp;
                                                        query.Description == parentQuery.Description </span><span class="cov8" title="1">{
                                                        // Values match parent - this is an unmodified delta (ORIGIN)
                                                        actualSourceKind = deltav1.SourceKind_SOURCE_KIND_ORIGIN
                                                }</span> else<span class="cov8" title="1"> {
                                                        // Values differ from parent - this is a modified delta (MIXED)
                                                        actualSourceKind = deltav1.SourceKind_SOURCE_KIND_MIXED
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                // Parent not found, treat as DELTA
                                                actualSourceKind = deltav1.SourceKind_SOURCE_KIND_DELTA
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // No origin found, this is a standalone DELTA
                                        actualSourceKind = deltav1.SourceKind_SOURCE_KIND_DELTA
                                }</span>

                                // Build the response based on the source kind
                                <span class="cov8" title="1">var rpcQuery *requestv1.QueryDeltaListItem
                                if actualSourceKind == deltav1.SourceKind_SOURCE_KIND_ORIGIN &amp;&amp; origin != nil </span><span class="cov8" title="1">{
                                        // For ORIGIN items, use the parent's values to reflect inheritance
                                        rpcQuery = &amp;requestv1.QueryDeltaListItem{
                                                QueryId:     query.ID.Bytes(),
                                                Key:         origin.Key,
                                                Enabled:     origin.Enabled,
                                                Value:       origin.Value,
                                                Description: origin.Description,
                                                Origin:      origin,
                                                Source:      &amp;actualSourceKind,
                                        }
                                }</span> else<span class="cov8" title="1"> {
                                        // For DELTA/MIXED items, use the delta's values
                                        rpcQuery = &amp;requestv1.QueryDeltaListItem{
                                                QueryId:     query.ID.Bytes(),
                                                Key:         query.QueryKey,
                                                Enabled:     query.Enable,
                                                Value:       query.Value,
                                                Description: query.Description,
                                                Origin:      origin,
                                                Source:      &amp;actualSourceKind,
                                        }
                                }</span>
                                <span class="cov8" title="1">rpcQueries = append(rpcQueries, rpcQuery)</span>
                        } else<span class="cov8" title="1"> {
                                // This is a new query created in the delta (no parent)
                                sourceKind := deltaType.ToSourceKind()
                                rpcQuery := &amp;requestv1.QueryDeltaListItem{
                                        QueryId:     query.ID.Bytes(),
                                        Key:         query.QueryKey,
                                        Enabled:     query.Enable,
                                        Value:       query.Value,
                                        Description: query.Description,
                                        Origin:      nil, // No origin for new queries
                                        Source:      &amp;sourceKind,
                                }
                                rpcQueries = append(rpcQueries, rpcQuery)
                        }</span>
                }
                // Note: MIXED queries won't appear here since we're only processing delta example queries
        }

        // Newly created delta queries are now processed in the main loop above

        // Sort rpcQueries by ID, but if it has DeltaParentID use that ID instead
        <span class="cov8" title="1">sort.Slice(rpcQueries, func(i, j int) bool </span><span class="cov8" title="1">{
                idI, _ := idwrap.NewFromBytes(rpcQueries[i].QueryId)
                idJ, _ := idwrap.NewFromBytes(rpcQueries[j].QueryId)

                // Determine the ID to use for sorting for item i
                sortIDI := idI
                if rpcQueries[i].Origin != nil &amp;&amp; len(rpcQueries[i].Origin.QueryId) &gt; 0 </span><span class="cov8" title="1">{
                        if parentID, err := idwrap.NewFromBytes(rpcQueries[i].Origin.QueryId); err == nil </span><span class="cov8" title="1">{
                                sortIDI = parentID
                        }</span>
                }

                // Determine the ID to use for sorting for item j
                <span class="cov8" title="1">sortIDJ := idJ
                if rpcQueries[j].Origin != nil &amp;&amp; len(rpcQueries[j].Origin.QueryId) &gt; 0 </span><span class="cov8" title="1">{
                        if parentID, err := idwrap.NewFromBytes(rpcQueries[j].Origin.QueryId); err == nil </span><span class="cov8" title="1">{
                                sortIDJ = parentID
                        }</span>
                }

                <span class="cov8" title="1">return sortIDI.Compare(sortIDJ) &lt; 0</span>
        })

        <span class="cov8" title="1">resp := &amp;requestv1.QueryDeltaListResponse{
                ExampleId: deltaExampleID.Bytes(),
                Items:     rpcQueries,
        }
        return connect.NewResponse(resp), nil</span>
}

func (c RequestRPC) QueryDeltaCreate(ctx context.Context, req *connect.Request[requestv1.QueryDeltaCreateRequest]) (*connect.Response[requestv1.QueryDeltaCreateResponse], error) <span class="cov8" title="1">{
        exID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, exID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Get origin example ID from request
        <span class="cov8" title="1">originExampleID, err := idwrap.NewFromBytes(req.Msg.GetOriginId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        // Check permissions for origin example as well
        <span class="cov8" title="1">rpcErr = permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, originExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">reqQuery := requestv1.Query{
                Key:         req.Msg.GetKey(),
                Enabled:     req.Msg.GetEnabled(),
                Value:       req.Msg.GetValue(),
                Description: req.Msg.GetDescription(),
        }
        query, err := tquery.SerlializeQueryRPCtoModelNoIDForDelta(&amp;reqQuery, exID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">queryID := idwrap.NewNow()
        query.ID = queryID

        // Check if query_id is provided in request
        if len(req.Msg.GetQueryId()) &gt; 0 </span><span class="cov0" title="0">{
                // Query ID is provided, verify it exists and use as delta parent
                parentQueryID, err := idwrap.NewFromBytes(req.Msg.GetQueryId())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>

                // Verify the parent query exists
                <span class="cov0" title="0">parentQuery, err := c.eqs.GetExampleQuery(ctx, parentQueryID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>

                // Verify parent query relationship (same logic as headers)
                <span class="cov0" title="0">if parentQuery.ExampleID.Compare(originExampleID) == 0 </span><span class="cov0" title="0">{
                        // Parent belongs to origin example, use it directly
                        query.DeltaParentID = &amp;parentQueryID
                }</span> else<span class="cov0" title="0"> {
                        // Parent doesn't belong to origin example
                        if parentQuery.DeltaParentID != nil </span><span class="cov0" title="0">{
                                // This is a delta query, use its DeltaParentID
                                query.DeltaParentID = parentQuery.DeltaParentID
                        }</span> else<span class="cov0" title="0"> {
                                // Check if the parent example is related to origin
                                parentExample, err := c.iaes.GetApiExample(ctx, parentQuery.ExampleID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, connect.NewError(connect.CodeInternal, err)
                                }</span>

                                <span class="cov0" title="0">if parentExample.VersionParentID != nil &amp;&amp; parentExample.VersionParentID.Compare(originExampleID) == 0 </span><span class="cov0" title="0">{
                                        query.DeltaParentID = &amp;parentQueryID
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, connect.NewError(connect.CodeInvalidArgument,
                                                fmt.Errorf("parent query does not have a valid relationship to the origin example"))
                                }</span>
                        }
                }
        }
        // If no query_id provided, DeltaParentID remains nil (standalone delta)

        <span class="cov8" title="1">err = c.eqs.CreateExampleQuery(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">return connect.NewResponse(&amp;requestv1.QueryDeltaCreateResponse{QueryId: queryID.Bytes()}), nil</span>
}

// QueryDeltaUpdate updates a delta query with new values
//
// Important behavior: When a delta item is updated, it transitions from:
// - ORIGIN -&gt; MIXED (if it was unmodified, now has local changes)
// - MIXED -&gt; MIXED (stays mixed with new local changes)
// - DELTA -&gt; DELTA (standalone items remain standalone)
//
// The transition to MIXED is automatic based on the DetermineDeltaType logic
// Frontend uses MIXED state to show this item has been customized
func (c RequestRPC) QueryDeltaUpdate(ctx context.Context, req *connect.Request[requestv1.QueryDeltaUpdateRequest]) (*connect.Response[requestv1.QueryDeltaUpdateResponse], error) <span class="cov8" title="1">{
        queryID, err := idwrap.NewFromBytes(req.Msg.GetQueryId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerQuery(ctx, c.eqs, c.iaes, c.cs, c.us, queryID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Get the existing query to check its source
        <span class="cov8" title="1">existingQuery, err := c.eqs.GetExampleQuery(ctx, queryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Apply partial updates - only update fields that are provided
        <span class="cov8" title="1">if req.Msg.Key != nil </span><span class="cov8" title="1">{
                existingQuery.QueryKey = *req.Msg.Key
        }</span>
        <span class="cov8" title="1">if req.Msg.Enabled != nil </span><span class="cov8" title="1">{
                existingQuery.Enable = *req.Msg.Enabled
        }</span>
        <span class="cov8" title="1">if req.Msg.Value != nil </span><span class="cov8" title="1">{
                existingQuery.Value = *req.Msg.Value
        }</span>
        <span class="cov8" title="1">if req.Msg.Description != nil </span><span class="cov8" title="1">{
                existingQuery.Description = *req.Msg.Description
        }</span>

        <span class="cov8" title="1">err = c.eqs.UpdateExampleQuery(ctx, existingQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;requestv1.QueryDeltaUpdateResponse{}), nil</span>
}

// QueryDeltaReset resets a delta query to its origin values
//
// Reset behavior:
//   - If item has DeltaParentID: Restores all values from the parent
//     This transitions the item from MIXED -&gt; ORIGIN (removes local changes)
//   - If item has no DeltaParentID: Clears all fields (DELTA items)
//
// This allows users to undo modifications and return to inherited values
func (c RequestRPC) QueryDeltaReset(ctx context.Context, req *connect.Request[requestv1.QueryDeltaResetRequest]) (*connect.Response[requestv1.QueryDeltaResetResponse], error) <span class="cov8" title="1">{
        queryID, err := idwrap.NewFromBytes(req.Msg.GetQueryId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerQuery(ctx, c.eqs, c.iaes, c.cs, c.us, queryID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Get the delta query
        <span class="cov8" title="1">deltaQuery, err := c.eqs.GetExampleQuery(ctx, queryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // If the query has a parent, restore values from parent
        <span class="cov8" title="1">if deltaQuery.DeltaParentID != nil </span><span class="cov8" title="1">{
                // Restore values from parent
                parentQuery, err := c.eqs.GetExampleQuery(ctx, *deltaQuery.DeltaParentID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>

                // Restore delta query fields to match parent
                // This makes the item ORIGIN again (no local modifications)
                <span class="cov8" title="1">deltaQuery.QueryKey = parentQuery.QueryKey
                deltaQuery.Enable = parentQuery.Enable
                deltaQuery.Description = parentQuery.Description
                deltaQuery.Value = parentQuery.Value

                err = c.eqs.UpdateExampleQuery(ctx, deltaQuery)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        } else<span class="cov8" title="1"> {
                // If no parent, use the original reset behavior (clear fields)
                // This is for standalone DELTA items
                err = c.eqs.ResetExampleQueryDelta(ctx, queryID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov8" title="1">return connect.NewResponse(&amp;requestv1.QueryDeltaResetResponse{}), nil</span>
}

func (c RequestRPC) HeaderList(ctx context.Context, req *connect.Request[requestv1.HeaderListRequest]) (*connect.Response[requestv1.HeaderListResponse], error) <span class="cov8" title="1">{
        exID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, exID))
        if rpcErr != nil </span><span class="cov8" title="1">{
                return nil, rpcErr
        }</span>

        // Use the ordered version that traverses the linked list
        <span class="cov8" title="1">allHeaders, err := c.ehs.GetHeaderByExampleIDOrdered(ctx, exID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Filter to only include origin headers
        <span class="cov8" title="1">var originHeaders []mexampleheader.Header
        for _, header := range allHeaders </span><span class="cov8" title="1">{
                deltaType, err := c.determineHeaderDeltaType(ctx, header)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov8" title="1">if deltaType == mexampleheader.HeaderSourceOrigin </span><span class="cov8" title="1">{
                        originHeaders = append(originHeaders, header)
                }</span>
        }

        <span class="cov8" title="1">rpcHeaders := tgeneric.MassConvert(originHeaders, theader.SerializeHeaderModelToRPCItem)
        resp := &amp;requestv1.HeaderListResponse{
                ExampleId: exID.Bytes(),
                Items:     rpcHeaders,
        }
        return connect.NewResponse(resp), nil</span>
}

func (c RequestRPC) HeaderCreate(ctx context.Context, req *connect.Request[requestv1.HeaderCreateRequest]) (*connect.Response[requestv1.HeaderCreateResponse], error) <span class="cov8" title="1">{
        exID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, exID))
        if rpcErr != nil </span><span class="cov8" title="1">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">rpcHeader := requestv1.Header{
                Key:         req.Msg.GetKey(),
                Enabled:     req.Msg.GetEnabled(),
                Value:       req.Msg.GetValue(),
                Description: req.Msg.GetDescription(),
        }
        headerID := idwrap.NewNow()
        var deltaParentIDPtr *idwrap.IDWrap
        header := theader.SerlializeHeaderRPCtoModelNoID(&amp;rpcHeader, exID, deltaParentIDPtr)
        header.ID = headerID

        // Note: Source field removed - delta type is determined dynamically

        // Use AppendHeader to properly add the header to the end of the linked list
        err = c.ehs.AppendHeader(ctx, header)
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;requestv1.HeaderCreateResponse{HeaderId: headerID.Bytes()}), nil</span>
}

func (c RequestRPC) HeaderUpdate(ctx context.Context, req *connect.Request[requestv1.HeaderUpdateRequest]) (*connect.Response[requestv1.HeaderUpdateResponse], error) <span class="cov8" title="1">{
        rpcHeader := requestv1.Header{
                HeaderId:    req.Msg.GetHeaderId(),
                Key:         req.Msg.GetKey(),
                Enabled:     req.Msg.GetEnabled(),
                Value:       req.Msg.GetValue(),
                Description: req.Msg.GetDescription(),
        }
        header, err := theader.SerlializeHeaderRPCtoModel(&amp;rpcHeader, idwrap.IDWrap{})
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerHeader(ctx, c.ehs, c.iaes, c.cs, c.us, header.ID))
        if rpcErr != nil </span><span class="cov8" title="1">{
                return nil, rpcErr
        }</span>

        // Update the origin header
        // Note: Source field removed - delta type is determined dynamically
        <span class="cov8" title="1">err = c.ehs.UpdateHeader(ctx, header)
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Propagate changes to delta items with "origin" source that reference this header
        <span class="cov8" title="1">originHeader, err := c.ehs.GetHeaderByID(ctx, header.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Get all headers from this example to find any that reference this origin header
        <span class="cov8" title="1">allHeaders, err := c.ehs.GetHeaderByExampleID(ctx, originHeader.ExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Update any delta headers that reference this origin header with source="origin"
        <span class="cov8" title="1">for _, deltaHeader := range allHeaders </span><span class="cov8" title="1">{
                if deltaHeader.DeltaParentID != nil &amp;&amp;
                        deltaHeader.DeltaParentID.Compare(header.ID) == 0 </span><span class="cov0" title="0">{

                        deltaType, err := c.determineHeaderDeltaType(ctx, deltaHeader)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>

                        <span class="cov0" title="0">if deltaType == mexampleheader.HeaderSourceOrigin </span><span class="cov0" title="0">{
                                // Update the delta header to match the origin
                                deltaHeader.HeaderKey = header.HeaderKey
                                deltaHeader.Enable = header.Enable
                                deltaHeader.Description = header.Description
                                deltaHeader.Value = header.Value

                                err = c.ehs.UpdateHeader(ctx, deltaHeader)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, connect.NewError(connect.CodeInternal, err)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return connect.NewResponse(&amp;requestv1.HeaderUpdateResponse{}), nil</span>
}

func (c RequestRPC) HeaderDelete(ctx context.Context, req *connect.Request[requestv1.HeaderDeleteRequest]) (*connect.Response[requestv1.HeaderDeleteResponse], error) <span class="cov8" title="1">{
        headerID, err := idwrap.NewFromBytes(req.Msg.GetHeaderId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerHeader(ctx, c.ehs, c.iaes, c.cs, c.us, headerID))
        if rpcErr != nil </span><span class="cov8" title="1">{
                return nil, rpcErr
        }</span>

        // Get the header to check if it's an origin header and get its example ID
        <span class="cov8" title="1">originHeader, err := c.ehs.GetHeaderByID(ctx, headerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // If this is an origin header, delete all delta items with "origin" or "mixed" source that reference it
        <span class="cov8" title="1">deltaType, err := c.determineHeaderDeltaType(ctx, originHeader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">if deltaType == mexampleheader.HeaderSourceOrigin </span><span class="cov8" title="1">{
                // Need to find and delete delta headers in OTHER examples that reference this origin
                // Get the example to find the collection
                example, err := c.iaes.GetApiExample(ctx, originHeader.ExampleID)
                if err == nil </span><span class="cov8" title="1">{
                        // Get all examples in the collection to search for delta headers
                        examples, err := c.iaes.GetApiExampleByCollection(ctx, example.CollectionID)
                        if err == nil </span><span class="cov8" title="1">{
                                for _, ex := range examples </span><span class="cov8" title="1">{
                                        // Check all examples for headers that reference this one
                                        deltaHeaders, err := c.ehs.GetHeaderByExampleID(ctx, ex.ID)
                                        if err == nil </span><span class="cov8" title="1">{
                                                for _, deltaHeader := range deltaHeaders </span><span class="cov8" title="1">{
                                                        if deltaHeader.DeltaParentID != nil &amp;&amp;
                                                                deltaHeader.DeltaParentID.Compare(headerID) == 0 </span><span class="cov0" title="0">{
                                                                // Delete this delta header that references the origin being deleted
                                                                _ = c.ehs.DeleteHeader(ctx, deltaHeader.ID)
                                                        }</span>
                                                }
                                        }
                                }
                        }

                        // ADDITIONAL WORKAROUND: Also check for delta examples that have this example as their parent
                        // This is needed because GetApiExampleByCollection may not return all examples
                        <span class="cov8" title="1">deltaExamples, err := c.iaes.GetApiExampleByVersionParentID(ctx, example.ID)
                        if err == nil </span><span class="cov8" title="1">{
                                for _, deltaExample := range deltaExamples </span><span class="cov8" title="1">{
                                        // Check for headers in these delta examples that reference the origin header
                                        deltaHeaders, err := c.ehs.GetHeaderByExampleID(ctx, deltaExample.ID)
                                        if err == nil </span><span class="cov8" title="1">{
                                                for _, deltaHeader := range deltaHeaders </span><span class="cov8" title="1">{
                                                        if deltaHeader.DeltaParentID != nil &amp;&amp;
                                                                deltaHeader.DeltaParentID.Compare(headerID) == 0 </span><span class="cov8" title="1">{
                                                                // Delete this delta header that references the origin being deleted
                                                                _ = c.ehs.DeleteHeader(ctx, deltaHeader.ID)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        // Delete the origin header itself
        <span class="cov8" title="1">err = c.ehs.DeleteHeader(ctx, headerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">return connect.NewResponse(&amp;requestv1.HeaderDeleteResponse{}), nil</span>
}

// HeaderDeltaExampleCopy copies all headers from an origin example to a delta example
// This implements the "Delta example create" functionality
func (c RequestRPC) HeaderDeltaExampleCopy(ctx context.Context, originExampleID, deltaExampleID idwrap.IDWrap) error <span class="cov8" title="1">{
        // Check permissions for both examples
        rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, originExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return rpcErr
        }</span>
        <span class="cov8" title="1">rpcErr = permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, deltaExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return rpcErr
        }</span>

        // Get all headers from the origin example
        <span class="cov8" title="1">originHeaders, err := c.ehs.GetHeaderByExampleID(ctx, originExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create corresponding headers in the delta example
        <span class="cov8" title="1">var deltaHeaders []mexampleheader.Header
        for _, originHeader := range originHeaders </span><span class="cov8" title="1">{
                // Only copy origin headers (not mixed or delta headers)
                deltaType, err := c.determineHeaderDeltaType(ctx, originHeader)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if deltaType == mexampleheader.HeaderSourceOrigin </span><span class="cov8" title="1">{
                        deltaHeader := mexampleheader.Header{
                                ID:            idwrap.NewNow(),
                                ExampleID:     deltaExampleID,
                                DeltaParentID: &amp;originHeader.ID, // Reference the origin header
                                HeaderKey:     originHeader.HeaderKey,
                                Enable:        originHeader.Enable,
                                Description:   originHeader.Description,
                                Value:         originHeader.Value,
                        }
                        deltaHeaders = append(deltaHeaders, deltaHeader)
                }</span>
        }

        // Bulk create all delta headers with proper linked list maintenance
        <span class="cov8" title="1">if len(deltaHeaders) &gt; 0 </span><span class="cov8" title="1">{
                err = c.ehs.AppendBulkHeader(ctx, deltaHeaders)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// AssertDeltaExampleCopy copies all asserts from an origin example to a delta example
// This implements the "Delta example create" functionality
func (c RequestRPC) AssertDeltaExampleCopy(ctx context.Context, originExampleID, deltaExampleID idwrap.IDWrap) error <span class="cov8" title="1">{
        // Check permissions for both examples
        rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, originExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return rpcErr
        }</span>
        <span class="cov8" title="1">rpcErr = permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, deltaExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return rpcErr
        }</span>

        // Get the origin example to determine if it has a version parent
        <span class="cov8" title="1">originExample, err := c.iaes.GetApiExample(ctx, originExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">originExampleHasVersionParent := originExample.VersionParentID != nil

        // Get all asserts from the origin example
        originAsserts, err := c.as.GetAssertByExampleID(ctx, originExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create corresponding asserts in the delta example
        <span class="cov8" title="1">var deltaAsserts []massert.Assert
        for _, originAssert := range originAsserts </span><span class="cov8" title="1">{
                // Only copy origin asserts (not mixed or delta asserts)
                originDeltaType := originAssert.DetermineDeltaType(originExampleHasVersionParent)
                if originDeltaType == massert.AssertSourceOrigin </span><span class="cov8" title="1">{
                        deltaAssert := massert.Assert{
                                ID:            idwrap.NewNow(),
                                ExampleID:     deltaExampleID,
                                DeltaParentID: &amp;originAssert.ID, // Reference the origin assert
                                Condition:     originAssert.Condition,
                                Enable:        originAssert.Enable,
                                Prev:          originAssert.Prev,
                                Next:          originAssert.Next,
                        }
                        deltaAsserts = append(deltaAsserts, deltaAssert)
                }</span>
        }

        // Bulk create all delta asserts
        <span class="cov8" title="1">if len(deltaAsserts) &gt; 0 </span><span class="cov8" title="1">{
                err = c.as.CreateBulkAssert(ctx, deltaAsserts)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (c RequestRPC) HeaderDeltaList(ctx context.Context, req *connect.Request[requestv1.HeaderDeltaListRequest]) (*connect.Response[requestv1.HeaderDeltaListResponse], error) <span class="cov8" title="1">{
        // Parse both example IDs
        deltaExampleID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">originExampleID, err := idwrap.NewFromBytes(req.Msg.GetOriginId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // Check permissions for both examples
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, deltaExampleID))
        if rpcErr != nil </span><span class="cov8" title="1">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">rpcErr = permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, originExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Get headers from both origin and delta examples using linked list ordering
        // With linked lists, each example maintains its own ordered list of headers
        
        // Get all headers for origin example
        <span class="cov8" title="1">originHeaders, err := c.ehs.GetHeadersOrdered(ctx, originExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        
        // Get all headers for delta example
        <span class="cov8" title="1">deltaHeaders, err := c.ehs.GetHeadersOrdered(ctx, deltaExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Combine all headers and build maps for lookup
        <span class="cov8" title="1">allHeaders := append(originHeaders, deltaHeaders...)
        headerMap := make(map[idwrap.IDWrap]mexampleheader.Header)
        originMap := make(map[idwrap.IDWrap]*requestv1.Header)

        // Build maps
        for _, header := range allHeaders </span><span class="cov8" title="1">{
                headerMap[header.ID] = header
                originMap[header.ID] = theader.SerializeHeaderModelToRPC(header)
        }</span>

        // First pass: identify which origins are replaced by delta/mixed headers
        <span class="cov8" title="1">processedOrigins := make(map[idwrap.IDWrap]bool)
        for _, header := range allHeaders </span><span class="cov8" title="1">{
                deltaType, err := c.determineHeaderDeltaType(ctx, header)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov8" title="1">if (deltaType == mexampleheader.HeaderSourceDelta || deltaType == mexampleheader.HeaderSourceMixed) &amp;&amp; header.DeltaParentID != nil </span><span class="cov8" title="1">{
                        processedOrigins[*header.DeltaParentID] = true
                }</span>
        }

        // Build a map of existing delta headers by key to avoid duplicates
        <span class="cov8" title="1">deltaHeadersByKey := make(map[string]bool)
        for _, header := range deltaHeaders </span><span class="cov8" title="1">{
                deltaHeadersByKey[strings.ToLower(header.HeaderKey)] = true
        }</span>

        // Collect origin headers that need delta entries created
        <span class="cov8" title="1">var originHeadersNeedingDeltas []mexampleheader.Header
        for _, header := range originHeaders </span><span class="cov8" title="1">{ // Only check origin headers
                if !processedOrigins[header.ID] &amp;&amp; // If not already processed by a delta
                        !deltaHeadersByKey[strings.ToLower(header.HeaderKey)] </span><span class="cov8" title="1">{ // And no header with same key exists
                        originHeadersNeedingDeltas = append(originHeadersNeedingDeltas, header)
                }</span>
        }

        // Create delta entries for origin headers that don't have them
        <span class="cov8" title="1">newDeltaHeaders := make(map[idwrap.IDWrap]mexampleheader.Header)
        if len(originHeadersNeedingDeltas) &gt; 0 </span><span class="cov8" title="1">{
                var deltaHeadersToCreate []mexampleheader.Header
                for _, originHeader := range originHeadersNeedingDeltas </span><span class="cov8" title="1">{
                        deltaHeader := mexampleheader.Header{
                                ID:            idwrap.NewNow(),
                                ExampleID:     deltaExampleID,
                                DeltaParentID: &amp;originHeader.ID,
                                HeaderKey:     originHeader.HeaderKey,
                                Enable:        originHeader.Enable,
                                Description:   originHeader.Description,
                                Value:         originHeader.Value,
                                // Don't copy Prev/Next - these will be set by AppendBulkHeader
                                // to maintain proper linked list within the delta example
                                Prev:          nil,
                                Next:          nil,
                        }
                        deltaHeadersToCreate = append(deltaHeadersToCreate, deltaHeader)
                        newDeltaHeaders[originHeader.ID] = deltaHeader
                }</span>

                // Bulk create the delta headers with proper linked list maintenance
                <span class="cov8" title="1">if len(deltaHeadersToCreate) &gt; 0 </span><span class="cov8" title="1">{
                        err = c.ehs.AppendBulkHeader(ctx, deltaHeadersToCreate)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>
                        // Add newly created headers to allHeaders so they're processed in the main loop
                        <span class="cov8" title="1">allHeaders = append(allHeaders, deltaHeadersToCreate...)</span>
                }
        }

        // Second pass: create result entries
        <span class="cov8" title="1">var rpcHeaders []*requestv1.HeaderDeltaListItem
        for _, header := range allHeaders </span><span class="cov8" title="1">{
                // Only include headers that belong to the delta example
                if header.ExampleID.Compare(deltaExampleID) != 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">deltaType, err := c.determineHeaderDeltaType(ctx, header)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov8" title="1">if deltaType == mexampleheader.HeaderSourceDelta || deltaType == mexampleheader.HeaderSourceMixed </span><span class="cov8" title="1">{
                        if header.DeltaParentID != nil </span><span class="cov8" title="1">{
                                // This is a delta header with a parent - check if it's been modified
                                var origin *requestv1.Header
                                var actualSourceKind deltav1.SourceKind

                                if originRPC, exists := originMap[*header.DeltaParentID]; exists </span><span class="cov8" title="1">{
                                        origin = originRPC

                                        // Compare with parent to determine if modified
                                        if parentHeader, exists := headerMap[*header.DeltaParentID]; exists </span><span class="cov8" title="1">{
                                                if header.HeaderKey == parentHeader.HeaderKey &amp;&amp;
                                                        header.Enable == parentHeader.Enable &amp;&amp;
                                                        header.Value == parentHeader.Value &amp;&amp;
                                                        header.Description == parentHeader.Description </span><span class="cov8" title="1">{
                                                        // Values match parent - this is an unmodified delta (ORIGIN)
                                                        actualSourceKind = deltav1.SourceKind_SOURCE_KIND_ORIGIN
                                                }</span> else<span class="cov8" title="1"> {
                                                        // Values differ from parent - this is a modified delta (MIXED)
                                                        actualSourceKind = deltav1.SourceKind_SOURCE_KIND_MIXED
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                // Parent not found, treat as DELTA
                                                actualSourceKind = deltav1.SourceKind_SOURCE_KIND_DELTA
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // No origin found, this is a standalone DELTA
                                        actualSourceKind = deltav1.SourceKind_SOURCE_KIND_DELTA
                                }</span>

                                // Build the response based on the source kind
                                <span class="cov8" title="1">var rpcHeader *requestv1.HeaderDeltaListItem
                                if actualSourceKind == deltav1.SourceKind_SOURCE_KIND_ORIGIN &amp;&amp; origin != nil </span><span class="cov8" title="1">{
                                        // For ORIGIN items, use the parent's values to reflect inheritance
                                        rpcHeader = &amp;requestv1.HeaderDeltaListItem{
                                                HeaderId:    header.ID.Bytes(),
                                                Key:         origin.Key,
                                                Enabled:     origin.Enabled,
                                                Value:       origin.Value,
                                                Description: origin.Description,
                                                Origin:      origin,
                                                Source:      &amp;actualSourceKind,
                                        }
                                }</span> else<span class="cov8" title="1"> {
                                        // For DELTA/MIXED items, use the delta's values
                                        rpcHeader = &amp;requestv1.HeaderDeltaListItem{
                                                HeaderId:    header.ID.Bytes(),
                                                Key:         header.HeaderKey,
                                                Enabled:     header.Enable,
                                                Value:       header.Value,
                                                Description: header.Description,
                                                Origin:      origin,
                                                Source:      &amp;actualSourceKind,
                                        }
                                }</span>
                                <span class="cov8" title="1">rpcHeaders = append(rpcHeaders, rpcHeader)</span>
                        } else<span class="cov8" title="1"> {
                                // This is a new header created in the delta (no parent)
                                sourceKind := deltaType.ToSourceKind()
                                rpcHeader := &amp;requestv1.HeaderDeltaListItem{
                                        HeaderId:    header.ID.Bytes(),
                                        Key:         header.HeaderKey,
                                        Enabled:     header.Enable,
                                        Value:       header.Value,
                                        Description: header.Description,
                                        Origin:      nil, // No origin for new headers
                                        Source:      &amp;sourceKind,
                                }
                                rpcHeaders = append(rpcHeaders, rpcHeader)
                        }</span>
                }
                // Note: MIXED headers won't appear here since we're only processing delta example headers
        }

        // Newly created delta headers are now processed in the main loop above

        // Headers are already in order from the linked list traversal
        // No additional sorting needed since GetHeadersOrdered returns them in correct order

        <span class="cov8" title="1">resp := &amp;requestv1.HeaderDeltaListResponse{
                ExampleId: deltaExampleID.Bytes(),
                Items:     rpcHeaders,
        }
        return connect.NewResponse(resp), nil</span>
}

func (c RequestRPC) HeaderDeltaCreate(ctx context.Context, req *connect.Request[requestv1.HeaderDeltaCreateRequest]) (*connect.Response[requestv1.HeaderDeltaCreateResponse], error) <span class="cov8" title="1">{
        exID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, exID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Get origin example ID from request
        <span class="cov8" title="1">originExampleID, err := idwrap.NewFromBytes(req.Msg.GetOriginId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        // Check permissions for origin example as well
        <span class="cov8" title="1">rpcErr = permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, originExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">rpcHeader := requestv1.Header{
                Key:         req.Msg.GetKey(),
                Enabled:     req.Msg.GetEnabled(),
                Value:       req.Msg.GetValue(),
                Description: req.Msg.GetDescription(),
        }
        header := theader.SerlializeHeaderRPCtoModelNoID(&amp;rpcHeader, exID, nil)

        headerID := idwrap.NewNow()
        header.ID = headerID

        // Note: Source field removed - delta type determined dynamically

        // Check if header_id is provided in request
        if len(req.Msg.GetHeaderId()) &gt; 0 </span><span class="cov8" title="1">{
                // Header ID is provided, verify it exists and use as delta parent
                parentHeaderID, err := idwrap.NewFromBytes(req.Msg.GetHeaderId())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>

                // Verify the parent header exists
                <span class="cov8" title="1">parentHeader, err := c.ehs.GetHeaderByID(ctx, parentHeaderID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>

                // Verify parent header relationship
                // For HAR imports and node copying, we need to handle multiple scenarios:
                // 1. Parent header belongs to the origin example directly
                // 2. Parent header belongs to a delta example and has a DeltaParentID
                // 3. Parent header belongs to a different example that's also a version of the origin

                // First check if the parent header belongs to the origin example
                <span class="cov8" title="1">if parentHeader.ExampleID.Compare(originExampleID) == 0 </span><span class="cov8" title="1">{
                        // Parent belongs to origin example, use it directly
                        header.DeltaParentID = &amp;parentHeaderID
                }</span> else<span class="cov8" title="1"> {
                        // Parent doesn't belong to origin example
                        // Check if it has a DeltaParentID (meaning it's a delta header)
                        if parentHeader.DeltaParentID != nil </span><span class="cov8" title="1">{
                                // This is a delta header, use its DeltaParentID
                                header.DeltaParentID = parentHeader.DeltaParentID
                        }</span> else<span class="cov8" title="1"> {
                                // This header doesn't belong to origin and doesn't have a DeltaParentID
                                // It might be from a different version/example chain
                                // Try to find if this example is related to the origin through VersionParentID
                                parentExample, err := c.iaes.GetApiExample(ctx, parentHeader.ExampleID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, connect.NewError(connect.CodeInternal, err)
                                }</span>

                                // Check if the parent example is a version of the origin
                                <span class="cov8" title="1">if parentExample.VersionParentID != nil &amp;&amp; parentExample.VersionParentID.Compare(originExampleID) == 0 </span><span class="cov0" title="0">{
                                        // The parent header's example is a direct child of the origin example
                                        // Use the parent header ID as the delta parent
                                        header.DeltaParentID = &amp;parentHeaderID
                                }</span> else<span class="cov8" title="1"> {
                                        // Unable to establish relationship to origin example
                                        return nil, connect.NewError(connect.CodeInvalidArgument,
                                                fmt.Errorf("parent header does not have a valid relationship to the origin example"))
                                }</span>
                        }
                }
        }
        // If no header_id provided, DeltaParentID remains nil (standalone delta)

        // Use AppendHeader to properly add the header to the end of the linked list
        <span class="cov8" title="1">err = c.ehs.AppendHeader(ctx, header)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">return connect.NewResponse(&amp;requestv1.HeaderDeltaCreateResponse{HeaderId: headerID.Bytes()}), nil</span>
}

func (c RequestRPC) HeaderDeltaUpdate(ctx context.Context, req *connect.Request[requestv1.HeaderDeltaUpdateRequest]) (*connect.Response[requestv1.HeaderDeltaUpdateResponse], error) <span class="cov8" title="1">{
        headerID, err := idwrap.NewFromBytes(req.Msg.GetHeaderId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerHeader(ctx, c.ehs, c.iaes, c.cs, c.us, headerID))
        if rpcErr != nil </span><span class="cov8" title="1">{
                return nil, rpcErr
        }</span>

        // Get the existing header to check its source
        <span class="cov8" title="1">existingHeader, err := c.ehs.GetHeaderByID(ctx, headerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Apply partial updates - only update fields that are provided
        <span class="cov8" title="1">if req.Msg.Key != nil </span><span class="cov8" title="1">{
                existingHeader.HeaderKey = *req.Msg.Key
        }</span>
        <span class="cov8" title="1">if req.Msg.Enabled != nil </span><span class="cov8" title="1">{
                existingHeader.Enable = *req.Msg.Enabled
        }</span>
        <span class="cov8" title="1">if req.Msg.Value != nil </span><span class="cov8" title="1">{
                existingHeader.Value = *req.Msg.Value
        }</span>
        <span class="cov8" title="1">if req.Msg.Description != nil </span><span class="cov8" title="1">{
                existingHeader.Description = *req.Msg.Description
        }</span>

        <span class="cov8" title="1">err = c.ehs.UpdateHeader(ctx, existingHeader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;requestv1.HeaderDeltaUpdateResponse{}), nil</span>
}

func (c RequestRPC) HeaderDeltaDelete(ctx context.Context, req *connect.Request[requestv1.HeaderDeltaDeleteRequest]) (*connect.Response[requestv1.HeaderDeltaDeleteResponse], error) <span class="cov8" title="1">{
        headerID, err := idwrap.NewFromBytes(req.Msg.GetHeaderId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerHeader(ctx, c.ehs, c.iaes, c.cs, c.us, headerID))
        if rpcErr != nil </span><span class="cov8" title="1">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">err = c.ehs.DeleteHeader(ctx, headerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">return connect.NewResponse(&amp;requestv1.HeaderDeltaDeleteResponse{}), nil</span>
}

func (c RequestRPC) HeaderDeltaReset(ctx context.Context, req *connect.Request[requestv1.HeaderDeltaResetRequest]) (*connect.Response[requestv1.HeaderDeltaResetResponse], error) <span class="cov8" title="1">{
        headerID, err := idwrap.NewFromBytes(req.Msg.GetHeaderId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerHeader(ctx, c.ehs, c.iaes, c.cs, c.us, headerID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Get the delta header
        <span class="cov8" title="1">deltaHeader, err := c.ehs.GetHeaderByID(ctx, headerID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // If the header has a parent, restore values from parent
        <span class="cov8" title="1">if deltaHeader.DeltaParentID != nil </span><span class="cov8" title="1">{
                // Restore values from parent
                parentHeader, err := c.ehs.GetHeaderByID(ctx, *deltaHeader.DeltaParentID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>

                // Restore delta header fields to match parent and set source to origin
                <span class="cov8" title="1">deltaHeader.HeaderKey = parentHeader.HeaderKey
                deltaHeader.Enable = parentHeader.Enable
                deltaHeader.Description = parentHeader.Description
                deltaHeader.Value = parentHeader.Value

                err = c.ehs.UpdateHeader(ctx, deltaHeader)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        } else<span class="cov8" title="1"> {
                // If no parent, use the original reset behavior (clear fields)
                err = c.ehs.ResetHeaderDelta(ctx, headerID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov8" title="1">return connect.NewResponse(&amp;requestv1.HeaderDeltaResetResponse{}), nil</span>
}

func (c RequestRPC) AssertList(ctx context.Context, req *connect.Request[requestv1.AssertListRequest]) (*connect.Response[requestv1.AssertListResponse], error) <span class="cov0" title="0">{
        exID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, exID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">allAsserts, err := c.as.GetAssertByExampleID(ctx, exID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Check if example has a version parent
        <span class="cov0" title="0">example, err := c.iaes.GetApiExample(ctx, exID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">exampleHasVersionParent := example.VersionParentID != nil

        // Filter to only include origin asserts
        var originAsserts []massert.Assert
        for _, assert := range allAsserts </span><span class="cov0" title="0">{
                deltaType := assert.DetermineDeltaType(exampleHasVersionParent)
                if deltaType == massert.AssertSourceOrigin </span><span class="cov0" title="0">{
                        originAsserts = append(originAsserts, assert)
                }</span>
        }

        <span class="cov0" title="0">var rpcAssserts []*requestv1.AssertListItem
        for _, a := range originAsserts </span><span class="cov0" title="0">{
                rpcAssert, err := tassert.SerializeAssertModelToRPCItem(a)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">rpcAssserts = append(rpcAssserts, rpcAssert)</span>
        }

        <span class="cov0" title="0">resp := &amp;requestv1.AssertListResponse{
                ExampleId: exID.Bytes(),
                Items:     rpcAssserts,
        }
        return connect.NewResponse(resp), nil</span>
}

func (c RequestRPC) AssertCreate(ctx context.Context, req *connect.Request[requestv1.AssertCreateRequest]) (*connect.Response[requestv1.AssertCreateResponse], error) <span class="cov8" title="1">{
        exID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, exID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">rpcAssert := requestv1.Assert{
                Condition: req.Msg.GetCondition(),
        }

        var deltaParentIDPtr *idwrap.IDWrap
        assert := tassert.SerializeAssertRPCToModelWithoutID(&amp;rpcAssert, exID, deltaParentIDPtr)
        assert.Enable = true
        assert.ID = idwrap.NewNow()
        err = c.as.CreateAssert(ctx, assert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;requestv1.AssertCreateResponse{AssertId: assert.ID.Bytes()}), nil</span>
}

func (c RequestRPC) AssertUpdate(ctx context.Context, req *connect.Request[requestv1.AssertUpdateRequest]) (*connect.Response[requestv1.AssertUpdateResponse], error) <span class="cov0" title="0">{
        assertID, err := idwrap.NewFromBytes(req.Msg.GetAssertId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(CheckOwnerAssert(ctx, c.as, c.iaes, c.cs, c.us, assertID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Get the assert to update
        <span class="cov0" title="0">assertDB, err := c.as.GetAssert(ctx, assertID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Update the origin assert
        <span class="cov0" title="0">assertDB.Condition = tcondition.DeserializeConditionRPCToModel(req.Msg.GetCondition())

        err = c.as.UpdateAssert(ctx, *assertDB)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Propagate changes to delta items with "origin" source that reference this assert
        // Get the example to determine if it has a version parent
        <span class="cov0" title="0">example, err := c.iaes.GetApiExample(ctx, assertDB.ExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">exampleHasVersionParent := example.VersionParentID != nil

        // Get all asserts from this example to find any that reference this origin assert
        allAsserts, err := c.as.GetAssertByExampleID(ctx, assertDB.ExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Update any delta asserts that reference this origin assert with source="origin"
        <span class="cov0" title="0">for _, deltaAssert := range allAsserts </span><span class="cov0" title="0">{
                deltaType := deltaAssert.DetermineDeltaType(exampleHasVersionParent)
                if deltaAssert.DeltaParentID != nil &amp;&amp;
                        deltaAssert.DeltaParentID.Compare(assertID) == 0 &amp;&amp;
                        deltaType == massert.AssertSourceOrigin </span><span class="cov0" title="0">{
                        // Update the delta assert to match the origin
                        deltaAssert.Condition = assertDB.Condition
                        deltaAssert.Enable = assertDB.Enable

                        err = c.as.UpdateAssert(ctx, deltaAssert)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return connect.NewResponse(&amp;requestv1.AssertUpdateResponse{}), nil</span>
}

func (c RequestRPC) AssertDelete(ctx context.Context, req *connect.Request[requestv1.AssertDeleteRequest]) (*connect.Response[requestv1.AssertDeleteResponse], error) <span class="cov8" title="1">{
        assertID, err := idwrap.NewFromBytes(req.Msg.GetAssertId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerAssert(ctx, c.as, c.iaes, c.cs, c.us, assertID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Get the assert to check if it's an origin assert and get its example ID
        <span class="cov8" title="1">originAssert, err := c.as.GetAssert(ctx, assertID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Get the example to determine if it has a version parent
        <span class="cov8" title="1">example, err := c.iaes.GetApiExample(ctx, originAssert.ExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">exampleHasVersionParent := example.VersionParentID != nil

        // Determine if this is an origin assert
        originDeltaType := originAssert.DetermineDeltaType(exampleHasVersionParent)
        if originDeltaType == massert.AssertSourceOrigin </span><span class="cov8" title="1">{
                // Need to find and delete delta asserts in OTHER examples that reference this origin
                // Get all examples in the collection to search for delta asserts
                examples, err := c.iaes.GetApiExampleByCollection(ctx, example.CollectionID)
                if err == nil </span><span class="cov8" title="1">{
                        for _, ex := range examples </span><span class="cov8" title="1">{
                                // Check all examples for asserts that reference this one
                                deltaAsserts, err := c.as.GetAssertByExampleID(ctx, ex.ID)
                                if err == nil </span><span class="cov8" title="1">{
                                        for _, deltaAssert := range deltaAsserts </span><span class="cov8" title="1">{
                                                if deltaAssert.DeltaParentID != nil &amp;&amp;
                                                        deltaAssert.DeltaParentID.Compare(assertID) == 0 </span><span class="cov0" title="0">{
                                                        // Delete this delta assert that references the origin being deleted
                                                        _ = c.as.DeleteAssert(ctx, deltaAssert.ID)
                                                }</span>
                                        }
                                }
                        }
                }

                // ADDITIONAL WORKAROUND: Also check for delta examples that have this example as their parent
                // This is needed because GetApiExampleByCollection may not return all examples
                <span class="cov8" title="1">deltaExamples, err := c.iaes.GetApiExampleByVersionParentID(ctx, example.ID)
                if err == nil </span><span class="cov8" title="1">{
                        for _, deltaExample := range deltaExamples </span><span class="cov8" title="1">{
                                // Check for asserts in these delta examples that reference the origin assert
                                deltaAsserts, err := c.as.GetAssertByExampleID(ctx, deltaExample.ID)
                                if err == nil </span><span class="cov8" title="1">{
                                        for _, deltaAssert := range deltaAsserts </span><span class="cov8" title="1">{
                                                if deltaAssert.DeltaParentID != nil &amp;&amp;
                                                        deltaAssert.DeltaParentID.Compare(assertID) == 0 </span><span class="cov8" title="1">{
                                                        // Delete this delta assert that references the origin being deleted
                                                        _ = c.as.DeleteAssert(ctx, deltaAssert.ID)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        // Delete the origin assert itself
        <span class="cov8" title="1">err = c.as.DeleteAssert(ctx, assertID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;requestv1.AssertDeleteResponse{}), nil</span>
}

func (c RequestRPC) AssertDeltaList(ctx context.Context, req *connect.Request[requestv1.AssertDeltaListRequest]) (*connect.Response[requestv1.AssertDeltaListResponse], error) <span class="cov8" title="1">{
        // Parse both example IDs
        deltaExampleID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">originExampleID, err := idwrap.NewFromBytes(req.Msg.GetOriginId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // Check permissions for both examples
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, deltaExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">rpcErr = permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, originExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Check if delta example has a version parent
        <span class="cov8" title="1">deltaExample, err := c.iaes.GetApiExample(ctx, deltaExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">deltaExampleHasVersionParent := deltaExample.VersionParentID != nil

        // Get asserts from both origin and delta examples
        originAsserts, err := c.as.GetAssertByExampleID(ctx, originExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">deltaAsserts, err := c.as.GetAssertByExampleID(ctx, deltaExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Combine all asserts and build maps for lookup
        <span class="cov8" title="1">allAsserts := append(originAsserts, deltaAsserts...)
        assertMap := make(map[idwrap.IDWrap]massert.Assert)
        originMap := make(map[idwrap.IDWrap]*requestv1.Assert)

        // Build maps
        for _, assert := range allAsserts </span><span class="cov8" title="1">{
                assertMap[assert.ID] = assert
                rpcAssert, err := tassert.SerializeAssertModelToRPC(assert)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov8" title="1">originMap[assert.ID] = rpcAssert</span>
        }

        // First pass: identify which origins are replaced by delta/mixed asserts
        <span class="cov8" title="1">processedOrigins := make(map[idwrap.IDWrap]bool)
        for _, assert := range allAsserts </span><span class="cov8" title="1">{
                deltaType := assert.DetermineDeltaType(deltaExampleHasVersionParent)
                if (deltaType == massert.AssertSourceDelta || deltaType == massert.AssertSourceMixed) &amp;&amp; assert.DeltaParentID != nil </span><span class="cov8" title="1">{
                        processedOrigins[*assert.DeltaParentID] = true
                }</span>
        }

        // Collect origin asserts that need delta entries created
        <span class="cov8" title="1">var originAssertsNeedingDeltas []massert.Assert
        for _, assert := range originAsserts </span><span class="cov8" title="1">{ // Only check origin asserts
                if !processedOrigins[assert.ID] </span><span class="cov0" title="0">{ // If not already processed by a delta
                        originAssertsNeedingDeltas = append(originAssertsNeedingDeltas, assert)
                }</span>
        }

        // Create delta entries for origin asserts that don't have them
        <span class="cov8" title="1">newDeltaAsserts := make(map[idwrap.IDWrap]massert.Assert)
        if len(originAssertsNeedingDeltas) &gt; 0 </span><span class="cov0" title="0">{
                var deltaAssertsToCreate []massert.Assert
                for _, originAssert := range originAssertsNeedingDeltas </span><span class="cov0" title="0">{
                        deltaAssert := massert.Assert{
                                ID:            idwrap.NewNow(),
                                ExampleID:     deltaExampleID,
                                DeltaParentID: &amp;originAssert.ID,
                                Condition:     originAssert.Condition,
                                Enable:        originAssert.Enable,
                                Prev:          originAssert.Prev,
                                Next:          originAssert.Next,
                        }
                        deltaAssertsToCreate = append(deltaAssertsToCreate, deltaAssert)
                        newDeltaAsserts[originAssert.ID] = deltaAssert
                }</span>

                // Bulk create the delta asserts
                <span class="cov0" title="0">if len(deltaAssertsToCreate) &gt; 0 </span><span class="cov0" title="0">{
                        err = c.as.CreateBulkAssert(ctx, deltaAssertsToCreate)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>
                        // Add newly created asserts to allAsserts so they're processed in the main loop
                        <span class="cov0" title="0">allAsserts = append(allAsserts, deltaAssertsToCreate...)</span>
                }
        }

        // Second pass: create result entries
        <span class="cov8" title="1">var rpcAsserts []*requestv1.AssertDeltaListItem
        for _, assert := range allAsserts </span><span class="cov8" title="1">{
                // Only include asserts that belong to the delta example
                if assert.ExampleID.Compare(deltaExampleID) != 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">deltaType := assert.DetermineDeltaType(deltaExampleHasVersionParent)
                if (deltaType == massert.AssertSourceDelta || deltaType == massert.AssertSourceMixed) &amp;&amp; assert.DeltaParentID != nil </span><span class="cov8" title="1">{
                        // This is a delta assert - check if it's been modified from its parent
                        var origin *requestv1.Assert
                        var actualSourceKind deltav1.SourceKind

                        if originRPC, exists := originMap[*assert.DeltaParentID]; exists </span><span class="cov8" title="1">{
                                origin = originRPC

                                // Compare with parent to determine if modified
                                // The parent should be from the origin example, not the delta example
                                if parentAssert, exists := assertMap[*assert.DeltaParentID]; exists </span><span class="cov8" title="1">{
                                        // For asserts, we need to compare the condition fields
                                        // Since Condition is a complex type, we'll do a deep comparison
                                        parentCondition := tcondition.SeralizeConditionModelToRPC(parentAssert.Condition)
                                        currentCondition := tcondition.SeralizeConditionModelToRPC(assert.Condition)

                                        conditionsMatch := true
                                        if (parentCondition == nil &amp;&amp; currentCondition != nil) ||
                                                (parentCondition != nil &amp;&amp; currentCondition == nil) </span><span class="cov0" title="0">{
                                                conditionsMatch = false
                                        }</span> else<span class="cov8" title="1"> if parentCondition != nil &amp;&amp; currentCondition != nil </span><span class="cov8" title="1">{
                                                // Compare the condition fields - check if both have comparisons
                                                if parentCondition.Comparison != nil &amp;&amp; currentCondition.Comparison != nil </span><span class="cov8" title="1">{
                                                        conditionsMatch = parentCondition.Comparison.Expression == currentCondition.Comparison.Expression
                                                }</span> else<span class="cov0" title="0"> {
                                                        conditionsMatch = (parentCondition.Comparison == nil) == (currentCondition.Comparison == nil)
                                                }</span>
                                        }

                                        <span class="cov8" title="1">if conditionsMatch &amp;&amp; assert.Enable == parentAssert.Enable </span><span class="cov8" title="1">{
                                                // Values match parent - this is an unmodified delta (ORIGIN)
                                                actualSourceKind = deltav1.SourceKind_SOURCE_KIND_ORIGIN
                                        }</span> else<span class="cov8" title="1"> {
                                                // Values differ from parent - this is a modified delta (MIXED)
                                                // deltaType should be AssertSourceMixed when the assert has a DeltaParentID
                                                // and the example has a version parent
                                                actualSourceKind = deltav1.SourceKind_SOURCE_KIND_MIXED
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        // Parent not found, treat as modified
                                        actualSourceKind = deltaType.ToSourceKind()
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // No origin found, use the delta type
                                actualSourceKind = deltaType.ToSourceKind()
                        }</span>

                        // Build the response based on the source kind
                        <span class="cov8" title="1">var rpcAssert *requestv1.AssertDeltaListItem
                        if actualSourceKind == deltav1.SourceKind_SOURCE_KIND_ORIGIN &amp;&amp; origin != nil </span><span class="cov8" title="1">{
                                // For ORIGIN items, use the parent's condition to reflect inheritance
                                rpcAssert = &amp;requestv1.AssertDeltaListItem{
                                        AssertId:  assert.ID.Bytes(),
                                        Condition: origin.Condition,
                                        Origin:    origin,
                                        Source:    &amp;actualSourceKind,
                                }
                        }</span> else<span class="cov8" title="1"> {
                                // For DELTA/MIXED items, use the delta's condition
                                rpcAssert = &amp;requestv1.AssertDeltaListItem{
                                        AssertId:  assert.ID.Bytes(),
                                        Condition: tcondition.SeralizeConditionModelToRPC(assert.Condition),
                                        Origin:    origin,
                                        Source:    &amp;actualSourceKind,
                                }
                        }</span>
                        <span class="cov8" title="1">rpcAsserts = append(rpcAsserts, rpcAssert)</span>
                } else<span class="cov0" title="0"> if deltaType == massert.AssertSourceMixed </span><span class="cov0" title="0">{
                        // This is already a mixed assert, keep it as is
                        var origin *requestv1.Assert
                        if assert.DeltaParentID != nil </span><span class="cov0" title="0">{
                                if originRPC, exists := originMap[*assert.DeltaParentID]; exists </span><span class="cov0" title="0">{
                                        origin = originRPC
                                }</span>
                        }

                        <span class="cov0" title="0">sourceKind := deltaType.ToSourceKind()
                        rpcAssert := &amp;requestv1.AssertDeltaListItem{
                                AssertId:  assert.ID.Bytes(),
                                Condition: tcondition.SeralizeConditionModelToRPC(assert.Condition),
                                Origin:    origin,
                                Source:    &amp;sourceKind,
                        }
                        rpcAsserts = append(rpcAsserts, rpcAssert)</span>
                }
                // Skip origin asserts that have been processed (replaced by delta/mixed)
        }

        // Newly created delta asserts are now processed in the main loop above

        // Sort rpcAsserts by ID, but if it has DeltaParentID use that ID instead
        <span class="cov8" title="1">sort.Slice(rpcAsserts, func(i, j int) bool </span><span class="cov0" title="0">{
                idI, _ := idwrap.NewFromBytes(rpcAsserts[i].AssertId)
                idJ, _ := idwrap.NewFromBytes(rpcAsserts[j].AssertId)

                // Determine the ID to use for sorting for item i
                sortIDI := idI
                if rpcAsserts[i].Origin != nil &amp;&amp; len(rpcAsserts[i].Origin.AssertId) &gt; 0 </span><span class="cov0" title="0">{
                        if parentID, err := idwrap.NewFromBytes(rpcAsserts[i].Origin.AssertId); err == nil </span><span class="cov0" title="0">{
                                sortIDI = parentID
                        }</span>
                }

                // Determine the ID to use for sorting for item j
                <span class="cov0" title="0">sortIDJ := idJ
                if rpcAsserts[j].Origin != nil &amp;&amp; len(rpcAsserts[j].Origin.AssertId) &gt; 0 </span><span class="cov0" title="0">{
                        if parentID, err := idwrap.NewFromBytes(rpcAsserts[j].Origin.AssertId); err == nil </span><span class="cov0" title="0">{
                                sortIDJ = parentID
                        }</span>
                }

                <span class="cov0" title="0">return sortIDI.Compare(sortIDJ) &lt; 0</span>
        })

        <span class="cov8" title="1">resp := &amp;requestv1.AssertDeltaListResponse{
                ExampleId: deltaExampleID.Bytes(),
                Items:     rpcAsserts,
        }
        return connect.NewResponse(resp), nil</span>
}

func (c RequestRPC) AssertDeltaCreate(ctx context.Context, req *connect.Request[requestv1.AssertDeltaCreateRequest]) (*connect.Response[requestv1.AssertDeltaCreateResponse], error) <span class="cov0" title="0">{
        exID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, exID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Get origin example ID from request
        <span class="cov0" title="0">originExampleID, err := idwrap.NewFromBytes(req.Msg.GetOriginId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        // Check permissions for origin example as well
        <span class="cov0" title="0">rpcErr = permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, originExampleID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">rpcAssert := requestv1.Assert{
                Condition: req.Msg.GetCondition(),
        }

        var deltaParentIDPtr *idwrap.IDWrap
        assert := tassert.SerializeAssertRPCToModelWithoutID(&amp;rpcAssert, exID, deltaParentIDPtr)
        assert.Enable = true
        assert.ID = idwrap.NewNow()

        // Check if assert_id is provided in request
        if len(req.Msg.GetAssertId()) &gt; 0 </span><span class="cov0" title="0">{
                // Assert ID is provided, verify it exists and use as delta parent
                parentAssertID, err := idwrap.NewFromBytes(req.Msg.GetAssertId())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>

                // Verify the parent assert exists
                <span class="cov0" title="0">parentAssert, err := c.as.GetAssert(ctx, parentAssertID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>

                // Verify parent assert relationship (same logic as headers and queries)
                <span class="cov0" title="0">if parentAssert.ExampleID.Compare(originExampleID) == 0 </span><span class="cov0" title="0">{
                        // Parent belongs to origin example, use it directly
                        assert.DeltaParentID = &amp;parentAssertID
                }</span> else<span class="cov0" title="0"> {
                        // Parent doesn't belong to origin example
                        if parentAssert.DeltaParentID != nil </span><span class="cov0" title="0">{
                                // This is a delta assert, use its DeltaParentID
                                assert.DeltaParentID = parentAssert.DeltaParentID
                        }</span> else<span class="cov0" title="0"> {
                                // Check if the parent example is related to origin
                                parentExample, err := c.iaes.GetApiExample(ctx, parentAssert.ExampleID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, connect.NewError(connect.CodeInternal, err)
                                }</span>

                                <span class="cov0" title="0">if parentExample.VersionParentID != nil &amp;&amp; parentExample.VersionParentID.Compare(originExampleID) == 0 </span><span class="cov0" title="0">{
                                        assert.DeltaParentID = &amp;parentAssertID
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, connect.NewError(connect.CodeInvalidArgument,
                                                fmt.Errorf("parent assert does not have a valid relationship to the origin example"))
                                }</span>
                        }
                }
        }
        // If no assert_id provided, DeltaParentID remains nil (standalone delta)

        <span class="cov0" title="0">err = c.as.CreateAssert(ctx, assert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;requestv1.AssertDeltaCreateResponse{AssertId: assert.ID.Bytes()}), nil</span>
}

func (c RequestRPC) AssertDeltaUpdate(ctx context.Context, req *connect.Request[requestv1.AssertDeltaUpdateRequest]) (*connect.Response[requestv1.AssertDeltaUpdateResponse], error) <span class="cov8" title="1">{
        assertID, err := idwrap.NewFromBytes(req.Msg.GetAssertId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerAssert(ctx, c.as, c.iaes, c.cs, c.us, assertID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Get the existing assert to check its source
        <span class="cov8" title="1">existingAssert, err := c.as.GetAssert(ctx, assertID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // Always update the existing assert instead of creating a new one
        <span class="cov8" title="1">existingAssert.Condition = tcondition.DeserializeConditionRPCToModel(req.Msg.GetCondition())

        err = c.as.UpdateAssert(ctx, *existingAssert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;requestv1.AssertDeltaUpdateResponse{}), nil</span>
}

func (c RequestRPC) AssertDeltaDelete(ctx context.Context, req *connect.Request[requestv1.AssertDeltaDeleteRequest]) (*connect.Response[requestv1.AssertDeltaDeleteResponse], error) <span class="cov0" title="0">{
        assertID, err := idwrap.NewFromBytes(req.Msg.GetAssertId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(CheckOwnerAssert(ctx, c.as, c.iaes, c.cs, c.us, assertID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov0" title="0">err = c.as.DeleteAssert(ctx, assertID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">return connect.NewResponse(&amp;requestv1.AssertDeltaDeleteResponse{}), nil</span>
}

func (c RequestRPC) AssertDeltaReset(ctx context.Context, req *connect.Request[requestv1.AssertDeltaResetRequest]) (*connect.Response[requestv1.AssertDeltaResetResponse], error) <span class="cov8" title="1">{
        assertID, err := idwrap.NewFromBytes(req.Msg.GetAssertId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerAssert(ctx, c.as, c.iaes, c.cs, c.us, assertID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        // Get the delta assert
        <span class="cov8" title="1">deltaAssert, err := c.as.GetAssert(ctx, assertID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        // If the assert has a parent, restore values from parent
        <span class="cov8" title="1">if deltaAssert.DeltaParentID != nil </span><span class="cov8" title="1">{
                // Restore values from parent
                parentAssert, err := c.as.GetAssert(ctx, *deltaAssert.DeltaParentID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>

                // Restore delta assert fields to match parent and set source to origin
                <span class="cov8" title="1">deltaAssert.Condition = parentAssert.Condition
                deltaAssert.Enable = parentAssert.Enable

                err = c.as.UpdateAssert(ctx, *deltaAssert)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        } else<span class="cov0" title="0"> {
                // If no parent, use the original reset behavior (clear fields)
                err = c.as.ResetAssertDelta(ctx, assertID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov8" title="1">return connect.NewResponse(&amp;requestv1.AssertDeltaResetResponse{}), nil</span>
}

// TODO: implement move RPC
func (c RequestRPC) QueryMove(ctx context.Context, req *connect.Request[requestv1.QueryMoveRequest]) (*connect.Response[requestv1.QueryMoveResponse], error) <span class="cov0" title="0">{
        return connect.NewResponse(&amp;requestv1.QueryMoveResponse{}), nil
}</span>

// TODO: implement move RPC
func (c RequestRPC) QueryDeltaMove(ctx context.Context, req *connect.Request[requestv1.QueryDeltaMoveRequest]) (*connect.Response[requestv1.QueryDeltaMoveResponse], error) <span class="cov0" title="0">{
        return connect.NewResponse(&amp;requestv1.QueryDeltaMoveResponse{}), nil
}</span>

func (c RequestRPC) HeaderMove(ctx context.Context, req *connect.Request[requestv1.HeaderMoveRequest]) (*connect.Response[requestv1.HeaderMoveResponse], error) <span class="cov8" title="1">{
        // Parse request parameters
        exampleID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("invalid example ID: %w", err))
        }</span>

        <span class="cov8" title="1">headerID, err := idwrap.NewFromBytes(req.Msg.GetHeaderId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("invalid header ID: %w", err))
        }</span>

        <span class="cov8" title="1">targetHeaderID, err := idwrap.NewFromBytes(req.Msg.GetTargetHeaderId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("invalid target header ID: %w", err))
        }</span>

        <span class="cov8" title="1">position := req.Msg.GetPosition()
        if position == resourcesv1.MovePosition_MOVE_POSITION_UNSPECIFIED </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("position must be specified"))
        }</span>

        // Check permissions for the example
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, exampleID))
        if rpcErr != nil </span><span class="cov8" title="1">{
                return nil, rpcErr
        }</span>

        // Prevent moving header relative to itself
        <span class="cov8" title="1">if headerID.Compare(targetHeaderID) == 0 </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("cannot move header relative to itself"))
        }</span>

        // Determine after/before pointers based on position
        <span class="cov8" title="1">var afterHeaderID, beforeHeaderID *idwrap.IDWrap
        if position == resourcesv1.MovePosition_MOVE_POSITION_AFTER </span><span class="cov8" title="1">{
                afterHeaderID = &amp;targetHeaderID
        }</span> else<span class="cov8" title="1"> {
                beforeHeaderID = &amp;targetHeaderID
        }</span>

        // Use HeaderService to perform the move
        <span class="cov8" title="1">err = c.ehs.MoveHeader(ctx, headerID, afterHeaderID, beforeHeaderID, exampleID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to move header: %w", err))
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;requestv1.HeaderMoveResponse{}), nil</span>
}

func (c RequestRPC) HeaderDeltaMove(ctx context.Context, req *connect.Request[requestv1.HeaderDeltaMoveRequest]) (*connect.Response[requestv1.HeaderDeltaMoveResponse], error) <span class="cov8" title="1">{
        // Parse request parameters
        exampleID, err := idwrap.NewFromBytes(req.Msg.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("invalid example ID: %w", err))
        }</span>

        <span class="cov8" title="1">headerID, err := idwrap.NewFromBytes(req.Msg.GetHeaderId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("invalid header ID: %w", err))
        }</span>

        <span class="cov8" title="1">targetHeaderID, err := idwrap.NewFromBytes(req.Msg.GetTargetHeaderId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("invalid target header ID: %w", err))
        }</span>

        <span class="cov8" title="1">position := req.Msg.GetPosition()
        if position == resourcesv1.MovePosition_MOVE_POSITION_UNSPECIFIED </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("position must be specified"))
        }</span>

        // Check permissions for the example
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(ritemapiexample.CheckOwnerExample(ctx, c.iaes, c.cs, c.us, exampleID))
        if rpcErr != nil </span><span class="cov8" title="1">{
                return nil, rpcErr
        }</span>

        // Prevent moving header relative to itself
        <span class="cov8" title="1">if headerID.Compare(targetHeaderID) == 0 </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("cannot move header relative to itself"))
        }</span>

        // Get both headers to validate they exist and belong to the same example
        <span class="cov8" title="1">headerToMove, err := c.ehs.GetHeaderByID(ctx, headerID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeNotFound, fmt.Errorf("header to move not found: %w", err))
        }</span>

        <span class="cov8" title="1">targetHeader, err := c.ehs.GetHeaderByID(ctx, targetHeaderID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeNotFound, fmt.Errorf("target header not found: %w", err))
        }</span>

        // Verify both headers belong to the specified example
        <span class="cov8" title="1">if headerToMove.ExampleID.Compare(exampleID) != 0 </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("header does not belong to the specified example"))
        }</span>
        <span class="cov8" title="1">if targetHeader.ExampleID.Compare(exampleID) != 0 </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("target header does not belong to the same example"))
        }</span>

        // Manually unlink header from current position without deleting it
        <span class="cov8" title="1">if headerToMove.Prev != nil </span><span class="cov8" title="1">{
                // Update previous header's next pointer to skip the moved header
                err = c.ehs.UpdateHeaderNext(ctx, *headerToMove.Prev, headerToMove.Next)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to update prev header: %w", err))
                }</span>
        }
        <span class="cov8" title="1">if headerToMove.Next != nil </span><span class="cov8" title="1">{
                // Update next header's prev pointer to skip the moved header
                err = c.ehs.UpdateHeaderPrev(ctx, *headerToMove.Next, headerToMove.Prev)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to update next header: %w", err))
                }</span>
        }

        // Get fresh data for target header after unlinking (in case target was adjacent)
        <span class="cov8" title="1">targetHeader, err = c.ehs.GetHeaderByID(ctx, targetHeaderID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeNotFound, fmt.Errorf("target header not found after unlink: %w", err))
        }</span>

        // Determine new position and update pointers
        <span class="cov8" title="1">var newPrev, newNext *idwrap.IDWrap
        if position == resourcesv1.MovePosition_MOVE_POSITION_AFTER </span><span class="cov8" title="1">{
                // Insert after target: moved header goes between target and target.next
                newPrev = &amp;targetHeaderID
                newNext = targetHeader.Next
                
                // Update target's next pointer to moved header
                err = c.ehs.UpdateHeaderNext(ctx, targetHeaderID, &amp;headerID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to update target header: %w", err))
                }</span>
                
                // If target had a next, update it to point back to moved header
                <span class="cov8" title="1">if targetHeader.Next != nil </span><span class="cov8" title="1">{
                        err = c.ehs.UpdateHeaderPrev(ctx, *targetHeader.Next, &amp;headerID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to update next header: %w", err))
                        }</span>
                }
        } else<span class="cov8" title="1"> { // MOVE_POSITION_BEFORE
                // Insert before target: moved header goes between target.prev and target
                newPrev = targetHeader.Prev
                newNext = &amp;targetHeaderID
                
                // Update target's prev pointer to moved header
                err = c.ehs.UpdateHeaderPrev(ctx, targetHeaderID, &amp;headerID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to update target header: %w", err))
                }</span>
                
                // If target had a prev, update it to point to moved header
                <span class="cov8" title="1">if targetHeader.Prev != nil </span><span class="cov8" title="1">{
                        err = c.ehs.UpdateHeaderNext(ctx, *targetHeader.Prev, &amp;headerID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to update prev header: %w", err))
                        }</span>
                }
        }

        // Update moved header's pointers to its new position
        <span class="cov8" title="1">err = c.ehs.UpdateHeaderLinks(ctx, headerID, newPrev, newNext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to update moved header's links: %w", err))
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;requestv1.HeaderDeltaMoveResponse{}), nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package rtag

import (
        "context"
        "database/sql"
        "errors"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/rworkspace"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/permcheck"
        "the-dev-tools/server/pkg/service/stag"
        "the-dev-tools/server/pkg/service/suser"
        "the-dev-tools/server/pkg/service/sworkspace"
        "the-dev-tools/server/pkg/translate/tgeneric"
        "the-dev-tools/server/pkg/translate/ttag"
        "the-dev-tools/spec/dist/buf/go/tag/v1/tagv1connect"

        tagv1 "the-dev-tools/spec/dist/buf/go/tag/v1"

        "connectrpc.com/connect"
)

type TagServiceRPC struct {
        DB *sql.DB
        ws sworkspace.WorkspaceService
        us suser.UserService
        ts stag.TagService
}

func New(db *sql.DB, ws sworkspace.WorkspaceService, us suser.UserService, ts stag.TagService) TagServiceRPC <span class="cov8" title="1">{
        return TagServiceRPC{
                DB: db,
                ws: ws,
                us: us,
                ts: ts,
        }
}</span>

func CreateService(srv TagServiceRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := tagv1connect.NewTagServiceHandler(&amp;srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

func (c TagServiceRPC) TagList(ctx context.Context, req *connect.Request[tagv1.TagListRequest]) (*connect.Response[tagv1.TagListResponse], error) <span class="cov0" title="0">{
        wsID, err := idwrap.NewFromBytes(req.Msg.WorkspaceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">rpcErr := permcheck.CheckPerm(rworkspace.CheckOwnerWorkspace(ctx, c.us, wsID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov0" title="0">tags, err := c.ts.GetTagByWorkspace(ctx, wsID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeUnknown, err)
        }</span>

        <span class="cov0" title="0">tgeneric.MassConvert(tags, ttag.SeralizeModelToRPCItem)

        resp := &amp;tagv1.TagListResponse{
                Items: tgeneric.MassConvert(tags, ttag.SeralizeModelToRPCItem),
        }

        return connect.NewResponse(resp), nil</span>
}

func (c TagServiceRPC) TagGet(ctx context.Context, req *connect.Request[tagv1.TagGetRequest]) (*connect.Response[tagv1.TagGetResponse], error) <span class="cov8" title="1">{
        tagID, err := idwrap.NewFromBytes(req.Msg.TagId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerTag(ctx, c.ts, c.us, tagID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">tags, err := c.ts.GetTag(ctx, tagID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeUnknown, err)
        }</span>

        <span class="cov8" title="1">rpcTag := ttag.SeralizeModelToRPC(tags)

        resp := &amp;tagv1.TagGetResponse{
                TagId: rpcTag.TagId,
                Name:  rpcTag.Name,
                Color: rpcTag.Color,
        }

        return connect.NewResponse(resp), nil</span>
}

func (c TagServiceRPC) TagCreate(ctx context.Context, req *connect.Request[tagv1.TagCreateRequest]) (*connect.Response[tagv1.TagCreateResponse], error) <span class="cov8" title="1">{
        wsID, err := idwrap.NewFromBytes(req.Msg.WorkspaceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(rworkspace.CheckOwnerWorkspace(ctx, c.us, wsID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">rpcTag := tagv1.Tag{
                Name:  req.Msg.Name,
                Color: req.Msg.Color,
        }

        tagID := idwrap.NewNow()
        tag := ttag.SeralizeRpcToModelWithoutID(&amp;rpcTag, wsID)
        tag.ID = tagID
        err = c.ts.CreateTag(ctx, *tag)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeUnknown, err)
        }</span>

        <span class="cov8" title="1">resp := &amp;tagv1.TagCreateResponse{
                TagId: tagID.Bytes(),
        }
        return connect.NewResponse(resp), nil</span>
}

func (c TagServiceRPC) TagUpdate(ctx context.Context, req *connect.Request[tagv1.TagUpdateRequest]) (*connect.Response[tagv1.TagUpdateResponse], error) <span class="cov8" title="1">{
        if req.Msg.TagId == nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("tag id is required"))
        }</span>
        <span class="cov8" title="1">if req.Msg.Name == nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("name is required"))
        }</span>

        <span class="cov8" title="1">rpcTag := tagv1.Tag{
                TagId: req.Msg.TagId,
                Name:  *req.Msg.Name,
                Color: *req.Msg.Color,
        }
        tag, err := ttag.SeralizeRpcToModel(&amp;rpcTag, idwrap.IDWrap{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerTag(ctx, c.ts, c.us, tag.ID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">err = c.ts.UpdateTag(ctx, *tag)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeUnknown, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;tagv1.TagUpdateResponse{}), nil</span>
}

func (c TagServiceRPC) TagDelete(ctx context.Context, req *connect.Request[tagv1.TagDeleteRequest]) (*connect.Response[tagv1.TagDeleteResponse], error) <span class="cov8" title="1">{
        tagID, err := idwrap.NewFromBytes(req.Msg.TagId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerTag(ctx, c.ts, c.us, tagID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">err = c.ts.DeleteTag(ctx, tagID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeUnknown, err)
        }</span>
        <span class="cov8" title="1">return connect.NewResponse(&amp;tagv1.TagDeleteResponse{}), nil</span>
}

func CheckOwnerTag(ctx context.Context, ts stag.TagService, us suser.UserService, tagID idwrap.IDWrap) (bool, error) <span class="cov8" title="1">{
        // TODO: add sql query to make it faster
        flow, err := ts.GetTag(ctx, tagID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return rworkspace.CheckOwnerWorkspace(ctx, us, flow.WorkspaceID)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package rvar

import (
        "bytes"
        "context"
        "database/sql"
        "errors"
        "log/slog"
        "sort"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/renv"
        "the-dev-tools/server/internal/api/rworkspace"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mvar"
        "the-dev-tools/server/pkg/permcheck"
        "the-dev-tools/server/pkg/service/senv"
        "the-dev-tools/server/pkg/service/suser"
        "the-dev-tools/server/pkg/service/svar"
        "the-dev-tools/server/pkg/translate/tgeneric"
        "the-dev-tools/server/pkg/translate/tvar"
        resourcesv1 "the-dev-tools/spec/dist/buf/go/resources/v1"
        variablev1 "the-dev-tools/spec/dist/buf/go/variable/v1"
        "the-dev-tools/spec/dist/buf/go/variable/v1/variablev1connect"

        "connectrpc.com/connect"
)

type VarRPC struct {
        DB *sql.DB

        us suser.UserService

        es senv.EnvService
        vs svar.VarService
}

func New(db *sql.DB, us suser.UserService, es senv.EnvService, vs svar.VarService) VarRPC <span class="cov8" title="1">{
        return VarRPC{
                DB: db,
                us: us,
                es: es,
                vs: vs,
        }
}</span>

func CreateService(srv VarRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := variablev1connect.NewVariableServiceHandler(&amp;srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

func (v *VarRPC) VariableList(ctx context.Context, req *connect.Request[variablev1.VariableListRequest]) (*connect.Response[variablev1.VariableListResponse], error) <span class="cov8" title="1">{
        envIDRaw, workspaceIDRaw := req.Msg.GetEnvironmentId(), req.Msg.GetWorkspaceId()
        if len(envIDRaw) != 0 </span><span class="cov8" title="1">{
                envID, err := idwrap.NewFromBytes(req.Msg.EnvironmentId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>
                <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(renv.CheckOwnerEnv(ctx, v.us, v.es, envID))
                if rpcErr != nil </span><span class="cov0" title="0">{
                        return nil, rpcErr
                }</span>
                <span class="cov8" title="1">vars, err := v.vs.GetVariablesByEnvIDOrdered(ctx, envID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov8" title="1">rpcVars := tgeneric.MassConvert(vars, tvar.SerializeModelToRPCItem)
                return connect.NewResponse(&amp;variablev1.VariableListResponse{Items: rpcVars, EnvironmentId: envIDRaw}), nil</span>

        } else<span class="cov8" title="1"> if len(workspaceIDRaw) != 0 </span><span class="cov8" title="1">{
                workspaceID, err := idwrap.NewFromBytes(req.Msg.WorkspaceId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>
                <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(rworkspace.CheckOwnerWorkspace(ctx, v.us, workspaceID))
                if rpcErr != nil </span><span class="cov0" title="0">{
                        return nil, rpcErr
                }</span>
                <span class="cov8" title="1">envs, err := v.es.GetByWorkspace(ctx, workspaceID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov8" title="1">var vars []mvar.Var
                for _, env := range envs </span><span class="cov8" title="1">{
                        envVars, err := v.vs.GetVariablesByEnvIDOrdered(ctx, env.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>

                        <span class="cov8" title="1">vars = append(vars, envVars...)</span>
                }

                <span class="cov8" title="1">sort.Slice(vars, func(i, j int) bool </span><span class="cov8" title="1">{
                        return bytes.Compare(vars[i].EnvID.Bytes(), vars[j].EnvID.Bytes()) &lt; 0
                }</span>)

                <span class="cov8" title="1">rpcVars := tgeneric.MassConvert(vars, tvar.SerializeModelToRPCItem)

                return connect.NewResponse(&amp;variablev1.VariableListResponse{
                        EnvironmentId: envIDRaw,
                        Items:         rpcVars,
                }), nil</span>
        }
        <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("workspace id or env ID is required"))</span>
}

func (v *VarRPC) VariableGet(ctx context.Context, req *connect.Request[variablev1.VariableGetRequest]) (*connect.Response[variablev1.VariableGetResponse], error) <span class="cov8" title="1">{
        id, err := idwrap.NewFromBytes(req.Msg.VariableId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerVar(ctx, v.us, v.vs, v.es, id))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">varible, err := v.vs.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">rpcVar := tvar.SerializeModelToRPC(*varible)
        rpcRawResp := &amp;variablev1.VariableGetResponse{
                VariableId:  rpcVar.VariableId,
                Name:        rpcVar.Name,
                Value:       rpcVar.Value,
                Enabled:     rpcVar.Enabled,
                Description: rpcVar.Description,
        }
        return connect.NewResponse(rpcRawResp), nil</span>
}

func (v *VarRPC) VariableCreate(ctx context.Context, req *connect.Request[variablev1.VariableCreateRequest]) (*connect.Response[variablev1.VariableCreateResponse], error) <span class="cov8" title="1">{
        envID, err := idwrap.NewFromBytes(req.Msg.GetEnvironmentId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(renv.CheckOwnerEnv(ctx, v.us, v.es, envID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>

        <span class="cov8" title="1">rpcVar := variablev1.Variable{
                Name:        req.Msg.Name,
                Value:       req.Msg.Value,
                Enabled:     req.Msg.Enabled,
                Description: req.Msg.Description,
        }

        varReq := tvar.DeserializeRPCToModelWithID(idwrap.NewNow(), envID, &amp;rpcVar)
        err = v.vs.Create(ctx, varReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">varReq.EnvID = envID

        return connect.NewResponse(&amp;variablev1.VariableCreateResponse{VariableId: varReq.ID.Bytes()}), nil</span>
}

func (c *VarRPC) VariableUpdate(ctx context.Context, req *connect.Request[variablev1.VariableUpdateRequest]) (*connect.Response[variablev1.VariableUpdateResponse], error) <span class="cov8" title="1">{
        msg := req.Msg

        var name string
        var value string
        var enabled bool
        var description string
        if msg.Name != nil </span><span class="cov8" title="1">{
                name = *msg.Name
        }</span>
        <span class="cov8" title="1">if msg.Value != nil </span><span class="cov8" title="1">{
                value = *msg.Value
        }</span>
        <span class="cov8" title="1">if msg.Enabled != nil </span><span class="cov8" title="1">{
                enabled = *msg.Enabled
        }</span>
        <span class="cov8" title="1">if msg.Description != nil </span><span class="cov8" title="1">{
                description = *msg.Description
        }</span>

        <span class="cov8" title="1">varConverted := &amp;variablev1.Variable{
                VariableId:  msg.GetVariableId(),
                Name:        name,
                Value:       value,
                Enabled:     enabled,
                Description: description,
        }
        varReq, err := tvar.DeserializeRPCToModel(varConverted)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerVar(ctx, c.us, c.vs, c.es, varReq.ID))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">err = c.vs.Update(ctx, &amp;varReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">return connect.NewResponse(&amp;variablev1.VariableUpdateResponse{}), nil</span>
}

func (c *VarRPC) VariableDelete(ctx context.Context, req *connect.Request[variablev1.VariableDeleteRequest]) (*connect.Response[variablev1.VariableDeleteResponse], error) <span class="cov8" title="1">{
        id, err := idwrap.NewFromBytes(req.Msg.GetVariableId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerVar(ctx, c.us, c.vs, c.es, id))
        if rpcErr != nil </span><span class="cov0" title="0">{
                return nil, rpcErr
        }</span>
        <span class="cov8" title="1">err = c.vs.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">return connect.NewResponse(&amp;variablev1.VariableDeleteResponse{}), nil</span>
}

func CheckOwnerVar(ctx context.Context, us suser.UserService, vs svar.VarService, es senv.EnvService, varID idwrap.IDWrap) (bool, error) <span class="cov8" title="1">{
        variable, err := vs.Get(ctx, varID)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">return renv.CheckOwnerEnv(ctx, us, es, variable.EnvID)</span>
}

func (c *VarRPC) VariableMove(ctx context.Context, req *connect.Request[variablev1.VariableMoveRequest]) (*connect.Response[variablev1.VariableMoveResponse], error) <span class="cov8" title="1">{
        // Validate variable ID
        variableID, err := idwrap.NewFromBytes(req.Msg.GetVariableId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // Validate target variable ID
        <span class="cov8" title="1">targetVariableID, err := idwrap.NewFromBytes(req.Msg.GetTargetVariableId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        // Check permissions for the variable being moved
        <span class="cov8" title="1">rpcErr := permcheck.CheckPerm(CheckOwnerVar(ctx, c.us, c.vs, c.es, variableID))
        if rpcErr != nil </span><span class="cov8" title="1">{
                return nil, rpcErr
        }</span>

        // Check permissions for the target variable
        <span class="cov8" title="1">rpcErr = permcheck.CheckPerm(CheckOwnerVar(ctx, c.us, c.vs, c.es, targetVariableID))
        if rpcErr != nil </span><span class="cov8" title="1">{
                return nil, rpcErr
        }</span>

        // Validate position
        <span class="cov8" title="1">position := req.Msg.GetPosition()
        if position == resourcesv1.MovePosition_MOVE_POSITION_UNSPECIFIED </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("position must be specified"))
        }</span>

        // Prevent moving variable relative to itself
        <span class="cov8" title="1">if variableID.Compare(targetVariableID) == 0 </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("cannot move variable relative to itself"))
        }</span>

        // Verify both variables are in the same environment
        <span class="cov8" title="1">sourceEnvID, err := c.vs.GetEnvID(ctx, variableID)
        if err != nil </span><span class="cov0" title="0">{
                if err == svar.ErrNoVarFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, errors.New("variable not found"))
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov8" title="1">targetEnvID, err := c.vs.GetEnvID(ctx, targetVariableID)
        if err != nil </span><span class="cov0" title="0">{
                if err == svar.ErrNoVarFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, errors.New("target variable not found"))
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov8" title="1">if sourceEnvID.Compare(targetEnvID) != 0 </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("variables must be in the same environment"))
        }</span>

        // Add debug logging for move operations
        <span class="cov8" title="1">slog.DebugContext(ctx, "VariableMove request",
                "variable_id", variableID.String(),
                "target_variable_id", targetVariableID.String(),
                "position", position.String(),
                "environment_id", sourceEnvID.String())

        // Execute the move operation
        switch position </span>{
        case resourcesv1.MovePosition_MOVE_POSITION_AFTER:<span class="cov8" title="1">
                err = c.vs.MoveVariableAfter(ctx, variableID, targetVariableID)</span>
        case resourcesv1.MovePosition_MOVE_POSITION_BEFORE:<span class="cov8" title="1">
                err = c.vs.MoveVariableBefore(ctx, variableID, targetVariableID)</span>
        default:<span class="cov0" title="0">
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid position"))</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                // Map service-level errors to appropriate Connect error codes
                if err == svar.ErrNoVarFound </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">if err == svar.ErrSelfReferentialMove </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>
                <span class="cov0" title="0">if err == svar.ErrEnvironmentBoundaryViolation </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov8" title="1">return connect.NewResponse(&amp;variablev1.VariableMoveResponse{}), nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package rworkspace

import (
        "context"
        "database/sql"
        "errors"
        devtoolsdb "the-dev-tools/db"
        "the-dev-tools/server/internal/api"
        "the-dev-tools/server/internal/api/middleware/mwauth"
        "the-dev-tools/server/pkg/dbtime"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/menv"
        "the-dev-tools/server/pkg/model/mworkspace"
        "the-dev-tools/server/pkg/model/mworkspaceuser"
        "the-dev-tools/server/pkg/service/senv"
        "the-dev-tools/server/pkg/service/suser"
        "the-dev-tools/server/pkg/service/sworkspace"
        "the-dev-tools/server/pkg/service/sworkspacesusers"
        "the-dev-tools/server/pkg/translate/tworkspace"
        resourcesv1 "the-dev-tools/spec/dist/buf/go/resources/v1"
        workspacev1 "the-dev-tools/spec/dist/buf/go/workspace/v1"
        "the-dev-tools/spec/dist/buf/go/workspace/v1/workspacev1connect"

        "connectrpc.com/connect"
        "google.golang.org/protobuf/types/known/emptypb"
        "google.golang.org/protobuf/types/known/timestamppb"
)

var ErrWorkspaceNotFound = errors.New("workspace not found")

type WorkspaceServiceRPC struct {
        DB  *sql.DB
        ws  sworkspace.WorkspaceService
        wus sworkspacesusers.WorkspaceUserService
        us  suser.UserService

        // env
        es senv.EnvService

        // TODO: @Ege move to private repo
        // email
        // ec  emailclient.EmailClient
        // eim *emailinvite.EmailTemplateManager
}

func New(db *sql.DB, ws sworkspace.WorkspaceService, wus sworkspacesusers.WorkspaceUserService, us suser.UserService, es senv.EnvService) WorkspaceServiceRPC <span class="cov8" title="1">{
        return WorkspaceServiceRPC{
                DB:  db,
                ws:  ws,
                wus: wus,
                us:  us,
                es:  es,
        }
}</span>

func CreateService(srv WorkspaceServiceRPC, options []connect.HandlerOption) (*api.Service, error) <span class="cov0" title="0">{
        path, handler := workspacev1connect.NewWorkspaceServiceHandler(&amp;srv, options...)
        return &amp;api.Service{Path: path, Handler: handler}, nil
}</span>

func (c *WorkspaceServiceRPC) GetWorkspace(ctx context.Context, req *connect.Request[workspacev1.WorkspaceGetRequest]) (*connect.Response[workspacev1.WorkspaceGetResponse], error) <span class="cov0" title="0">{
        wsID, err := idwrap.NewFromBytes(req.Msg.WorkspaceId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov0" title="0">userID, err := mwauth.GetContextUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("user id not found"))
        }</span>

        <span class="cov0" title="0">ws, err := c.ws.GetByIDandUserID(ctx, wsID, userID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sworkspace.ErrNoWorkspaceFound) </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov0" title="0">env, err := c.es.Get(ctx, ws.ActiveEnv)
        if err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, senv.ErrNoEnvFound) </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov0" title="0">resp := &amp;workspacev1.WorkspaceGetResponse{
                WorkspaceId:           ws.ID.Bytes(),
                Name:                  ws.Name,
                Updated:               timestamppb.New(ws.Updated),
                SelectedEnvironmentId: env.ID.Bytes(),
        }

        return connect.NewResponse(resp), nil</span>
}

func (c *WorkspaceServiceRPC) WorkspaceList(ctx context.Context, req *connect.Request[emptypb.Empty]) (*connect.Response[workspacev1.WorkspaceListResponse], error) <span class="cov8" title="1">{
        userID, err := mwauth.GetContextUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("user id not found"))
        }</span>

        <span class="cov8" title="1">workspaces, err := c.ws.GetWorkspacesByUserIDOrdered(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sworkspace.ErrNoWorkspaceFound) </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov8" title="1">var rpcWorkspaces []*workspacev1.WorkspaceListItem
        for _, workspace := range workspaces </span><span class="cov8" title="1">{
                env, err := c.es.Get(ctx, workspace.ActiveEnv)
                if err != nil </span><span class="cov8" title="1">{
                        if !errors.Is(err, senv.ErrNoEnvFound) </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov8" title="1">rpcworkspace := tworkspace.SeralizeWorkspaceItem(workspace, env)
                rpcWorkspaces = append(rpcWorkspaces, rpcworkspace)</span>

        }
        <span class="cov8" title="1">resp := &amp;workspacev1.WorkspaceListResponse{
                Items: rpcWorkspaces,
        }
        return connect.NewResponse(resp), nil</span>
}

func (c *WorkspaceServiceRPC) WorkspaceGet(ctx context.Context, req *connect.Request[workspacev1.WorkspaceGetRequest]) (*connect.Response[workspacev1.WorkspaceGetResponse], error) <span class="cov8" title="1">{
        workspaceID, err := idwrap.NewFromBytes(req.Msg.GetWorkspaceId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">userID, err := mwauth.GetContextUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("user id not found"))
        }</span>

        <span class="cov8" title="1">permc, err := c.us.CheckUserBelongsToWorkspace(ctx, userID, workspaceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">if !permc </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodePermissionDenied, errors.New("permission denied"))
        }</span>

        <span class="cov8" title="1">ws, err := c.ws.Get(ctx, workspaceID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sworkspace.ErrNoWorkspaceFound) </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov8" title="1">env, err := c.es.Get(ctx, ws.ActiveEnv)
        if err != nil </span><span class="cov8" title="1">{
                if !errors.Is(err, senv.ErrNoEnvFound) </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
        }

        <span class="cov8" title="1">rpcWs := tworkspace.SeralizeWorkspace(*ws, env)

        resp := &amp;workspacev1.WorkspaceGetResponse{
                WorkspaceId:           rpcWs.WorkspaceId,
                Name:                  rpcWs.Name,
                Updated:               rpcWs.Updated,
                SelectedEnvironmentId: rpcWs.SelectedEnvironmentId,
                CollectionCount:       rpcWs.CollectionCount,
                FlowCount:             rpcWs.FlowCount,
        }
        return connect.NewResponse(resp), nil</span>
}

func (c *WorkspaceServiceRPC) WorkspaceCreate(ctx context.Context, req *connect.Request[workspacev1.WorkspaceCreateRequest]) (*connect.Response[workspacev1.WorkspaceCreateResponse], error) <span class="cov8" title="1">{
        userID, err := mwauth.GetContextUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("user id not found"))
        }</span>
        <span class="cov8" title="1">name := req.Msg.GetName()
        if name == "" </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("name is required"))
        }</span>

        <span class="cov8" title="1">envID := idwrap.NewNow()

        workspaceidWrap := idwrap.NewNow()
        ws := &amp;mworkspace.Workspace{
                ID:        workspaceidWrap,
                Name:      name,
                Updated:   dbtime.DBNow(),
                ActiveEnv: envID,
                GlobalEnv: envID,
        }

        wsEnv := menv.Env{
                ID:          envID,
                WorkspaceID: workspaceidWrap,
                Name:        "default",
                Type:        menv.EnvGlobal,
        }

        wsUser := &amp;mworkspaceuser.WorkspaceUser{
                ID:          idwrap.NewNow(),
                WorkspaceID: workspaceidWrap,
                UserID:      userID,
                Role:        mworkspaceuser.RoleOwner,
        }

        tx, err := c.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">defer devtoolsdb.TxnRollback(tx)
        workspaceServiceTX, err := sworkspace.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = workspaceServiceTX.Create(ctx, ws)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">envServiceTX, err := senv.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = envServiceTX.Create(ctx, wsEnv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">workspaceUserServiceTX, err := sworkspacesusers.NewTX(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">err = workspaceUserServiceTX.CreateWorkspaceUser(ctx, wsUser)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">resp := &amp;workspacev1.WorkspaceCreateResponse{
                WorkspaceId: workspaceidWrap.Bytes(),
        }
        return connect.NewResponse(resp), nil</span>
}

func (c *WorkspaceServiceRPC) WorkspaceUpdate(ctx context.Context, req *connect.Request[workspacev1.WorkspaceUpdateRequest]) (*connect.Response[workspacev1.WorkspaceUpdateResponse], error) <span class="cov8" title="1">{
        workspaceUlid, err := idwrap.NewFromBytes(req.Msg.GetWorkspaceId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov8" title="1">userUlid, err := mwauth.GetContextUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("user id not found"))
        }</span>
        <span class="cov8" title="1">wsUser, err := c.wus.GetWorkspaceUsersByWorkspaceIDAndUserID(ctx, workspaceUlid, userUlid)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sworkspacesusers.ErrWorkspaceUserNotFound) </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, errors.New("workspace not found"))
                }</span>
        }
        // TODO: role system will change later
        <span class="cov8" title="1">if wsUser.Role &lt; mworkspaceuser.RoleAdmin </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodePermissionDenied, errors.New("permission denied"))
        }</span>
        <span class="cov8" title="1">ws, err := c.ws.Get(ctx, workspaceUlid)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, errors.New("workspace not found"))
                }</span>
        }

        <span class="cov8" title="1">envID := req.Msg.SelectedEnvironmentId
        if len(envID) != 0 </span><span class="cov8" title="1">{
                tempEnvID, err := idwrap.NewFromBytes(envID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInvalidArgument, err)
                }</span>
                <span class="cov8" title="1">ws.ActiveEnv = tempEnvID</span>
        }

        <span class="cov8" title="1">name := req.Msg.GetName()
        if name != "" </span><span class="cov8" title="1">{
                ws.Name = name
        }</span>
        <span class="cov8" title="1">err = c.ws.Update(ctx, ws)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov8" title="1">return connect.NewResponse(&amp;workspacev1.WorkspaceUpdateResponse{}), nil</span>
}

func (c *WorkspaceServiceRPC) WorkspaceDelete(ctx context.Context, req *connect.Request[workspacev1.WorkspaceDeleteRequest]) (*connect.Response[workspacev1.WorkspaceDeleteResponse], error) <span class="cov8" title="1">{
        userUlid, err := mwauth.GetContextUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("user id not found"))
        }</span>

        <span class="cov8" title="1">workspaceUlid, err := idwrap.NewFromBytes(req.Msg.GetWorkspaceId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>

        <span class="cov8" title="1">wsUser, err := c.wus.GetWorkspaceUsersByWorkspaceIDAndUserID(ctx, workspaceUlid, userUlid)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sworkspacesusers.ErrWorkspaceUserNotFound) </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, errors.New("workspace not found"))
                }</span>
        }

        <span class="cov8" title="1">if wsUser.Role != mworkspaceuser.RoleOwner </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodePermissionDenied, errors.New("permission denied"))
        }</span>

        <span class="cov8" title="1">err = c.ws.Delete(ctx, workspaceUlid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov8" title="1">return connect.NewResponse(&amp;workspacev1.WorkspaceDeleteResponse{}), nil</span>
}

func (c *WorkspaceServiceRPC) WorkspaceMemberList(ctx context.Context, req *connect.Request[workspacev1.WorkspaceMemberListRequest]) (*connect.Response[workspacev1.WorkspaceMemberListResponse], error) <span class="cov0" title="0">{
        actionUserUlid, err := mwauth.GetContextUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("user id not found"))
        }</span>
        <span class="cov0" title="0">workspaceUlid, err := idwrap.NewFromBytes(req.Msg.GetWorkspaceId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">ok, err := c.us.CheckUserBelongsToWorkspace(ctx, actionUserUlid, workspaceUlid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                // TODO: remove perm error for information leak
                return nil, connect.NewError(connect.CodePermissionDenied, errors.New("permission denied"))
        }</span>
        <span class="cov0" title="0">wsUsers, err := c.wus.GetWorkspaceUserByWorkspaceID(ctx, workspaceUlid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">rpcUser := make([]*workspacev1.WorkspaceMemberListItem, len(wsUsers))
        for i, wsUser := range wsUsers </span><span class="cov0" title="0">{
                user, err := c.us.GetUser(ctx, wsUser.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>

                <span class="cov0" title="0">rpcUser[i] = &amp;workspacev1.WorkspaceMemberListItem{
                        UserID: wsUser.UserID.Bytes(),
                        Email:  user.Email,
                        Role:   workspacev1.MemberRole(wsUser.Role),
                }</span>
        }

        <span class="cov0" title="0">return connect.NewResponse(&amp;workspacev1.WorkspaceMemberListResponse{Items: rpcUser}), nil</span>
}

func (c *WorkspaceServiceRPC) WorkspaceMemberCreate(ctx context.Context, req *connect.Request[workspacev1.WorkspaceMemberCreateRequest]) (*connect.Response[workspacev1.WorkspaceMemberCreateResponse], error) <span class="cov0" title="0">{
        // TODO: @Ege move to private repo
        // wid, err := idwrap.NewFromBytes(req.Msg.GetWorkspaceId())
        // if err != nil {
        //         return nil, connect.NewError(connect.CodeInvalidArgument, err)
        // }
        // // check email
        // if req.Msg.GetEmail() == "" {
        //         return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("email is required"))
        // }
        // // TODO: add more validation for email
        // userID, err := mwauth.GetContextUserID(ctx)
        // if err != nil {
        //         return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("user id not found"))
        // }

        // // check if workspace has the user
        // _, err = c.ws.GetByIDandUserID(ctx, wid, userID)
        // if err != nil {
        //         if err == sql.ErrNoRows {
        //                 return nil, connect.NewError(connect.CodeNotFound, errors.New("workspace not found"))
        //         }
        //         return nil, connect.NewError(connect.CodeInternal, err)
        // }

        // inviterUser, err := c.us.GetUser(ctx, userID)
        // if err != nil {
        //         return nil, connect.NewError(connect.CodeInternal, err)
        // }

        // invitedUser, err := c.us.GetUserByEmail(ctx, req.Msg.GetEmail())
        // if err != nil {
        //         if errors.Is(err, sql.ErrNoRows) {
        //                 invitedUser = &amp;muser.User{
        //                         ID:           idwrap.NewNow(),
        //                         Email:        req.Msg.GetEmail(),
        //                         Password:     nil,
        //                         ProviderType: muser.Unknown,
        //                         ProviderID:   nil,
        //                         Status:       muser.Pending,
        //                 }
        //                 err = c.us.CreateUser(ctx, invitedUser)
        //         }
        //         return nil, err
        // }

        // err = c.wus.CreateWorkspaceUser(ctx, &amp;mworkspaceuser.WorkspaceUser{
        //         ID:          idwrap.NewNow(),
        //         WorkspaceID: wid,
        //         UserID:      invitedUser.ID,
        //         Role:        mworkspaceuser.RoleUser,
        // })
        // if err != nil {
        //         return nil, connect.NewError(connect.CodeInternal, err)
        // }

        // workspace, err := c.ws.Get(ctx, wid)
        // if err != nil {
        //         return nil, connect.NewError(connect.CodeInternal, err)
        // }

        // // TODO: @Ege move to private repo
        // EmailInviteTemplateData := &amp;emailinvite.EmailInviteTemplateData{
        //         WorkspaceName:     workspace.Name,
        //         InviteLink:        "https://dev.tools",
        //         InvitedByUsername: inviterUser.Email,
        //         Username:          invitedUser.Email,
        // }

        // // TODO: add limit for sending email
        // err = c.eim.SendEmailInvite(ctx, req.Msg.GetEmail(), EmailInviteTemplateData)
        // if err != nil {
        //         return nil, connect.NewError(connect.CodeInternal, err)
        // }

        // TODO: look into this with new spec member id return just not possible
        return connect.NewResponse(&amp;workspacev1.WorkspaceMemberCreateResponse{}), nil
}</span>

func (c *WorkspaceServiceRPC) WorkspaceMemberDelete(ctx context.Context, req *connect.Request[workspacev1.WorkspaceMemberDeleteRequest]) (*connect.Response[workspacev1.WorkspaceMemberDeleteResponse], error) <span class="cov0" title="0">{
        workspaceULID, err := idwrap.NewFromBytes(req.Msg.GetWorkspaceId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">actionUserUlid, err := mwauth.GetContextUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("user id not found"))
        }</span>
        <span class="cov0" title="0">targetUserUlid, err := idwrap.NewFromBytes(req.Msg.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("user id not found"))
        }</span>

        <span class="cov0" title="0">ActionUser, err := c.wus.GetWorkspaceUsersByWorkspaceIDAndUserID(ctx, workspaceULID, actionUserUlid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">TargetUser, err := c.wus.GetWorkspaceUsersByWorkspaceIDAndUserID(ctx, workspaceULID, targetUserUlid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">ok, err := sworkspacesusers.IsPermGreater(ActionUser, TargetUser)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodePermissionDenied, errors.New("permission denied"))
        }</span>
        <span class="cov0" title="0">err = c.wus.DeleteWorkspaceUser(ctx, targetUserUlid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">return connect.NewResponse(&amp;workspacev1.WorkspaceMemberDeleteResponse{}), nil</span>
}

func (c *WorkspaceServiceRPC) WorkspaceMemberUpdate(ctx context.Context, req *connect.Request[workspacev1.WorkspaceMemberUpdateRequest]) (*connect.Response[workspacev1.WorkspaceMemberUpdateResponse], error) <span class="cov0" title="0">{
        workspaceULID, err := idwrap.NewFromBytes(req.Msg.GetWorkspaceId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInvalidArgument, err)
        }</span>
        <span class="cov0" title="0">actionUserUlid, err := mwauth.GetContextUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("user id not found"))
        }</span>
        <span class="cov0" title="0">targetUserUlid, err := idwrap.NewFromBytes(req.Msg.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("user id not found"))
        }</span>

        <span class="cov0" title="0">ActionUser, err := c.wus.GetWorkspaceUsersByWorkspaceIDAndUserID(ctx, workspaceULID, actionUserUlid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">TargetUser, err := c.wus.GetWorkspaceUsersByWorkspaceIDAndUserID(ctx, workspaceULID, targetUserUlid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>

        <span class="cov0" title="0">ok, err := sworkspacesusers.IsPermGreater(ActionUser, TargetUser)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodePermissionDenied, errors.New("permission denied"))
        }</span>
        <span class="cov0" title="0">TargetUser.Role = mworkspaceuser.Role(req.Msg.GetRole())

        // TODO: add check for user role such bigger then enum etc
        err = c.wus.UpdateWorkspaceUser(ctx, TargetUser)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeInternal, err)
        }</span>
        <span class="cov0" title="0">return connect.NewResponse(&amp;workspacev1.WorkspaceMemberUpdateResponse{}), nil</span>
}

func CheckOwnerWorkspace(ctx context.Context, su suser.UserService, workspaceID idwrap.IDWrap) (bool, error) <span class="cov0" title="0">{
        userID, err := mwauth.GetContextUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return su.CheckUserBelongsToWorkspace(ctx, userID, workspaceID)</span>
}

func (c *WorkspaceServiceRPC) WorkspaceMove(ctx context.Context, req *connect.Request[workspacev1.WorkspaceMoveRequest]) (*connect.Response[workspacev1.WorkspaceMoveResponse], error) <span class="cov8" title="1">{
        // Get user ID from authenticated context
        userID, err := mwauth.GetContextUserID(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeUnauthenticated, errors.New("user id not found"))
        }</span>

        // Validate workspace ID
        <span class="cov8" title="1">workspaceID, err := idwrap.NewFromBytes(req.Msg.GetWorkspaceId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid workspace id"))
        }</span>

        // Validate target workspace ID
        <span class="cov8" title="1">targetWorkspaceID, err := idwrap.NewFromBytes(req.Msg.GetTargetWorkspaceId())
        if err != nil </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid target workspace id"))
        }</span>

        // Validate position
        <span class="cov8" title="1">position := req.Msg.GetPosition()
        if position == resourcesv1.MovePosition_MOVE_POSITION_UNSPECIFIED </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("position must be specified"))
        }</span>

        // Prevent moving workspace relative to itself
        <span class="cov8" title="1">if workspaceID.Compare(targetWorkspaceID) == 0 </span><span class="cov8" title="1">{
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("cannot move workspace relative to itself"))
        }</span>

        // Verify user has access to both workspaces (source and target)
        <span class="cov8" title="1">_, err = c.ws.GetByIDandUserID(ctx, workspaceID, userID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sworkspace.ErrNoWorkspaceFound) </span><span class="cov8" title="1">{
                        return nil, connect.NewError(connect.CodeNotFound, errors.New("workspace not found"))
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov8" title="1">_, err = c.ws.GetByIDandUserID(ctx, targetWorkspaceID, userID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sworkspace.ErrNoWorkspaceFound) </span><span class="cov8" title="1">{
                        return nil, connect.NewError(connect.CodeNotFound, errors.New("target workspace not found"))
                }</span>
                <span class="cov0" title="0">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        // Execute the move operation
        <span class="cov8" title="1">switch position </span>{
        case resourcesv1.MovePosition_MOVE_POSITION_AFTER:<span class="cov8" title="1">
                err = c.ws.MoveWorkspaceAfter(ctx, userID, workspaceID, targetWorkspaceID)</span>
        case resourcesv1.MovePosition_MOVE_POSITION_BEFORE:<span class="cov8" title="1">
                err = c.ws.MoveWorkspaceBefore(ctx, userID, workspaceID, targetWorkspaceID)</span>
        default:<span class="cov0" title="0">
                return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("invalid position"))</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                // Map service-level errors to appropriate Connect error codes
                if errors.Is(err, sworkspace.ErrNoWorkspaceFound) </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
                <span class="cov8" title="1">return nil, connect.NewError(connect.CodeInternal, err)</span>
        }

        <span class="cov8" title="1">return connect.NewResponse(&amp;workspacev1.WorkspaceMoveResponse{}), nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package assertv2

import (
        "context"
        "fmt"
        "reflect"
        "regexp"
        "unicode"

        "github.com/PaesslerAG/gval"
)

type AssertType int8

type AssertTargetType int16

const (
        AssertTypeUndefined AssertType = iota
        AssertTypeEqual
        AssertTypeNotEqual
        AssertTypeContains
        AssertTypeNotContains
        AssertTypeGreater
        AssertTypeLess
        AssertTypeGreaterOrEqual
        AssertTypeLessOrEqual
)

const (
        AssertTypeEqualStr          = "=="
        AssertTypeNotEqualStr       = "!="
        AssertTypeContainsStr       = "in"
        AssertTypeNotContainsStr    = "in"
        AssertTypeGreaterStr        = "&gt;"
        AssertTypeLessStr           = "&lt;"
        AssertTypeGreaterOrEqualStr = "&gt;="
        AssertTypeLessOrEqualStr    = "&lt;="
)

const (
        AssertTargetTypeUndefined AssertTargetType = iota
        AssertTargetTypeBody
        AssertTargetTypeHeader
        AssertTargetTypeResponse
        AssertTargetTypeQuery
        AssertTargetTypeNode
)

const (
        AssertPathResponse = "response"
        AssertPathBody     = "body"
        AssertPathHeader   = "header"
        AssertPathQuery    = "query"
        AssertPathNode     = "node"
)

// TODO: refactor this module
type AssertSystem struct {
        root *AssertRoot
}

func NewAssertSystem(root *AssertRoot) *AssertSystem <span class="cov8" title="1">{
        return &amp;AssertSystem{
                root: root,
        }
}</span>

type AssertRoot struct {
        Leaf interface{}
}

func NewAssertRoot(leaf interface{}) *AssertRoot <span class="cov8" title="1">{
        return &amp;AssertRoot{
                Leaf: leaf,
        }
}</span>

func NewAssertMapLeaf(leaf map[string]interface{}) AssertRoot <span class="cov0" title="0">{
        return AssertRoot{
                Leaf: leaf,
        }
}</span>

type AssertLeaf interface {
        Get(ctx context.Context, k string) (AssertLeafResponse, error)
}

type AssertLeafResponse struct {
        Result *interface{}
        Leaf   *AssertLeaf
}

func NewAssertLeafResponse(result *interface{}, leaf *AssertLeaf) AssertLeafResponse <span class="cov0" title="0">{
        return AssertLeafResponse{
                Result: result,
                Leaf:   leaf,
        }
}</span>

func NotinArray(a, b interface{}) (interface{}, error) <span class="cov0" title="0">{
        col, ok := b.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected type []interface{} for in operator but got %T", b)
        }</span>
        <span class="cov0" title="0">for _, value := range col </span><span class="cov0" title="0">{
                if reflect.DeepEqual(a, value) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

func (s AssertSystem) EvalBool(ctx context.Context, expr string, extensions ...gval.Language) (bool, error) <span class="cov8" title="1">{
        ln := gval.Full(extensions...)
        eval, err := ln.NewEvaluable(expr)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return eval.EvalBool(ctx, s.root.Leaf)</span>
}

var Regex *regexp.Regexp = regexp.MustCompile(`^[a-zA-Z0-9._-]+$`)

var Langs []gval.Language = []gval.Language{
        gval.NewLanguage(
                gval.Init(func(ctx context.Context, p *gval.Parser) (gval.Evaluable, error) <span class="cov8" title="1">{
                        p.SetIsIdentRuneFunc(func(r rune, pos int) bool </span><span class="cov8" title="1">{
                                return unicode.IsLetter(r) || r == '_' || (pos &gt; 0 &amp;&amp; unicode.IsDigit(r)) || (pos &gt; 0 &amp;&amp; r == '-')
                        }</span>)
                        <span class="cov8" title="1">return p.ParseExpression(ctx)</span>
                })),
        gval.InfixOperator("notin", NotinArray),
}

func ToSliceOfAny[T any](s []T) []any <span class="cov0" title="0">{
        result := make([]any, len(s))
        for i, v := range s </span><span class="cov0" title="0">{
                result[i] = v
        }</span>
        <span class="cov0" title="0">return result</span>
}

func (s AssertSystem) EvalArray(ctx context.Context, expr string, extensions ...gval.Language) ([]interface{}, error) <span class="cov0" title="0">{
        ln := gval.Full(extensions...)
        a, err := ln.EvaluateWithContext(ctx, expr, s.root.Leaf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if a is slice
        <span class="cov0" title="0">arr, ok := a.([]interface{})
        if !ok </span><span class="cov0" title="0">{
                // Try to convert to []interface{}
                switch v := a.(type) </span>{
                case []string:<span class="cov0" title="0">
                        arr = make([]interface{}, len(v))
                        for i, val := range v </span><span class="cov0" title="0">{
                                arr[i] = val
                        }</span>
                case []int:<span class="cov0" title="0">
                        arr = make([]interface{}, len(v))
                        for i, val := range v </span><span class="cov0" title="0">{
                                arr[i] = val
                        }</span>
                case []float64:<span class="cov0" title="0">
                        arr = make([]interface{}, len(v))
                        for i, val := range v </span><span class="cov0" title="0">{
                                arr[i] = val
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("expected type []interface{} but got %T", a)</span>
                }
        }

        <span class="cov0" title="0">return arr, nil</span>
}

func (s AssertSystem) EvalMap(ctx context.Context, expr string, extensions ...gval.Language) (map[string]interface{}, error) <span class="cov0" title="0">{
        ln := gval.Full(extensions...)
        a, err := ln.EvaluateWithContext(ctx, expr, s.root.Leaf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">arr, ok := a.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                // Try to convert to []interface{}
                switch v := a.(type) </span>{
                case map[string]string:<span class="cov0" title="0">
                        arr = make(map[string]interface{}, len(v))
                        for k, val := range v </span><span class="cov0" title="0">{
                                arr[k] = val
                        }</span>
                case map[string]int:<span class="cov0" title="0">
                        arr = make(map[string]interface{}, len(v))
                        for k, val := range v </span><span class="cov0" title="0">{
                                arr[k] = val
                        }</span>
                case map[string]float64:<span class="cov0" title="0">
                        arr = make(map[string]interface{}, len(v))
                        for k, val := range v </span><span class="cov0" title="0">{
                                arr[k] = val
                        }</span>
                case map[string]float32:<span class="cov0" title="0">
                        arr = make(map[string]interface{}, len(v))
                        for k, val := range v </span><span class="cov0" title="0">{
                                arr[k] = val
                        }</span>
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("expected type []interface{} but got %T", a)</span>
                }
        }

        <span class="cov0" title="0">return arr, nil</span>
}

func (s AssertSystem) AssertSimple(ctx context.Context, assertType AssertType, path string, value any) (bool, error) <span class="cov8" title="1">{
        // Regex should not contain any special characters
        // only dot (.) is allowed
        // TODO: change the regex to allow only dot (.), underscore (_), and hyphen (-)
        if !Regex.MatchString(path) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("invalid path: %s", path)
        }</span>

        <span class="cov8" title="1">assertTypeStr := ConvertAssertTypeToExpr(assertType)

        constLang := gval.Constant("y", value)
        tempLangs := append(Langs, constLang)

        expr := fmt.Sprintf("y %s %s", assertTypeStr, path)
        a, err := s.EvalBool(ctx, expr, tempLangs...)

        if assertType == AssertTypeNotContains </span><span class="cov8" title="1">{
                a = !a
        }</span>
        <span class="cov8" title="1">return a, err</span>
}

func (s AssertSystem) AssertComplex(ctx context.Context, expr string) (bool, error) <span class="cov0" title="0">{

        return s.EvalBool(ctx, expr)
}</span>

func (s AssertSystem) AssertAny(ctx context.Context, expr string, extensions ...gval.Language) (any, error) <span class="cov0" title="0">{
        ln := gval.Full(extensions...)
        return ln.EvaluateWithContext(ctx, expr, s.root.Leaf)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package assertv2

/*
const (
        AssertTypeUndefined AssertType = iota
        AssertTypeEqual
        AssertTypeNotEqual
        AssertTypeContains
        AssertTypeNotContains
        AssertTypeGreater
        AssertTypeLess
        AssertTypeGreaterOrEqual
        AssertTypeLessOrEqual
)

const (
        AssertTypeEqualStr       = "=="
        AssertTypeNotEqualStr    = "!="
        AssertTypeContainsStr    = "in"
        AssertTypeNotContainsStr = "not in"
        TypeGreaterStr           = "&gt;"
        TypeLessStr              = "&lt;"
        TypeGreaterOrEqualStr    = "&gt;="
        TypeLessOrEqualStr       = "&lt;="
)
*/

func ConvertAssertTypeToExpr(assertType AssertType) string <span class="cov8" title="1">{
        switch assertType </span>{
        case AssertTypeEqual:<span class="cov8" title="1">
                return AssertTypeEqualStr</span>
        case AssertTypeNotEqual:<span class="cov0" title="0">
                return AssertTypeNotEqualStr</span>
        case AssertTypeContains:<span class="cov8" title="1">
                return AssertTypeContainsStr</span>
        case AssertTypeNotContains:<span class="cov8" title="1">
                return AssertTypeNotContainsStr</span>
        case AssertTypeGreater:<span class="cov0" title="0">
                return AssertTypeGreaterStr</span>
        case AssertTypeLess:<span class="cov0" title="0">
                return AssertTypeLessStr</span>
        case AssertTypeGreaterOrEqual:<span class="cov0" title="0">
                return AssertTypeGreaterOrEqualStr</span>
        case AssertTypeLessOrEqual:<span class="cov0" title="0">
                return AssertTypeLessOrEqualStr</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func ConvertAssertTargetTypeToPath(assertTargetType AssertTargetType) string <span class="cov0" title="0">{
        switch assertTargetType </span>{
        case AssertTargetTypeBody:<span class="cov0" title="0">
                return AssertPathBody</span>
        case AssertTargetTypeHeader:<span class="cov0" title="0">
                return AssertPathHeader</span>
        case AssertTargetTypeResponse:<span class="cov0" title="0">
                return AssertPathResponse</span>
        case AssertTargetTypeQuery:<span class="cov0" title="0">
                return AssertPathQuery</span>
        case AssertTargetTypeNode:<span class="cov0" title="0">
                return AssertPathNode</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package leafjson

import (
        "context"
        "encoding/json"
        "errors"
        "the-dev-tools/server/pkg/assertv2"
)

type LeafJSON struct {
        JsonMap map[string]interface{}
}

// TODO: refactor this to not use json.Marshal
func NewWithStruct(a interface{}) (*LeafJSON, error) <span class="cov0" title="0">{
        jsonBytes, err := json.Marshal(a)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var m map[string]interface{}
        err = json.Unmarshal(jsonBytes, &amp;m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return New(m), nil</span>
}

func New(input map[string]interface{}) *LeafJSON <span class="cov0" title="0">{
        return &amp;LeafJSON{
                JsonMap: input,
        }
}</span>

// TODO: add tests
func (l *LeafJSON) SelectGVal(ctx context.Context, k string) (interface{}, error) <span class="cov0" title="0">{
        leaf, ok := l.JsonMap[k]
        if !ok </span><span class="cov0" title="0">{
                return assertv2.AssertLeafResponse{}, errors.New("key not found")
        }</span>
        <span class="cov0" title="0">return leaf, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package leafmap

import (
        "context"
        "errors"
        "maps"
        "the-dev-tools/server/pkg/assertv2"
)

type LeafMap struct {
        Leafs map[string]interface{}
}

// TODO: add tests
func (l *LeafMap) SelectGVal(ctx context.Context, k string) (interface{}, error) <span class="cov0" title="0">{
        leaf, ok := l.Leafs[k]
        if !ok </span><span class="cov0" title="0">{
                return assertv2.AssertLeafResponse{}, errors.New("key not found")
        }</span>
        <span class="cov0" title="0">return leaf, nil</span>
}

func ConvertMapToLeafMap(oldMap map[string]any) *LeafMap <span class="cov0" title="0">{
        newMap := make(map[string]any)
        maps.Copy(newMap, oldMap)

        for k, v := range newMap </span><span class="cov0" title="0">{
                castedMap, ok := v.(map[string]any)
                if ok </span><span class="cov0" title="0">{
                        newMap[k] = ConvertMapToLeafMap(castedMap)
                }</span>
        }
        <span class="cov0" title="0">return &amp;LeafMap{Leafs: newMap}</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package leafmock

import (
        "context"
        "errors"
        "the-dev-tools/server/pkg/assertv2"
)

type LeafMock struct {
        DoFunc *func() (interface{}, error)
        Leafs  map[string]interface{}
}

// TODO: add tests
func (l *LeafMock) SelectGVal(ctx context.Context, k string) (interface{}, error) <span class="cov0" title="0">{
        if l.DoFunc != nil </span><span class="cov0" title="0">{
                _, err := (*l.DoFunc)()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">leaf, ok := l.Leafs[k]
        if !ok </span><span class="cov0" title="0">{
                return assertv2.AssertLeafResponse{}, errors.New("key not found")
        }</span>
        <span class="cov0" title="0">return leaf, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package compress

import (
        "bytes"
        "compress/gzip"
        "fmt"
        "io"
        "the-dev-tools/server/pkg/zstdcompress"

        "github.com/andybalholm/brotli"
)

type CompressType = int8

const (
        CompressTypeNone CompressType = 0
        CompressTypeGzip CompressType = 1
        CompressTypeZstd CompressType = 2
        CompressTypeBr   CompressType = 3
)

var CompressLockupMap map[string]CompressType = map[string]CompressType{
        "":     CompressTypeNone,
        "gzip": CompressTypeGzip,
        "zstd": CompressTypeZstd,
        "br":   CompressTypeBr,
}

// TODO: refactor this for better performance
func Compress(data []byte, compressType CompressType) ([]byte, error) <span class="cov0" title="0">{
        var buf bytes.Buffer
        switch compressType </span>{
        case CompressTypeGzip:<span class="cov0" title="0">
                // compress data with gzip
                z := gzip.NewWriter(&amp;buf)
                _, err := z.Write(data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">err = z.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        case CompressTypeZstd:<span class="cov0" title="0">
                byteArr := zstdcompress.Compress(data)
                buf.Write(byteArr)</span>
        case CompressTypeBr:<span class="cov0" title="0">
                // compress data with brotli
                w := brotli.NewWriter(&amp;buf)
                _, err := w.Write(data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">err = w.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

func Decompress(data []byte, compressType CompressType) ([]byte, error) <span class="cov0" title="0">{
        var buf bytes.Buffer
        buf.Write(data)

        switch compressType </span>{
        case CompressTypeGzip:<span class="cov0" title="0">
                // decompress data with gzip
                z, err := gzip.NewReader(&amp;buf)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">err = z.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return io.ReadAll(z)</span>

        case CompressTypeZstd:<span class="cov0" title="0">
                return zstdcompress.Decompress(data)</span>
        case CompressTypeBr:<span class="cov0" title="0">
                // decompress data with brotli
                br := brotli.NewReader(&amp;buf)
                return io.ReadAll(br)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported compression type: %v", compressType)</span>
        }
}

func DecompressWithContentEncodeStr(data []byte, contentEncoding string) ([]byte, error) <span class="cov0" title="0">{
        compressType, ok := CompressLockupMap[contentEncoding]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%s encoding not supported", contentEncoding)
        }</span>

        <span class="cov0" title="0">return Decompress(data, compressType)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package customerror

type CustomError struct {
        userError     string
        internalError string
}

func New(userError, internalError string) CustomError <span class="cov0" title="0">{
        return CustomError{
                userError:     userError,
                internalError: internalError,
        }
}</span>

func (c CustomError) Error() string <span class="cov0" title="0">{
        return c.internalError
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package dbtime

import "time"

type DBTimeData time.Time

func (t DBTimeData) Time() time.Time <span class="cov0" title="0">{
        return DBTime(time.Time(t))
}</span>

func DBNow() time.Time <span class="cov0" title="0">{
        return DBTime(time.Now())
}</span>

func DBTime(t time.Time) time.Time <span class="cov0" title="0">{
        return t.UTC()
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package depfinder

import (
        "encoding/json"
        "errors"
        "fmt"
        "reflect"
        "sort"
        "strings"
        "the-dev-tools/server/pkg/idwrap"
)

type VarCouple struct {
        Path   string
        NodeID idwrap.IDWrap
}

type DepFinder struct {
        vars map[any]VarCouple
}

func NewDepFinder() DepFinder <span class="cov8" title="1">{
        return DepFinder{vars: make(map[any]VarCouple)}
}</span>

func (d DepFinder) AddVar(value any, couple VarCouple) <span class="cov8" title="1">{
        if _, exists := d.vars[value]; !exists </span><span class="cov8" title="1">{
                d.vars[value] = couple
        }</span>
}

func (d DepFinder) AddJsonBytes(value []byte, couple VarCouple) error <span class="cov8" title="1">{
        var data any
        if err := json.Unmarshal(value, &amp;data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">d.addJsonValue(data, couple)
        return nil</span>
}

var (
        ErrNotFound     = errors.New("variable not found")
        ErrTypeMismatch = errors.New("type mismatch")
)

func (d DepFinder) FindVar(value any) (VarCouple, error) <span class="cov8" title="1">{
        res, ok := d.vars[value]
        var err error = nil
        if !ok </span><span class="cov8" title="1">{
                err = ErrNotFound
        }</span>
        <span class="cov8" title="1">return res, err</span>
}

func (d DepFinder) addJsonValue(value any, couple VarCouple) <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case map[string]any:<span class="cov8" title="1">
                for key, val := range v </span><span class="cov8" title="1">{
                        newPath := couple.Path
                        if newPath != "" </span><span class="cov8" title="1">{
                                newPath += "."
                        }</span>
                        <span class="cov8" title="1">newPath += key

                        // Only add primitive values to the vars map
                        switch val.(type) </span>{
                        case string, float64, bool, int, int64:<span class="cov8" title="1">
                                d.AddVar(val, VarCouple{Path: newPath, NodeID: couple.NodeID})
                                continue</span>
                        }

                        <span class="cov8" title="1">d.addJsonValue(val, VarCouple{Path: newPath, NodeID: couple.NodeID})</span>
                }
        case []any:<span class="cov8" title="1">
                for i, val := range v </span><span class="cov8" title="1">{
                        newPath := fmt.Sprintf("%s[%d]", couple.Path, i)

                        // Only add primitive values to the vars map
                        switch val.(type) </span>{
                        case string, float64, bool, int, int64:<span class="cov8" title="1">
                                d.AddVar(val, VarCouple{Path: newPath, NodeID: couple.NodeID})
                                continue</span>
                        }

                        <span class="cov0" title="0">d.addJsonValue(val, VarCouple{Path: newPath, NodeID: couple.NodeID})</span>
                }
        }
}

func (d DepFinder) FindInJsonBytes(jsonBytes []byte, value interface{}) (string, error) <span class="cov8" title="1">{
        var data interface{}
        if err := json.Unmarshal(jsonBytes, &amp;data); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">path, matches := d.findJsonValue(data, "", value)
        if !matches </span><span class="cov8" title="1">{
                return "", ErrNotFound
        }</span>
        <span class="cov8" title="1">return path, nil</span>
}

func (d DepFinder) findJsonValue(jsonValue interface{}, path string, searchValue interface{}) (string, bool) <span class="cov8" title="1">{
        // Check if current value matches
        if reflect.DeepEqual(jsonValue, searchValue) </span><span class="cov0" title="0">{
                return path, true
        }</span>

        <span class="cov8" title="1">switch v := jsonValue.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                for key, val := range v </span><span class="cov8" title="1">{
                        newPath := path
                        if path != "" </span><span class="cov8" title="1">{
                                newPath += "."
                        }</span>
                        <span class="cov8" title="1">newPath += key
                        if reflect.DeepEqual(val, searchValue) </span><span class="cov8" title="1">{
                                return newPath, true
                        }</span>
                        <span class="cov8" title="1">if foundPath, found := d.findJsonValue(val, newPath, searchValue); found </span><span class="cov8" title="1">{
                                return foundPath, true
                        }</span>
                }
        case []interface{}:<span class="cov8" title="1">
                for i, val := range v </span><span class="cov8" title="1">{
                        newPath := fmt.Sprintf("%s[%d]", path, i)
                        if reflect.DeepEqual(val, searchValue) </span><span class="cov8" title="1">{
                                return newPath, true
                        }</span>
                        <span class="cov8" title="1">if foundPath, found := d.findJsonValue(val, newPath, searchValue); found </span><span class="cov0" title="0">{
                                return foundPath, true
                        }</span>
                }
        }

        <span class="cov8" title="1">return "", false</span>
}

type TemplateJSONResult struct {
        FindAny bool
        Couples []VarCouple
        NewJson []byte
        Err     error
}

func (d DepFinder) TemplateJSON(jsonBytes []byte) TemplateJSONResult <span class="cov8" title="1">{
        data := make(map[string]any)
        // unmarshal the json bytes to a map

        if err := json.Unmarshal(jsonBytes, &amp;data); err != nil </span><span class="cov0" title="0">{
                return TemplateJSONResult{Err: err}
        }</span>

        // Process the JSON structure
        <span class="cov8" title="1">templated, findAny, couples := d.ReplaceWithPaths(data)

        // Marshal back to JSON
        jsonBytes, err := json.Marshal(templated)
        return TemplateJSONResult{FindAny: findAny, Couples: couples, NewJson: jsonBytes, Err: err}</span>
}

// replace value with path if the value in vars
func (d DepFinder) ReplaceWithPaths(value any) (any, bool, []VarCouple) <span class="cov8" title="1">{
        return d.replaceWithPaths(value, false) // JSON mode: exact match only
}</span>

// ReplaceWithPathsSubstring allows substring replacement for token templating
func (d DepFinder) ReplaceWithPathsSubstring(value any) (any, bool, []VarCouple) <span class="cov8" title="1">{
        return d.replaceWithPaths(value, true) // Token mode: allow substring replacement
}</span>

func (d DepFinder) replaceWithPaths(value any, allowSubstring bool) (any, bool, []VarCouple) <span class="cov8" title="1">{
        var findAny bool
        var couples []VarCouple
        var couplesSub []VarCouple

        switch v := value.(type) </span>{
        case map[string]any:<span class="cov8" title="1">
                // sort the map to make it deterministic
                keys := make([]string, 0, len(v))
                for key := range v </span><span class="cov8" title="1">{
                        keys = append(keys, key)
                }</span>
                <span class="cov8" title="1">sort.Strings(keys)
                result := make(map[string]any)
                for _, key := range keys </span><span class="cov8" title="1">{
                        val := v[key]
                        result[key], findAny, couplesSub = d.replaceWithPaths(val, allowSubstring)
                        couples = append(couples, couplesSub...)
                }</span>
                <span class="cov8" title="1">return result, findAny, couples</span>

        case []any:<span class="cov8" title="1">
                result := make([]any, len(v))
                for i, val := range v </span><span class="cov8" title="1">{
                        result[i], findAny, couplesSub = d.replaceWithPaths(val, allowSubstring)
                        couples = append(couples, couplesSub...)
                }</span>
                <span class="cov8" title="1">return result, findAny, couples</span>

        case string:<span class="cov8" title="1">
                // First try exact match
                if couple, err := d.FindVar(v); err == nil </span><span class="cov8" title="1">{
                        return fmt.Sprintf("{{ %s }}", couple.Path), true, []VarCouple{couple}
                }</span>

                // Try partial string replacement for substrings (only if enabled)
                <span class="cov8" title="1">if allowSubstring </span><span class="cov8" title="1">{
                        result := v
                        var foundAny bool
                        var allCouples []VarCouple

                        // Check each known variable to see if it appears as a substring
                        for varValue, couple := range d.vars </span><span class="cov8" title="1">{
                                if strValue, ok := varValue.(string); ok &amp;&amp; len(strValue) &gt; 0 </span><span class="cov8" title="1">{
                                        // Replace all occurrences of this token in the string
                                        if strings.Contains(result, strValue) </span><span class="cov8" title="1">{
                                                template := fmt.Sprintf("{{ %s }}", couple.Path)
                                                result = strings.ReplaceAll(result, strValue, template)
                                                foundAny = true
                                                allCouples = append(allCouples, couple)
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">if foundAny </span><span class="cov8" title="1">{
                                return result, true, allCouples
                        }</span>
                }

                <span class="cov8" title="1">return v, false, nil</span>

        case int, int64, float64:<span class="cov8" title="1">
                // Handle numeric values
                if couple, err := d.FindVar(v); err == nil </span><span class="cov8" title="1">{
                        return fmt.Sprintf("{{ %s }}", couple.Path), true, []VarCouple{couple}
                }</span>
                <span class="cov0" title="0">return v, false, nil</span>

        case bool:<span class="cov8" title="1">
                // Handle boolean values
                if couple, err := d.FindVar(v); err == nil </span><span class="cov8" title="1">{
                        return fmt.Sprintf("{{ %s }}", couple.Path), true, []VarCouple{couple}
                }</span>
                <span class="cov0" title="0">return v, false, nil</span>

        default:<span class="cov0" title="0">
                return v, false, nil</span>
        }
}

// IsUUID checks if a string matches UUID format (8-4-4-4-12 hex characters)
func IsUUID(s string) bool <span class="cov8" title="1">{
        if len(s) != 36 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for i, char := range s </span><span class="cov8" title="1">{
                if i == 8 || i == 13 || i == 18 || i == 23 </span><span class="cov8" title="1">{
                        if char != '-' </span><span class="cov8" title="1">{
                                return false
                        }</span>
                } else<span class="cov8" title="1"> {
                        if (char &lt; '0' || char &gt; '9') &amp;&amp; (char &lt; 'a' || char &gt; 'f') &amp;&amp; (char &lt; 'A' || char &gt; 'F') </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

// ReplaceURLPathParams detects UUIDs in URL paths and replaces them with templated variables
func (d DepFinder) ReplaceURLPathParams(url string) (string, bool, []VarCouple) <span class="cov8" title="1">{
        var couples []VarCouple
        var foundAny bool

        // Split URL by '/' to get path segments
        parts := strings.Split(url, "/")

        for i, part := range parts </span><span class="cov8" title="1">{
                // Check if this part looks like a UUID
                if IsUUID(part) </span><span class="cov8" title="1">{
                        // Try to find this UUID in our vars
                        if couple, err := d.FindVar(part); err == nil </span><span class="cov8" title="1">{
                                parts[i] = fmt.Sprintf("{{ %s }}", couple.Path)
                                couples = append(couples, couple)
                                foundAny = true
                        }</span>
                }
        }

        <span class="cov8" title="1">if foundAny </span><span class="cov8" title="1">{
                return strings.Join(parts, "/"), foundAny, couples
        }</span>

        <span class="cov8" title="1">return url, false, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package expression

import (
        "context"
        "encoding/json"
        "fmt"
        "iter"
        "reflect"
        "strings"
        "the-dev-tools/server/pkg/flow/tracking"
        "the-dev-tools/server/pkg/varsystem"

        "github.com/expr-lang/expr"
)

type Env struct {
        varMap map[string]any
}

func NewEnv(varMap map[string]any) Env <span class="cov8" title="1">{
        return Env{
                varMap: varMap,
        }
}</span>

// GetVarMap returns the internal varMap for debugging purposes
func (e Env) GetVarMap() map[string]any <span class="cov0" title="0">{
        return e.varMap
}</span>

func NormalizeExpression(ctx context.Context, expressionString string, varsystem varsystem.VarMap) (string, error) <span class="cov8" title="1">{
        // trim spaces
        expressionString = strings.TrimSpace(expressionString)
        normalizedString, err := varsystem.ReplaceVars(expressionString)
        if err != nil </span><span class="cov8" title="1">{
                return expressionString, err
        }</span>
        <span class="cov8" title="1">return normalizedString, nil</span>

}

// convertStructToMapWithJSONTags recursively converts a struct to a map using JSON tags
func convertStructToMapWithJSONTags(v any) (any, error) <span class="cov0" title="0">{
        // Use JSON marshaling and unmarshaling to handle nested structs with JSON tags
        jsonData, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result any
        err = json.Unmarshal(jsonData, &amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func NewEnvFromStruct(s any) (Env, error) <span class="cov0" title="0">{
        varMap := make(map[string]any)
        val := reflect.ValueOf(s)

        if val.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return Env{}, fmt.Errorf("input is not a struct, got %T", s)
        }</span>

        <span class="cov0" title="0">typ := reflect.TypeOf(s)
        for i := range val.NumField() </span><span class="cov0" title="0">{
                fieldValue := val.Field(i)
                field := typ.Field(i)

                // Use JSON tag if available, otherwise use field name
                fieldName := field.Name
                if jsonTag := field.Tag.Get("json"); jsonTag != "" </span><span class="cov0" title="0">{
                        // Handle JSON tag options like "fieldname,omitempty"
                        jsonFieldName := jsonTag
                        if commaIndex := strings.Index(jsonTag, ","); commaIndex != -1 </span><span class="cov0" title="0">{
                                jsonFieldName = jsonTag[:commaIndex]
                        }</span>
                        <span class="cov0" title="0">if jsonFieldName != "" &amp;&amp; jsonFieldName != "-" </span><span class="cov0" title="0">{
                                fieldName = jsonFieldName
                        }</span>
                }

                // Convert the field value to use JSON tag names recursively
                <span class="cov0" title="0">convertedValue, err := convertStructToMapWithJSONTags(fieldValue.Interface())
                if err != nil </span><span class="cov0" title="0">{
                        return Env{}, err
                }</span>

                <span class="cov0" title="0">varMap[fieldName] = convertedValue</span>
        }

        <span class="cov0" title="0">return NewEnv(varMap), nil</span>
}

func ExpressionEvaluteAsBool(ctx context.Context, env Env, expressionString string) (bool, error) <span class="cov8" title="1">{
        program, err := expr.Compile(expressionString, expr.AsBool(), expr.Env(env.varMap))
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">output, err := expr.Run(program, env.varMap)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">ok := output.(bool)
        return ok, nil</span>
}

func ExpressionEvaluteAsArray(ctx context.Context, env Env, expressionString string) ([]any, error) <span class="cov8" title="1">{
        program, err := expr.Compile(expressionString, expr.AsAny(), expr.Env(env.varMap))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output, err := expr.Run(program, env.varMap) // Pass the map directly
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // expr.Run can return []interface{} for arrays. Convert it to []any.
        <span class="cov8" title="1">if outputSlice, ok := output.([]any); ok </span><span class="cov8" title="1">{
                return outputSlice, nil
        }</span>

        // If it's not []interface{}, check if it's already []any (less common for expr output)
        <span class="cov8" title="1">if outputAnySlice, ok := output.([]any); ok </span><span class="cov0" title="0">{
                return outputAnySlice, nil
        }</span>

        // If it's neither, it's not an array
        <span class="cov8" title="1">return nil, fmt.Errorf("expected array, but got %T", output)</span>
}

// ExpressionEvaluateAsIter evaluates the expression and returns an iterator sequence
// (iter.Seq[any] for slices, iter.Seq2[string, any] for maps) if the result is iterable.
// Otherwise, it returns an error.
func ExpressionEvaluateAsIter(ctx context.Context, env Env, expressionString string) (any, error) <span class="cov0" title="0">{
        program, err := expr.Compile(expressionString, expr.AsAny(), expr.Env(env.varMap))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">output, err := expr.Run(program, env.varMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if the result is an iterable type (map or slice/array)
        <span class="cov0" title="0">val := reflect.ValueOf(output)
        switch val.Kind() </span>{
        case reflect.Map:<span class="cov0" title="0">
                // Handle map iteration
                if val.Type().Key().Kind() != reflect.String </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("map keys must be strings for iteration, got %s", val.Type().Key().Kind())
                }</span>
                <span class="cov0" title="0">seq := func(yield func(string, any) bool) </span><span class="cov0" title="0">{
                        for _, key := range val.MapKeys() </span><span class="cov0" title="0">{
                                k := key.String()
                                v := val.MapIndex(key).Interface()
                                if !yield(k, v) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
                <span class="cov0" title="0">return iter.Seq2[string, any](seq), nil</span>

        case reflect.Slice, reflect.Array:<span class="cov0" title="0">
                // Handle slice/array iteration
                seq := func(yield func(any) bool) </span><span class="cov0" title="0">{
                        for i := range val.Len() </span><span class="cov0" title="0">{
                                item := val.Index(i).Interface()
                                if !yield(item) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
                <span class="cov0" title="0">return iter.Seq[any](seq), nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("expected iterable (map or slice/array), but got %T", output)</span>
        }
}

// ExpressionEvaluteAsBoolWithTracking evaluates a boolean expression with variable access tracking
func ExpressionEvaluteAsBoolWithTracking(ctx context.Context, env Env, expressionString string, tracker *tracking.VariableTracker) (bool, error) <span class="cov8" title="1">{
        if tracker == nil </span><span class="cov8" title="1">{
                // If no tracker provided, use regular function
                return ExpressionEvaluteAsBool(ctx, env, expressionString)
        }</span>

        <span class="cov8" title="1">trackedEnv := tracking.NewTrackingEnv(env.varMap, tracker)

        // Track all variables as potentially accessed since we can't track individual access
        trackedEnv.TrackAllVariables()

        program, err := expr.Compile(expressionString, expr.AsBool(), expr.Env(trackedEnv.GetMap()))
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">output, err := expr.Run(program, trackedEnv.GetMap())
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">ok := output.(bool)
        return ok, nil</span>
}

// ExpressionEvaluteAsArrayWithTracking evaluates an array expression with variable access tracking
func ExpressionEvaluteAsArrayWithTracking(ctx context.Context, env Env, expressionString string, tracker *tracking.VariableTracker) ([]any, error) <span class="cov8" title="1">{
        if tracker == nil </span><span class="cov0" title="0">{
                // If no tracker provided, use regular function
                return ExpressionEvaluteAsArray(ctx, env, expressionString)
        }</span>

        <span class="cov8" title="1">trackedEnv := tracking.NewTrackingEnv(env.varMap, tracker)

        // Track all variables as potentially accessed since we can't track individual access
        trackedEnv.TrackAllVariables()

        program, err := expr.Compile(expressionString, expr.AsAny(), expr.Env(trackedEnv.GetMap()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output, err := expr.Run(program, trackedEnv.GetMap())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // expr.Run can return []interface{} for arrays. Convert it to []any.
        <span class="cov8" title="1">if outputSlice, ok := output.([]any); ok </span><span class="cov8" title="1">{
                return outputSlice, nil
        }</span>

        // If it's not []interface{}, check if it's already []any (less common for expr output)
        <span class="cov0" title="0">if outputAnySlice, ok := output.([]any); ok </span><span class="cov0" title="0">{
                return outputAnySlice, nil
        }</span>

        // If it's neither, it's not an array
        <span class="cov0" title="0">return nil, fmt.Errorf("expected array, but got %T", output)</span>
}

// ExpressionEvaluateAsIterWithTracking evaluates an iterable expression with variable access tracking
func ExpressionEvaluateAsIterWithTracking(ctx context.Context, env Env, expressionString string, tracker *tracking.VariableTracker) (any, error) <span class="cov8" title="1">{
        if tracker == nil </span><span class="cov0" title="0">{
                // If no tracker provided, use regular function
                return ExpressionEvaluateAsIter(ctx, env, expressionString)
        }</span>

        <span class="cov8" title="1">trackedEnv := tracking.NewTrackingEnv(env.varMap, tracker)

        // Track all variables as potentially accessed since we can't track individual access
        trackedEnv.TrackAllVariables()

        program, err := expr.Compile(expressionString, expr.AsAny(), expr.Env(trackedEnv.GetMap()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">output, err := expr.Run(program, trackedEnv.GetMap())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if the result is an iterable type (map or slice/array)
        <span class="cov8" title="1">val := reflect.ValueOf(output)
        switch val.Kind() </span>{
        case reflect.Map:<span class="cov8" title="1">
                // Handle map iteration
                if val.Type().Key().Kind() != reflect.String </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("map keys must be strings for iteration, got %s", val.Type().Key().Kind())
                }</span>
                <span class="cov8" title="1">seq := func(yield func(string, any) bool) </span><span class="cov0" title="0">{
                        for _, key := range val.MapKeys() </span><span class="cov0" title="0">{
                                k := key.String()
                                v := val.MapIndex(key).Interface()
                                if !yield(k, v) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
                <span class="cov8" title="1">return iter.Seq2[string, any](seq), nil</span>

        case reflect.Slice, reflect.Array:<span class="cov0" title="0">
                // Handle slice/array iteration
                seq := func(yield func(any) bool) </span><span class="cov0" title="0">{
                        for i := range val.Len() </span><span class="cov0" title="0">{
                                item := val.Index(i).Interface()
                                if !yield(item) </span><span class="cov0" title="0">{
                                        return
                                }</span>
                        }
                }
                <span class="cov0" title="0">return iter.Seq[any](seq), nil</span>

        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("expected iterable (map or slice/array), but got %T", output)</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package edge

import (
        "errors"
        "the-dev-tools/server/pkg/idwrap"
)

type EdgeHandle = int32

/*
  HANDLE_UNSPECIFIED: 0,
  HANDLE_THEN: 1,
  HANDLE_ELSE: 2,
  HANDLE_LOOP: 3,
*/

const (
        HandleUnspecified EdgeHandle = iota
        HandleThen
        HandleElse
        HandleLoop
        HandleLength
)

type EdgeKind = int32

const (
        EdgeKindUnspecified EdgeKind = 0
        EdgeKindNoOp        EdgeKind = 1
)

var ErrEdgeNotFound = errors.New("edge not found")

type Edge struct {
        ID            idwrap.IDWrap
        FlowID        idwrap.IDWrap
        SourceID      idwrap.IDWrap
        TargetID      idwrap.IDWrap
        SourceHandler EdgeHandle
        Kind          int32
}

type (
        EdgesMap map[idwrap.IDWrap]map[EdgeHandle][]idwrap.IDWrap
)

func GetNextNodeID(edgesMap EdgesMap, sourceID idwrap.IDWrap, handle EdgeHandle) []idwrap.IDWrap <span class="cov0" title="0">{
        edges, ok := edgesMap[sourceID]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">edge, ok := edges[handle]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return edge</span>
}

func NewEdge(id, sourceID, targetID idwrap.IDWrap, sourceHandlerID EdgeHandle, kind int32) Edge <span class="cov0" title="0">{
        return Edge{
                ID:            id,
                SourceID:      sourceID,
                TargetID:      targetID,
                SourceHandler: sourceHandlerID,
                Kind:          kind,
        }
}</span>

func NewEdges(edges ...Edge) []Edge <span class="cov0" title="0">{
        return edges
}</span>

func NewEdgesMap(edges []Edge) EdgesMap <span class="cov0" title="0">{
        edgesMap := make(EdgesMap)
        for _, edge := range edges </span><span class="cov0" title="0">{
                if _, ok := edgesMap[edge.SourceID]; !ok </span><span class="cov0" title="0">{
                        edgesMap[edge.SourceID] = make(map[EdgeHandle][]idwrap.IDWrap)
                }</span>
                <span class="cov0" title="0">a := edgesMap[edge.SourceID][edge.SourceHandler]
                a = append(a, edge.TargetID)
                edgesMap[edge.SourceID][edge.SourceHandler] = a</span>
        }
        <span class="cov0" title="0">return edgesMap</span>
}

// NodePosition represents the relative position of nodes
type NodePosition int

const (
        NodeBefore NodePosition = iota
        NodeAfter
        NodeUnrelated
)

// IsNodeCheckTarget determines if sourceNode is before targetNode in the flow graph
func IsNodeCheckTarget(edgesMap EdgesMap, sourceNode, targetNode idwrap.IDWrap) NodePosition <span class="cov0" title="0">{
        if sourceNode == targetNode </span><span class="cov0" title="0">{
                return NodeUnrelated
        }</span>

        <span class="cov0" title="0">visited := make(map[idwrap.IDWrap]bool)
        queue := []idwrap.IDWrap{sourceNode}

        // BFS to find if target node is reachable from source
        for len(queue) &gt; 0 </span><span class="cov0" title="0">{
                current := queue[0]
                queue = queue[1:]

                if current == targetNode </span><span class="cov0" title="0">{
                        return NodeBefore
                }</span>

                // Check all possible edges from current node
                <span class="cov0" title="0">for handle := HandleUnspecified; handle &lt; HandleLength; handle++ </span><span class="cov0" title="0">{
                        nextNodes := GetNextNodeID(edgesMap, current, handle)
                        for _, next := range nextNodes </span><span class="cov0" title="0">{
                                if !visited[next] </span><span class="cov0" title="0">{
                                        visited[next] = true
                                        queue = append(queue, next)
                                }</span>
                        }
                }
        }

        // Check if source is reachable from target (reverse check)
        <span class="cov0" title="0">visited = make(map[idwrap.IDWrap]bool)
        queue = []idwrap.IDWrap{targetNode}

        for len(queue) &gt; 0 </span><span class="cov0" title="0">{
                current := queue[0]
                queue = queue[1:]

                if current == sourceNode </span><span class="cov0" title="0">{
                        return NodeAfter
                }</span>

                <span class="cov0" title="0">for handle := HandleUnspecified; handle &lt; HandleLength; handle++ </span><span class="cov0" title="0">{
                        nextNodes := GetNextNodeID(edgesMap, current, handle)
                        for _, next := range nextNodes </span><span class="cov0" title="0">{
                                if !visited[next] </span><span class="cov0" title="0">{
                                        visited[next] = true
                                        queue = append(queue, next)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return NodeUnrelated</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package mocknode

import (
        "context"
        "the-dev-tools/server/pkg/flow/node"
        "the-dev-tools/server/pkg/idwrap"
)

type MockNode struct {
        ID    idwrap.IDWrap
        Next  []idwrap.IDWrap
        OnRun func()
}

func NewMockNode(id idwrap.IDWrap, next []idwrap.IDWrap, onRun func()) *MockNode <span class="cov0" title="0">{
        return &amp;MockNode{
                ID:    id,
                Next:  next,
                OnRun: onRun,
        }
}</span>

func (mn *MockNode) GetID() idwrap.IDWrap <span class="cov0" title="0">{
        return mn.ID
}</span>

func (mn *MockNode) SetID(id idwrap.IDWrap) <span class="cov0" title="0">{
        mn.ID = id
}</span>

func (mn *MockNode) GetName() string <span class="cov0" title="0">{
        return "mock"
}</span>

func (mn *MockNode) RunSync(ctx context.Context, req *node.FlowNodeRequest) node.FlowNodeResult <span class="cov0" title="0">{
        mn.OnRun()
        return node.FlowNodeResult{
                NextNodeID: mn.Next,
                Err:        nil,
        }
}</span>

func (mn *MockNode) RunAsync(ctx context.Context, req *node.FlowNodeRequest, resultChan chan node.FlowNodeResult) <span class="cov0" title="0">{
        mn.OnRun()
        resultChan &lt;- node.FlowNodeResult{
                NextNodeID: mn.Next,
                Err:        nil,
        }
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package nfor

import (
        "context"
        "fmt"
        "the-dev-tools/server/pkg/expression"
        "the-dev-tools/server/pkg/flow/edge"
        "the-dev-tools/server/pkg/flow/node"
        "the-dev-tools/server/pkg/flow/runner"
        "the-dev-tools/server/pkg/flow/runner/flowlocalrunner"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mcondition"
        "the-dev-tools/server/pkg/model/mnnode"
        "the-dev-tools/server/pkg/model/mnnode/mnfor"
        "the-dev-tools/server/pkg/varsystem"
        "time"
)

// TODO: this is dupe should me refactored
const NodeVarKey = "var"

type NodeFor struct {
        FlowNodeID    idwrap.IDWrap
        Name          string
        IterCount     int64
        Timeout       time.Duration
        Condition     mcondition.Condition
        ErrorHandling mnfor.ErrorHandling
}

// NewWithCondition creates a NodeFor with condition data for break logic
func NewWithCondition(id idwrap.IDWrap, name string, iterCount int64, timeout time.Duration, errorHandling mnfor.ErrorHandling, condition mcondition.Condition) *NodeFor <span class="cov8" title="1">{
        return &amp;NodeFor{
                FlowNodeID:    id,
                Name:          name,
                IterCount:     iterCount,
                Timeout:       timeout,
                ErrorHandling: errorHandling,
                Condition:     condition,
        }
}</span>

// New creates a NodeFor without condition data (for backward compatibility)
func New(id idwrap.IDWrap, name string, iterCount int64, timeout time.Duration, errorHandling mnfor.ErrorHandling) *NodeFor <span class="cov8" title="1">{
        return &amp;NodeFor{
                FlowNodeID:    id,
                Name:          name,
                IterCount:     iterCount,
                Timeout:       timeout,
                ErrorHandling: errorHandling,
                Condition:     mcondition.Condition{}, // Empty condition
        }
}</span>

func (nr *NodeFor) GetID() idwrap.IDWrap <span class="cov8" title="1">{
        return nr.FlowNodeID
}</span>

func (nr *NodeFor) SetID(id idwrap.IDWrap) <span class="cov8" title="1">{
        nr.FlowNodeID = id
}</span>

func (n *NodeFor) GetName() string <span class="cov8" title="1">{
        return n.Name
}</span>

// checkBreakCondition evaluates the break condition and returns (shouldBreak, error)
func (nr *NodeFor) checkBreakCondition(ctx context.Context, req *node.FlowNodeRequest) (bool, error) <span class="cov8" title="1">{
        if nr.Condition.Comparisons.Expression == "" </span><span class="cov8" title="1">{
                return false, nil // No condition, don't break
        }</span>

        // Create a deep copy of VarMap to prevent concurrent access issues
        <span class="cov8" title="1">varMapCopy := node.DeepCopyVarMap(req)
        exprEnv := expression.NewEnv(varMapCopy)

        // Normalize the condition expression
        conditionExpr := nr.Condition.Comparisons.Expression
        varMap := varsystem.NewVarMapFromAnyMap(varMapCopy)
        normalizedExpression, err := expression.NormalizeExpression(ctx, conditionExpr, varMap)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to normalize break condition '%s': %w", conditionExpr, err)
        }</span>

        // Evaluate the condition expression
        <span class="cov8" title="1">var shouldBreak bool
        if req.VariableTracker != nil </span><span class="cov0" title="0">{
                shouldBreak, err = expression.ExpressionEvaluteAsBoolWithTracking(ctx, exprEnv, normalizedExpression, req.VariableTracker)
        }</span> else<span class="cov8" title="1"> {
                shouldBreak, err = expression.ExpressionEvaluteAsBool(ctx, exprEnv, normalizedExpression)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to evaluate break condition '%s': %w", normalizedExpression, err)
        }</span>

        <span class="cov8" title="1">return shouldBreak, nil</span>
}

func (nr *NodeFor) RunSync(ctx context.Context, req *node.FlowNodeRequest) node.FlowNodeResult <span class="cov8" title="1">{
        loopID := edge.GetNextNodeID(req.EdgeSourceMap, nr.FlowNodeID, edge.HandleLoop)
        nextID := edge.GetNextNodeID(req.EdgeSourceMap, nr.FlowNodeID, edge.HandleThen)

        // Note: assertSys not needed for simple index comparison

        var loopError error
        var failedAtIteration int64 = -1

        for i := int64(0); i &lt; nr.IterCount; i++ </span><span class="cov8" title="1">{
                // Write the iteration index to the node variables
                var err error
                if req.VariableTracker != nil </span><span class="cov8" title="1">{
                        err = node.WriteNodeVarWithTracking(req, nr.Name, "index", i, req.VariableTracker)
                }</span> else<span class="cov8" title="1"> {
                        err = node.WriteNodeVar(req, nr.Name, "index", i)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return node.FlowNodeResult{
                                Err: err,
                        }
                }</span>

                // Check break condition AFTER setting index variable, BEFORE executing iteration
                <span class="cov8" title="1">shouldBreak, err := nr.checkBreakCondition(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        return node.FlowNodeResult{
                                Err: err,
                        }
                }</span>
                <span class="cov8" title="1">if shouldBreak </span><span class="cov8" title="1">{
                        // Break condition met - exit loop
                        goto Exit</span>
                }

                // Store execution ID and iteration context for later update
                <span class="cov8" title="1">executionID := idwrap.NewNow()

                // Create iteration context for this execution
                var parentPath []int
                var parentNodes []idwrap.IDWrap
                if req.IterationContext != nil </span><span class="cov8" title="1">{
                        parentPath = req.IterationContext.IterationPath
                        parentNodes = req.IterationContext.ParentNodes
                }</span>
                <span class="cov8" title="1">iterContext := &amp;runner.IterationContext{
                        IterationPath: append(parentPath, int(i)),
                        ParentNodes:   append(parentNodes, nr.FlowNodeID),
                }

                // Create initial RUNNING record
                if req.LogPushFunc != nil </span><span class="cov8" title="1">{
                        outputData := map[string]any{
                                "index": i,
                        }
                        executionName := fmt.Sprintf("%s iteration %d", nr.Name, i+1)

                        req.LogPushFunc(runner.FlowNodeStatus{
                                ExecutionID:      executionID, // Store this ID for update
                                NodeID:           nr.FlowNodeID,
                                Name:             executionName,
                                State:            mnnode.NODE_STATE_RUNNING,
                                OutputData:       outputData,
                                IterationContext: iterContext,
                        })
                }</span>

                // Execute child nodes
                <span class="cov8" title="1">var iterationError error
                for _, nextNodeID := range loopID </span><span class="cov8" title="1">{

                        // Create iteration context for child nodes
                        var parentPath []int
                        var parentNodes []idwrap.IDWrap
                        if req.IterationContext != nil </span><span class="cov8" title="1">{
                                parentPath = req.IterationContext.IterationPath
                                parentNodes = req.IterationContext.ParentNodes
                        }</span>
                        <span class="cov8" title="1">childIterationContext := &amp;runner.IterationContext{
                                IterationPath:  append(parentPath, int(i)),
                                ExecutionIndex: int(i),                             // Use iteration index to differentiate executions
                                ParentNodes:    append(parentNodes, nr.FlowNodeID), // Add current loop node to parent chain
                        }

                        // Generate unique execution ID for child node
                        childExecutionID := idwrap.NewNow()

                        // Create new request with iteration context for child nodes
                        childReq := *req // Copy the request
                        childReq.IterationContext = childIterationContext
                        childReq.ExecutionID = childExecutionID // Set unique execution ID

                        err := flowlocalrunner.RunNodeSync(ctx, nextNodeID, &amp;childReq, req.LogPushFunc)
                        if err != nil </span><span class="cov8" title="1">{
                                iterationError = err
                                break</span> // Exit inner loop on error
                        }
                }

                // Update iteration record based on result
                <span class="cov8" title="1">if req.LogPushFunc != nil </span><span class="cov8" title="1">{
                        executionName := fmt.Sprintf("%s iteration %d", nr.Name, i+1)
                        if iterationError != nil </span><span class="cov8" title="1">{
                                // Update to FAILURE
                                req.LogPushFunc(runner.FlowNodeStatus{
                                        ExecutionID:      executionID, // Same ID = UPDATE
                                        NodeID:           nr.FlowNodeID,
                                        Name:             executionName,
                                        State:            mnnode.NODE_STATE_FAILURE,
                                        Error:            iterationError,
                                        IterationContext: iterContext,
                                })
                        }</span> else<span class="cov8" title="1"> {
                                // Update to SUCCESS (iteration completed successfully)
                                req.LogPushFunc(runner.FlowNodeStatus{
                                        ExecutionID:      executionID, // Same ID = UPDATE
                                        NodeID:           nr.FlowNodeID,
                                        Name:             executionName,
                                        State:            mnnode.NODE_STATE_SUCCESS,
                                        OutputData:       map[string]any{"index": i, "completed": true},
                                        IterationContext: iterContext,
                                })
                        }</span>
                }

                // Handle iteration error according to error policy
                <span class="cov8" title="1">if iterationError != nil </span><span class="cov8" title="1">{
                        switch nr.ErrorHandling </span>{
                        case mnfor.ErrorHandling_ERROR_HANDLING_IGNORE:<span class="cov8" title="1">
                                continue</span> // Continue to next iteration
                        case mnfor.ErrorHandling_ERROR_HANDLING_BREAK:<span class="cov8" title="1">
                                failedAtIteration = i // Track where we stopped
                                goto Exit</span>             // Stop loop but don't propagate error
                        case mnfor.ErrorHandling_ERROR_HANDLING_UNSPECIFIED:<span class="cov8" title="1">
                                loopError = iterationError
                                failedAtIteration = i
                                goto Exit</span> // Fail entire flow
                        }
                }
        }

Exit:
        // Create final summary record
        <span class="cov8" title="1">if loopError != nil </span><span class="cov8" title="1">{
                // Failure case: loop failed with error propagation
                if req.LogPushFunc != nil </span><span class="cov8" title="1">{
                        outputData := map[string]any{
                                "failedAtIteration": failedAtIteration,
                                "totalIterations":   nr.IterCount,
                        }
                        executionName := "Error Summary"
                        req.LogPushFunc(runner.FlowNodeStatus{
                                ExecutionID: idwrap.NewNow(),
                                NodeID:      nr.FlowNodeID,
                                Name:        executionName,
                                State:       mnnode.NODE_STATE_FAILURE,
                                OutputData:  outputData,
                        })
                }</span>
                <span class="cov8" title="1">return node.FlowNodeResult{
                        Err: loopError,
                }</span>
        }
        // Note: Break case (failedAtIteration &gt;= 0) doesn't create summary record per test expectations

        // Write final output with total iterations completed (for variable system)
        <span class="cov8" title="1">var err error
        if req.VariableTracker != nil </span><span class="cov8" title="1">{
                err = node.WriteNodeVarWithTracking(req, nr.Name, "totalIterations", nr.IterCount, req.VariableTracker)
        }</span> else<span class="cov8" title="1"> {
                err = node.WriteNodeVar(req, nr.Name, "totalIterations", nr.IterCount)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return node.FlowNodeResult{
                        Err: err,
                }
        }</span>

        // Success case: No final summary record needed - last iteration record shows completion
        <span class="cov8" title="1">return node.FlowNodeResult{
                NextNodeID: nextID,
                Err:        nil,
        }</span>
}

func (nr *NodeFor) RunAsync(ctx context.Context, req *node.FlowNodeRequest, resultChan chan node.FlowNodeResult) <span class="cov8" title="1">{
        loopID := edge.GetNextNodeID(req.EdgeSourceMap, nr.FlowNodeID, edge.HandleLoop)
        nextID := edge.GetNextNodeID(req.EdgeSourceMap, nr.FlowNodeID, edge.HandleThen)

        // Note: assertSys not needed for simple index comparison

        var loopError error
        var failedAtIteration int64 = -1

        for i := int64(0); i &lt; nr.IterCount; i++ </span><span class="cov8" title="1">{
                // Write the iteration index to the node variables
                var err error
                if req.VariableTracker != nil </span><span class="cov0" title="0">{
                        err = node.WriteNodeVarWithTracking(req, nr.Name, "index", i, req.VariableTracker)
                }</span> else<span class="cov8" title="1"> {
                        err = node.WriteNodeVar(req, nr.Name, "index", i)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        resultChan &lt;- node.FlowNodeResult{
                                Err: err,
                        }
                        return
                }</span>

                // Check break condition AFTER setting index variable, BEFORE executing iteration
                <span class="cov8" title="1">shouldBreak, err := nr.checkBreakCondition(ctx, req)
                if err != nil </span><span class="cov0" title="0">{
                        resultChan &lt;- node.FlowNodeResult{
                                Err: err,
                        }
                        return
                }</span>
                <span class="cov8" title="1">if shouldBreak </span><span class="cov0" title="0">{
                        // Break condition met - exit loop
                        goto Exit</span>
                }

                // Store execution ID and iteration context for later update
                <span class="cov8" title="1">executionID := idwrap.NewNow()

                // Create iteration context for this execution
                var parentPath []int
                var parentNodes []idwrap.IDWrap
                if req.IterationContext != nil </span><span class="cov0" title="0">{
                        parentPath = req.IterationContext.IterationPath
                        parentNodes = req.IterationContext.ParentNodes
                }</span>
                <span class="cov8" title="1">iterContext := &amp;runner.IterationContext{
                        IterationPath: append(parentPath, int(i)),
                        ParentNodes:   append(parentNodes, nr.FlowNodeID),
                }

                // Create initial RUNNING record
                if req.LogPushFunc != nil </span><span class="cov8" title="1">{
                        outputData := map[string]any{
                                "index": i,
                        }
                        executionName := fmt.Sprintf("%s iteration %d", nr.Name, i+1)

                        req.LogPushFunc(runner.FlowNodeStatus{
                                ExecutionID:      executionID, // Store this ID for update
                                NodeID:           nr.FlowNodeID,
                                Name:             executionName,
                                State:            mnnode.NODE_STATE_RUNNING,
                                OutputData:       outputData,
                                IterationContext: iterContext,
                        })
                }</span>

                // Execute child nodes
                <span class="cov8" title="1">var iterationError error
                for _, nextNodeID := range loopID </span><span class="cov8" title="1">{

                        // Create iteration context for child nodes
                        var parentPath []int
                        var parentNodes []idwrap.IDWrap
                        if req.IterationContext != nil </span><span class="cov0" title="0">{
                                parentPath = req.IterationContext.IterationPath
                                parentNodes = req.IterationContext.ParentNodes
                        }</span>
                        <span class="cov8" title="1">childIterationContext := &amp;runner.IterationContext{
                                IterationPath:  append(parentPath, int(i)),
                                ExecutionIndex: int(i),                             // Use iteration index to differentiate executions
                                ParentNodes:    append(parentNodes, nr.FlowNodeID), // Add current loop node to parent chain
                        }

                        // Generate unique execution ID for child node
                        childExecutionID := idwrap.NewNow()

                        // Create new request with iteration context for child nodes
                        childReq := *req // Copy the request
                        childReq.IterationContext = childIterationContext
                        childReq.ExecutionID = childExecutionID // Set unique execution ID

                        err := flowlocalrunner.RunNodeASync(ctx, nextNodeID, &amp;childReq, req.LogPushFunc)
                        if err != nil </span><span class="cov0" title="0">{
                                iterationError = err
                                break</span> // Exit inner loop on error
                        }
                }

                // Update iteration record based on result
                <span class="cov8" title="1">if req.LogPushFunc != nil </span><span class="cov8" title="1">{
                        executionName := fmt.Sprintf("%s iteration %d", nr.Name, i+1)
                        if iterationError != nil </span><span class="cov0" title="0">{
                                // Update to FAILURE
                                req.LogPushFunc(runner.FlowNodeStatus{
                                        ExecutionID:      executionID, // Same ID = UPDATE
                                        NodeID:           nr.FlowNodeID,
                                        Name:             executionName,
                                        State:            mnnode.NODE_STATE_FAILURE,
                                        Error:            iterationError,
                                        IterationContext: iterContext,
                                })
                        }</span> else<span class="cov8" title="1"> {
                                // Update to SUCCESS
                                req.LogPushFunc(runner.FlowNodeStatus{
                                        ExecutionID:      executionID, // Same ID = UPDATE
                                        NodeID:           nr.FlowNodeID,
                                        Name:             executionName,
                                        State:            mnnode.NODE_STATE_SUCCESS,
                                        OutputData:       map[string]interface{}{"index": i, "completed": true},
                                        IterationContext: iterContext,
                                })
                        }</span>
                }

                // Handle iteration error according to error policy
                <span class="cov8" title="1">if iterationError != nil </span><span class="cov0" title="0">{
                        switch nr.ErrorHandling </span>{
                        case mnfor.ErrorHandling_ERROR_HANDLING_IGNORE:<span class="cov0" title="0">
                                continue</span> // Continue to next iteration
                        case mnfor.ErrorHandling_ERROR_HANDLING_BREAK:<span class="cov0" title="0">
                                failedAtIteration = i // Track where we stopped
                                goto Exit</span>             // Stop loop but don't propagate error
                        case mnfor.ErrorHandling_ERROR_HANDLING_UNSPECIFIED:<span class="cov0" title="0">
                                loopError = iterationError
                                failedAtIteration = i
                                goto Exit</span> // Fail entire flow
                        }
                }
        }

Exit:
        // Only create final summary record on failure
        <span class="cov8" title="1">if loopError != nil </span><span class="cov0" title="0">{
                if req.LogPushFunc != nil </span><span class="cov0" title="0">{
                        outputData := map[string]interface{}{
                                "failedAtIteration": failedAtIteration,
                                "totalIterations":   nr.IterCount,
                        }
                        executionName := "Error Summary"
                        req.LogPushFunc(runner.FlowNodeStatus{
                                ExecutionID: idwrap.NewNow(),
                                NodeID:      nr.FlowNodeID,
                                Name:        executionName,
                                State:       mnnode.NODE_STATE_FAILURE,
                                OutputData:  outputData,
                        })
                }</span>
                <span class="cov0" title="0">resultChan &lt;- node.FlowNodeResult{
                        Err: loopError,
                }
                return</span>
        }

        // Write final output with total iterations completed (for variable system)
        <span class="cov8" title="1">var err error
        if req.VariableTracker != nil </span><span class="cov0" title="0">{
                err = node.WriteNodeVarWithTracking(req, nr.Name, "totalIterations", nr.IterCount, req.VariableTracker)
        }</span> else<span class="cov8" title="1"> {
                err = node.WriteNodeVar(req, nr.Name, "totalIterations", nr.IterCount)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                resultChan &lt;- node.FlowNodeResult{
                        Err: err,
                }
                return
        }</span>

        // Success case: No final summary record needed - last iteration record shows completion
        <span class="cov8" title="1">resultChan &lt;- node.FlowNodeResult{
                NextNodeID: nextID,
                Err:        nil,
        }</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package nforeach

import (
        "context"
        "fmt"
        "iter"
        "sync"
        "the-dev-tools/server/pkg/expression"
        "the-dev-tools/server/pkg/flow/edge"
        "the-dev-tools/server/pkg/flow/node"
        "the-dev-tools/server/pkg/flow/runner"
        "the-dev-tools/server/pkg/flow/runner/flowlocalrunner"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mcondition"
        "the-dev-tools/server/pkg/model/mnnode"
        "the-dev-tools/server/pkg/model/mnnode/mnfor"
        "the-dev-tools/server/pkg/varsystem"
        "time"
)

// TODO: this is dupe should me refactored
const NodeVarKey = "var"

type NodeForEach struct {
        FlowNodeID    idwrap.IDWrap
        Name          string
        IterPath      string
        Timeout       time.Duration
        Condition     mcondition.Condition
        ErrorHandling mnfor.ErrorHandling
}

func New(id idwrap.IDWrap, name string, iterPath string, timeout time.Duration,
        Condition mcondition.Condition, ErrorHandling mnfor.ErrorHandling,
) *NodeForEach <span class="cov8" title="1">{
        return &amp;NodeForEach{
                FlowNodeID:    id,
                Name:          name,
                IterPath:      iterPath,
                Timeout:       timeout,
                Condition:     Condition,
                ErrorHandling: ErrorHandling,
        }
}</span>

func (nr *NodeForEach) GetID() idwrap.IDWrap <span class="cov8" title="1">{
        return nr.FlowNodeID
}</span>

func (nr *NodeForEach) SetID(id idwrap.IDWrap) <span class="cov8" title="1">{
        nr.FlowNodeID = id
}</span>

func (n *NodeForEach) GetName() string <span class="cov8" title="1">{
        return n.Name
}</span>

func (nr *NodeForEach) RunSync(ctx context.Context, req *node.FlowNodeRequest) node.FlowNodeResult <span class="cov8" title="1">{
        loopID := edge.GetNextNodeID(req.EdgeSourceMap, nr.FlowNodeID, edge.HandleLoop)
        nextID := edge.GetNextNodeID(req.EdgeSourceMap, nr.FlowNodeID, edge.HandleThen)

        // Create a deep copy of VarMap to prevent concurrent access issues
        varMapCopy := node.DeepCopyVarMap(req)

        varMap := varsystem.NewVarMapFromAnyMap(varMapCopy)
        normalizedExpressionIterPath, err := expression.NormalizeExpression(ctx, nr.IterPath, varMap)
        if err != nil </span><span class="cov0" title="0">{
                return node.FlowNodeResult{
                        Err: err,
                }
        }</span>

        <span class="cov8" title="1">exprEnv := expression.NewEnv(varMapCopy)

        // Use tracking version if tracker is available
        var result any
        if req.VariableTracker != nil </span><span class="cov0" title="0">{
                result, err = expression.ExpressionEvaluateAsIterWithTracking(ctx, exprEnv, normalizedExpressionIterPath, req.VariableTracker)
        }</span> else<span class="cov8" title="1"> {
                result, err = expression.ExpressionEvaluateAsIter(ctx, exprEnv, normalizedExpressionIterPath)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return node.FlowNodeResult{
                        Err: err,
                }
        }</span>

        <span class="cov8" title="1">breakExpr := nr.Condition.Comparisons.Expression
        normalizedExpressionBreak, err := expression.NormalizeExpression(ctx, breakExpr, varMap)
        if err != nil </span><span class="cov0" title="0">{
                return node.FlowNodeResult{
                        Err: err,
                }
        }</span>

        <span class="cov8" title="1">processNode := func(iterationIndex int) node.FlowNodeResult </span><span class="cov8" title="1">{
                for _, nextNodeID := range loopID </span><span class="cov8" title="1">{
                        if breakExpr != "" </span><span class="cov8" title="1">{
                                // Use tracking version if tracker is available
                                var ok bool
                                var err error
                                if req.VariableTracker != nil </span><span class="cov0" title="0">{
                                        ok, err = expression.ExpressionEvaluteAsBoolWithTracking(ctx, exprEnv, normalizedExpressionBreak, req.VariableTracker)
                                }</span> else<span class="cov8" title="1"> {
                                        ok, err = expression.ExpressionEvaluteAsBool(ctx, exprEnv, normalizedExpressionBreak)
                                }</span>
                                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                        return node.FlowNodeResult{
                                                Err: err,
                                        }
                                }</span>
                                <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }

                        // Create iteration context for child nodes
                        <span class="cov8" title="1">var parentPath []int
                        var parentNodes []idwrap.IDWrap
                        if req.IterationContext != nil </span><span class="cov0" title="0">{
                                parentPath = req.IterationContext.IterationPath
                                parentNodes = req.IterationContext.ParentNodes
                        }</span>
                        <span class="cov8" title="1">childIterationContext := &amp;runner.IterationContext{
                                IterationPath:  append(parentPath, iterationIndex),
                                ExecutionIndex: iterationIndex,                     // Use iteration index to differentiate executions
                                ParentNodes:    append(parentNodes, nr.FlowNodeID), // Add current loop node to parent chain
                        }

                        // Generate unique execution ID for child node
                        childExecutionID := idwrap.NewNow()

                        // Create new request with iteration context for child nodes
                        childReq := *req // Copy the request
                        childReq.IterationContext = childIterationContext
                        childReq.ExecutionID = childExecutionID // Set unique execution ID

                        err := flowlocalrunner.RunNodeSync(ctx, nextNodeID, &amp;childReq, req.LogPushFunc)
                        if err != nil </span><span class="cov8" title="1">{
                                return node.FlowNodeResult{
                                        Err: err,
                                }
                        }</span>
                }
                <span class="cov8" title="1">return node.FlowNodeResult{}</span>
        }

        <span class="cov8" title="1">switch seq := result.(type) </span>{
        case iter.Seq[any]:<span class="cov8" title="1">
                // Handle slice/array sequence
                itemIndex := 0
                totalItems := 0
                var loopError error
                var failedAt = -1

                for item := range seq </span><span class="cov8" title="1">{
                        // Write the item and key (index) to the node variables
                        var err error
                        if req.VariableTracker != nil </span><span class="cov0" title="0">{
                                err = node.WriteNodeVarWithTracking(req, nr.Name, "item", item, req.VariableTracker)
                        }</span> else<span class="cov8" title="1"> {
                                err = node.WriteNodeVar(req, nr.Name, "item", item)
                        }</span>
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return node.FlowNodeResult{
                                        Err: err,
                                }
                        }</span>

                        <span class="cov8" title="1">if req.VariableTracker != nil </span><span class="cov0" title="0">{
                                err = node.WriteNodeVarWithTracking(req, nr.Name, "key", itemIndex, req.VariableTracker)
                        }</span> else<span class="cov8" title="1"> {
                                err = node.WriteNodeVar(req, nr.Name, "key", itemIndex)
                        }</span>
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return node.FlowNodeResult{
                                        Err: err,
                                }
                        }</span>

                        // Store execution ID for later update
                        <span class="cov8" title="1">executionID := idwrap.NewNow()

                        // Create iteration context for this execution
                        var parentPath []int
                        var parentNodes []idwrap.IDWrap
                        if req.IterationContext != nil </span><span class="cov0" title="0">{
                                parentPath = req.IterationContext.IterationPath
                                parentNodes = req.IterationContext.ParentNodes
                        }</span>
                        <span class="cov8" title="1">iterContext := &amp;runner.IterationContext{
                                IterationPath: append(parentPath, itemIndex),
                                ParentNodes:   append(parentNodes, nr.FlowNodeID),
                        }

                        // Create initial RUNNING record
                        if req.LogPushFunc != nil </span><span class="cov8" title="1">{
                                iterationData := map[string]any{
                                        "item": item,
                                        "key":  itemIndex,
                                }
                                executionName := fmt.Sprintf("Iteration %d", itemIndex)
                                req.LogPushFunc(runner.FlowNodeStatus{
                                        ExecutionID:      executionID, // Store this ID for update
                                        NodeID:           nr.FlowNodeID,
                                        Name:             executionName,
                                        State:            mnnode.NODE_STATE_RUNNING,
                                        OutputData:       iterationData,
                                        IterationContext: iterContext,
                                })
                        }</span>

                        <span class="cov8" title="1">itemIndex++
                        totalItems++

                        result := processNode(itemIndex - 1)

                        // Update iteration record based on result
                        if req.LogPushFunc != nil &amp;&amp; result.Err == nil </span><span class="cov8" title="1">{
                                // Update to SUCCESS (iteration completed successfully)
                                executionName := fmt.Sprintf("Iteration %d", itemIndex-1)
                                req.LogPushFunc(runner.FlowNodeStatus{
                                        ExecutionID:      executionID, // Same ID = UPDATE
                                        NodeID:           nr.FlowNodeID,
                                        Name:             executionName,
                                        State:            mnnode.NODE_STATE_SUCCESS,
                                        OutputData:       map[string]any{"item": item, "key": itemIndex - 1},
                                        IterationContext: iterContext,
                                })
                        }</span>
                        // Note: No FAILURE updates are created - errors are handled via Error Summary records only

                        // Handle iteration error according to error policy
                        <span class="cov8" title="1">if result.Err != nil </span><span class="cov8" title="1">{
                                switch nr.ErrorHandling </span>{
                                case mnfor.ErrorHandling_ERROR_HANDLING_IGNORE:<span class="cov8" title="1">
                                        continue</span> // Continue to next iteration
                                case mnfor.ErrorHandling_ERROR_HANDLING_BREAK:<span class="cov8" title="1">
                                        failedAt = itemIndex - 1 // Track where we stopped
                                        goto ExitSeq</span>             // Stop loop but don't propagate error
                                case mnfor.ErrorHandling_ERROR_HANDLING_UNSPECIFIED:<span class="cov8" title="1">
                                        loopError = result.Err
                                        failedAt = itemIndex - 1 // Store the index where failure occurred
                                        goto ExitSeq</span>             // Fail entire flow
                                }
                        }
                }

        ExitSeq:
                // Create final summary record
                <span class="cov8" title="1">if loopError != nil </span><span class="cov8" title="1">{
                        // Failure case: loop failed with error propagation
                        if req.LogPushFunc != nil </span><span class="cov8" title="1">{
                                outputData := map[string]interface{}{
                                        "failedAtIndex": failedAt,
                                        "totalItems":    totalItems,
                                }
                                executionName := "Error Summary"
                                req.LogPushFunc(runner.FlowNodeStatus{
                                        ExecutionID: idwrap.NewNow(),
                                        NodeID:      nr.FlowNodeID,
                                        Name:        executionName,
                                        State:       mnnode.NODE_STATE_FAILURE,
                                        OutputData:  outputData,
                                        Error:       loopError,
                                })
                        }</span>
                        <span class="cov8" title="1">return node.FlowNodeResult{
                                Err: loopError,
                        }</span>
                }
                // Note: Break case (failedAt &gt;= 0) doesn't create summary record per test expectations
                // Write total items processed
                <span class="cov8" title="1">if req.VariableTracker != nil </span><span class="cov0" title="0">{
                        err = node.WriteNodeVarWithTracking(req, nr.Name, "totalItems", totalItems, req.VariableTracker)
                }</span> else<span class="cov8" title="1"> {
                        err = node.WriteNodeVar(req, nr.Name, "totalItems", totalItems)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return node.FlowNodeResult{
                                Err: err,
                        }
                }</span>
        case iter.Seq2[string, any]:<span class="cov8" title="1">
                // Handle map sequence
                totalItems := 0
                var loopError error
                var failedAt interface{} = nil

                for key, value := range seq </span><span class="cov8" title="1">{
                        // Write the key and item (value) to the node variables
                        var err error
                        if req.VariableTracker != nil </span><span class="cov0" title="0">{
                                err = node.WriteNodeVarWithTracking(req, nr.Name, "key", key, req.VariableTracker)
                        }</span> else<span class="cov8" title="1"> {
                                err = node.WriteNodeVar(req, nr.Name, "key", key)
                        }</span>
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return node.FlowNodeResult{
                                        Err: err,
                                }
                        }</span>

                        <span class="cov8" title="1">if req.VariableTracker != nil </span><span class="cov0" title="0">{
                                err = node.WriteNodeVarWithTracking(req, nr.Name, "item", value, req.VariableTracker)
                        }</span> else<span class="cov8" title="1"> {
                                err = node.WriteNodeVar(req, nr.Name, "item", value)
                        }</span>
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return node.FlowNodeResult{
                                        Err: err,
                                }
                        }</span>

                        // Store execution ID for later update
                        <span class="cov8" title="1">executionID := idwrap.NewNow()

                        // Create iteration context for this execution
                        var parentPath []int
                        var parentNodes []idwrap.IDWrap
                        if req.IterationContext != nil </span><span class="cov0" title="0">{
                                parentPath = req.IterationContext.IterationPath
                                parentNodes = req.IterationContext.ParentNodes
                        }</span>
                        <span class="cov8" title="1">iterContext := &amp;runner.IterationContext{
                                IterationPath: append(parentPath, totalItems),
                                ParentNodes:   append(parentNodes, nr.FlowNodeID),
                        }

                        // Create initial RUNNING record
                        if req.LogPushFunc != nil </span><span class="cov8" title="1">{
                                iterationData := map[string]any{
                                        "item": value,
                                        "key":  key,
                                }
                                executionName := fmt.Sprintf("Iteration %d", totalItems)
                                req.LogPushFunc(runner.FlowNodeStatus{
                                        ExecutionID:      executionID, // Store this ID for update
                                        NodeID:           nr.FlowNodeID,
                                        Name:             executionName,
                                        State:            mnnode.NODE_STATE_RUNNING,
                                        OutputData:       iterationData,
                                        IterationContext: iterContext,
                                })
                        }</span>

                        <span class="cov8" title="1">totalItems++

                        result := processNode(totalItems - 1)

                        // Update iteration record based on result
                        if req.LogPushFunc != nil &amp;&amp; result.Err == nil </span><span class="cov8" title="1">{
                                // Update to SUCCESS (iteration completed successfully)
                                executionName := fmt.Sprintf("Iteration %d", totalItems-1)
                                req.LogPushFunc(runner.FlowNodeStatus{
                                        ExecutionID:      executionID, // Same ID = UPDATE
                                        NodeID:           nr.FlowNodeID,
                                        Name:             executionName,
                                        State:            mnnode.NODE_STATE_SUCCESS,
                                        OutputData:       map[string]any{"item": value, "key": key},
                                        IterationContext: iterContext,
                                })
                        }</span>
                        // Note: No FAILURE updates are created - errors are handled via Error Summary records only

                        // Handle iteration error according to error policy
                        <span class="cov8" title="1">if result.Err != nil </span><span class="cov8" title="1">{
                                switch nr.ErrorHandling </span>{
                                case mnfor.ErrorHandling_ERROR_HANDLING_IGNORE:<span class="cov0" title="0">
                                        continue</span> // Continue to next iteration
                                case mnfor.ErrorHandling_ERROR_HANDLING_BREAK:<span class="cov0" title="0">
                                        goto ExitSeq2</span> // Stop loop but don't propagate error
                                case mnfor.ErrorHandling_ERROR_HANDLING_UNSPECIFIED:<span class="cov8" title="1">
                                        loopError = result.Err
                                        failedAt = key // Store the key where failure occurred
                                        goto ExitSeq2</span>  // Fail entire flow
                                }
                        }
                }

        ExitSeq2:
                // Only create final summary record on failure
                <span class="cov8" title="1">if loopError != nil </span><span class="cov8" title="1">{
                        if req.LogPushFunc != nil </span><span class="cov8" title="1">{
                                outputData := map[string]interface{}{
                                        "failedAtKey": failedAt,
                                        "totalItems":  totalItems,
                                }
                                executionName := "Error Summary"
                                req.LogPushFunc(runner.FlowNodeStatus{
                                        ExecutionID: idwrap.NewNow(),
                                        NodeID:      nr.FlowNodeID,
                                        Name:        executionName,
                                        State:       mnnode.NODE_STATE_FAILURE,
                                        OutputData:  outputData,
                                        Error:       loopError,
                                })
                        }</span>
                        <span class="cov8" title="1">return node.FlowNodeResult{
                                Err: loopError,
                        }</span>
                }
                // Write total items processed
                <span class="cov8" title="1">if req.VariableTracker != nil </span><span class="cov0" title="0">{
                        err = node.WriteNodeVarWithTracking(req, nr.Name, "totalItems", totalItems, req.VariableTracker)
                }</span> else<span class="cov8" title="1"> {
                        err = node.WriteNodeVar(req, nr.Name, "totalItems", totalItems)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return node.FlowNodeResult{
                                Err: err,
                        }
                }</span>
        default:<span class="cov0" title="0">
                // Unexpected result type
                return node.FlowNodeResult{
                        Err: fmt.Errorf("unexpected iterator type: %T", result),
                }</span>
        }
        <span class="cov8" title="1">return node.FlowNodeResult{
                NextNodeID: nextID,
                Err:        nil,
        }</span>
}

func (nr *NodeForEach) RunAsync(ctx context.Context, req *node.FlowNodeRequest, resultChan chan node.FlowNodeResult) <span class="cov8" title="1">{
        loopID := edge.GetNextNodeID(req.EdgeSourceMap, nr.FlowNodeID, edge.HandleLoop)
        nextID := edge.GetNextNodeID(req.EdgeSourceMap, nr.FlowNodeID, edge.HandleThen)

        // Use mutex and sync.Once to ensure thread-safe channel access
        var once sync.Once
        var resultMutex sync.Mutex
        resultSent := false

        sendResult := func(result node.FlowNodeResult) </span><span class="cov8" title="1">{
                resultMutex.Lock()
                defer resultMutex.Unlock()

                if resultSent </span><span class="cov0" title="0">{
                        return // Result already sent
                }</span>

                <span class="cov8" title="1">once.Do(func() </span><span class="cov8" title="1">{
                        // Double-check inside once.Do to prevent race
                        if !resultSent </span><span class="cov8" title="1">{
                                // Recover from panic if channel is closed
                                defer func() </span><span class="cov8" title="1">{
                                        _ = recover() // Ignore panic from closed channel
                                }</span>()

                                <span class="cov8" title="1">select </span>{
                                case resultChan &lt;- result:<span class="cov8" title="1">
                                        resultSent = true</span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        // Context cancelled, don't send
                                        resultSent = true</span>
                                default:<span class="cov0" title="0">
                                        // Channel might be full or closed, don't block
                                        resultSent = true</span>
                                }
                        }
                })
        }

        // Safely read VarMap with lock protection
        <span class="cov8" title="1">req.ReadWriteLock.RLock()
        varMapCopy := make(map[string]any)
        for k, v := range req.VarMap </span><span class="cov8" title="1">{
                varMapCopy[k] = v
        }</span>
        <span class="cov8" title="1">req.ReadWriteLock.RUnlock()

        // Create the expression environment
        exprEnv := expression.NewEnv(varMapCopy)

        // Normalize the iteration path expression
        varMap := varsystem.NewVarMapFromAnyMap(varMapCopy)
        normalizedExpressionIterPath, err := expression.NormalizeExpression(ctx, nr.IterPath, varMap)
        if err != nil </span><span class="cov0" title="0">{
                sendResult(node.FlowNodeResult{Err: err})
                return
        }</span>

        // Use tracking version if tracker is available
        <span class="cov8" title="1">var result any
        if req.VariableTracker != nil </span><span class="cov0" title="0">{
                result, err = expression.ExpressionEvaluateAsIterWithTracking(ctx, exprEnv, normalizedExpressionIterPath, req.VariableTracker)
        }</span> else<span class="cov8" title="1"> {
                result, err = expression.ExpressionEvaluateAsIter(ctx, exprEnv, normalizedExpressionIterPath)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                sendResult(node.FlowNodeResult{Err: err})
                return
        }</span>

        // Normalize the break condition expression
        <span class="cov8" title="1">breakExpr := nr.Condition.Comparisons.Expression
        var normalizedExpressionBreak string
        if breakExpr != "" </span><span class="cov8" title="1">{
                normalizedExpressionBreak, err = expression.NormalizeExpression(ctx, breakExpr, varMap)
                if err != nil </span><span class="cov0" title="0">{
                        sendResult(node.FlowNodeResult{Err: err})
                        return
                }</span>
        }

        // Define the function to process the child node(s) within the loop
        <span class="cov8" title="1">processNode := func(iterationIndex int) node.FlowNodeResult </span><span class="cov8" title="1">{
                for _, nextNodeID := range loopID </span><span class="cov8" title="1">{
                        // Evaluate the break condition if it exists
                        if breakExpr != "" </span><span class="cov8" title="1">{
                                // Use tracking version if tracker is available
                                var ok bool
                                var err error
                                if req.VariableTracker != nil </span><span class="cov0" title="0">{
                                        ok, err = expression.ExpressionEvaluteAsBoolWithTracking(ctx, exprEnv, normalizedExpressionBreak, req.VariableTracker)
                                }</span> else<span class="cov8" title="1"> {
                                        ok, err = expression.ExpressionEvaluteAsBool(ctx, exprEnv, normalizedExpressionBreak)
                                }</span>
                                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                        return node.FlowNodeResult{Err: err}
                                }</span>
                                <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }

                        // Create iteration context for child nodes
                        <span class="cov8" title="1">var parentPath []int
                        var parentNodes []idwrap.IDWrap
                        if req.IterationContext != nil </span><span class="cov0" title="0">{
                                parentPath = req.IterationContext.IterationPath
                                parentNodes = req.IterationContext.ParentNodes
                        }</span>
                        <span class="cov8" title="1">childIterationContext := &amp;runner.IterationContext{
                                IterationPath:  append(parentPath, iterationIndex),
                                ExecutionIndex: iterationIndex,                     // Use iteration index to differentiate executions
                                ParentNodes:    append(parentNodes, nr.FlowNodeID), // Add current loop node to parent chain
                        }

                        // Generate unique execution ID for child node
                        childExecutionID := idwrap.NewNow()

                        // Create new request with iteration context for child nodes
                        childReq := *req // Copy the request
                        childReq.IterationContext = childIterationContext
                        childReq.ExecutionID = childExecutionID // Set unique execution ID

                        // Run the child node asynchronously
                        err := flowlocalrunner.RunNodeASync(ctx, nextNodeID, &amp;childReq, req.LogPushFunc)
                        if err != nil </span><span class="cov0" title="0">{
                                switch nr.ErrorHandling </span>{
                                case mnfor.ErrorHandling_ERROR_HANDLING_IGNORE:<span class="cov0" title="0">
                                        // Log error but continue to next iteration
                                        continue</span>
                                case mnfor.ErrorHandling_ERROR_HANDLING_BREAK:<span class="cov0" title="0">
                                        // Stop the loop but don't propagate error
                                        return node.FlowNodeResult{}</span>
                                case mnfor.ErrorHandling_ERROR_HANDLING_UNSPECIFIED:<span class="cov0" title="0">
                                        // Default behavior: fail the entire flow
                                        return node.FlowNodeResult{Err: err}</span>
                                }
                        }
                }
                <span class="cov8" title="1">return node.FlowNodeResult{}</span>
        }

        // Iterate over the sequence based on its type
        <span class="cov8" title="1">switch seq := result.(type) </span>{
        case iter.Seq[any]:<span class="cov8" title="1">
                // Handle slice/array sequence
                go func() </span><span class="cov8" title="1">{
                        itemIndex := 0
                        totalItems := 0
                        var loopError error
                        var failedAt interface{} = nil

                        for item := range seq </span><span class="cov8" title="1">{
                                // Write the item and key (index) to the node variables
                                var err error
                                if req.VariableTracker != nil </span><span class="cov0" title="0">{
                                        err = node.WriteNodeVarWithTracking(req, nr.Name, "item", item, req.VariableTracker)
                                }</span> else<span class="cov8" title="1"> {
                                        err = node.WriteNodeVar(req, nr.Name, "item", item)
                                }</span>
                                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                        sendResult(node.FlowNodeResult{
                                                Err: err,
                                        })
                                        return
                                }</span>

                                <span class="cov8" title="1">if req.VariableTracker != nil </span><span class="cov0" title="0">{
                                        err = node.WriteNodeVarWithTracking(req, nr.Name, "key", itemIndex, req.VariableTracker)
                                }</span> else<span class="cov8" title="1"> {
                                        err = node.WriteNodeVar(req, nr.Name, "key", itemIndex)
                                }</span>
                                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                        sendResult(node.FlowNodeResult{
                                                Err: err,
                                        })
                                        return
                                }</span>

                                // Store execution ID for later update
                                <span class="cov8" title="1">executionID := idwrap.NewNow()

                                // Create iteration context for this execution
                                var parentPath []int
                                var parentNodes []idwrap.IDWrap
                                if req.IterationContext != nil </span><span class="cov0" title="0">{
                                        parentPath = req.IterationContext.IterationPath
                                        parentNodes = req.IterationContext.ParentNodes
                                }</span>
                                <span class="cov8" title="1">iterContext := &amp;runner.IterationContext{
                                        IterationPath: append(parentPath, itemIndex),
                                        ParentNodes:   append(parentNodes, nr.FlowNodeID),
                                }

                                // Create initial RUNNING record
                                if req.LogPushFunc != nil </span><span class="cov8" title="1">{
                                        iterationData := map[string]any{
                                                "item": item,
                                                "key":  itemIndex,
                                        }
                                        executionName := fmt.Sprintf("Iteration %d", itemIndex)
                                        req.LogPushFunc(runner.FlowNodeStatus{
                                                ExecutionID:      executionID, // Store this ID for update
                                                NodeID:           nr.FlowNodeID,
                                                Name:             executionName,
                                                State:            mnnode.NODE_STATE_RUNNING,
                                                OutputData:       iterationData,
                                                IterationContext: iterContext,
                                        })
                                }</span>

                                <span class="cov8" title="1">itemIndex++
                                totalItems++

                                loopResult := processNode(itemIndex - 1)

                                // Update iteration record based on result
                                if req.LogPushFunc != nil &amp;&amp; loopResult.Err == nil </span><span class="cov8" title="1">{
                                        // Update to SUCCESS (iteration completed successfully)
                                        executionName := fmt.Sprintf("Iteration %d", itemIndex-1)
                                        req.LogPushFunc(runner.FlowNodeStatus{
                                                ExecutionID:      executionID, // Same ID = UPDATE
                                                NodeID:           nr.FlowNodeID,
                                                Name:             executionName,
                                                State:            mnnode.NODE_STATE_SUCCESS,
                                                OutputData:       map[string]any{"item": item, "key": itemIndex - 1},
                                                IterationContext: iterContext,
                                        })
                                }</span>
                                // Note: No FAILURE updates are created - errors are handled via Error Summary records only

                                // Handle iteration error according to error policy
                                <span class="cov8" title="1">if loopResult.Err != nil </span><span class="cov0" title="0">{
                                        switch nr.ErrorHandling </span>{
                                        case mnfor.ErrorHandling_ERROR_HANDLING_IGNORE:<span class="cov0" title="0">
                                                continue</span> // Continue to next iteration
                                        case mnfor.ErrorHandling_ERROR_HANDLING_BREAK:<span class="cov0" title="0">
                                                sendResult(node.FlowNodeResult{NextNodeID: nextID, Err: nil})
                                                return</span> // Stop loop but don't propagate error
                                        case mnfor.ErrorHandling_ERROR_HANDLING_UNSPECIFIED:<span class="cov0" title="0">
                                                loopError = loopResult.Err
                                                failedAt = itemIndex - 1 // Fail entire flow
                                                goto ExitSeqAsync</span>        // Exit the loop immediately on error
                                        }
                                }
                        }

                ExitSeqAsync:
                        // Only create final summary record on failure
                        <span class="cov8" title="1">if loopError != nil </span><span class="cov0" title="0">{
                                if req.LogPushFunc != nil </span><span class="cov0" title="0">{
                                        outputData := map[string]interface{}{
                                                "failedAtIndex": failedAt,
                                                "totalItems":    totalItems,
                                        }
                                        executionName := "Error Summary"
                                        req.LogPushFunc(runner.FlowNodeStatus{
                                                ExecutionID: idwrap.NewNow(),
                                                NodeID:      nr.FlowNodeID,
                                                Name:        executionName,
                                                State:       mnnode.NODE_STATE_FAILURE,
                                                OutputData:  outputData,
                                                Error:       loopError,
                                        })
                                }</span>
                                <span class="cov0" title="0">sendResult(node.FlowNodeResult{Err: loopError})
                                return</span>
                        }
                        // Write total items processed
                        <span class="cov8" title="1">if req.VariableTracker != nil </span><span class="cov0" title="0">{
                                err := node.WriteNodeVarWithTracking(req, nr.Name, "totalItems", totalItems, req.VariableTracker)
                                if err != nil </span><span class="cov0" title="0">{
                                        sendResult(node.FlowNodeResult{Err: err})
                                        return
                                }</span>
                        } else<span class="cov8" title="1"> {
                                if err := node.WriteNodeVar(req, nr.Name, "totalItems", totalItems); err != nil </span><span class="cov0" title="0">{
                                        sendResult(node.FlowNodeResult{Err: err})
                                        return
                                }</span>
                        }
                        // Send success result after loop finishes
                        <span class="cov8" title="1">sendResult(node.FlowNodeResult{NextNodeID: nextID, Err: nil})</span>
                }()
        case iter.Seq2[string, any]:<span class="cov8" title="1">
                // Handle map sequence
                go func() </span><span class="cov8" title="1">{
                        totalItems := 0
                        var loopError error
                        var failedAt interface{} = nil

                        for key, value := range seq </span><span class="cov8" title="1">{
                                // Write the key and item (value) to the node variables
                                var err error
                                if req.VariableTracker != nil </span><span class="cov0" title="0">{
                                        err = node.WriteNodeVarWithTracking(req, nr.Name, "key", key, req.VariableTracker)
                                }</span> else<span class="cov8" title="1"> {
                                        err = node.WriteNodeVar(req, nr.Name, "key", key)
                                }</span>
                                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                        sendResult(node.FlowNodeResult{
                                                Err: err,
                                        })
                                        return
                                }</span>

                                <span class="cov8" title="1">if req.VariableTracker != nil </span><span class="cov0" title="0">{
                                        err = node.WriteNodeVarWithTracking(req, nr.Name, "item", value, req.VariableTracker)
                                }</span> else<span class="cov8" title="1"> {
                                        err = node.WriteNodeVar(req, nr.Name, "item", value)
                                }</span>
                                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                        sendResult(node.FlowNodeResult{
                                                Err: err,
                                        })
                                        return
                                }</span>

                                // Store execution ID for later update
                                <span class="cov8" title="1">executionID := idwrap.NewNow()

                                // Create iteration context for this execution
                                var parentPath []int
                                var parentNodes []idwrap.IDWrap
                                if req.IterationContext != nil </span><span class="cov0" title="0">{
                                        parentPath = req.IterationContext.IterationPath
                                        parentNodes = req.IterationContext.ParentNodes
                                }</span>
                                <span class="cov8" title="1">iterContext := &amp;runner.IterationContext{
                                        IterationPath: append(parentPath, totalItems),
                                        ParentNodes:   append(parentNodes, nr.FlowNodeID),
                                }

                                // Create initial RUNNING record
                                if req.LogPushFunc != nil </span><span class="cov8" title="1">{
                                        iterationData := map[string]any{
                                                "item": value,
                                                "key":  key,
                                        }
                                        executionName := fmt.Sprintf("Iteration %d", totalItems)
                                        req.LogPushFunc(runner.FlowNodeStatus{
                                                ExecutionID:      executionID, // Store this ID for update
                                                NodeID:           nr.FlowNodeID,
                                                Name:             executionName,
                                                State:            mnnode.NODE_STATE_RUNNING,
                                                OutputData:       iterationData,
                                                IterationContext: iterContext,
                                        })
                                }</span>

                                <span class="cov8" title="1">totalItems++

                                loopResult := processNode(totalItems - 1)

                                // Update iteration record based on result
                                if req.LogPushFunc != nil &amp;&amp; loopResult.Err == nil </span><span class="cov8" title="1">{
                                        // Update to SUCCESS (iteration completed successfully)
                                        executionName := fmt.Sprintf("Iteration %d", totalItems-1)
                                        req.LogPushFunc(runner.FlowNodeStatus{
                                                ExecutionID:      executionID, // Same ID = UPDATE
                                                NodeID:           nr.FlowNodeID,
                                                Name:             executionName,
                                                State:            mnnode.NODE_STATE_SUCCESS,
                                                OutputData:       map[string]any{"item": value, "key": key},
                                                IterationContext: iterContext,
                                        })
                                }</span>
                                // Note: No FAILURE updates are created - errors are handled via Error Summary records only

                                // Handle iteration error according to error policy
                                <span class="cov8" title="1">if loopResult.Err != nil </span><span class="cov0" title="0">{
                                        switch nr.ErrorHandling </span>{
                                        case mnfor.ErrorHandling_ERROR_HANDLING_IGNORE:<span class="cov0" title="0">
                                                continue</span> // Continue to next iteration
                                        case mnfor.ErrorHandling_ERROR_HANDLING_BREAK:<span class="cov0" title="0">
                                                sendResult(node.FlowNodeResult{NextNodeID: nextID, Err: nil})
                                                return</span> // Stop loop but don't propagate error
                                        case mnfor.ErrorHandling_ERROR_HANDLING_UNSPECIFIED:<span class="cov0" title="0">
                                                loopError = loopResult.Err
                                                failedAt = key     // Fail entire flow
                                                goto ExitSeq2Async</span> // Exit the loop immediately on error
                                        }
                                }
                        }

                ExitSeq2Async:
                        // Only create final summary record on failure
                        <span class="cov8" title="1">if loopError != nil </span><span class="cov0" title="0">{
                                if req.LogPushFunc != nil </span><span class="cov0" title="0">{
                                        outputData := map[string]interface{}{
                                                "failedAtKey": failedAt,
                                                "totalItems":  totalItems,
                                        }
                                        executionName := "Error Summary"
                                        req.LogPushFunc(runner.FlowNodeStatus{
                                                ExecutionID: idwrap.NewNow(),
                                                NodeID:      nr.FlowNodeID,
                                                Name:        executionName,
                                                State:       mnnode.NODE_STATE_FAILURE,
                                                OutputData:  outputData,
                                                Error:       loopError,
                                        })
                                }</span>
                                <span class="cov0" title="0">sendResult(node.FlowNodeResult{Err: loopError})
                                return</span>
                        }
                        // Write total items processed
                        <span class="cov8" title="1">if req.VariableTracker != nil </span><span class="cov0" title="0">{
                                err := node.WriteNodeVarWithTracking(req, nr.Name, "totalItems", totalItems, req.VariableTracker)
                                if err != nil </span><span class="cov0" title="0">{
                                        sendResult(node.FlowNodeResult{Err: err})
                                        return
                                }</span>
                        } else<span class="cov8" title="1"> {
                                if err := node.WriteNodeVar(req, nr.Name, "totalItems", totalItems); err != nil </span><span class="cov0" title="0">{
                                        sendResult(node.FlowNodeResult{Err: err})
                                        return
                                }</span>
                        }
                        // Send success result after loop finishes
                        <span class="cov8" title="1">sendResult(node.FlowNodeResult{NextNodeID: nextID, Err: nil})</span>
                }()
        default:<span class="cov0" title="0">
                // Should not happen if ExpressionEvaluateAsIter works correctly
                sendResult(node.FlowNodeResult{Err: fmt.Errorf("unexpected iterator type: %T", result)})</span>
        }
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package nif

import (
        "context"
        "fmt"
        "the-dev-tools/server/pkg/expression"
        "the-dev-tools/server/pkg/flow/edge"
        "the-dev-tools/server/pkg/flow/node"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mcondition"
        "the-dev-tools/server/pkg/varsystem"
)

type NodeIf struct {
        FlowNodeID idwrap.IDWrap
        Name       string
        Condition  mcondition.Condition
}

func New(id idwrap.IDWrap, name string, condition mcondition.Condition) *NodeIf <span class="cov8" title="1">{
        return &amp;NodeIf{
                FlowNodeID: id,
                Name:       name,
                Condition:  condition,
        }
}</span>

func (n NodeIf) GetID() idwrap.IDWrap <span class="cov0" title="0">{
        return n.FlowNodeID
}</span>

func (n *NodeIf) SetID(id idwrap.IDWrap) <span class="cov0" title="0">{
        n.FlowNodeID = id
}</span>

func (n NodeIf) GetName() string <span class="cov0" title="0">{
        return n.Name
}</span>

func (n NodeIf) RunSync(ctx context.Context, req *node.FlowNodeRequest) node.FlowNodeResult <span class="cov8" title="1">{
        trueID := edge.GetNextNodeID(req.EdgeSourceMap, n.FlowNodeID, edge.HandleThen)
        falseID := edge.GetNextNodeID(req.EdgeSourceMap, n.FlowNodeID, edge.HandleElse)
        var result node.FlowNodeResult
        if trueID == nil || falseID == nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("%w: missing true or false branch for node %s", node.ErrNodeNotFound, n.FlowNodeID)
                return result
        }</span>
        // Create a deep copy of VarMap to prevent concurrent access issues
        <span class="cov8" title="1">varMapCopy := node.DeepCopyVarMap(req)

        exprEnv := expression.NewEnv(varMapCopy)

        // Normalize the condition expression
        conditionExpr := n.Condition.Comparisons.Expression
        varMap := varsystem.NewVarMapFromAnyMap(varMapCopy)
        normalizedExpression, err := expression.NormalizeExpression(ctx, conditionExpr, varMap)
        if err != nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("failed to normalize condition expression '%s': %w", conditionExpr, err)
                return result
        }</span>

        // Evaluate the condition expression using tracking if available
        <span class="cov8" title="1">var ok bool
        if req.VariableTracker != nil </span><span class="cov0" title="0">{
                ok, err = expression.ExpressionEvaluteAsBoolWithTracking(ctx, exprEnv, normalizedExpression, req.VariableTracker)
        }</span> else<span class="cov8" title="1"> {
                ok, err = expression.ExpressionEvaluteAsBool(ctx, exprEnv, normalizedExpression)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("failed to evaluate condition expression '%s': %w", normalizedExpression, err)
                return result
        }</span>

        // Write the decision result
        <span class="cov8" title="1">outputData := map[string]interface{}{
                "condition": normalizedExpression,
                "result":    ok,
        }
        if req.VariableTracker != nil </span><span class="cov0" title="0">{
                err = node.WriteNodeVarBulkWithTracking(req, n.Name, outputData, req.VariableTracker)
        }</span> else<span class="cov8" title="1"> {
                err = node.WriteNodeVarBulk(req, n.Name, outputData)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("failed to write node output: %w", err)
                return result
        }</span>

        <span class="cov8" title="1">if ok </span><span class="cov8" title="1">{
                result.NextNodeID = trueID
        }</span> else<span class="cov8" title="1"> {
                result.NextNodeID = falseID
        }</span>
        <span class="cov8" title="1">return result</span>
}

func (n NodeIf) RunAsync(ctx context.Context, req *node.FlowNodeRequest, resultChan chan node.FlowNodeResult) <span class="cov0" title="0">{
        trueID := edge.GetNextNodeID(req.EdgeSourceMap, n.FlowNodeID, edge.HandleThen)
        falseID := edge.GetNextNodeID(req.EdgeSourceMap, n.FlowNodeID, edge.HandleElse)
        var result node.FlowNodeResult
        if trueID == nil || falseID == nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("%w: missing true or false branch for node %s", node.ErrNodeNotFound, n.FlowNodeID)
                resultChan &lt;- result
                return
        }</span>

        // Create a deep copy of VarMap to prevent concurrent access issues
        <span class="cov0" title="0">varMapCopy := node.DeepCopyVarMap(req)

        exprEnv := expression.NewEnv(varMapCopy)

        // Normalize the condition expression
        conditionExpr := n.Condition.Comparisons.Expression
        varMap := varsystem.NewVarMapFromAnyMap(varMapCopy)
        normalizedExpression, err := expression.NormalizeExpression(ctx, conditionExpr, varMap)
        if err != nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("failed to normalize condition expression '%s': %w", conditionExpr, err)
                resultChan &lt;- result
                return
        }</span>

        // Evaluate the condition expression using tracking if available
        <span class="cov0" title="0">var ok bool
        if req.VariableTracker != nil </span><span class="cov0" title="0">{
                ok, err = expression.ExpressionEvaluteAsBoolWithTracking(ctx, exprEnv, normalizedExpression, req.VariableTracker)
        }</span> else<span class="cov0" title="0"> {
                ok, err = expression.ExpressionEvaluteAsBool(ctx, exprEnv, normalizedExpression)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("failed to evaluate condition expression '%s': %w", normalizedExpression, err)
                resultChan &lt;- result
                return
        }</span>

        // Write the decision result
        <span class="cov0" title="0">outputData := map[string]interface{}{
                "condition": normalizedExpression,
                "result":    ok,
        }
        if req.VariableTracker != nil </span><span class="cov0" title="0">{
                err = node.WriteNodeVarBulkWithTracking(req, n.Name, outputData, req.VariableTracker)
        }</span> else<span class="cov0" title="0"> {
                err = node.WriteNodeVarBulk(req, n.Name, outputData)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("failed to write node output: %w", err)
                resultChan &lt;- result
                return
        }</span>

        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                result.NextNodeID = trueID
        }</span> else<span class="cov0" title="0"> {
                result.NextNodeID = falseID
        }</span>

        <span class="cov0" title="0">resultChan &lt;- result</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package njs

import (
        "context"
        "fmt"
        "the-dev-tools/server/pkg/flow/edge"
        "the-dev-tools/server/pkg/flow/node"
        "the-dev-tools/server/pkg/idwrap"
        nodejs_executorv1 "the-dev-tools/spec/dist/buf/go/nodejs_executor/v1"
        "the-dev-tools/spec/dist/buf/go/nodejs_executor/v1/nodejs_executorv1connect"

        "connectrpc.com/connect"
        "google.golang.org/protobuf/types/known/structpb"
)

type NodeJS struct {
        FlowNodeID   idwrap.IDWrap
        Name         string
        jsCode       string
        nodejsClient nodejs_executorv1connect.NodeJSExecutorServiceClient
}

func New(id idwrap.IDWrap, name, jsCode string, nodejsv1Cleint nodejs_executorv1connect.NodeJSExecutorServiceClient) *NodeJS <span class="cov0" title="0">{
        return &amp;NodeJS{
                FlowNodeID:   id,
                Name:         name,
                jsCode:       jsCode,
                nodejsClient: nodejsv1Cleint,
        }
}</span>

func (n NodeJS) GetID() idwrap.IDWrap <span class="cov0" title="0">{
        return n.FlowNodeID
}</span>

func (n *NodeJS) SetID(id idwrap.IDWrap) <span class="cov0" title="0">{
        n.FlowNodeID = id
}</span>

func (n NodeJS) GetName() string <span class="cov0" title="0">{
        return n.Name
}</span>

func (n NodeJS) RunSync(ctx context.Context, req *node.FlowNodeRequest) node.FlowNodeResult <span class="cov0" title="0">{
        next := edge.GetNextNodeID(req.EdgeSourceMap, n.FlowNodeID, edge.HandleUnspecified)

        result := node.FlowNodeResult{
                NextNodeID: next,
        }

        val, err := structpb.NewValue(req.VarMap)
        if err != nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("failed to create structpb.Value: %w", err)
                return result
        }</span>

        <span class="cov0" title="0">rpcReqRaw := nodejs_executorv1.ExecuteNodeJSRequest{
                Context: val,
                Code:    n.jsCode,
        }
        rpcReq := connect.NewRequest(&amp;rpcReqRaw)

        rpcResp, err := n.nodejsClient.ExecuteNodeJS(ctx, rpcReq)
        if err != nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("failed to execute nodejs: %w", err)
                return result
        }</span>

        <span class="cov0" title="0">InterfaceRaw := rpcResp.Msg.Result.AsInterface()

        if req.VariableTracker != nil </span><span class="cov0" title="0">{
                err = node.WriteNodeVarRawWithTracking(req, n.Name, InterfaceRaw, req.VariableTracker)
        }</span> else<span class="cov0" title="0"> {
                err = node.WriteNodeVarRaw(req, n.Name, InterfaceRaw)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("failed to write node var bulk: %w", err)
        }</span>

        <span class="cov0" title="0">return result</span>
}

func (n NodeJS) RunAsync(ctx context.Context, req *node.FlowNodeRequest, resultChan chan node.FlowNodeResult) <span class="cov0" title="0">{
        next := edge.GetNextNodeID(req.EdgeSourceMap, n.FlowNodeID, edge.HandleUnspecified)

        result := node.FlowNodeResult{
                NextNodeID: next,
        }

        val, err := structpb.NewValue(req.VarMap)
        if err != nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("failed to create structpb.Value: %w", err)
                resultChan &lt;- result
                return
        }</span>

        <span class="cov0" title="0">rpcReqRaw := nodejs_executorv1.ExecuteNodeJSRequest{
                Context: val,
                Code:    n.jsCode,
        }
        rpcReq := connect.NewRequest(&amp;rpcReqRaw)

        rpcResp, err := n.nodejsClient.ExecuteNodeJS(ctx, rpcReq)
        if err != nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("failed to execute nodejs: %w", err)
                resultChan &lt;- result
                return
        }</span>
        <span class="cov0" title="0">InterfaceRaw := rpcResp.Msg.Result.AsInterface()
        if req.VariableTracker != nil </span><span class="cov0" title="0">{
                err = node.WriteNodeVarRawWithTracking(req, n.Name, InterfaceRaw, req.VariableTracker)
        }</span> else<span class="cov0" title="0"> {
                err = node.WriteNodeVarRaw(req, n.Name, InterfaceRaw)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                result.Err = fmt.Errorf("failed to write node var bulk: %w", err)
        }</span>

        <span class="cov0" title="0">resultChan &lt;- result</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package nnoop

import (
        "context"
        "the-dev-tools/server/pkg/flow/edge"
        "the-dev-tools/server/pkg/flow/node"
        "the-dev-tools/server/pkg/idwrap"
)

const NodeOutputKey = "noop"

type NodeNoop struct {
        FlowNodeID idwrap.IDWrap
        Name       string
}

func New(id idwrap.IDWrap, name string) *NodeNoop <span class="cov0" title="0">{
        return &amp;NodeNoop{
                FlowNodeID: id,
                Name:       name,
        }
}</span>

func (n NodeNoop) GetID() idwrap.IDWrap <span class="cov0" title="0">{
        return n.FlowNodeID
}</span>

func (n *NodeNoop) SetID(id idwrap.IDWrap) <span class="cov0" title="0">{
        n.FlowNodeID = id
}</span>

func (n NodeNoop) GetName() string <span class="cov0" title="0">{
        return n.Name
}</span>

func (n NodeNoop) RunSync(ctx context.Context, req *node.FlowNodeRequest) node.FlowNodeResult <span class="cov0" title="0">{
        nextID := edge.GetNextNodeID(req.EdgeSourceMap, n.FlowNodeID, edge.HandleUnspecified)
        var result node.FlowNodeResult
        result.NextNodeID = nextID
        return result
}</span>

func (n NodeNoop) RunAsync(ctx context.Context, req *node.FlowNodeRequest, resultChan chan node.FlowNodeResult) <span class="cov0" title="0">{
        trueID := edge.GetNextNodeID(req.EdgeSourceMap, n.FlowNodeID, edge.HandleUnspecified)
        var result node.FlowNodeResult
        result.NextNodeID = trueID
        resultChan &lt;- result
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package node

import (
        "context"
        "errors"
        "sync"
        "the-dev-tools/server/pkg/flow/edge"
        "the-dev-tools/server/pkg/flow/runner"
        "the-dev-tools/server/pkg/flow/tracking"
        "the-dev-tools/server/pkg/idwrap"
        "time"
)

var ErrNodeNotFound = errors.New("node not found")

// INFO: this is workaround for expr lang
const NodeVarPrefix = "node"

type FlowNode interface {
        GetID() idwrap.IDWrap
        GetName() string

        // TODO: will implement streaming in the future
        RunSync(ctx context.Context, req *FlowNodeRequest) FlowNodeResult
        RunAsync(ctx context.Context, req *FlowNodeRequest, resultChan chan FlowNodeResult)
}

type FlowNodeRequest struct {
        VarMap           map[string]any
        ReadWriteLock    *sync.RWMutex
        NodeMap          map[idwrap.IDWrap]FlowNode
        EdgeSourceMap    edge.EdgesMap
        Timeout          time.Duration
        LogPushFunc      LogPushFunc
        PendingAtmoicMap map[idwrap.IDWrap]uint32
        VariableTracker  *tracking.VariableTracker // Optional tracking for input/output data
        IterationContext *runner.IterationContext  // For hierarchical execution naming in loops
        ExecutionID      idwrap.IDWrap             // Unique ID for this specific execution of the node
}

type LogPushFunc func(status runner.FlowNodeStatus)

type FlowNodeResult struct {
        NextNodeID []idwrap.IDWrap
        Err        error
}

var (
        ErrVarGroupNotFound error = errors.New("group not found")
        ErrVarNodeNotFound  error = errors.New("node not found")
        ErrVarKeyNotFound   error = errors.New("key not found")
)

// DeepCopyVarMap creates a deep copy of the VarMap to prevent concurrent access issues
func DeepCopyVarMap(req *FlowNodeRequest) map[string]any <span class="cov0" title="0">{
        req.ReadWriteLock.RLock()
        defer req.ReadWriteLock.RUnlock()

        return deepCopyMap(req.VarMap)
}</span>

// deepCopyMap recursively copies a map[string]any
func deepCopyMap(m map[string]any) map[string]any <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make(map[string]any, len(m))
        for k, v := range m </span><span class="cov0" title="0">{
                result[k] = DeepCopyValue(v)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// DeepCopyValue creates a deep copy of any value
func DeepCopyValue(v any) any <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">switch val := v.(type) </span>{
        case map[string]any:<span class="cov0" title="0">
                return deepCopyMap(val)</span>
        case []any:<span class="cov0" title="0">
                result := make([]any, len(val))
                for i, item := range val </span><span class="cov0" title="0">{
                        result[i] = DeepCopyValue(item)
                }</span>
                <span class="cov0" title="0">return result</span>
        case []map[string]interface{}:<span class="cov0" title="0">
                result := make([]map[string]interface{}, len(val))
                for i, item := range val </span><span class="cov0" title="0">{
                        if mapCopy, ok := DeepCopyValue(item).(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                result[i] = mapCopy
                        }</span>
                }
                <span class="cov0" title="0">return result</span>
        default:<span class="cov0" title="0">
                // Primitive types (string, int, float, bool, etc.) are copied by value
                // This includes string, int, float, bool, time.Time, etc.
                return val</span>
        }
}

func WriteNodeVar(a *FlowNodeRequest, name string, key string, v interface{}) error <span class="cov8" title="1">{
        a.ReadWriteLock.Lock()
        defer a.ReadWriteLock.Unlock()

        nodeKey := name

        oldV, ok := a.VarMap[nodeKey]
        if !ok </span><span class="cov8" title="1">{
                oldV = map[string]interface{}{}
        }</span>

        <span class="cov8" title="1">mapV, ok := oldV.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return errors.New("value is not a map")
        }</span>

        <span class="cov8" title="1">mapV[key] = v
        a.VarMap[nodeKey] = mapV
        return nil</span>
}

func WriteNodeVarRaw(a *FlowNodeRequest, name string, v interface{}) error <span class="cov8" title="1">{
        a.ReadWriteLock.Lock()
        defer a.ReadWriteLock.Unlock()

        nodeKey := name

        a.VarMap[nodeKey] = v
        return nil
}</span>

func WriteNodeVarBulk(a *FlowNodeRequest, name string, v map[string]interface{}) error <span class="cov8" title="1">{
        a.ReadWriteLock.Lock()
        defer a.ReadWriteLock.Unlock()

        nodeKey := name

        oldV, ok := a.VarMap[nodeKey]
        if !ok </span><span class="cov8" title="1">{
                oldV = map[string]interface{}{}
        }</span>

        <span class="cov8" title="1">mapV, ok := oldV.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return errors.New("value is not a map")
        }</span>

        <span class="cov8" title="1">for key, value := range v </span><span class="cov8" title="1">{
                mapV[key] = value
        }</span>

        <span class="cov8" title="1">a.VarMap[nodeKey] = mapV
        return nil</span>
}

func ReadVarRaw(a *FlowNodeRequest, key string) (interface{}, error) <span class="cov8" title="1">{
        a.ReadWriteLock.RLock()
        v, ok := a.VarMap[key]
        a.ReadWriteLock.RUnlock()

        if !ok </span><span class="cov8" title="1">{
                return nil, ErrVarKeyNotFound
        }</span>

        <span class="cov8" title="1">return v, nil</span>
}

func ReadNodeVar(a *FlowNodeRequest, name, key string) (interface{}, error) <span class="cov8" title="1">{
        a.ReadWriteLock.RLock()
        nodeKey := name
        nodeVarMap, ok := a.VarMap[nodeKey]
        a.ReadWriteLock.RUnlock()

        if !ok </span><span class="cov8" title="1">{
                return nil, ErrVarNodeNotFound
        }</span>

        <span class="cov8" title="1">castedNodeVarMap, ok := nodeVarMap.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.New("value is not a map")
        }</span>

        <span class="cov8" title="1">v, ok := castedNodeVarMap[key]
        if !ok </span><span class="cov8" title="1">{
                return nil, ErrVarKeyNotFound
        }</span>

        <span class="cov8" title="1">return v, nil</span>
}

// WriteNodeVarWithTracking writes a node variable with optional tracking
func WriteNodeVarWithTracking(a *FlowNodeRequest, name string, key string, v interface{}, tracker *tracking.VariableTracker) error <span class="cov8" title="1">{
        // First perform the regular write
        err := WriteNodeVar(a, name, key, v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Track the write if tracker is provided
        <span class="cov8" title="1">if tracker != nil </span><span class="cov8" title="1">{
                nodeKey := name
                fullKey := nodeKey + "." + key
                tracker.TrackWrite(fullKey, v)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// WriteNodeVarRawWithTracking writes a raw node variable with optional tracking
func WriteNodeVarRawWithTracking(a *FlowNodeRequest, name string, v interface{}, tracker *tracking.VariableTracker) error <span class="cov8" title="1">{
        // First perform the regular write
        err := WriteNodeVarRaw(a, name, v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Track the write if tracker is provided
        <span class="cov8" title="1">if tracker != nil </span><span class="cov8" title="1">{
                tracker.TrackWrite(name, v)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// WriteNodeVarBulkWithTracking writes bulk node variables with optional tracking
func WriteNodeVarBulkWithTracking(a *FlowNodeRequest, name string, v map[string]interface{}, tracker *tracking.VariableTracker) error <span class="cov8" title="1">{
        // First perform the regular write
        err := WriteNodeVarBulk(a, name, v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Track each write if tracker is provided
        <span class="cov8" title="1">if tracker != nil </span><span class="cov8" title="1">{
                nodeKey := name
                for key, value := range v </span><span class="cov8" title="1">{
                        fullKey := nodeKey + "." + key
                        tracker.TrackWrite(fullKey, value)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ReadVarRawWithTracking reads a raw variable with optional tracking
func ReadVarRawWithTracking(a *FlowNodeRequest, key string, tracker *tracking.VariableTracker) (interface{}, error) <span class="cov8" title="1">{
        // First perform the regular read
        v, err := ReadVarRaw(a, key)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Track the read if tracker is provided
        <span class="cov8" title="1">if tracker != nil </span><span class="cov8" title="1">{
                tracker.TrackRead(key, v)
        }</span>

        <span class="cov8" title="1">return v, nil</span>
}

// ReadNodeVarWithTracking reads a node variable with optional tracking
func ReadNodeVarWithTracking(a *FlowNodeRequest, name, key string, tracker *tracking.VariableTracker) (interface{}, error) <span class="cov8" title="1">{
        // First perform the regular read
        v, err := ReadNodeVar(a, name, key)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Track the read if tracker is provided
        <span class="cov8" title="1">if tracker != nil </span><span class="cov8" title="1">{
                nodeKey := name
                fullKey := nodeKey + "." + key
                tracker.TrackRead(fullKey, v)
        }</span>

        <span class="cov8" title="1">return v, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package nrequest

import (
        "context"
        "encoding/json"
        "fmt"
        "the-dev-tools/server/pkg/flow/edge"
        "the-dev-tools/server/pkg/flow/node"
        "the-dev-tools/server/pkg/http/request"
        "the-dev-tools/server/pkg/http/response"
        "the-dev-tools/server/pkg/httpclient"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/massert"
        "the-dev-tools/server/pkg/model/mbodyform"
        "the-dev-tools/server/pkg/model/mbodyraw"
        "the-dev-tools/server/pkg/model/mbodyurl"
        "the-dev-tools/server/pkg/model/mexampleheader"
        "the-dev-tools/server/pkg/model/mexamplequery"
        "the-dev-tools/server/pkg/model/mexampleresp"
        "the-dev-tools/server/pkg/model/mexamplerespheader"
        "the-dev-tools/server/pkg/model/mitemapi"
        "the-dev-tools/server/pkg/model/mitemapiexample"
        "the-dev-tools/server/pkg/varsystem"
)

type NodeRequest struct {
        FlownNodeID idwrap.IDWrap
        Name        string

        Api     mitemapi.ItemApi
        Example mitemapiexample.ItemApiExample
        Queries []mexamplequery.Query
        Headers []mexampleheader.Header

        RawBody        mbodyraw.ExampleBodyRaw
        FormBody       []mbodyform.BodyForm
        UrlBody        []mbodyurl.BodyURLEncoded
        ExampleAsserts []massert.Assert

        ExampleResp       mexampleresp.ExampleResp
        ExampleRespHeader []mexamplerespheader.ExampleRespHeader

        HttpClient              httpclient.HttpClient
        NodeRequestSideRespChan chan NodeRequestSideResp
}

type NodeRequestSideResp struct {
        // Execution tracking
        ExecutionID idwrap.IDWrap // The specific execution ID for this request

        // Request
        Example mitemapiexample.ItemApiExample
        Queries []mexamplequery.Query
        Headers []mexampleheader.Header

        RawBody  mbodyraw.ExampleBodyRaw
        FormBody []mbodyform.BodyForm
        UrlBody  []mbodyurl.BodyURLEncoded

        // Resp
        Resp response.ResponseCreateOutput
}

const (
        OUTPUT_RESPONE_NAME = "response"
        OUTPUT_REQUEST_NAME = "request"
)

type NodeRequestOutput struct {
        Request  request.RequestResponseVar `json:"request"`
        Response httpclient.ResponseVar     `json:"response"`
}

func New(id idwrap.IDWrap, name string, api mitemapi.ItemApi, example mitemapiexample.ItemApiExample,
        Queries []mexamplequery.Query, Headers []mexampleheader.Header,
        rawBody mbodyraw.ExampleBodyRaw, formBody []mbodyform.BodyForm, urlBody []mbodyurl.BodyURLEncoded,
        ExampleResp mexampleresp.ExampleResp, ExampleRespHeader []mexamplerespheader.ExampleRespHeader, asserts []massert.Assert,
        Httpclient httpclient.HttpClient, NodeRequestSideRespChan chan NodeRequestSideResp,
) *NodeRequest <span class="cov8" title="1">{
        return &amp;NodeRequest{
                FlownNodeID: id,
                Name:        name,
                Api:         api,
                Example:     example,

                Headers: Headers,
                Queries: Queries,

                RawBody:  rawBody,
                FormBody: formBody,
                UrlBody:  urlBody,

                ExampleResp:       ExampleResp,
                ExampleRespHeader: ExampleRespHeader,
                ExampleAsserts:    asserts,

                HttpClient:              Httpclient,
                NodeRequestSideRespChan: NodeRequestSideRespChan,
        }
}</span>

func (nr *NodeRequest) GetID() idwrap.IDWrap <span class="cov8" title="1">{
        return nr.FlownNodeID
}</span>

func (nr *NodeRequest) SetID(id idwrap.IDWrap) <span class="cov8" title="1">{
        nr.FlownNodeID = id
}</span>

func (nr *NodeRequest) GetName() string <span class="cov8" title="1">{
        return nr.Name
}</span>

func (nr *NodeRequest) RunSync(ctx context.Context, req *node.FlowNodeRequest) node.FlowNodeResult <span class="cov8" title="1">{
        nextID := edge.GetNextNodeID(req.EdgeSourceMap, nr.GetID(), edge.HandleUnspecified)
        result := node.FlowNodeResult{
                NextNodeID: nextID,
                Err:        nil,
        }

        nr.ExampleResp.ID = idwrap.NewNow()

        // TODO: varMap is null create varMap
        // Create a deep copy of VarMap to prevent concurrent access issues
        varMapCopy := node.DeepCopyVarMap(req)
        varMap := varsystem.NewVarMapFromAnyMap(varMapCopy)

        prepareResult, err := request.PrepareRequestWithTracking(nr.Api, nr.Example,
                nr.Queries, nr.Headers, nr.RawBody, nr.FormBody, nr.UrlBody, varMap)
        if err != nil </span><span class="cov8" title="1">{
                result.Err = err
                return result
        }</span>

        <span class="cov8" title="1">prepareOutput := prepareResult.Request
        inputVars := prepareResult.ReadVars

        // Track variable reads if tracker is available
        if req.VariableTracker != nil </span><span class="cov8" title="1">{
                for varKey, varValue := range inputVars </span><span class="cov8" title="1">{
                        req.VariableTracker.TrackRead(varKey, varValue)
                }</span>
        }

        <span class="cov8" title="1">if ctx.Err() != nil </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov8" title="1">resp, err := request.SendRequestWithContext(ctx, prepareOutput, nr.Example.ID, nr.HttpClient)
        if err != nil </span><span class="cov8" title="1">{
                result.Err = err
                return result
        }</span>

        <span class="cov8" title="1">if ctx.Err() != nil </span><span class="cov0" title="0">{
                return result
        }</span>

        <span class="cov8" title="1">output := NodeRequestOutput{
                Request:  request.ConvertRequestToVar(prepareOutput),
                Response: httpclient.ConvertResponseToVar(resp.HttpResp),
        }

        respMap := map[string]any{}
        // TODO: change map conversion non json
        marshaledResp, err := json.Marshal(output)
        if err != nil </span><span class="cov0" title="0">{
                result.Err = err
                return result
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(marshaledResp, &amp;respMap)
        if err != nil </span><span class="cov0" title="0">{
                result.Err = err
                return result
        }</span>

        <span class="cov8" title="1">if req.VariableTracker != nil </span><span class="cov8" title="1">{
                err = node.WriteNodeVarBulkWithTracking(req, nr.Name, respMap, req.VariableTracker)
        }</span> else<span class="cov8" title="1"> {
                err = node.WriteNodeVarBulk(req, nr.Name, respMap)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                result.Err = err
                return result
        }</span>

        <span class="cov8" title="1">respCreate, err := response.ResponseCreate(ctx, *resp, nr.ExampleResp, nr.ExampleRespHeader, nr.ExampleAsserts, varMap)
        if err != nil </span><span class="cov0" title="0">{
                result.Err = err
                return result
        }</span>

        <span class="cov8" title="1">if ctx.Err() != nil </span><span class="cov0" title="0">{
                return result
        }</span>

        // Check if any assertions failed
        <span class="cov8" title="1">for _, assertCouple := range respCreate.AssertCouples </span><span class="cov0" title="0">{
                if !assertCouple.AssertRes.Result </span><span class="cov0" title="0">{
                        result.Err = fmt.Errorf("assertion failed: %s", assertCouple.Assert.Condition.Comparisons.Expression)
                        // Still send the response data even though we're failing
                        nr.NodeRequestSideRespChan &lt;- NodeRequestSideResp{
                                ExecutionID: req.ExecutionID,
                                Example:     nr.Example,
                                Queries:     nr.Queries,
                                Headers:     nr.Headers,

                                RawBody:  nr.RawBody,
                                FormBody: nr.FormBody,
                                UrlBody:  nr.UrlBody,

                                Resp: *respCreate,
                        }
                        return result
                }</span>
        }

        <span class="cov8" title="1">nr.NodeRequestSideRespChan &lt;- NodeRequestSideResp{
                ExecutionID: req.ExecutionID,
                Example:     nr.Example,
                Queries:     nr.Queries,
                Headers:     nr.Headers,

                RawBody:  nr.RawBody,
                FormBody: nr.FormBody,
                UrlBody:  nr.UrlBody,

                Resp: *respCreate,
        }

        return result</span>
}

func (nr *NodeRequest) RunAsync(ctx context.Context, req *node.FlowNodeRequest, resultChan chan node.FlowNodeResult) <span class="cov8" title="1">{
        nextID := edge.GetNextNodeID(req.EdgeSourceMap, nr.GetID(), edge.HandleUnspecified)
        result := node.FlowNodeResult{
                NextNodeID: nextID,
                Err:        nil,
        }

        nr.ExampleResp.ID = idwrap.NewNow()

        // TODO: varMap is null create varMap
        // Create a deep copy of VarMap to prevent concurrent access issues
        varMapCopy := node.DeepCopyVarMap(req)
        varMap := varsystem.NewVarMapFromAnyMap(varMapCopy)

        prepareResult, err := request.PrepareRequestWithTracking(nr.Api, nr.Example,
                nr.Queries, nr.Headers, nr.RawBody, nr.FormBody, nr.UrlBody, varMap)
        if err != nil </span><span class="cov0" title="0">{
                result.Err = err
                resultChan &lt;- result
                return
        }</span>

        <span class="cov8" title="1">prepareOutput := prepareResult.Request
        inputVars := prepareResult.ReadVars

        // Track variable reads if tracker is available
        if req.VariableTracker != nil </span><span class="cov8" title="1">{
                for varKey, varValue := range inputVars </span><span class="cov8" title="1">{
                        req.VariableTracker.TrackRead(varKey, varValue)
                }</span>
        }

        <span class="cov8" title="1">if ctx.Err() != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">resp, err := request.SendRequestWithContext(ctx, prepareOutput, nr.Example.ID, nr.HttpClient)
        if err != nil </span><span class="cov0" title="0">{
                result.Err = err
                resultChan &lt;- result
                return
        }</span>

        <span class="cov8" title="1">if ctx.Err() != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">output := NodeRequestOutput{
                Request:  request.ConvertRequestToVar(prepareOutput),
                Response: httpclient.ConvertResponseToVar(resp.HttpResp),
        }

        respMap := map[string]any{}
        // TODO: change map conversion non json
        marshaledResp, err := json.Marshal(output)
        if err != nil </span><span class="cov0" title="0">{
                result.Err = err
                resultChan &lt;- result
                return
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(marshaledResp, &amp;respMap)
        if err != nil </span><span class="cov0" title="0">{
                result.Err = err
                resultChan &lt;- result
                return
        }</span>

        <span class="cov8" title="1">if req.VariableTracker != nil </span><span class="cov8" title="1">{
                err = node.WriteNodeVarBulkWithTracking(req, nr.Name, respMap, req.VariableTracker)
        }</span> else<span class="cov8" title="1"> {
                err = node.WriteNodeVarBulk(req, nr.Name, respMap)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                result.Err = err
                resultChan &lt;- result
                return
        }</span>

        <span class="cov8" title="1">respCreate, err := response.ResponseCreate(ctx, *resp, nr.ExampleResp, nr.ExampleRespHeader, nr.ExampleAsserts, varMap)
        if err != nil </span><span class="cov0" title="0">{
                result.Err = err
                resultChan &lt;- result
                return
        }</span>

        <span class="cov8" title="1">nr.ExampleResp.ID = idwrap.NewNow()

        // Check if any assertions failed
        for _, assertCouple := range respCreate.AssertCouples </span><span class="cov0" title="0">{
                if !assertCouple.AssertRes.Result </span><span class="cov0" title="0">{
                        result.Err = fmt.Errorf("assertion failed: %s", assertCouple.Assert.Condition.Comparisons.Expression)
                        // Still send the response data even though we're failing
                        nr.NodeRequestSideRespChan &lt;- NodeRequestSideResp{
                                ExecutionID: req.ExecutionID,
                                Example:     nr.Example,
                                Queries:     nr.Queries,
                                Headers:     nr.Headers,

                                RawBody:  nr.RawBody,
                                FormBody: nr.FormBody,
                                UrlBody:  nr.UrlBody,

                                Resp: *respCreate,
                        }
                        resultChan &lt;- result
                        return
                }</span>
        }

        <span class="cov8" title="1">nr.NodeRequestSideRespChan &lt;- NodeRequestSideResp{
                ExecutionID: req.ExecutionID,
                Example:     nr.Example,
                Queries:     nr.Queries,
                Headers:     nr.Headers,

                RawBody:  nr.RawBody,
                FormBody: nr.FormBody,
                UrlBody:  nr.UrlBody,

                Resp: *respCreate,
        }
        if ctx.Err() != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">resultChan &lt;- result</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package nstart

import (
        "context"
        "the-dev-tools/server/pkg/flow/edge"
        "the-dev-tools/server/pkg/flow/node"
        "the-dev-tools/server/pkg/idwrap"
)

type NodeStart struct {
        FlowNodeID idwrap.IDWrap
        Name       string
}

func New(id idwrap.IDWrap, name string) *NodeStart <span class="cov0" title="0">{
        return &amp;NodeStart{
                FlowNodeID: id,
                Name:       name,
        }
}</span>

func (nr *NodeStart) GetID() idwrap.IDWrap <span class="cov0" title="0">{
        return nr.FlowNodeID
}</span>

func (nr *NodeStart) SetID(id idwrap.IDWrap) <span class="cov0" title="0">{
        nr.FlowNodeID = id
}</span>

func (nr *NodeStart) RunSync(ctx context.Context, req *node.FlowNodeRequest) node.FlowNodeResult <span class="cov0" title="0">{
        nextID := edge.GetNextNodeID(req.EdgeSourceMap, nr.FlowNodeID, edge.HandleUnspecified)

        return node.FlowNodeResult{
                NextNodeID: nextID,
                Err:        nil,
        }
}</span>

func (nr *NodeStart) RunAsync(ctx context.Context, req *node.FlowNodeRequest, resultChan chan node.FlowNodeResult) <span class="cov0" title="0">{
        nextID := edge.GetNextNodeID(req.EdgeSourceMap, nr.FlowNodeID, edge.HandleUnspecified)

        result := node.FlowNodeResult{
                NextNodeID: nextID,
                Err:        nil,
        }
        resultChan &lt;- result
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package flowlocalrunner

import (
        "context"
        "fmt"
        "runtime"
        "sync"
        "the-dev-tools/server/pkg/flow/edge"
        "the-dev-tools/server/pkg/flow/node"
        "the-dev-tools/server/pkg/flow/runner"
        "the-dev-tools/server/pkg/flow/tracking"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mnnode"
        "time"
)

type FlowLocalRunner struct {
        ID               idwrap.IDWrap
        FlowID           idwrap.IDWrap
        FlowNodeMap      map[idwrap.IDWrap]node.FlowNode
        PendingAtmoicMap map[idwrap.IDWrap]uint32

        EdgesMap    edge.EdgesMap
        StartNodeID idwrap.IDWrap
        Timeout     time.Duration
}

func CreateFlowRunner(id, flowID, StartNodeID idwrap.IDWrap, FlowNodeMap map[idwrap.IDWrap]node.FlowNode, edgesMap edge.EdgesMap, timeout time.Duration) *FlowLocalRunner <span class="cov8" title="1">{
        return &amp;FlowLocalRunner{
                ID:               id,
                FlowID:           flowID,
                StartNodeID:      StartNodeID,
                FlowNodeMap:      FlowNodeMap,
                PendingAtmoicMap: make(map[idwrap.IDWrap]uint32),
                EdgesMap:         edgesMap,
                Timeout:          timeout,
        }
}</span>

func (r FlowLocalRunner) Run(ctx context.Context, flowNodeStatusChan chan runner.FlowNodeStatus, flowStatusChan chan runner.FlowStatus, baseVars map[string]any) error <span class="cov8" title="1">{
        defer close(flowNodeStatusChan)
        defer close(flowStatusChan)
        nextNodeID := &amp;r.StartNodeID
        var err error

        logWorkaround := func(status runner.FlowNodeStatus) </span><span class="cov8" title="1">{
                flowNodeStatusChan &lt;- status
        }</span>

        <span class="cov8" title="1">flowEdgeDepCounter := make(map[idwrap.IDWrap]uint32)
        for _, v := range r.EdgesMap </span><span class="cov8" title="1">{
                for _, targetIDs := range v </span><span class="cov8" title="1">{
                        for _, targetID := range targetIDs </span><span class="cov8" title="1">{
                                v, ok := flowEdgeDepCounter[targetID]
                                if !ok </span><span class="cov8" title="1">{
                                        flowEdgeDepCounter[targetID] = 0
                                }</span>
                                <span class="cov8" title="1">flowEdgeDepCounter[targetID] = v + 1</span>
                        }
                }
        }

        <span class="cov8" title="1">pendingAtmoicMap := make(map[idwrap.IDWrap]uint32)
        for k, v := range flowEdgeDepCounter </span><span class="cov8" title="1">{
                if v &gt; 1 </span><span class="cov8" title="1">{
                        pendingAtmoicMap[k] = v
                }</span>
        }

        <span class="cov8" title="1">if baseVars == nil </span><span class="cov8" title="1">{
                baseVars = make(map[string]any)
        }</span>

        <span class="cov8" title="1">req := &amp;node.FlowNodeRequest{
                VarMap:           baseVars,
                ReadWriteLock:    &amp;sync.RWMutex{},
                NodeMap:          r.FlowNodeMap,
                EdgeSourceMap:    r.EdgesMap,
                LogPushFunc:      node.LogPushFunc(logWorkaround),
                Timeout:          r.Timeout,
                PendingAtmoicMap: pendingAtmoicMap,
        }
        flowStatusChan &lt;- runner.FlowStatusStarting
        if r.Timeout == 0 </span><span class="cov8" title="1">{
                err = RunNodeSync(ctx, *nextNodeID, req, logWorkaround)
        }</span> else<span class="cov8" title="1"> {
                err = RunNodeASync(ctx, *nextNodeID, req, logWorkaround)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                flowStatusChan &lt;- runner.FlowStatusFailed
        }</span> else<span class="cov8" title="1"> {
                flowStatusChan &lt;- runner.FlowStatusSuccess
        }</span>
        <span class="cov8" title="1">return err</span>
}

type processResult struct {
        originalID  idwrap.IDWrap
        executionID idwrap.IDWrap
        nextNodes   []idwrap.IDWrap
        err         error
        inputData   map[string]any
        outputData  map[string]any // NEW: From tracker.GetWrittenVars()
}

func processNode(ctx context.Context, n node.FlowNode, req *node.FlowNodeRequest,
) ([]idwrap.IDWrap, error) <span class="cov8" title="1">{
        res := n.RunSync(ctx, req)
        return res.NextNodeID, res.Err
}</span>

type FlowNodeStatusLocal struct {
        StartTime time.Time
}

func MaxParallelism() int <span class="cov8" title="1">{
        maxProcs := runtime.GOMAXPROCS(0)
        numCPU := runtime.NumCPU()
        if maxProcs &lt; numCPU </span><span class="cov0" title="0">{
                return maxProcs
        }</span>
        <span class="cov8" title="1">return numCPU</span>
}

var goroutineCount int = MaxParallelism()

// getPredecessorNodes returns all nodes that have edges pointing to the given node
func getPredecessorNodes(nodeID idwrap.IDWrap, edgesMap edge.EdgesMap) []idwrap.IDWrap <span class="cov8" title="1">{
        var predecessors []idwrap.IDWrap
        seen := make(map[idwrap.IDWrap]bool)

        for sourceID, edges := range edgesMap </span><span class="cov8" title="1">{
                for _, targetNodes := range edges </span><span class="cov8" title="1">{
                        for _, targetID := range targetNodes </span><span class="cov8" title="1">{
                                if targetID == nodeID &amp;&amp; !seen[sourceID] </span><span class="cov8" title="1">{
                                        predecessors = append(predecessors, sourceID)
                                        seen[sourceID] = true
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return predecessors</span>
}

func RunNodeSync(ctx context.Context, startNodeID idwrap.IDWrap, req *node.FlowNodeRequest,
        statusLogFunc node.LogPushFunc,
) error <span class="cov8" title="1">{
        queue := []idwrap.IDWrap{startNodeID}

        var status runner.FlowNodeStatus
        var processCount int
        // Mutex to protect PendingAtmoicMap from concurrent access
        var pendingMapMutex sync.Mutex
        // Track nodes that have been sent RUNNING status but haven't completed
        // Map from executionID to the full status for proper state transitions
        runningNodes := make(map[idwrap.IDWrap]runner.FlowNodeStatus)
        runningNodesMutex := sync.Mutex{}
        // Track start times for duration calculation
        nodeStartTimes := make(map[idwrap.IDWrap]time.Time)

        // Cleanup function to send CANCELED status for all running/queued nodes
        sendCanceledStatuses := func(cancelErr error) </span><span class="cov8" title="1">{
                // Send CANCELED status for any nodes still in RUNNING state
                runningNodesMutex.Lock()
                for execID, runningStatus := range runningNodes </span><span class="cov0" title="0">{
                        // Calculate actual duration if we have a start time
                        duration := time.Duration(0)
                        if startTime, ok := nodeStartTimes[execID]; ok </span><span class="cov0" title="0">{
                                duration = time.Since(startTime)
                        }</span>

                        <span class="cov0" title="0">canceledStatus := runner.FlowNodeStatus{
                                ExecutionID:      execID,
                                NodeID:           runningStatus.NodeID,
                                Name:             runningStatus.Name,
                                State:            mnnode.NODE_STATE_CANCELED,
                                Error:            cancelErr,
                                IterationContext: runningStatus.IterationContext,
                                RunDuration:      duration,
                        }
                        statusLogFunc(canceledStatus)</span>
                }
                // Clear the maps after sending all canceled statuses
                <span class="cov8" title="1">runningNodes = make(map[idwrap.IDWrap]runner.FlowNodeStatus)
                nodeStartTimes = make(map[idwrap.IDWrap]time.Time)
                runningNodesMutex.Unlock()

                // Send CANCELED status for any nodes still in the queue
                for _, nodeID := range queue </span><span class="cov8" title="1">{
                        if node, ok := req.NodeMap[nodeID]; ok </span><span class="cov8" title="1">{
                                canceledStatus := runner.FlowNodeStatus{
                                        ExecutionID:      idwrap.NewNow(),
                                        NodeID:           nodeID,
                                        Name:             node.GetName(),
                                        State:            mnnode.NODE_STATE_CANCELED,
                                        Error:            cancelErr,
                                        IterationContext: req.IterationContext,
                                }
                                statusLogFunc(canceledStatus)
                        }</span>
                }
        }

        // Ensure we send canceled statuses on any return path
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if ctx.Err() != nil </span><span class="cov8" title="1">{
                        sendCanceledStatuses(ctx.Err())
                }</span>
        }()

        <span class="cov8" title="1">for queueLen := len(queue); queueLen != 0; queueLen = len(queue) </span><span class="cov8" title="1">{
                // Check if context was cancelled before processing next batch
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return ctx.Err()
                }</span>

                <span class="cov8" title="1">processCount = min(goroutineCount, queueLen)

                var wg sync.WaitGroup
                resultChan := make(chan processResult, processCount)

                // TODO: can be done better
                nodeStateMap := make(map[idwrap.IDWrap]FlowNodeStatusLocal, processCount)

                subqueue := queue[:processCount]

                wg.Add(processCount)
                FlowNodeCancelCtx, FlowNodeCancelCtxCancel := context.WithCancel(ctx)
                defer FlowNodeCancelCtxCancel()
                for _, flowNodeId := range subqueue </span><span class="cov8" title="1">{
                        currentNode, ok := req.NodeMap[flowNodeId]
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("node not found: %v", currentNode)
                        }</span>
                        <span class="cov8" title="1">nodeStateMap[flowNodeId] = FlowNodeStatusLocal{StartTime: time.Now()}
                        go func(nodeID idwrap.IDWrap) </span><span class="cov8" title="1">{
                                defer wg.Done()

                                // Wait for all predecessors to complete before reading their output
                                // This prevents race conditions where we read before predecessors finish writing
                                predecessors := getPredecessorNodes(nodeID, req.EdgeSourceMap)

                                // For each predecessor, wait until its variable is available
                                inputData := make(map[string]any)
                                for _, predID := range predecessors </span><span class="cov8" title="1">{
                                        if predNode, ok := req.NodeMap[predID]; ok </span><span class="cov8" title="1">{
                                                predName := predNode.GetName()

                                                // Retry reading with backoff to handle race conditions
                                                var predData interface{}
                                                var err error
                                                maxRetries := 10 // Max ~1ms total wait
                                                for retry := 0; retry &lt; maxRetries; retry++ </span><span class="cov8" title="1">{
                                                        predData, err = node.ReadVarRaw(req, predName)
                                                        if err == nil </span><span class="cov8" title="1">{
                                                                break</span>
                                                        }
                                                        // Very short wait before retry to allow predecessor to complete
                                                        <span class="cov8" title="1">time.Sleep(100 * time.Microsecond)</span>
                                                }

                                                // Only add to inputData if we successfully read the predecessor data
                                                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                                                        inputData[predName] = predData
                                                }</span>
                                        }
                                }

                                // Generate execution ID right before processing
                                <span class="cov8" title="1">executionID := idwrap.NewNow()

                                // Log RUNNING status with execution ID
                                runningStatus := runner.FlowNodeStatus{
                                        ExecutionID:      executionID,
                                        NodeID:           nodeID,
                                        Name:             currentNode.GetName(),
                                        State:            mnnode.NODE_STATE_RUNNING,
                                        Error:            nil,
                                        IterationContext: req.IterationContext,
                                }
                                statusLogFunc(runningStatus)

                                // Track this node as running with its start time
                                runningNodesMutex.Lock()
                                runningNodes[executionID] = runningStatus
                                nodeStartTimes[executionID] = time.Now()
                                runningNodesMutex.Unlock()

                                // Create a copy of the request for this execution to avoid race conditions
                                // This ensures each goroutine has its own tracker and execution ID
                                nodeReq := *req // Shallow copy of the request struct

                                // Initialize tracker for this node execution
                                tracker := tracking.NewVariableTracker()
                                nodeReq.VariableTracker = tracker

                                // Set the execution ID in the copied request
                                nodeReq.ExecutionID = executionID

                                ids, localErr := processNode(FlowNodeCancelCtx, currentNode, &amp;nodeReq)

                                // Capture tracked data as tree structures
                                outputData := tracker.GetWrittenVarsAsTree()

                                // Merge tracked variable reads as tree structure into inputData
                                trackedReads := tracker.GetReadVarsAsTree()
                                if len(trackedReads) &gt; 0 </span><span class="cov8" title="1">{
                                        // Merge the tracked reads into inputData without wrapping
                                        inputData = tracking.MergeTreesPreferFirst(inputData, trackedReads)
                                }</span>

                                <span class="cov8" title="1">resultChan &lt;- processResult{
                                        originalID:  currentNode.GetID(),
                                        executionID: executionID,
                                        nextNodes:   ids,
                                        err:         localErr,
                                        inputData:   inputData,
                                        outputData:  outputData,
                                }</span>
                        }(flowNodeId)
                }

                <span class="cov8" title="1">wg.Wait()

                close(resultChan)

                var lastNodeError error
                for result := range resultChan </span><span class="cov8" title="1">{
                        status.NodeID = result.originalID
                        status.ExecutionID = result.executionID
                        currentNode := req.NodeMap[result.originalID]
                        status.Name = currentNode.GetName()
                        status.IterationContext = req.IterationContext
                        nodeState := nodeStateMap[status.NodeID]
                        status.RunDuration = time.Since(nodeState.StartTime)

                        // Remove from running nodes since we're processing its completion
                        runningNodesMutex.Lock()
                        delete(runningNodes, result.executionID)
                        delete(nodeStartTimes, result.executionID)
                        runningNodesMutex.Unlock()

                        if FlowNodeCancelCtx.Err() != nil </span><span class="cov8" title="1">{
                                status.State = mnnode.NODE_STATE_CANCELED
                                status.Error = FlowNodeCancelCtx.Err()
                                // Capture tracked input/output data even for canceled nodes
                                // This ensures we show what data was read/written before cancellation
                                status.InputData = node.DeepCopyValue(result.inputData)
                                status.OutputData = node.DeepCopyValue(result.outputData)
                                statusLogFunc(status)
                                // Remove from running nodes since we've sent the CANCELED status
                                runningNodesMutex.Lock()
                                delete(runningNodes, result.executionID)
                                delete(nodeStartTimes, result.executionID)
                                runningNodesMutex.Unlock()
                                continue</span>
                        }

                        <span class="cov8" title="1">if result.err != nil </span><span class="cov8" title="1">{
                                status.State = mnnode.NODE_STATE_FAILURE
                                status.Error = result.err
                                statusLogFunc(status)
                                lastNodeError = result.err
                                FlowNodeCancelCtxCancel()
                                continue</span>
                        }

                        // All nodes should report SUCCESS when they complete successfully
                        // Loop nodes handle their own iteration tracking internally
                        <span class="cov8" title="1">status.State = mnnode.NODE_STATE_SUCCESS
                        status.Error = nil
                        // Use the tracked output data which has the proper tree structure
                        status.OutputData = node.DeepCopyValue(result.outputData)
                        // Deep copy input data as well
                        status.InputData = node.DeepCopyValue(result.inputData)
                        statusLogFunc(status)

                        for _, id := range result.nextNodes </span><span class="cov8" title="1">{
                                pendingMapMutex.Lock()
                                i, ok := req.PendingAtmoicMap[id]
                                if !ok || i == 1 </span><span class="cov8" title="1">{
                                        pendingMapMutex.Unlock()
                                        queue = append(queue, id)
                                }</span> else<span class="cov8" title="1"> {
                                        req.PendingAtmoicMap[id] = i - 1
                                        pendingMapMutex.Unlock()
                                }</span>
                        }
                }

                <span class="cov8" title="1">if lastNodeError != nil </span><span class="cov8" title="1">{
                        return lastNodeError
                }</span>

                // Check if flow was canceled - the defer will handle sending CANCELED statuses
                <span class="cov8" title="1">if FlowNodeCancelCtx.Err() != nil </span><span class="cov8" title="1">{
                        return FlowNodeCancelCtx.Err()
                }</span>

                // remove from queue
                <span class="cov8" title="1">queue = queue[processCount:]</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// RunNodeASync runs nodes with timeout handling
func RunNodeASync(ctx context.Context, startNodeID idwrap.IDWrap, req *node.FlowNodeRequest,
        statusLogFunc node.LogPushFunc,
) error <span class="cov8" title="1">{
        queue := []idwrap.IDWrap{startNodeID}

        var status runner.FlowNodeStatus
        var processCount int
        // Mutex to protect PendingAtmoicMap from concurrent access
        var pendingMapMutex sync.Mutex
        // Track nodes that have been sent RUNNING status but haven't completed
        // Map from executionID to the full status for proper state transitions
        runningNodes := make(map[idwrap.IDWrap]runner.FlowNodeStatus)
        runningNodesMutex := sync.Mutex{}
        // Track start times for duration calculation
        nodeStartTimes := make(map[idwrap.IDWrap]time.Time)

        // Cleanup function to send CANCELED status for all running/queued nodes
        sendCanceledStatuses := func(cancelErr error) </span><span class="cov0" title="0">{
                // Send CANCELED status for any nodes still in RUNNING state
                runningNodesMutex.Lock()
                for execID, runningStatus := range runningNodes </span><span class="cov0" title="0">{
                        // Calculate actual duration if we have a start time
                        duration := time.Duration(0)
                        if startTime, ok := nodeStartTimes[execID]; ok </span><span class="cov0" title="0">{
                                duration = time.Since(startTime)
                        }</span>

                        <span class="cov0" title="0">canceledStatus := runner.FlowNodeStatus{
                                ExecutionID:      execID,
                                NodeID:           runningStatus.NodeID,
                                Name:             runningStatus.Name,
                                State:            mnnode.NODE_STATE_CANCELED,
                                Error:            cancelErr,
                                IterationContext: runningStatus.IterationContext,
                                RunDuration:      duration,
                        }
                        statusLogFunc(canceledStatus)</span>
                }
                // Clear the maps after sending all canceled statuses
                <span class="cov0" title="0">runningNodes = make(map[idwrap.IDWrap]runner.FlowNodeStatus)
                nodeStartTimes = make(map[idwrap.IDWrap]time.Time)
                runningNodesMutex.Unlock()

                // Send CANCELED status for any nodes still in the queue
                for _, nodeID := range queue </span><span class="cov0" title="0">{
                        if node, ok := req.NodeMap[nodeID]; ok </span><span class="cov0" title="0">{
                                canceledStatus := runner.FlowNodeStatus{
                                        ExecutionID:      idwrap.NewNow(),
                                        NodeID:           nodeID,
                                        Name:             node.GetName(),
                                        State:            mnnode.NODE_STATE_CANCELED,
                                        Error:            cancelErr,
                                        IterationContext: req.IterationContext,
                                }
                                statusLogFunc(canceledStatus)
                        }</span>
                }
        }

        // Ensure we send canceled statuses on any return path
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        sendCanceledStatuses(ctx.Err())
                }</span>
        }()

        <span class="cov8" title="1">for queueLen := len(queue); queueLen != 0; queueLen = len(queue) </span><span class="cov8" title="1">{
                // Check if context was cancelled before processing next batch
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return ctx.Err()
                }</span>

                <span class="cov8" title="1">processCount = min(goroutineCount, queueLen)

                ctxTimed, cancelTimeFn := context.WithDeadline(ctx, time.Now().Add(req.Timeout))
                defer cancelTimeFn()

                var wg sync.WaitGroup
                resultChan := make(chan processResult, processCount)

                // TODO: can be done better
                timeStart := make(map[idwrap.IDWrap]time.Time, processCount)

                wg.Add(processCount)
                FlowNodeCancelCtx, FlowNodeCancelCtxCancelFn := context.WithCancel(ctxTimed)
                defer FlowNodeCancelCtxCancelFn()
                for i := range processCount </span><span class="cov8" title="1">{
                        id := queue[i]

                        currentNode, ok := req.NodeMap[id]
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("node not found: %v", currentNode)
                        }</span>

                        <span class="cov8" title="1">timeStart[id] = time.Now()

                        go func(nodeID idwrap.IDWrap) </span><span class="cov8" title="1">{
                                defer wg.Done()

                                // Wait for all predecessors to complete before reading their output
                                // This prevents race conditions where we read before predecessors finish writing
                                predecessors := getPredecessorNodes(nodeID, req.EdgeSourceMap)

                                // For each predecessor, wait until its variable is available
                                inputData := make(map[string]any)
                                for _, predID := range predecessors </span><span class="cov8" title="1">{
                                        if predNode, ok := req.NodeMap[predID]; ok </span><span class="cov8" title="1">{
                                                predName := predNode.GetName()

                                                // Retry reading with backoff to handle race conditions
                                                var predData interface{}
                                                var err error
                                                maxRetries := 10 // Max ~1ms total wait
                                                for retry := 0; retry &lt; maxRetries; retry++ </span><span class="cov8" title="1">{
                                                        predData, err = node.ReadVarRaw(req, predName)
                                                        if err == nil </span><span class="cov8" title="1">{
                                                                break</span>
                                                        }
                                                        // Very short wait before retry to allow predecessor to complete
                                                        <span class="cov8" title="1">time.Sleep(100 * time.Microsecond)</span>
                                                }

                                                // Only add to inputData if we successfully read the predecessor data
                                                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                                                        inputData[predName] = predData
                                                }</span>
                                        }
                                }

                                // Generate execution ID right before processing
                                <span class="cov8" title="1">executionID := idwrap.NewNow()

                                // Log RUNNING status with execution ID
                                runningStatus := runner.FlowNodeStatus{
                                        ExecutionID:      executionID,
                                        NodeID:           nodeID,
                                        Name:             currentNode.GetName(),
                                        State:            mnnode.NODE_STATE_RUNNING,
                                        Error:            nil,
                                        IterationContext: req.IterationContext,
                                }
                                statusLogFunc(runningStatus)

                                // Track this node as running with its start time
                                runningNodesMutex.Lock()
                                runningNodes[executionID] = runningStatus
                                nodeStartTimes[executionID] = time.Now()
                                runningNodesMutex.Unlock()

                                // Create a copy of the request for this execution to avoid race conditions
                                // This ensures each goroutine has its own tracker and execution ID
                                nodeReq := *req // Shallow copy of the request struct

                                // Initialize tracker for this node execution
                                tracker := tracking.NewVariableTracker()
                                nodeReq.VariableTracker = tracker

                                // Set the execution ID in the copied request
                                nodeReq.ExecutionID = executionID

                                ids, localErr := processNode(FlowNodeCancelCtx, currentNode, &amp;nodeReq)

                                // Always capture tracked data and send result, even if context timed out
                                // This ensures nodes don't get stuck in RUNNING state
                                outputData := tracker.GetWrittenVarsAsTree()

                                // Merge tracked variable reads as tree structure into inputData
                                trackedReads := tracker.GetReadVarsAsTree()
                                if len(trackedReads) &gt; 0 </span><span class="cov8" title="1">{
                                        // Merge the tracked reads into inputData without wrapping
                                        inputData = tracking.MergeTreesPreferFirst(inputData, trackedReads)
                                }</span>

                                // If context timed out after node execution, mark it as an error
                                <span class="cov8" title="1">if ctxTimed.Err() != nil &amp;&amp; localErr == nil </span><span class="cov8" title="1">{
                                        localErr = ctxTimed.Err()
                                }</span>

                                <span class="cov8" title="1">resultChan &lt;- processResult{
                                        originalID:  currentNode.GetID(),
                                        executionID: executionID,
                                        nextNodes:   ids,
                                        err:         localErr,
                                        inputData:   inputData,
                                        outputData:  outputData,
                                }</span>
                        }(id)
                }

                <span class="cov8" title="1">waitCh := make(chan struct{}, 1)
                go func() </span><span class="cov8" title="1">{
                        wg.Wait()
                        close(waitCh)
                }</span>()

                // Wait for all goroutines to complete or timeout
                <span class="cov8" title="1">timedOut := false
                select </span>{
                case &lt;-ctxTimed.Done():<span class="cov8" title="1">
                        timedOut = true
                        &lt;-waitCh</span> // Wait for goroutines to finish sending their results
                case &lt;-waitCh:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">close(resultChan)
                queue = queue[processCount:]

                var lastNodeError error
                for result := range resultChan </span><span class="cov8" title="1">{
                        status.NodeID = result.originalID
                        status.ExecutionID = result.executionID
                        currentNode := req.NodeMap[result.originalID]
                        status.Name = currentNode.GetName()
                        status.IterationContext = req.IterationContext
                        status.RunDuration = time.Since(timeStart[status.NodeID])

                        // Remove from running nodes since we're processing its completion
                        runningNodesMutex.Lock()
                        delete(runningNodes, result.executionID)
                        delete(nodeStartTimes, result.executionID)
                        runningNodesMutex.Unlock()

                        if FlowNodeCancelCtx.Err() != nil </span><span class="cov8" title="1">{
                                status.State = mnnode.NODE_STATE_CANCELED
                                status.Error = FlowNodeCancelCtx.Err()
                                // Capture tracked input/output data even for canceled nodes
                                // This ensures we show what data was read/written before cancellation
                                status.InputData = node.DeepCopyValue(result.inputData)
                                status.OutputData = node.DeepCopyValue(result.outputData)
                                statusLogFunc(status)
                                // Remove from running nodes since we've sent the CANCELED status
                                runningNodesMutex.Lock()
                                delete(runningNodes, result.executionID)
                                delete(nodeStartTimes, result.executionID)
                                runningNodesMutex.Unlock()
                                continue</span>
                        }
                        <span class="cov8" title="1">if result.err != nil </span><span class="cov8" title="1">{
                                status.State = mnnode.NODE_STATE_FAILURE
                                status.Error = result.err
                                statusLogFunc(status)
                                lastNodeError = result.err
                                FlowNodeCancelCtxCancelFn()
                                continue</span>
                        }
                        // All nodes should report SUCCESS when they complete successfully
                        // Loop nodes handle their own iteration tracking internally
                        <span class="cov8" title="1">status.State = mnnode.NODE_STATE_SUCCESS
                        status.Error = nil
                        // Use the tracked output data which has the proper tree structure
                        status.OutputData = node.DeepCopyValue(result.outputData)
                        // Deep copy input data as well
                        status.InputData = node.DeepCopyValue(result.inputData)
                        statusLogFunc(status)

                        for _, id := range result.nextNodes </span><span class="cov8" title="1">{
                                pendingMapMutex.Lock()
                                i, ok := req.PendingAtmoicMap[id]
                                if !ok || i == 1 </span><span class="cov8" title="1">{
                                        pendingMapMutex.Unlock()
                                        queue = append(queue, id)
                                }</span> else<span class="cov8" title="1"> {
                                        req.PendingAtmoicMap[id] = i - 1
                                        pendingMapMutex.Unlock()
                                }</span>
                        }
                }

                <span class="cov8" title="1">if lastNodeError != nil </span><span class="cov8" title="1">{
                        return lastNodeError
                }</span>

                // Check if flow was canceled - the defer will handle sending CANCELED statuses
                <span class="cov8" title="1">if FlowNodeCancelCtx.Err() != nil </span><span class="cov8" title="1">{
                        return FlowNodeCancelCtx.Err()
                }</span>

                // If we timed out but no specific node error, return the timeout error
                // The defer will handle sending CANCELED statuses
                <span class="cov8" title="1">if timedOut </span><span class="cov0" title="0">{
                        return ctxTimed.Err()
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package runner

import (
        "context"
        "errors"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mnnode"
        "time"
)

var (
        ErrFlowRunnerNotImplemented = errors.New("flowrunner not implemented")
        ErrNodeNotFound             = errors.New("next node not found")
)

type FlowRunner interface {
        Run(context.Context, chan FlowNodeStatus, chan FlowStatus) error
}

type FlowStatus int8

const (
        FlowStatusStarting FlowStatus = iota
        FlowStatusRunning
        FlowStatusSuccess
        FlowStatusFailed
        FlowStatusTimeout
)

func FlowStatusString(f FlowStatus) string <span class="cov0" title="0">{
        return [...]string{"Starting", "Running", "Success", "Failed", "Timeout"}[f]
}</span>

func FlowStatusStringWithIcons(f FlowStatus) string <span class="cov0" title="0">{
        return [...]string{"🔄 Starting", "⏳ Running", "✅ Success", "❌ Failed", "⏰ Timeout"}[f]
}</span>

func IsFlowStatusDone(f FlowStatus) bool <span class="cov0" title="0">{
        return f == FlowStatusSuccess || f == FlowStatusFailed || f == FlowStatusTimeout
}</span>

type IterationContext struct {
        IterationPath  []int           `json:"iteration_path"`         // [1, 2, 3] for nested loops
        ExecutionIndex int             `json:"execution_index"`        // Current execution within current loop
        ParentNodes    []idwrap.IDWrap `json:"parent_nodes,omitempty"` // Parent loop node IDs for hierarchical naming
}

type FlowNodeStatus struct {
        ExecutionID      idwrap.IDWrap
        NodeID           idwrap.IDWrap
        Name             string
        State            mnnode.NodeState
        OutputData       any
        InputData        any // Data that was read by this node during execution
        RunDuration      time.Duration
        Error            error
        IterationContext *IterationContext `json:"iteration_context,omitempty"`
}

func NewFlowNodeStatus(nodeID idwrap.IDWrap, status mnnode.NodeState, output []byte) FlowNodeStatus <span class="cov0" title="0">{
        return FlowNodeStatus{
                NodeID:     nodeID,
                State:      status,
                OutputData: output,
                Error:      nil,
        }
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package tracking

// TrackingEnv wraps an environment map to track variable access
type TrackingEnv struct {
        originalEnv map[string]any
        tracker     *VariableTracker
}

// NewTrackingEnv creates a new tracking environment wrapper
func NewTrackingEnv(env map[string]any, tracker *VariableTracker) *TrackingEnv <span class="cov8" title="1">{
        return &amp;TrackingEnv{
                originalEnv: env,
                tracker:     tracker,
        }
}</span>

// Get retrieves a value from the environment and tracks the read
func (te *TrackingEnv) Get(key string) (any, bool) <span class="cov8" title="1">{
        if te.originalEnv == nil </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">value, exists := te.originalEnv[key]
        if exists &amp;&amp; te.tracker != nil </span><span class="cov8" title="1">{
                te.tracker.TrackRead(key, value)
        }</span>

        <span class="cov8" title="1">return value, exists</span>
}

// GetMap returns the underlying map for use with expr.Compile
// This is needed for expression compilation but doesn't track access
func (te *TrackingEnv) GetMap() map[string]any <span class="cov8" title="1">{
        if te.originalEnv == nil </span><span class="cov8" title="1">{
                return make(map[string]any)
        }</span>
        <span class="cov8" title="1">return te.originalEnv</span>
}

// TrackAllVariables tracks all variables in the environment as potentially accessed
// This is called for expression evaluation since we can't track individual variable access
func (te *TrackingEnv) TrackAllVariables() <span class="cov8" title="1">{
        if te.tracker == nil || te.originalEnv == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">for key, value := range te.originalEnv </span><span class="cov8" title="1">{
                te.tracker.TrackRead(key, value)
        }</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package tracking

import (
        "sync"
)

// VariableTracker tracks variable reads and writes during node execution
type VariableTracker struct {
        readVars    map[string]any
        writtenVars map[string]any
        mutex       sync.RWMutex
}

// NewVariableTracker creates a new variable tracker instance
func NewVariableTracker() *VariableTracker <span class="cov8" title="1">{
        return &amp;VariableTracker{
                readVars:    make(map[string]any),
                writtenVars: make(map[string]any),
        }
}</span>

// TrackRead records a variable read operation
func (vt *VariableTracker) TrackRead(key string, value any) <span class="cov8" title="1">{
        if vt == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">vt.mutex.Lock()
        defer vt.mutex.Unlock()
        vt.readVars[key] = deepCopy(value)</span>
}

// TrackWrite records a variable write operation
func (vt *VariableTracker) TrackWrite(key string, value any) <span class="cov8" title="1">{
        if vt == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">vt.mutex.Lock()
        defer vt.mutex.Unlock()
        vt.writtenVars[key] = deepCopy(value)</span>
}

// GetReadVars returns a copy of all tracked read variables
func (vt *VariableTracker) GetReadVars() map[string]any <span class="cov8" title="1">{
        if vt == nil </span><span class="cov8" title="1">{
                return make(map[string]any)
        }</span>

        <span class="cov8" title="1">vt.mutex.RLock()
        defer vt.mutex.RUnlock()

        result := make(map[string]any, len(vt.readVars))
        for k, v := range vt.readVars </span><span class="cov8" title="1">{
                result[k] = deepCopy(v)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// GetReadVarsAsTree returns read variables as a nested tree structure
func (vt *VariableTracker) GetReadVarsAsTree() map[string]any <span class="cov8" title="1">{
        flatVars := vt.GetReadVars()
        return BuildTree(flatVars)
}</span>

// GetWrittenVars returns a copy of all tracked written variables
func (vt *VariableTracker) GetWrittenVars() map[string]any <span class="cov8" title="1">{
        if vt == nil </span><span class="cov8" title="1">{
                return make(map[string]any)
        }</span>

        <span class="cov8" title="1">vt.mutex.RLock()
        defer vt.mutex.RUnlock()

        result := make(map[string]any, len(vt.writtenVars))
        for k, v := range vt.writtenVars </span><span class="cov8" title="1">{
                result[k] = deepCopy(v)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// GetWrittenVarsAsTree returns written variables as a nested tree structure
func (vt *VariableTracker) GetWrittenVarsAsTree() map[string]any <span class="cov8" title="1">{
        flatVars := vt.GetWrittenVars()
        return BuildTree(flatVars)
}</span>

// deepCopy creates a deep copy of the value to prevent external modifications
func deepCopy(v any) any <span class="cov8" title="1">{
        if v == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">switch val := v.(type) </span>{
        case map[string]any:<span class="cov8" title="1">
                result := make(map[string]any, len(val))
                for k, v := range val </span><span class="cov8" title="1">{
                        result[k] = deepCopy(v)
                }</span>
                <span class="cov8" title="1">return result</span>
        case []any:<span class="cov8" title="1">
                result := make([]any, len(val))
                for i, v := range val </span><span class="cov8" title="1">{
                        result[i] = deepCopy(v)
                }</span>
                <span class="cov8" title="1">return result</span>
        case []map[string]interface{}:<span class="cov8" title="1">
                result := make([]map[string]interface{}, len(val))
                for i, v := range val </span><span class="cov8" title="1">{
                        if mapCopy, ok := deepCopy(v).(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                result[i] = mapCopy
                        }</span>
                }
                <span class="cov8" title="1">return result</span>
        default:<span class="cov8" title="1">
                // For primitive types and other types, return as is
                // This includes string, int, float, bool, etc.
                // Also handles map[string]interface{} and []interface{} through any
                return v</span>
        }
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package tracking

import (
        "strings"
)

// BuildTree converts flat key-value pairs with dot notation into a nested tree structure
// Example: {"a.b.c": "value"} becomes {"a": {"b": {"c": "value"}}}
func BuildTree(flatMap map[string]any) map[string]any <span class="cov8" title="1">{
        if len(flatMap) == 0 </span><span class="cov8" title="1">{
                return make(map[string]any)
        }</span>

        <span class="cov8" title="1">result := make(map[string]any)

        for key, value := range flatMap </span><span class="cov8" title="1">{
                setNestedValue(result, key, value)
        }</span>

        <span class="cov8" title="1">return result</span>
}

// setNestedValue sets a value in a nested map structure using dot notation
func setNestedValue(target map[string]any, path string, value any) <span class="cov8" title="1">{
        // Handle edge case of empty path
        if path == "" </span><span class="cov0" title="0">{
                return
        }</span>

        // Remove leading/trailing spaces from path
        <span class="cov8" title="1">path = strings.TrimSpace(path)
        if path == "" </span><span class="cov0" title="0">{
                return
        }</span>

        // Split the path by dots
        <span class="cov8" title="1">parts := strings.Split(path, ".")

        // Navigate/create the nested structure
        current := target
        for i, part := range parts </span><span class="cov8" title="1">{
                // Remove leading/trailing spaces from each part
                part = strings.TrimSpace(part)
                if part == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // If this is the last part, set the value
                <span class="cov8" title="1">if i == len(parts)-1 </span><span class="cov8" title="1">{
                        current[part] = deepCopyValue(value)
                        return
                }</span>

                // Create or navigate to the next level
                <span class="cov8" title="1">if _, exists := current[part]; !exists </span><span class="cov8" title="1">{
                        current[part] = make(map[string]any)
                }</span>

                // Type assertion to continue navigation
                <span class="cov8" title="1">if nextLevel, ok := current[part].(map[string]any); ok </span><span class="cov8" title="1">{
                        current = nextLevel
                }</span> else<span class="cov0" title="0"> {
                        // If the current value is not a map, we can't navigate further
                        // This could happen if there's a conflict in the tree structure
                        // For now, just overwrite with a new map
                        current[part] = make(map[string]any)
                        current = current[part].(map[string]any)
                }</span>
        }
}

// deepCopyValue creates a deep copy of a value to prevent external modifications
func deepCopyValue(v any) any <span class="cov8" title="1">{
        if v == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">switch val := v.(type) </span>{
        case map[string]any:<span class="cov8" title="1">
                result := make(map[string]any, len(val))
                for k, v := range val </span><span class="cov8" title="1">{
                        result[k] = deepCopyValue(v)
                }</span>
                <span class="cov8" title="1">return result</span>
        case []any:<span class="cov0" title="0">
                result := make([]any, len(val))
                for i, v := range val </span><span class="cov0" title="0">{
                        result[i] = deepCopyValue(v)
                }</span>
                <span class="cov0" title="0">return result</span>
        case []map[string]interface{}:<span class="cov0" title="0">
                result := make([]map[string]interface{}, len(val))
                for i, v := range val </span><span class="cov0" title="0">{
                        if mapCopy, ok := deepCopyValue(v).(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                result[i] = mapCopy
                        }</span>
                }
                <span class="cov0" title="0">return result</span>
        default:<span class="cov8" title="1">
                // For primitive types and other types, return as is
                // This includes string, int, float, bool, etc.
                // Note: map[string]interface{} and []interface{} are handled by map[string]any and []any
                return v</span>
        }
}

// MergeTreesPreferFirst merges two tree structures, preferring values from the first tree when conflicts occur
func MergeTreesPreferFirst(first, second map[string]any) map[string]any <span class="cov8" title="1">{
        if len(first) == 0 </span><span class="cov0" title="0">{
                return deepCopyTree(second)
        }</span>
        <span class="cov8" title="1">if len(second) == 0 </span><span class="cov0" title="0">{
                return deepCopyTree(first)
        }</span>

        <span class="cov8" title="1">result := deepCopyTree(first)

        for key, value := range second </span><span class="cov8" title="1">{
                if _, exists := result[key]; !exists </span><span class="cov8" title="1">{
                        result[key] = deepCopyValue(value)
                }</span> else<span class="cov8" title="1"> {
                        // If both are maps, recursively merge
                        if firstMap, ok := result[key].(map[string]any); ok </span><span class="cov8" title="1">{
                                if secondMap, ok := value.(map[string]any); ok </span><span class="cov8" title="1">{
                                        result[key] = MergeTreesPreferFirst(firstMap, secondMap)
                                }</span>
                                // If first is map but second isn't, keep first (prefer first)
                        }
                        // If first exists and is not a map, keep first (prefer first)
                }
        }

        <span class="cov8" title="1">return result</span>
}

// deepCopyTree creates a deep copy of a tree structure
func deepCopyTree(tree map[string]any) map[string]any <span class="cov8" title="1">{
        if tree == nil </span><span class="cov0" title="0">{
                return make(map[string]any)
        }</span>

        <span class="cov8" title="1">result := make(map[string]any, len(tree))
        for k, v := range tree </span><span class="cov8" title="1">{
                result[k] = deepCopyValue(v)
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package fuzzyfinder

import "github.com/lithammer/fuzzysearch/fuzzy"

type Rank struct {
        // Source is used as the source for matching.
        Source string

        // Target is the word matched against.
        Target string

        // Distance is the Levenshtein distance between Source and Target.
        Distance int

        // Location of Target in original list
        OriginalIndex int
}

func RankFind(keys []string, query string) []Rank <span class="cov8" title="1">{
        ranksLib := fuzzy.RankFindFold(query, keys)
        ranks := make([]Rank, ranksLib.Len())
        for i, r := range ranksLib </span><span class="cov8" title="1">{
                ranks[i] = Rank{
                        Source:        r.Source,
                        Target:        r.Target,
                        Distance:      r.Distance,
                        OriginalIndex: r.OriginalIndex,
                }
        }</span>
        <span class="cov8" title="1">return ranks</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package request

import (
        "bytes"
        "context"
        "fmt"
        "mime"
        "mime/multipart"
        "net/textproto"
        "net/url"
        "os"
        "path/filepath"
        "strings"
        "the-dev-tools/server/pkg/compress"
        "the-dev-tools/server/pkg/httpclient"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mbodyform"
        "the-dev-tools/server/pkg/model/mbodyraw"
        "the-dev-tools/server/pkg/model/mbodyurl"
        "the-dev-tools/server/pkg/model/mexampleheader"
        "the-dev-tools/server/pkg/model/mexamplequery"
        "the-dev-tools/server/pkg/model/mitemapi"
        "the-dev-tools/server/pkg/model/mitemapiexample"
        "the-dev-tools/server/pkg/sort/sortenabled"
        "the-dev-tools/server/pkg/varsystem"
        "time"

        "connectrpc.com/connect"
)

type RequestResponseVar struct {
        Headers map[string]string `json:"headers"`
        Queries map[string]string `json:"queries"`
        Body    string            `json:"body"`
}

type RequestResponse struct {
        HttpResp httpclient.Response
        LapTime  time.Duration
}

func ConvertRequestToVar(r *httpclient.Request) RequestResponseVar <span class="cov0" title="0">{
        headersMaps := make(map[string]string, len(r.Headers))
        queriesMaps := make(map[string]string, len(r.Queries))
        for _, header := range r.Headers </span><span class="cov0" title="0">{
                headersMaps[header.HeaderKey] = header.Value
        }</span>

        <span class="cov0" title="0">for _, query := range r.Queries </span><span class="cov0" title="0">{
                queriesMaps[query.QueryKey] = query.Value
        }</span>
        <span class="cov0" title="0">return RequestResponseVar{Headers: headersMaps, Queries: queriesMaps, Body: string(r.Body)}</span>
}

// quoteEscaper is used to escape quotes in MIME headers.
var quoteEscaper = strings.NewReplacer("\\", "\\\\", "\"", "\\\"")

func escapeQuotes(s string) string <span class="cov8" title="1">{
        return quoteEscaper.Replace(s)
}</span>

// PrepareRequestResult holds the result of preparing a request with tracked variable usage
type PrepareRequestResult struct {
        Request  *httpclient.Request
        ReadVars map[string]string // Variables that were read during request preparation
}

func PrepareRequest(endpoint mitemapi.ItemApi, example mitemapiexample.ItemApiExample, queries []mexamplequery.Query, headers []mexampleheader.Header,
        rawBody mbodyraw.ExampleBodyRaw, formBody []mbodyform.BodyForm, urlBody []mbodyurl.BodyURLEncoded, varMap varsystem.VarMap,
) (*httpclient.Request, error) <span class="cov8" title="1">{
        var err error
        if varsystem.CheckStringHasAnyVarKey(endpoint.Url) </span><span class="cov0" title="0">{
                endpoint.Url, err = varMap.ReplaceVars(endpoint.Url)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
        }

        // get only enabled
        <span class="cov8" title="1">sortenabled.GetAllWithState(&amp;headers, true)
        sortenabled.GetAllWithState(&amp;queries, true)
        sortenabled.GetAllWithState(&amp;formBody, true)
        sortenabled.GetAllWithState(&amp;urlBody, true)

        compressType := compress.CompressTypeNone
        if varMap != nil </span><span class="cov8" title="1">{
                for i, query := range queries </span><span class="cov0" title="0">{
                        if varsystem.CheckIsVar(query.QueryKey) </span><span class="cov0" title="0">{
                                key := varsystem.GetVarKeyFromRaw(query.QueryKey)
                                if val, ok := varMap.Get(key); ok </span><span class="cov0" title="0">{
                                        queries[i].QueryKey = val.Value
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, connect.NewError(connect.CodeNotFound, fmt.Errorf("%s named variable not found", key))
                                }</span>
                        }

                        <span class="cov0" title="0">if varsystem.CheckIsVar(query.Value) </span><span class="cov0" title="0">{
                                key := varsystem.GetVarKeyFromRaw(query.Value)
                                if val, ok := varMap.Get(key); ok </span><span class="cov0" title="0">{
                                        queries[i].Value = val.Value
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, connect.NewError(connect.CodeNotFound, fmt.Errorf("%s named variable not found", key))
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">for i, header := range headers </span><span class="cov8" title="1">{
                if header.HeaderKey == "Content-Encoding" </span><span class="cov0" title="0">{
                        switch strings.ToLower(header.Value) </span>{
                        case "gzip":<span class="cov0" title="0">
                                compressType = compress.CompressTypeGzip</span>
                        case "zstd":<span class="cov0" title="0">
                                compressType = compress.CompressTypeZstd</span>
                        case "br":<span class="cov0" title="0">
                                compressType = compress.CompressTypeBr</span>
                        case "deflate", "identity":<span class="cov0" title="0">
                                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("%s not supported", header.Value))</span>
                        default:<span class="cov0" title="0">
                                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("invalid compression type %s", header.Value))</span>
                        }
                }

                <span class="cov8" title="1">if varMap != nil </span><span class="cov8" title="1">{
                        if varsystem.CheckIsVar(header.HeaderKey) </span><span class="cov0" title="0">{
                                key := varsystem.GetVarKeyFromRaw(header.HeaderKey)
                                if val, ok := varMap.Get(key); ok </span><span class="cov0" title="0">{
                                        headers[i].HeaderKey = val.Value
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, connect.NewError(connect.CodeNotFound, fmt.Errorf("%s named variable not found", key))
                                }</span>
                        }

                        <span class="cov8" title="1">if varsystem.CheckStringHasAnyVarKey(header.Value) </span><span class="cov8" title="1">{
                                // Use varsystem's ReplaceVars for any string containing variables
                                replacedValue, err := varMap.ReplaceVars(header.Value)
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, connect.NewError(connect.CodeNotFound, err)
                                }</span>
                                <span class="cov8" title="1">headers[i].Value = replacedValue</span>
                        }
                }
        }

        <span class="cov8" title="1">bodyBytes := &amp;bytes.Buffer{}
        switch example.BodyType </span>{
        case mitemapiexample.BodyTypeRaw:<span class="cov8" title="1">
                if len(rawBody.Data) &gt; 0 </span><span class="cov0" title="0">{
                        if rawBody.CompressType != compress.CompressTypeNone </span><span class="cov0" title="0">{
                                rawBody.Data, err = compress.Decompress(rawBody.Data, rawBody.CompressType)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }
                        <span class="cov0" title="0">bodyStr := string(rawBody.Data)
                        bodyStr, err = varMap.ReplaceVars(bodyStr)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeNotFound, err)
                        }</span>
                        <span class="cov0" title="0">rawBody.Data = []byte(bodyStr)</span>
                }
                <span class="cov8" title="1">_, err = bodyBytes.Write(rawBody.Data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        case mitemapiexample.BodyTypeForm:<span class="cov8" title="1">
                writer := multipart.NewWriter(bodyBytes)

                // Add Content-Type header with multipart boundary
                contentTypeHeader := mexampleheader.Header{
                        HeaderKey: "Content-Type",
                        Value:     writer.FormDataContentType(),
                        Enable:    true,
                }
                headers = append(headers, contentTypeHeader)

                for _, v := range formBody </span><span class="cov8" title="1">{
                        actualBodyKey := v.BodyKey
                        if varsystem.CheckIsVar(v.BodyKey) </span><span class="cov0" title="0">{
                                key := varsystem.GetVarKeyFromRaw(v.BodyKey)
                                if val, ok := varMap.Get(key); ok </span><span class="cov0" title="0">{
                                        actualBodyKey = val.Value
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, connect.NewError(connect.CodeNotFound, fmt.Errorf("%s named error not found", key))
                                }</span>
                        }

                        // First check if this value contains file references (before variable replacement)
                        <span class="cov8" title="1">filePathsToUpload := []string{}
                        potentialFileRefs := strings.Split(v.Value, ",")
                        allAreFileReferences := true

                        for _, ref := range potentialFileRefs </span><span class="cov8" title="1">{
                                trimmedRef := strings.TrimSpace(ref)
                                // Check if this is a variable containing a file reference
                                if varsystem.CheckIsVar(trimmedRef) </span><span class="cov8" title="1">{
                                        key := varsystem.GetVarKeyFromRaw(trimmedRef)
                                        if varsystem.IsFileReference(key) </span><span class="cov8" title="1">{
                                                // This is {{#file:path}} format
                                                filePathsToUpload = append(filePathsToUpload, varsystem.GetIsFileReferencePath(key))
                                        }</span> else<span class="cov0" title="0"> {
                                                // This is a regular variable, try to resolve it
                                                if val, ok := varMap.Get(key); ok </span><span class="cov0" title="0">{
                                                        if varsystem.IsFileReference(val.Value) </span><span class="cov0" title="0">{
                                                                filePathsToUpload = append(filePathsToUpload, varsystem.GetIsFileReferencePath(val.Value))
                                                        }</span> else<span class="cov0" title="0"> {
                                                                allAreFileReferences = false
                                                                break</span>
                                                        }
                                                } else<span class="cov0" title="0"> {
                                                        allAreFileReferences = false
                                                        break</span>
                                                }
                                        }
                                } else<span class="cov0" title="0"> if varsystem.IsFileReference(trimmedRef) </span><span class="cov0" title="0">{
                                        // This is direct #file:path format
                                        filePathsToUpload = append(filePathsToUpload, varsystem.GetIsFileReferencePath(trimmedRef))
                                }</span> else<span class="cov0" title="0"> {
                                        allAreFileReferences = false
                                        break</span>
                                }
                        }

                        <span class="cov8" title="1">resolvedValue := v.Value
                        if !allAreFileReferences &amp;&amp; varsystem.CheckStringHasAnyVarKey(v.Value) </span><span class="cov0" title="0">{
                                // Only replace variables if this is not a file reference
                                var err error
                                resolvedValue, err = varMap.ReplaceVars(v.Value)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, connect.NewError(connect.CodeNotFound, err)
                                }</span>
                        }

                        <span class="cov8" title="1">if allAreFileReferences &amp;&amp; len(filePathsToUpload) &gt; 0 </span><span class="cov8" title="1">{
                                // This is a file upload (single or multiple)
                                for _, filePath := range filePathsToUpload </span><span class="cov8" title="1">{
                                        fileContentBytes, err := os.ReadFile(filePath)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to read file %s: %w", filePath, err))
                                        }</span>

                                        <span class="cov8" title="1">fileName := filepath.Base(filePath)

                                        h := make(textproto.MIMEHeader)
                                        h.Set("Content-Disposition",
                                                fmt.Sprintf(`form-data; name="%s"; filename="%s"`,
                                                        escapeQuotes(actualBodyKey), escapeQuotes(fileName)))

                                        mimeType := mime.TypeByExtension(filepath.Ext(fileName))
                                        if mimeType == "" </span><span class="cov0" title="0">{
                                                mimeType = "application/octet-stream"
                                        }</span>
                                        <span class="cov8" title="1">h.Set("Content-Type", mimeType)

                                        partWriter, err := writer.CreatePart(h)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to create form part: %w", err))
                                        }</span>

                                        <span class="cov8" title="1">if _, err = partWriter.Write(fileContentBytes); err != nil </span><span class="cov0" title="0">{
                                                return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to write file content: %w", err))
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                // This is a regular text field
                                if err := writer.WriteField(actualBodyKey, resolvedValue); err != nil </span><span class="cov0" title="0">{
                                        return nil, connect.NewError(connect.CodeInternal, err)
                                }</span>
                        }
                }
                <span class="cov8" title="1">if err := writer.Close(); err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to close multipart writer: %w", err))
                }</span>
        case mitemapiexample.BodyTypeUrlencoded:<span class="cov0" title="0">
                urlVal := url.Values{}
                for _, url := range urlBody </span><span class="cov0" title="0">{
                        if varsystem.CheckIsVar(url.BodyKey) </span><span class="cov0" title="0">{
                                key := varsystem.GetVarKeyFromRaw(url.Value)
                                if val, ok := varMap.Get(key); ok </span><span class="cov0" title="0">{
                                        url.BodyKey = val.Value
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, connect.NewError(connect.CodeNotFound, fmt.Errorf("%s named error not found", key))
                                }</span>
                        }
                        <span class="cov0" title="0">if varsystem.CheckIsVar(url.Value) </span><span class="cov0" title="0">{
                                key := varsystem.GetVarKeyFromRaw(url.Value)
                                if val, ok := varMap.Get(key); ok </span><span class="cov0" title="0">{
                                        url.Value = val.Value
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, connect.NewError(connect.CodeNotFound, fmt.Errorf("%s named error not found", key))
                                }</span>
                        }

                        <span class="cov0" title="0">urlVal.Add(url.BodyKey, url.Value)</span>
                }
                <span class="cov0" title="0">endpoint.Url += urlVal.Encode()</span>
        }

        <span class="cov8" title="1">if compressType != compress.CompressTypeNone </span><span class="cov0" title="0">{
                compressedData, err := compress.Compress(bodyBytes.Bytes(), compressType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">bodyBytes = bytes.NewBuffer(compressedData)</span>
        }

        <span class="cov8" title="1">httpReq := &amp;httpclient.Request{
                Method:  endpoint.Method,
                URL:     endpoint.Url,
                Headers: headers,
                Queries: queries,
                Body:    bodyBytes.Bytes(),
        }

        return httpReq, nil</span>
}

// PrepareRequestWithTracking prepares a request and tracks which variables are read
func PrepareRequestWithTracking(endpoint mitemapi.ItemApi, example mitemapiexample.ItemApiExample, queries []mexamplequery.Query, headers []mexampleheader.Header,
        rawBody mbodyraw.ExampleBodyRaw, formBody []mbodyform.BodyForm, urlBody []mbodyurl.BodyURLEncoded, varMap varsystem.VarMap,
) (*PrepareRequestResult, error) <span class="cov8" title="1">{
        // Create a tracking wrapper around the varMap
        tracker := varsystem.NewVarMapTracker(varMap)

        var err error
        if varsystem.CheckStringHasAnyVarKey(endpoint.Url) </span><span class="cov8" title="1">{
                endpoint.Url, err = tracker.ReplaceVars(endpoint.Url)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeNotFound, err)
                }</span>
        }

        // get only enabled
        <span class="cov8" title="1">sortenabled.GetAllWithState(&amp;headers, true)
        sortenabled.GetAllWithState(&amp;queries, true)
        sortenabled.GetAllWithState(&amp;formBody, true)
        sortenabled.GetAllWithState(&amp;urlBody, true)

        compressType := compress.CompressTypeNone
        if varMap != nil </span><span class="cov8" title="1">{
                for i, query := range queries </span><span class="cov8" title="1">{
                        if varsystem.CheckIsVar(query.QueryKey) </span><span class="cov0" title="0">{
                                key := varsystem.GetVarKeyFromRaw(query.QueryKey)
                                if val, ok := tracker.Get(key); ok </span><span class="cov0" title="0">{
                                        queries[i].QueryKey = val.Value
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, connect.NewError(connect.CodeNotFound, fmt.Errorf("%s named variable not found", key))
                                }</span>
                        }

                        <span class="cov8" title="1">if varsystem.CheckIsVar(query.Value) </span><span class="cov8" title="1">{
                                key := varsystem.GetVarKeyFromRaw(query.Value)
                                if val, ok := tracker.Get(key); ok </span><span class="cov8" title="1">{
                                        queries[i].Value = val.Value
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, connect.NewError(connect.CodeNotFound, fmt.Errorf("%s named variable not found", key))
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">for i, header := range headers </span><span class="cov8" title="1">{
                if header.HeaderKey == "Content-Encoding" </span><span class="cov0" title="0">{
                        switch strings.ToLower(header.Value) </span>{
                        case "gzip":<span class="cov0" title="0">
                                compressType = compress.CompressTypeGzip</span>
                        case "zstd":<span class="cov0" title="0">
                                compressType = compress.CompressTypeZstd</span>
                        case "br":<span class="cov0" title="0">
                                compressType = compress.CompressTypeBr</span>
                        case "deflate", "identity":<span class="cov0" title="0">
                                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("%s not supported", header.Value))</span>
                        default:<span class="cov0" title="0">
                                return nil, connect.NewError(connect.CodeInvalidArgument, fmt.Errorf("invalid compression type %s", header.Value))</span>
                        }
                }

                <span class="cov8" title="1">if varMap != nil </span><span class="cov8" title="1">{
                        if varsystem.CheckIsVar(header.HeaderKey) </span><span class="cov0" title="0">{
                                key := varsystem.GetVarKeyFromRaw(header.HeaderKey)
                                if val, ok := tracker.Get(key); ok </span><span class="cov0" title="0">{
                                        headers[i].HeaderKey = val.Value
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, connect.NewError(connect.CodeNotFound, fmt.Errorf("%s named variable not found", key))
                                }</span>
                        }

                        <span class="cov8" title="1">if varsystem.CheckStringHasAnyVarKey(header.Value) </span><span class="cov8" title="1">{
                                // Use tracking wrapper's ReplaceVars for any string containing variables
                                replacedValue, err := tracker.ReplaceVars(header.Value)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, connect.NewError(connect.CodeNotFound, err)
                                }</span>
                                <span class="cov8" title="1">headers[i].Value = replacedValue</span>
                        }
                }
        }

        <span class="cov8" title="1">bodyBytes := &amp;bytes.Buffer{}
        switch example.BodyType </span>{
        case mitemapiexample.BodyTypeRaw:<span class="cov8" title="1">
                if len(rawBody.Data) &gt; 0 </span><span class="cov8" title="1">{
                        if rawBody.CompressType != compress.CompressTypeNone </span><span class="cov0" title="0">{
                                rawBody.Data, err = compress.Decompress(rawBody.Data, rawBody.CompressType)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }
                        <span class="cov8" title="1">bodyStr := string(rawBody.Data)
                        bodyStr, err = tracker.ReplaceVars(bodyStr)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeNotFound, err)
                        }</span>
                        <span class="cov8" title="1">rawBody.Data = []byte(bodyStr)</span>
                }
                <span class="cov8" title="1">_, err = bodyBytes.Write(rawBody.Data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        case mitemapiexample.BodyTypeForm:<span class="cov0" title="0">
                writer := multipart.NewWriter(bodyBytes)

                // Add Content-Type header with multipart boundary
                contentTypeHeader := mexampleheader.Header{
                        HeaderKey: "Content-Type",
                        Value:     writer.FormDataContentType(),
                        Enable:    true,
                }
                headers = append(headers, contentTypeHeader)

                for _, v := range formBody </span><span class="cov0" title="0">{
                        actualBodyKey := v.BodyKey
                        if varsystem.CheckIsVar(v.BodyKey) </span><span class="cov0" title="0">{
                                key := varsystem.GetVarKeyFromRaw(v.BodyKey)
                                if val, ok := tracker.Get(key); ok </span><span class="cov0" title="0">{
                                        actualBodyKey = val.Value
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, connect.NewError(connect.CodeNotFound, fmt.Errorf("%s named error not found", key))
                                }</span>
                        }

                        // First check if this value contains file references (before variable replacement)
                        <span class="cov0" title="0">filePathsToUpload := []string{}
                        potentialFileRefs := strings.Split(v.Value, ",")
                        allAreFileReferences := true

                        for _, ref := range potentialFileRefs </span><span class="cov0" title="0">{
                                trimmedRef := strings.TrimSpace(ref)
                                // Check if this is a variable containing a file reference
                                if varsystem.CheckIsVar(trimmedRef) </span><span class="cov0" title="0">{
                                        key := varsystem.GetVarKeyFromRaw(trimmedRef)
                                        if varsystem.IsFileReference(key) </span><span class="cov0" title="0">{
                                                // This is {{#file:path}} format
                                                filePathsToUpload = append(filePathsToUpload, varsystem.GetIsFileReferencePath(key))
                                                // Track the file reference read
                                                tracker.ReadVars[key], _ = varsystem.ReadFileContentAsString(key)
                                        }</span> else<span class="cov0" title="0"> {
                                                // This is a regular variable, try to resolve it
                                                if val, ok := tracker.Get(key); ok </span><span class="cov0" title="0">{
                                                        if varsystem.IsFileReference(val.Value) </span><span class="cov0" title="0">{
                                                                filePathsToUpload = append(filePathsToUpload, varsystem.GetIsFileReferencePath(val.Value))
                                                        }</span> else<span class="cov0" title="0"> {
                                                                allAreFileReferences = false
                                                                break</span>
                                                        }
                                                } else<span class="cov0" title="0"> {
                                                        allAreFileReferences = false
                                                        break</span>
                                                }
                                        }
                                } else<span class="cov0" title="0"> if varsystem.IsFileReference(trimmedRef) </span><span class="cov0" title="0">{
                                        // This is direct #file:path format
                                        filePathsToUpload = append(filePathsToUpload, varsystem.GetIsFileReferencePath(trimmedRef))
                                        // Track the file reference read
                                        tracker.ReadVars[trimmedRef], _ = varsystem.ReadFileContentAsString(trimmedRef)
                                }</span> else<span class="cov0" title="0"> {
                                        allAreFileReferences = false
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">resolvedValue := v.Value
                        if !allAreFileReferences &amp;&amp; varsystem.CheckStringHasAnyVarKey(v.Value) </span><span class="cov0" title="0">{
                                // Only replace variables if this is not a file reference
                                var err error
                                resolvedValue, err = tracker.ReplaceVars(v.Value)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, connect.NewError(connect.CodeNotFound, err)
                                }</span>
                        }

                        <span class="cov0" title="0">if allAreFileReferences &amp;&amp; len(filePathsToUpload) &gt; 0 </span><span class="cov0" title="0">{
                                // This is a file upload (single or multiple)
                                for _, filePath := range filePathsToUpload </span><span class="cov0" title="0">{
                                        fileContentBytes, err := os.ReadFile(filePath)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to read file %s: %w", filePath, err))
                                        }</span>

                                        <span class="cov0" title="0">fileName := filepath.Base(filePath)

                                        h := make(textproto.MIMEHeader)
                                        h.Set("Content-Disposition",
                                                fmt.Sprintf(`form-data; name="%s"; filename="%s"`,
                                                        escapeQuotes(actualBodyKey), escapeQuotes(fileName)))

                                        mimeType := mime.TypeByExtension(filepath.Ext(fileName))
                                        if mimeType == "" </span><span class="cov0" title="0">{
                                                mimeType = "application/octet-stream"
                                        }</span>
                                        <span class="cov0" title="0">h.Set("Content-Type", mimeType)

                                        partWriter, err := writer.CreatePart(h)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to create form part: %w", err))
                                        }</span>

                                        <span class="cov0" title="0">if _, err = partWriter.Write(fileContentBytes); err != nil </span><span class="cov0" title="0">{
                                                return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to write file content: %w", err))
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                // This is a regular text field
                                if err := writer.WriteField(actualBodyKey, resolvedValue); err != nil </span><span class="cov0" title="0">{
                                        return nil, connect.NewError(connect.CodeInternal, err)
                                }</span>
                        }
                }
                <span class="cov0" title="0">if err := writer.Close(); err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, fmt.Errorf("failed to close multipart writer: %w", err))
                }</span>
        case mitemapiexample.BodyTypeUrlencoded:<span class="cov0" title="0">
                urlVal := url.Values{}
                for _, url := range urlBody </span><span class="cov0" title="0">{
                        if varsystem.CheckIsVar(url.BodyKey) </span><span class="cov0" title="0">{
                                key := varsystem.GetVarKeyFromRaw(url.Value)
                                if val, ok := tracker.Get(key); ok </span><span class="cov0" title="0">{
                                        url.BodyKey = val.Value
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, connect.NewError(connect.CodeNotFound, fmt.Errorf("%s named error not found", key))
                                }</span>
                        }
                        <span class="cov0" title="0">if varsystem.CheckIsVar(url.Value) </span><span class="cov0" title="0">{
                                key := varsystem.GetVarKeyFromRaw(url.Value)
                                if val, ok := tracker.Get(key); ok </span><span class="cov0" title="0">{
                                        url.Value = val.Value
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, connect.NewError(connect.CodeNotFound, fmt.Errorf("%s named error not found", key))
                                }</span>
                        }

                        <span class="cov0" title="0">urlVal.Add(url.BodyKey, url.Value)</span>
                }
                <span class="cov0" title="0">endpoint.Url += urlVal.Encode()</span>
        }

        <span class="cov8" title="1">if compressType != compress.CompressTypeNone </span><span class="cov0" title="0">{
                compressedData, err := compress.Compress(bodyBytes.Bytes(), compressType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, connect.NewError(connect.CodeInternal, err)
                }</span>
                <span class="cov0" title="0">bodyBytes = bytes.NewBuffer(compressedData)</span>
        }

        <span class="cov8" title="1">httpReq := &amp;httpclient.Request{
                Method:  endpoint.Method,
                URL:     endpoint.Url,
                Headers: headers,
                Queries: queries,
                Body:    bodyBytes.Bytes(),
        }

        return &amp;PrepareRequestResult{
                Request:  httpReq,
                ReadVars: tracker.GetReadVars(),
        }, nil</span>
}

func SendRequest(req *httpclient.Request, exampleID idwrap.IDWrap, client httpclient.HttpClient) (*RequestResponse, error) <span class="cov0" title="0">{
        now := time.Now()
        respHttp, err := httpclient.SendRequestAndConvert(client, req, exampleID)
        lapse := time.Since(now)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeAborted, err)
        }</span>

        <span class="cov0" title="0">return &amp;RequestResponse{HttpResp: respHttp, LapTime: lapse}, nil</span>
}

func SendRequestWithContext(ctx context.Context, req *httpclient.Request, exampleID idwrap.IDWrap, client httpclient.HttpClient) (*RequestResponse, error) <span class="cov0" title="0">{
        now := time.Now()
        respHttp, err := httpclient.SendRequestAndConvertWithContext(ctx, client, req, exampleID)
        lapse := time.Since(now)
        if err != nil </span><span class="cov0" title="0">{
                return nil, connect.NewError(connect.CodeAborted, err)
        }</span>

        <span class="cov0" title="0">return &amp;RequestResponse{HttpResp: respHttp, LapTime: lapse}, nil</span>
}

type MergeExamplesInput struct {
        Base, Delta               mitemapiexample.ItemApiExample
        BaseQueries, DeltaQueries []mexamplequery.Query
        BaseHeaders, DeltaHeaders []mexampleheader.Header

        // Bodies
        BaseRawBody, DeltaRawBody               mbodyraw.ExampleBodyRaw
        BaseFormBody, DeltaFormBody             []mbodyform.BodyForm
        BaseUrlEncodedBody, DeltaUrlEncodedBody []mbodyurl.BodyURLEncoded
}

type MergeExamplesOutput struct {
        Merged              mitemapiexample.ItemApiExample
        MergeQueries        []mexamplequery.Query
        MergeHeaders        []mexampleheader.Header
        MergeRawBody        mbodyraw.ExampleBodyRaw
        MergeFormBody       []mbodyform.BodyForm
        MergeUrlEncodedBody []mbodyurl.BodyURLEncoded
}

// Function will merge two examples
// but ID will be the same as the base example
func MergeExamples(input MergeExamplesInput) MergeExamplesOutput <span class="cov8" title="1">{
        output := MergeExamplesOutput{}
        if input.Base.ID == input.Delta.ID </span><span class="cov0" title="0">{
                output.Merged = input.Base
        }</span> else<span class="cov8" title="1"> {
                output.Merged = input.Delta
                output.Merged.ID = input.Base.ID
                // INFO: seems like FE update base example insteed of delta for bodytype
                output.Merged.BodyType = input.Base.BodyType
        }</span>

        // Query
        <span class="cov8" title="1">queryMap := make(map[idwrap.IDWrap]mexamplequery.Query, len(input.BaseQueries))
        for _, q := range input.BaseQueries </span><span class="cov8" title="1">{
                queryMap[q.ID] = q
        }</span>

        // Create a map for matching base queries by key name (for legacy delta queries)
        <span class="cov8" title="1">baseQueryByKey := make(map[string]mexamplequery.Query)
        for _, q := range input.BaseQueries </span><span class="cov8" title="1">{
                baseQueryByKey[q.QueryKey] = q
        }</span>

        <span class="cov8" title="1">for _, q := range input.DeltaQueries </span><span class="cov8" title="1">{
                // Handle legacy delta queries that don't have DeltaParentID set
                if q.DeltaParentID != nil </span><span class="cov8" title="1">{
                        queryMap[*q.DeltaParentID] = q
                }</span> else<span class="cov8" title="1"> {
                        // For legacy delta queries without parent ID, try to find matching base query by key name
                        if baseQuery, exists := baseQueryByKey[q.QueryKey]; exists </span><span class="cov8" title="1">{
                                queryMap[baseQuery.ID] = q
                        }</span> else<span class="cov0" title="0"> {
                                // If no matching base query found, add as new query
                                queryMap[q.ID] = q
                        }</span>
                }
        }

        <span class="cov8" title="1">output.MergeQueries = make([]mexamplequery.Query, 0, len(queryMap))
        for _, q := range queryMap </span><span class="cov8" title="1">{
                output.MergeQueries = append(output.MergeQueries, q)
        }</span>

        // Header
        <span class="cov8" title="1">headerMap := make(map[idwrap.IDWrap]mexampleheader.Header, len(input.BaseHeaders))
        for _, h := range input.BaseHeaders </span><span class="cov8" title="1">{
                headerMap[h.ID] = h
        }</span>

        // Create a map for matching base headers by key name (for legacy delta headers)
        <span class="cov8" title="1">baseHeaderByKey := make(map[string]mexampleheader.Header)
        for _, h := range input.BaseHeaders </span><span class="cov8" title="1">{
                baseHeaderByKey[h.HeaderKey] = h
        }</span>

        <span class="cov8" title="1">for _, h := range input.DeltaHeaders </span><span class="cov8" title="1">{
                // Handle legacy delta headers that don't have DeltaParentID set
                if h.DeltaParentID != nil </span><span class="cov8" title="1">{
                        headerMap[*h.DeltaParentID] = h
                }</span> else<span class="cov8" title="1"> {
                        // For legacy delta headers without parent ID, try to find matching base header by key name
                        if baseHeader, exists := baseHeaderByKey[h.HeaderKey]; exists </span><span class="cov8" title="1">{
                                headerMap[baseHeader.ID] = h
                        }</span> else<span class="cov0" title="0"> {
                                // If no matching base header found, add as new header
                                headerMap[h.ID] = h
                        }</span>
                }
        }

        <span class="cov8" title="1">output.MergeHeaders = make([]mexampleheader.Header, 0, len(headerMap))
        for _, h := range headerMap </span><span class="cov8" title="1">{
                output.MergeHeaders = append(output.MergeHeaders, h)
        }</span>

        // Raw Body
        <span class="cov8" title="1">if len(input.DeltaRawBody.Data) &gt; 0 </span><span class="cov8" title="1">{
                output.MergeRawBody = input.DeltaRawBody
        }</span> else<span class="cov0" title="0"> {
                output.MergeRawBody = input.BaseRawBody
        }</span>

        // Form Body
        <span class="cov8" title="1">formMap := make(map[idwrap.IDWrap]mbodyform.BodyForm, len(input.BaseFormBody))
        for _, f := range input.BaseFormBody </span><span class="cov0" title="0">{
                formMap[f.ID] = f
        }</span>

        <span class="cov8" title="1">for _, f := range input.DeltaFormBody </span><span class="cov0" title="0">{
                formMap[f.ID] = f
        }</span>

        <span class="cov8" title="1">output.MergeFormBody = make([]mbodyform.BodyForm, 0, len(formMap))
        for _, f := range formMap </span><span class="cov0" title="0">{
                output.MergeFormBody = append(output.MergeFormBody, f)
        }</span>

        // Url Encoded Body
        <span class="cov8" title="1">urlEncodedMap := make(map[idwrap.IDWrap]mbodyurl.BodyURLEncoded, len(input.BaseUrlEncodedBody))
        for _, f := range input.BaseUrlEncodedBody </span><span class="cov0" title="0">{
                urlEncodedMap[f.ID] = f
        }</span>

        <span class="cov8" title="1">for _, f := range input.DeltaUrlEncodedBody </span><span class="cov0" title="0">{
                urlEncodedMap[f.ID] = f
        }</span>

        <span class="cov8" title="1">output.MergeUrlEncodedBody = make([]mbodyurl.BodyURLEncoded, 0, len(urlEncodedMap))
        for _, f := range urlEncodedMap </span><span class="cov0" title="0">{
                output.MergeUrlEncodedBody = append(output.MergeUrlEncodedBody, f)
        }</span>

        <span class="cov8" title="1">return output</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package response

import (
        "context"
        "fmt"
        "strings"
        "the-dev-tools/server/pkg/expression"
        "the-dev-tools/server/pkg/http/request"
        "the-dev-tools/server/pkg/httpclient"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/massert"
        "the-dev-tools/server/pkg/model/massertres"
        "the-dev-tools/server/pkg/model/mexampleresp"
        "the-dev-tools/server/pkg/model/mexamplerespheader"
        "the-dev-tools/server/pkg/varsystem"
        "the-dev-tools/server/pkg/zstdcompress"

        "connectrpc.com/connect"
)

type ResponseCreateOutput struct {
        BodyRaw     []byte
        ExampleResp mexampleresp.ExampleResp

        AssertCouples []AssertCouple

        // new headers
        CreateHeaders, UpdateHeaders []mexamplerespheader.ExampleRespHeader
        DeleteHeaderIds              []idwrap.IDWrap
}

type AssertCouple struct {
        Assert    massert.Assert
        AssertRes massertres.AssertResult
}

func ResponseCreate(ctx context.Context, r request.RequestResponse, exampleResp mexampleresp.ExampleResp, lastResonseHeaders []mexamplerespheader.ExampleRespHeader, assertions []massert.Assert, varMap varsystem.VarMap) (*ResponseCreateOutput, error) <span class="cov0" title="0">{
        ResponseCreateOutput := ResponseCreateOutput{}
        respHttp := r.HttpResp
        lapse := r.LapTime
        ResponseCreateOutput.BodyRaw = respHttp.Body
        bodyData := respHttp.Body

        exampleResp.BodyCompressType = mexampleresp.BodyCompressTypeNone

        if len(bodyData) &gt; 1024 </span><span class="cov0" title="0">{
                bodyDataTemp := zstdcompress.Compress(bodyData)
                if len(bodyDataTemp) &lt; len(bodyData) </span><span class="cov0" title="0">{
                        exampleResp.BodyCompressType = mexampleresp.BodyCompressTypeZstd
                        bodyData = bodyDataTemp
                }</span>
        }

        <span class="cov0" title="0">exampleResp.Body = bodyData
        exampleResp.Duration = int32(lapse.Milliseconds())
        exampleResp.Status = uint16(respHttp.StatusCode)

        ResponseCreateOutput.ExampleResp = exampleResp

        taskCreateHeaders := make([]mexamplerespheader.ExampleRespHeader, 0)
        taskUpdateHeaders := make([]mexamplerespheader.ExampleRespHeader, 0)
        taskDeleteHeaders := make([]idwrap.IDWrap, 0)

        // Create a map for quick lookup of current headers by key
        headerMap := make(map[string]mexamplerespheader.ExampleRespHeader, len(lastResonseHeaders))
        headerProcessed := make(map[string]struct{}, len(lastResonseHeaders))

        for _, header := range lastResonseHeaders </span><span class="cov0" title="0">{
                headerMap[header.HeaderKey] = header
        }</span>

        <span class="cov0" title="0">for _, respHeader := range respHttp.Headers </span><span class="cov0" title="0">{
                dbHeader, found := headerMap[respHeader.HeaderKey]
                headerProcessed[respHeader.HeaderKey] = struct{}{}

                if found </span><span class="cov0" title="0">{
                        // Update existing header if values differ
                        if dbHeader.Value != respHeader.Value </span><span class="cov0" title="0">{
                                dbHeader.Value = respHeader.Value
                                taskUpdateHeaders = append(taskUpdateHeaders, dbHeader)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Create new header if not found
                        taskCreateHeaders = append(taskCreateHeaders, mexamplerespheader.ExampleRespHeader{
                                ID:            idwrap.NewNow(),
                                ExampleRespID: exampleResp.ID,
                                HeaderKey:     respHeader.HeaderKey,
                                Value:         respHeader.Value,
                        })
                }</span>
        }

        <span class="cov0" title="0">for _, header := range lastResonseHeaders </span><span class="cov0" title="0">{
                _, ok := headerProcessed[header.HeaderKey]
                if !ok </span><span class="cov0" title="0">{
                        taskDeleteHeaders = append(taskDeleteHeaders, header.ID)
                }</span>
        }

        <span class="cov0" title="0">ResponseCreateOutput.CreateHeaders = taskCreateHeaders
        ResponseCreateOutput.UpdateHeaders = taskUpdateHeaders
        ResponseCreateOutput.DeleteHeaderIds = taskDeleteHeaders

        var resultArr []AssertCouple
        // TODO: move to proper package
        responseVar := httpclient.ConvertResponseToVar(respHttp)

        // Create environment manually to ensure proper structure
        envMap := map[string]any{
                "response": map[string]any{
                        "status":   responseVar.StatusCode,
                        "body":     responseVar.Body,
                        "headers":  responseVar.Headers,
                        "duration": responseVar.Duration,
                },
        }
        mergedVarMap := varsystem.MergeVarMap(varMap, varsystem.NewVarMapFromAnyMap(envMap))
        exprEnv := expression.NewEnv(envMap)

        for _, assertion := range assertions </span><span class="cov0" title="0">{
                if assertion.Enable </span><span class="cov0" title="0">{
                        // Use NormalizeExpression if {{ }} wrapper is found
                        expr := assertion.Condition.Comparisons.Expression
                        var err error
                        if strings.Contains(expr, "{{") &amp;&amp; strings.Contains(expr, "}}") </span><span class="cov0" title="0">{
                                fmt.Println("expr", expr)
                                fmt.Println("varMap", varMap)
                                expr, err = expression.NormalizeExpression(ctx, expr, mergedVarMap)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }

                        <span class="cov0" title="0">ok, err := expression.ExpressionEvaluteAsBool(ctx, exprEnv, expr)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, connect.NewError(connect.CodeInternal, err)
                        }</span>
                        <span class="cov0" title="0">res := massertres.AssertResult{
                                ID:         idwrap.NewNow(),
                                ResponseID: exampleResp.ID,
                                AssertID:   assertion.ID,
                                Result:     ok,
                        }

                        resultArr = append(resultArr, AssertCouple{
                                Assert:    assertion,
                                AssertRes: res,
                        })</span>

                }
        }

        <span class="cov0" title="0">ResponseCreateOutput.AssertCouples = resultArr

        return &amp;ResponseCreateOutput, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package httpclient

import (
        "bytes"
        "context"
        "encoding/json"
        "io"
        "net/http"
        "net/url"
        "the-dev-tools/server/pkg/compress"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mexampleheader"
        "the-dev-tools/server/pkg/model/mexamplequery"
        "the-dev-tools/server/pkg/model/mexamplerespheader"
        "time"
)

type HttpClient interface {
        Do(req *http.Request) (*http.Response, error)
}

const TimeoutRequest = 60 * time.Second

func New() HttpClient <span class="cov0" title="0">{
        return &amp;http.Client{
                Timeout: TimeoutRequest,
        }
}</span>

type Request struct {
        Method  string
        URL     string
        Queries []mexamplequery.Query
        Headers []mexampleheader.Header
        Body    []byte
}

type Response struct {
        StatusCode int                                    `json:"statusCode"`
        Body       []byte                                 `json:"body"`
        Headers    []mexamplerespheader.ExampleRespHeader `json:"headers"`
}

type ResponseVar struct {
        StatusCode int               `json:"status"`
        Body       any               `json:"body"`
        Headers    map[string]string `json:"headers"`
        Duration   int32             `json:"duration"`
}

func ConvertResponseToVar(r Response) ResponseVar <span class="cov8" title="1">{
        headersMaps := make(map[string]string)
        for _, header := range r.Headers </span><span class="cov8" title="1">{
                headersMaps[header.HeaderKey] = header.Value
        }</span>

        // check if body seems like json; if so decode it into a map[string]interface{}, otherwise use a string.
        <span class="cov8" title="1">var body any
        if json.Valid(r.Body) </span><span class="cov8" title="1">{
                var jsonBody any
                // If unmarshaling works, use the decoded JSON.
                if err := json.Unmarshal(r.Body, &amp;jsonBody); err == nil </span><span class="cov8" title="1">{
                        body = jsonBody
                }</span> else<span class="cov0" title="0"> {
                        body = string(r.Body)
                }</span>
        } else<span class="cov8" title="1"> {
                body = string(r.Body)
        }</span>

        <span class="cov8" title="1">return ResponseVar{
                StatusCode: r.StatusCode,
                Body:       body,
                Headers:    headersMaps,
        }</span>
}

func SendRequest(client HttpClient, req *Request) (*http.Response, error) <span class="cov0" title="0">{
        reqRaw, err := http.NewRequest(req.Method, req.URL, bytes.NewReader(req.Body))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">qNew := ConvertModelToQuery(req.Queries, reqRaw.URL.Query())
        reqRaw.URL.RawQuery = qNew.Encode()
        reqRaw.Header = ConvertModelToHeader(req.Headers)
        return client.Do(reqRaw)</span>
}

func SendRequestWithContext(ctx context.Context, client HttpClient, req *Request) (*http.Response, error) <span class="cov0" title="0">{
        reqRaw, err := http.NewRequestWithContext(ctx, req.Method, req.URL, bytes.NewReader(req.Body))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">qNew := ConvertModelToQuery(req.Queries, reqRaw.URL.Query())
        reqRaw.URL.RawQuery = qNew.Encode()
        reqRaw.Header = ConvertModelToHeader(req.Headers)
        return client.Do(reqRaw)</span>
}

func SendRequestAndConvert(client HttpClient, req *Request, exampleID idwrap.IDWrap) (Response, error) <span class="cov0" title="0">{
        resp, err := SendRequest(client, req)
        if err != nil </span><span class="cov0" title="0">{
                return Response{}, err
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return Response{}, err
        }</span>

        <span class="cov0" title="0">encoding := resp.Header.Get("Content-Encoding")
        if encoding != "" </span><span class="cov0" title="0">{
                body, err = compress.DecompressWithContentEncodeStr(body, encoding)
                if err != nil </span><span class="cov0" title="0">{
                        return Response{}, err
                }</span>
        }

        <span class="cov0" title="0">err = resp.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return Response{}, err
        }</span>
        <span class="cov0" title="0">return Response{
                StatusCode: resp.StatusCode,
                Body:       body,
                Headers:    ConvertHeaderToModel(resp.Header, exampleID),
        }, nil</span>
}

func SendRequestAndConvertWithContext(ctx context.Context, client HttpClient, req *Request, exampleID idwrap.IDWrap) (Response, error) <span class="cov0" title="0">{
        resp, err := SendRequestWithContext(ctx, client, req)
        if err != nil </span><span class="cov0" title="0">{
                return Response{}, err
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return Response{}, err
        }</span>

        <span class="cov0" title="0">encoding := resp.Header.Get("Content-Encoding")
        if encoding != "" </span><span class="cov0" title="0">{
                body, err = compress.DecompressWithContentEncodeStr(body, encoding)
                if err != nil </span><span class="cov0" title="0">{
                        return Response{}, err
                }</span>
        }

        <span class="cov0" title="0">err = resp.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return Response{}, err
        }</span>
        <span class="cov0" title="0">return Response{
                StatusCode: resp.StatusCode,
                Body:       body,
                Headers:    ConvertHeaderToModel(resp.Header, exampleID),
        }, nil</span>
}

func ConvertHeaderToModel(headers http.Header, exampleID idwrap.IDWrap) []mexamplerespheader.ExampleRespHeader <span class="cov0" title="0">{
        result := make([]mexamplerespheader.ExampleRespHeader, 0, len(headers))
        for key, values := range headers </span><span class="cov0" title="0">{
                for _, value := range values </span><span class="cov0" title="0">{
                        result = append(result, mexamplerespheader.ExampleRespHeader{
                                ExampleRespID: exampleID,
                                HeaderKey:     key,
                                Value:         value,
                        })
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func ConvertQueryToModel(query map[string][]string, exampleID idwrap.IDWrap) []mexamplequery.Query <span class="cov0" title="0">{
        var result []mexamplequery.Query
        for key, values := range query </span><span class="cov0" title="0">{
                for _, value := range values </span><span class="cov0" title="0">{
                        result = append(result, mexamplequery.Query{
                                ExampleID: exampleID,
                                QueryKey:  key,
                                Value:     value,
                        })
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func ConvertModelToHeader(headers []mexampleheader.Header) http.Header <span class="cov0" title="0">{
        result := make(http.Header)
        for _, header := range headers </span><span class="cov0" title="0">{
                result.Add(header.HeaderKey, header.Value)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func ConvertModelToQuery(queries []mexamplequery.Query, url url.Values) url.Values <span class="cov0" title="0">{
        for _, query := range queries </span><span class="cov0" title="0">{
                url.Add(query.QueryKey, query.Value)
        }</span>
        <span class="cov0" title="0">return url</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package httpmockclient

import "net/http"

type MockHttpClient struct {
        ReturnResponse *http.Response
}

func NewMockHttpClient(returnResponse *http.Response) *MockHttpClient <span class="cov0" title="0">{
        return &amp;MockHttpClient{
                ReturnResponse: returnResponse,
        }
}</span>

func (m *MockHttpClient) Do(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        return m.ReturnResponse, nil
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package idwrap

import (
        "database/sql/driver"
        "time"

        "github.com/oklog/ulid/v2"
)

type IDWrap struct {
        ulid ulid.ULID `yaml:"binary_data"`
}

func New(ulid ulid.ULID) IDWrap <span class="cov0" title="0">{
        return IDWrap{ulid: ulid}
}</span>

func NewNow() IDWrap <span class="cov8" title="1">{
        return IDWrap{ulid: ulid.Make()}
}</span>

// MarshalYAML implements the yaml.Marshaler interface.
func (id IDWrap) MarshalYAML() (interface{}, error) <span class="cov0" title="0">{
        return id.ulid.String(), nil
}</span>

// UnmarshalYAML implements the yaml.Unmarshaler interface.
func (id *IDWrap) UnmarshalYAML(unmarshal func(interface{}) error) error <span class="cov0" title="0">{
        var value string
        if err := unmarshal(&amp;value); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">parsed, err := ulid.Parse(value)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">id.ulid = parsed
        return nil</span>
}

func NewText(ulidString string) (IDWrap, error) <span class="cov0" title="0">{
        ulid, err := ulid.Parse(ulidString)
        if err != nil </span><span class="cov0" title="0">{
                return IDWrap{}, err
        }</span>
        <span class="cov0" title="0">return IDWrap{ulid: ulid}, nil</span>
}

func NewTextMust(ulidString string) IDWrap <span class="cov0" title="0">{
        ulid, err := ulid.Parse(ulidString)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return IDWrap{ulid: ulid}</span>
}

func NewFromBytes(data []byte) (IDWrap, error) <span class="cov8" title="1">{
        ulidData := ulid.ULID{}
        err := ulidData.UnmarshalBinary(data)
        return IDWrap{ulid: ulidData}, err
}</span>

func NewFromBytesMust(data []byte) IDWrap <span class="cov0" title="0">{
        ulidData := ulid.ULID{}
        err := ulidData.UnmarshalBinary(data)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return IDWrap{ulid: ulidData}</span>
}

func (u IDWrap) String() string <span class="cov0" title="0">{
        return u.ulid.String()
}</span>

func (u IDWrap) GetUlid() ulid.ULID <span class="cov0" title="0">{
        return u.ulid
}</span>

func (u IDWrap) Bytes() []byte <span class="cov0" title="0">{
        return u.ulid[:]
}</span>

func (u IDWrap) Compare(id IDWrap) int <span class="cov8" title="1">{
        return u.ulid.Compare(id.ulid)
}</span>

func (u IDWrap) Time() time.Time <span class="cov0" title="0">{
        return GetTimeFromULID(u)
}</span>

// SQL driver value
func (u IDWrap) Value() (driver.Value, error) <span class="cov8" title="1">{
        return u.ulid.Value()
}</span>

func (u *IDWrap) Scan(value interface{}) error <span class="cov8" title="1">{
        return u.ulid.UnmarshalBinary(value.([]byte))
}</span>

func GetTimeFromULID(idwrap IDWrap) time.Time <span class="cov0" title="0">{
        // Get the time from the ULID
        return time.UnixMilli(int64(idwrap.ulid.Time()))
}</span>

func GetUnixMilliFromULID(idwrap IDWrap) int64 <span class="cov0" title="0">{
        return int64(idwrap.ulid.Time())
}</span>

func GetUlid(Ulid IDWrap) ulid.ULID <span class="cov0" title="0">{
        return Ulid.ulid
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package yamlflowsimple

import (
        "encoding/json"
        "fmt"
        "gopkg.in/yaml.v3"
        "sort"
        "the-dev-tools/server/pkg/flow/edge"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/ioworkspace"
        "the-dev-tools/server/pkg/model/mflow"
        "the-dev-tools/server/pkg/model/mitemapi"
        "the-dev-tools/server/pkg/model/mnnode"
        "the-dev-tools/server/pkg/model/mnnode/mnfor"
        "the-dev-tools/server/pkg/model/mnnode/mnforeach"
        "the-dev-tools/server/pkg/model/mnnode/mnif"
        "the-dev-tools/server/pkg/model/mnnode/mnjs"
        "the-dev-tools/server/pkg/model/mnnode/mnnoop"
        "the-dev-tools/server/pkg/model/mnnode/mnrequest"
)

// ExportYamlFlowYAML converts ioworkspace.WorkspaceData to simplified yamlflow YAML
func ExportYamlFlowYAML(workspaceData *ioworkspace.WorkspaceData) ([]byte, error) <span class="cov8" title="1">{
        if workspaceData == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("workspace data cannot be nil")
        }</span>

        <span class="cov8" title="1">if len(workspaceData.Flows) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no flows to export")
        }</span>

        // Build request definitions from all endpoints across all flows
        <span class="cov8" title="1">requests := buildRequestDefinitions(workspaceData)

        // Build flows
        flows := []map[string]any{}
        for _, flow := range workspaceData.Flows </span><span class="cov8" title="1">{
                flowData := exportFlow(flow, workspaceData, requests)
                if flowData != nil </span><span class="cov8" title="1">{
                        flows = append(flows, flowData)
                }</span>
        }

        // Build final YAML structure using ordered approach
        <span class="cov8" title="1">var doc yaml.Node
        doc.Kind = yaml.DocumentNode

        var root yaml.Node
        root.Kind = yaml.MappingNode

        // Add workspace_name
        root.Content = append(root.Content,
                &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "workspace_name"},
                &amp;yaml.Node{Kind: yaml.ScalarNode, Value: workspaceData.Workspace.Name})

        // Add run field with all exported flows
        runEntries := buildRunEntries(workspaceData)
        if len(runEntries) &gt; 0 </span><span class="cov8" title="1">{
                var runNode yaml.Node
                runNode.Kind = yaml.SequenceNode
                for _, entry := range runEntries </span><span class="cov8" title="1">{
                        runNode.Content = append(runNode.Content, createRunEntryNode(entry))
                }</span>
                <span class="cov8" title="1">root.Content = append(root.Content,
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "run"},
                        &amp;runNode)</span>
        }

        // Add requests section if not empty
        <span class="cov8" title="1">if len(requests) &gt; 0 </span><span class="cov8" title="1">{
                requestList := make([]map[string]any, 0, len(requests))
                for _, req := range requests </span><span class="cov8" title="1">{
                        requestList = append(requestList, req)
                }</span>
                // Sort by name for consistent output
                <span class="cov8" title="1">sort.Slice(requestList, func(i, j int) bool </span><span class="cov8" title="1">{
                        nameI, _ := requestList[i]["name"].(string)
                        nameJ, _ := requestList[j]["name"].(string)
                        return nameI &lt; nameJ
                }</span>)

                // Create requests array node
                <span class="cov8" title="1">var requestsNode yaml.Node
                requestsNode.Kind = yaml.SequenceNode
                for _, req := range requestList </span><span class="cov8" title="1">{
                        requestsNode.Content = append(requestsNode.Content, createOrderedRequestNode(req))
                }</span>

                <span class="cov8" title="1">root.Content = append(root.Content,
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "requests"},
                        &amp;requestsNode)</span>
        }

        // Add flows
        <span class="cov8" title="1">var flowsNode yaml.Node
        flowsNode.Kind = yaml.SequenceNode
        for _, flow := range flows </span><span class="cov8" title="1">{
                flowsNode.Content = append(flowsNode.Content, createOrderedFlowNode(flow))
        }</span>
        <span class="cov8" title="1">root.Content = append(root.Content,
                &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "flows"},
                &amp;flowsNode)

        doc.Content = append(doc.Content, &amp;root)
        return yaml.Marshal(&amp;doc)</span>
}

// createOrderedRequestNode creates a YAML node with fields in the desired order
func createOrderedRequestNode(req map[string]any) *yaml.Node <span class="cov8" title="1">{
        node := &amp;yaml.Node{Kind: yaml.MappingNode}

        // Add fields in desired order: name first
        if name, ok := req["name"]; ok </span><span class="cov8" title="1">{
                node.Content = append(node.Content,
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "name"},
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: fmt.Sprintf("%v", name)})
        }</span>

        // Then method
        <span class="cov8" title="1">if method, ok := req["method"]; ok </span><span class="cov8" title="1">{
                node.Content = append(node.Content,
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "method"},
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: fmt.Sprintf("%v", method)})
        }</span>

        // Then url
        <span class="cov8" title="1">if url, ok := req["url"]; ok </span><span class="cov8" title="1">{
                node.Content = append(node.Content,
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "url"},
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: fmt.Sprintf("%v", url)})
        }</span>

        // Then headers
        <span class="cov8" title="1">if headers, ok := req["headers"]; ok </span><span class="cov8" title="1">{
                node.Content = append(node.Content,
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "headers"},
                        createMapNode(headers))
        }</span>

        // Then query_params
        <span class="cov8" title="1">if queryParams, ok := req["query_params"]; ok </span><span class="cov8" title="1">{
                node.Content = append(node.Content,
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "query_params"},
                        createMapNode(queryParams))
        }</span>

        // Finally body
        <span class="cov8" title="1">if body, ok := req["body"]; ok </span><span class="cov8" title="1">{
                node.Content = append(node.Content,
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "body"},
                        createAnyNode(body))
        }</span>

        <span class="cov8" title="1">return node</span>
}

// createOrderedFlowNode creates a YAML node for flow with proper field ordering
func createOrderedFlowNode(flow map[string]any) *yaml.Node <span class="cov8" title="1">{
        node := &amp;yaml.Node{Kind: yaml.MappingNode}

        // Add name first
        if name, ok := flow["name"]; ok </span><span class="cov8" title="1">{
                node.Content = append(node.Content,
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "name"},
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: fmt.Sprintf("%v", name)})
        }</span>

        // Then variables
        <span class="cov8" title="1">if variables, ok := flow["variables"]; ok </span><span class="cov8" title="1">{
                node.Content = append(node.Content,
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "variables"},
                        createAnyNode(variables))
        }</span>

        // Then steps
        <span class="cov8" title="1">if steps, ok := flow["steps"]; ok </span><span class="cov8" title="1">{
                node.Content = append(node.Content,
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "steps"},
                        createStepsNode(steps))
        }</span>

        <span class="cov8" title="1">return node</span>
}

// createStepsNode creates ordered step nodes
func createStepsNode(steps any) *yaml.Node <span class="cov8" title="1">{
        stepsSlice, ok := steps.([]map[string]any)
        if !ok </span><span class="cov0" title="0">{
                return createAnyNode(steps)
        }</span>

        <span class="cov8" title="1">node := &amp;yaml.Node{Kind: yaml.SequenceNode}
        for _, step := range stepsSlice </span><span class="cov8" title="1">{
                node.Content = append(node.Content, createOrderedStepNode(step))
        }</span>
        <span class="cov8" title="1">return node</span>
}

// createOrderedStepNode creates a step node with proper ordering
func createOrderedStepNode(step map[string]any) *yaml.Node <span class="cov8" title="1">{
        node := &amp;yaml.Node{Kind: yaml.MappingNode}

        // Handle different step types
        for stepType, stepData := range step </span><span class="cov8" title="1">{
                node.Content = append(node.Content,
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: stepType},
                        createOrderedStepDataNode(stepData))
        }</span>

        <span class="cov8" title="1">return node</span>
}

// createOrderedStepDataNode creates step data with name first
func createOrderedStepDataNode(data any) *yaml.Node <span class="cov8" title="1">{
        dataMap, ok := data.(map[string]any)
        if !ok </span><span class="cov0" title="0">{
                return createAnyNode(data)
        }</span>

        <span class="cov8" title="1">node := &amp;yaml.Node{Kind: yaml.MappingNode}

        // Add name first
        if name, ok := dataMap["name"]; ok </span><span class="cov8" title="1">{
                node.Content = append(node.Content,
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "name"},
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: fmt.Sprintf("%v", name)})
        }</span>

        // Then add other fields in a logical order
        <span class="cov8" title="1">fieldOrder := []string{"use_request", "method", "url", "headers", "query_params", "body",
                "condition", "code", "iter_count", "items", "then", "else", "loop", "depends_on"}

        for _, field := range fieldOrder </span><span class="cov8" title="1">{
                if val, ok := dataMap[field]; ok </span><span class="cov8" title="1">{
                        node.Content = append(node.Content,
                                &amp;yaml.Node{Kind: yaml.ScalarNode, Value: field},
                                createAnyNode(val))
                }</span>
        }

        // Add any remaining fields not in our order list
        <span class="cov8" title="1">for key, val := range dataMap </span><span class="cov8" title="1">{
                if key == "name" </span><span class="cov8" title="1">{
                        continue</span> // Already added
                }
                <span class="cov8" title="1">found := false
                for _, field := range fieldOrder </span><span class="cov8" title="1">{
                        if key == field </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        node.Content = append(node.Content,
                                &amp;yaml.Node{Kind: yaml.ScalarNode, Value: key},
                                createAnyNode(val))
                }</span>
        }

        <span class="cov8" title="1">return node</span>
}

// createMapNode creates a YAML mapping node from a map
func createMapNode(data any) *yaml.Node <span class="cov8" title="1">{
        dataMap, ok := data.(map[string]string)
        if !ok </span><span class="cov0" title="0">{
                return createAnyNode(data)
        }</span>

        <span class="cov8" title="1">node := &amp;yaml.Node{Kind: yaml.MappingNode}

        // Sort keys for consistent output
        keys := make([]string, 0, len(dataMap))
        for k := range dataMap </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)

        for _, k := range keys </span><span class="cov8" title="1">{
                node.Content = append(node.Content,
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: k},
                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: dataMap[k]})
        }</span>

        <span class="cov8" title="1">return node</span>
}

// createAnyNode creates a YAML node from any value
func createAnyNode(data any) *yaml.Node <span class="cov8" title="1">{
        node := &amp;yaml.Node{}
        if err := node.Encode(data); err != nil </span><span class="cov0" title="0">{
                // If encoding fails, return a string representation as fallback
                node.Kind = yaml.ScalarNode
                node.Value = fmt.Sprintf("%v", data)
        }</span>
        <span class="cov8" title="1">return node</span>
}

// buildRequestDefinitions creates global request definitions from endpoints
func buildRequestDefinitions(workspaceData *ioworkspace.WorkspaceData) map[string]map[string]any <span class="cov8" title="1">{
        requests := make(map[string]map[string]any)

        // Map node names to their request nodes for direct lookup
        nodeNameToRequestNode := make(map[string]*mnrequest.MNRequest)
        for i := range workspaceData.FlowRequestNodes </span><span class="cov8" title="1">{
                reqNode := &amp;workspaceData.FlowRequestNodes[i]
                // Find the node name for this request node
                for _, node := range workspaceData.FlowNodes </span><span class="cov8" title="1">{
                        if node.ID == reqNode.FlowNodeID </span><span class="cov8" title="1">{
                                nodeNameToRequestNode[node.Name] = reqNode
                                break</span>
                        }
                }
        }

        // Create a unique request definition for each request node
        // This ensures each request has its own headers/params/body
        <span class="cov8" title="1">processedNodes := make(map[string]bool)

        for _, node := range workspaceData.FlowNodes </span><span class="cov8" title="1">{
                if node.NodeKind != mnnode.NODE_KIND_REQUEST </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">reqNode, exists := nodeNameToRequestNode[node.Name]
                if !exists || reqNode.EndpointID == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip if already processed
                <span class="cov8" title="1">if processedNodes[node.Name] </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">processedNodes[node.Name] = true

                // Find the endpoint
                var endpoint *mitemapi.ItemApi
                for i := range workspaceData.Endpoints </span><span class="cov8" title="1">{
                        if workspaceData.Endpoints[i].ID == *reqNode.EndpointID </span><span class="cov8" title="1">{
                                endpoint = &amp;workspaceData.Endpoints[i]
                                break</span>
                        }
                }
                <span class="cov8" title="1">if endpoint == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Build request definition for this specific node
                <span class="cov8" title="1">req := map[string]any{
                        "name": node.Name,
                }

                // Only add method if not empty
                if endpoint.Method != "" </span><span class="cov8" title="1">{
                        req["method"] = endpoint.Method
                }</span>

                // Only add url if not empty
                <span class="cov8" title="1">if endpoint.Url != "" </span><span class="cov8" title="1">{
                        req["url"] = endpoint.Url
                }</span>

                // Check if there's a delta endpoint with overrides
                <span class="cov8" title="1">if reqNode.DeltaEndpointID != nil </span><span class="cov8" title="1">{
                        for _, deltaEndpoint := range workspaceData.Endpoints </span><span class="cov8" title="1">{
                                if deltaEndpoint.ID == *reqNode.DeltaEndpointID </span><span class="cov8" title="1">{
                                        // Use delta endpoint's method/URL if different
                                        if deltaEndpoint.Method != endpoint.Method &amp;&amp; deltaEndpoint.Method != "" </span><span class="cov0" title="0">{
                                                req["method"] = deltaEndpoint.Method
                                        }</span>
                                        <span class="cov8" title="1">if deltaEndpoint.Url != endpoint.Url &amp;&amp; deltaEndpoint.Url != "" </span><span class="cov8" title="1">{
                                                req["url"] = deltaEndpoint.Url
                                        }</span>
                                        <span class="cov8" title="1">break</span>
                                }
                        }
                }

                // Collect headers - use base example only (has hardcoded values)
                <span class="cov8" title="1">headerMap := make(map[string]string)
                if reqNode.ExampleID != nil </span><span class="cov8" title="1">{
                        for _, h := range workspaceData.ExampleHeaders </span><span class="cov8" title="1">{
                                if h.ExampleID == *reqNode.ExampleID &amp;&amp; h.Enable </span><span class="cov8" title="1">{
                                        headerMap[h.HeaderKey] = h.Value
                                }</span>
                        }
                }

                <span class="cov8" title="1">if len(headerMap) &gt; 0 </span><span class="cov8" title="1">{
                        // Create sorted headers for consistent output
                        headerKeys := make([]string, 0, len(headerMap))
                        for key := range headerMap </span><span class="cov8" title="1">{
                                headerKeys = append(headerKeys, key)
                        }</span>
                        <span class="cov8" title="1">sort.Strings(headerKeys)

                        // Build ordered header map
                        orderedHeaders := make(map[string]string)
                        for _, key := range headerKeys </span><span class="cov8" title="1">{
                                orderedHeaders[key] = headerMap[key]
                        }</span>
                        <span class="cov8" title="1">req["headers"] = orderedHeaders</span>
                }

                // Collect query params - use base example only
                <span class="cov8" title="1">queryMap := make(map[string]string)
                if reqNode.ExampleID != nil </span><span class="cov8" title="1">{
                        for _, q := range workspaceData.ExampleQueries </span><span class="cov8" title="1">{
                                if q.ExampleID == *reqNode.ExampleID </span><span class="cov8" title="1">{
                                        queryMap[q.QueryKey] = q.Value
                                }</span>
                        }
                }

                <span class="cov8" title="1">if len(queryMap) &gt; 0 </span><span class="cov8" title="1">{
                        // Create sorted query params for consistent output
                        queryKeys := make([]string, 0, len(queryMap))
                        for key := range queryMap </span><span class="cov8" title="1">{
                                queryKeys = append(queryKeys, key)
                        }</span>
                        <span class="cov8" title="1">sort.Strings(queryKeys)

                        // Build ordered query map
                        orderedQueries := make(map[string]string)
                        for _, key := range queryKeys </span><span class="cov8" title="1">{
                                orderedQueries[key] = queryMap[key]
                        }</span>
                        <span class="cov8" title="1">req["query_params"] = orderedQueries</span>
                }

                // Collect body - use base example only
                <span class="cov8" title="1">if reqNode.ExampleID != nil </span><span class="cov8" title="1">{
                        for _, b := range workspaceData.Rawbodies </span><span class="cov8" title="1">{
                                if b.ExampleID == *reqNode.ExampleID &amp;&amp; len(b.Data) &gt; 0 </span><span class="cov8" title="1">{
                                        var bodyData any
                                        if err := json.Unmarshal(b.Data, &amp;bodyData); err == nil </span><span class="cov8" title="1">{
                                                req["body"] = bodyData
                                                break</span>
                                        }
                                }
                        }
                }

                // Store with node name as key
                <span class="cov8" title="1">requests[node.Name] = req</span>
        }

        <span class="cov8" title="1">return requests</span>
}

// exportFlow exports a single flow
func exportFlow(flow mflow.Flow, workspaceData *ioworkspace.WorkspaceData, requests map[string]map[string]any) map[string]any <span class="cov8" title="1">{
        // Build node map for this flow
        nodeMap := make(map[idwrap.IDWrap]mnnode.MNode)
        for _, node := range workspaceData.FlowNodes </span><span class="cov8" title="1">{
                if node.FlowID == flow.ID </span><span class="cov8" title="1">{
                        nodeMap[node.ID] = node
                }</span>
        }

        // Build edge maps
        <span class="cov8" title="1">incomingEdges := make(map[idwrap.IDWrap][]edge.Edge)
        outgoingEdges := make(map[idwrap.IDWrap][]edge.Edge)
        for _, e := range workspaceData.FlowEdges </span><span class="cov8" title="1">{
                if e.FlowID == flow.ID </span><span class="cov8" title="1">{
                        incomingEdges[e.TargetID] = append(incomingEdges[e.TargetID], e)
                        outgoingEdges[e.SourceID] = append(outgoingEdges[e.SourceID], e)
                }</span>
        }

        // Find start node
        <span class="cov8" title="1">var startNodeID idwrap.IDWrap
        for _, noop := range workspaceData.FlowNoopNodes </span><span class="cov8" title="1">{
                if noop.Type == mnnoop.NODE_NO_OP_KIND_START </span><span class="cov8" title="1">{
                        // Check if this noop belongs to our flow
                        if node, exists := nodeMap[noop.FlowNodeID]; exists &amp;&amp; node.FlowID == flow.ID </span><span class="cov8" title="1">{
                                startNodeID = noop.FlowNodeID
                                break</span>
                        }
                }
        }

        // Build variables
        <span class="cov8" title="1">var variables []map[string]string
        for _, v := range workspaceData.FlowVariables </span><span class="cov8" title="1">{
                if v.FlowID == flow.ID &amp;&amp; v.Enabled </span><span class="cov8" title="1">{
                        variables = append(variables, map[string]string{
                                "name":  v.Name,
                                "value": v.Value,
                        })
                }</span>
        }

        // Build node name to request name mapping (which are now the same)
        <span class="cov8" title="1">nodeToRequest := make(map[string]string)
        for nodeName := range requests </span><span class="cov8" title="1">{
                nodeToRequest[nodeName] = nodeName
        }</span>

        // Process nodes to create steps
        <span class="cov8" title="1">steps := processFlowNodes(nodeMap, incomingEdges, outgoingEdges, startNodeID, workspaceData, nodeToRequest)

        // Build flow data
        flowData := map[string]any{
                "name": flow.Name,
        }

        if len(variables) &gt; 0 </span><span class="cov8" title="1">{
                flowData["variables"] = variables
        }</span>

        <span class="cov8" title="1">if len(steps) &gt; 0 </span><span class="cov8" title="1">{
                flowData["steps"] = steps
        }</span>

        <span class="cov8" title="1">return flowData</span>
}

// processFlowNodes processes all nodes in a flow and returns steps
func processFlowNodes(nodeMap map[idwrap.IDWrap]mnnode.MNode, incomingEdges map[idwrap.IDWrap][]edge.Edge,
        outgoingEdges map[idwrap.IDWrap][]edge.Edge, startNodeID idwrap.IDWrap,
        workspaceData *ioworkspace.WorkspaceData, nodeToRequest map[string]string) []map[string]any <span class="cov8" title="1">{

        processed := make(map[idwrap.IDWrap]bool)
        steps := make([]map[string]any, 0)

        var processNode func(nodeID idwrap.IDWrap)
        processNode = func(nodeID idwrap.IDWrap) </span><span class="cov8" title="1">{
                if processed[nodeID] || nodeID == startNodeID </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">processed[nodeID] = true

                node, exists := nodeMap[nodeID]
                if !exists </span><span class="cov0" title="0">{
                        return
                }</span>

                // Process dependencies first
                <span class="cov8" title="1">for _, e := range incomingEdges[nodeID] </span><span class="cov8" title="1">{
                        if e.SourceID != startNodeID </span><span class="cov8" title="1">{
                                processNode(e.SourceID)
                        }</span>
                }

                // Convert node to step
                <span class="cov8" title="1">var step map[string]any
                switch node.NodeKind </span>{
                case mnnode.NODE_KIND_REQUEST:<span class="cov8" title="1">
                        step = convertRequestNodeClean(node, incomingEdges, outgoingEdges, startNodeID,
                                nodeMap, workspaceData, nodeToRequest)</span>
                case mnnode.NODE_KIND_JS:<span class="cov8" title="1">
                        step = convertJSNodeClean(node, incomingEdges, startNodeID, nodeMap, workspaceData)</span>
                case mnnode.NODE_KIND_CONDITION:<span class="cov8" title="1">
                        step = convertConditionNodeClean(node, incomingEdges, outgoingEdges, startNodeID,
                                nodeMap, workspaceData)</span>
                case mnnode.NODE_KIND_FOR:<span class="cov0" title="0">
                        step = convertForNodeClean(node, incomingEdges, outgoingEdges, startNodeID,
                                nodeMap, workspaceData)</span>
                case mnnode.NODE_KIND_FOR_EACH:<span class="cov0" title="0">
                        step = convertForEachNodeClean(node, incomingEdges, outgoingEdges, startNodeID,
                                nodeMap, workspaceData)</span>
                }

                <span class="cov8" title="1">if step != nil </span><span class="cov8" title="1">{
                        steps = append(steps, step)
                }</span>
        }

        // Process all nodes
        <span class="cov8" title="1">for nodeID := range nodeMap </span><span class="cov8" title="1">{
                processNode(nodeID)
        }</span>

        <span class="cov8" title="1">return steps</span>
}

// convertRequestNodeClean converts a request node to clean format
func convertRequestNodeClean(node mnnode.MNode, incomingEdges map[idwrap.IDWrap][]edge.Edge,
        outgoingEdges map[idwrap.IDWrap][]edge.Edge, startNodeID idwrap.IDWrap,
        nodeMap map[idwrap.IDWrap]mnnode.MNode, workspaceData *ioworkspace.WorkspaceData,
        nodeToRequest map[string]string) map[string]any <span class="cov8" title="1">{

        // Find request node data
        var requestNode *mnrequest.MNRequest
        for i := range workspaceData.FlowRequestNodes </span><span class="cov8" title="1">{
                if workspaceData.FlowRequestNodes[i].FlowNodeID == node.ID </span><span class="cov8" title="1">{
                        requestNode = &amp;workspaceData.FlowRequestNodes[i]
                        break</span>
                }
        }
        <span class="cov8" title="1">if requestNode == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">step := map[string]any{
                "name": node.Name,
        }

        // Find the request reference using node name
        if requestName, ok := nodeToRequest[node.Name]; ok </span><span class="cov8" title="1">{
                step["use_request"] = requestName
        }</span>

        // Add override values from delta endpoint/examples (with variable references)
        // Check for method/URL overrides from delta endpoint
        <span class="cov8" title="1">if requestNode.DeltaEndpointID != nil &amp;&amp; requestNode.EndpointID != nil </span><span class="cov8" title="1">{
                // Find base and delta endpoints
                var baseEndpoint, deltaEndpoint *mitemapi.ItemApi
                for i := range workspaceData.Endpoints </span><span class="cov8" title="1">{
                        if workspaceData.Endpoints[i].ID == *requestNode.EndpointID </span><span class="cov8" title="1">{
                                baseEndpoint = &amp;workspaceData.Endpoints[i]
                        }</span>
                        <span class="cov8" title="1">if workspaceData.Endpoints[i].ID == *requestNode.DeltaEndpointID </span><span class="cov8" title="1">{
                                deltaEndpoint = &amp;workspaceData.Endpoints[i]
                        }</span>
                }

                <span class="cov8" title="1">if baseEndpoint != nil &amp;&amp; deltaEndpoint != nil </span><span class="cov8" title="1">{
                        // Add method override if different and not empty
                        if deltaEndpoint.Method != baseEndpoint.Method &amp;&amp; deltaEndpoint.Method != "" </span><span class="cov0" title="0">{
                                step["method"] = deltaEndpoint.Method
                        }</span>
                        // Add URL override if different and not empty
                        <span class="cov8" title="1">if deltaEndpoint.Url != baseEndpoint.Url &amp;&amp; deltaEndpoint.Url != "" </span><span class="cov8" title="1">{
                                step["url"] = deltaEndpoint.Url
                        }</span>
                }
        }

        <span class="cov8" title="1">if requestNode.DeltaExampleID != nil </span><span class="cov8" title="1">{
                // Check for header overrides
                headerOverrides := make(map[string]string)
                for _, h := range workspaceData.ExampleHeaders </span><span class="cov8" title="1">{
                        if h.ExampleID == *requestNode.DeltaExampleID &amp;&amp; h.Enable </span><span class="cov8" title="1">{
                                // Only include if different from base
                                var baseValue string
                                if requestNode.ExampleID != nil </span><span class="cov8" title="1">{
                                        for _, baseH := range workspaceData.ExampleHeaders </span><span class="cov8" title="1">{
                                                if baseH.ExampleID == *requestNode.ExampleID &amp;&amp; baseH.HeaderKey == h.HeaderKey &amp;&amp; baseH.Enable </span><span class="cov8" title="1">{
                                                        baseValue = baseH.Value
                                                        break</span>
                                                }
                                        }
                                }
                                <span class="cov8" title="1">if h.Value != baseValue </span><span class="cov8" title="1">{
                                        headerOverrides[h.HeaderKey] = h.Value
                                }</span>
                        }
                }
                <span class="cov8" title="1">if len(headerOverrides) &gt; 0 </span><span class="cov8" title="1">{
                        step["headers"] = headerOverrides
                }</span>

                // Check for query param overrides
                <span class="cov8" title="1">queryOverrides := make(map[string]string)
                for _, q := range workspaceData.ExampleQueries </span><span class="cov8" title="1">{
                        if q.ExampleID == *requestNode.DeltaExampleID </span><span class="cov8" title="1">{
                                // Only include if different from base
                                var baseValue string
                                if requestNode.ExampleID != nil </span><span class="cov8" title="1">{
                                        for _, baseQ := range workspaceData.ExampleQueries </span><span class="cov8" title="1">{
                                                if baseQ.ExampleID == *requestNode.ExampleID &amp;&amp; baseQ.QueryKey == q.QueryKey </span><span class="cov8" title="1">{
                                                        baseValue = baseQ.Value
                                                        break</span>
                                                }
                                        }
                                }
                                <span class="cov8" title="1">if q.Value != baseValue </span><span class="cov0" title="0">{
                                        queryOverrides[q.QueryKey] = q.Value
                                }</span>
                        }
                }
                <span class="cov8" title="1">if len(queryOverrides) &gt; 0 </span><span class="cov0" title="0">{
                        step["query_params"] = queryOverrides
                }</span>

                // Check for body overrides
                <span class="cov8" title="1">for _, b := range workspaceData.Rawbodies </span><span class="cov8" title="1">{
                        if b.ExampleID == *requestNode.DeltaExampleID &amp;&amp; len(b.Data) &gt; 0 </span><span class="cov8" title="1">{
                                var deltaBodyData any
                                if err := json.Unmarshal(b.Data, &amp;deltaBodyData); err == nil </span><span class="cov8" title="1">{
                                        // Check if different from base
                                        var baseBodyData any
                                        if requestNode.ExampleID != nil </span><span class="cov8" title="1">{
                                                for _, baseB := range workspaceData.Rawbodies </span><span class="cov8" title="1">{
                                                        if baseB.ExampleID == *requestNode.ExampleID &amp;&amp; len(baseB.Data) &gt; 0 </span><span class="cov8" title="1">{
                                                                if err := json.Unmarshal(baseB.Data, &amp;baseBodyData); err != nil </span><span class="cov0" title="0">{
                                                                        // If base body can't be unmarshaled, treat as different
                                                                        baseBodyData = nil
                                                                }</span>
                                                                <span class="cov8" title="1">break</span>
                                                        }
                                                }
                                        }
                                        // Simple comparison - if they're different, include the override
                                        <span class="cov8" title="1">if fmt.Sprintf("%v", deltaBodyData) != fmt.Sprintf("%v", baseBodyData) </span><span class="cov8" title="1">{
                                                step["body"] = deltaBodyData
                                        }</span>
                                }
                                <span class="cov8" title="1">break</span>
                        }
                }
        }

        // Add dependencies
        <span class="cov8" title="1">var dependencies []string
        for _, e := range incomingEdges[node.ID] </span><span class="cov8" title="1">{
                if e.SourceID != startNodeID </span><span class="cov8" title="1">{
                        if sourceNode, exists := nodeMap[e.SourceID]; exists &amp;&amp; sourceNode.Name != "" </span><span class="cov8" title="1">{
                                dependencies = append(dependencies, sourceNode.Name)
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(dependencies) &gt; 0 </span><span class="cov8" title="1">{
                step["depends_on"] = dependencies
        }</span>

        <span class="cov8" title="1">return map[string]any{"request": step}</span>
}

// convertJSNodeClean converts a JS node to clean format
func convertJSNodeClean(node mnnode.MNode, incomingEdges map[idwrap.IDWrap][]edge.Edge,
        startNodeID idwrap.IDWrap, nodeMap map[idwrap.IDWrap]mnnode.MNode,
        workspaceData *ioworkspace.WorkspaceData) map[string]any <span class="cov8" title="1">{

        // Find JS node data
        var jsNode *mnjs.MNJS
        for i := range workspaceData.FlowJSNodes </span><span class="cov8" title="1">{
                if workspaceData.FlowJSNodes[i].FlowNodeID == node.ID </span><span class="cov8" title="1">{
                        jsNode = &amp;workspaceData.FlowJSNodes[i]
                        break</span>
                }
        }
        <span class="cov8" title="1">if jsNode == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">step := map[string]any{
                "name": node.Name,
                "code": string(jsNode.Code),
        }

        // Add dependencies
        var dependencies []string
        for _, e := range incomingEdges[node.ID] </span><span class="cov8" title="1">{
                if e.SourceID != startNodeID </span><span class="cov8" title="1">{
                        if sourceNode, exists := nodeMap[e.SourceID]; exists &amp;&amp; sourceNode.Name != "" </span><span class="cov8" title="1">{
                                dependencies = append(dependencies, sourceNode.Name)
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(dependencies) &gt; 0 </span><span class="cov8" title="1">{
                step["depends_on"] = dependencies
        }</span>

        <span class="cov8" title="1">return map[string]any{"js": step}</span>
}

// convertConditionNodeClean converts a condition node to clean format
func convertConditionNodeClean(node mnnode.MNode, incomingEdges map[idwrap.IDWrap][]edge.Edge,
        outgoingEdges map[idwrap.IDWrap][]edge.Edge, startNodeID idwrap.IDWrap,
        nodeMap map[idwrap.IDWrap]mnnode.MNode, workspaceData *ioworkspace.WorkspaceData) map[string]any <span class="cov8" title="1">{

        // Find condition node data
        var condNode *mnif.MNIF
        for i := range workspaceData.FlowConditionNodes </span><span class="cov8" title="1">{
                if workspaceData.FlowConditionNodes[i].FlowNodeID == node.ID </span><span class="cov8" title="1">{
                        condNode = &amp;workspaceData.FlowConditionNodes[i]
                        break</span>
                }
        }
        <span class="cov8" title="1">if condNode == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">step := map[string]any{
                "name":       node.Name,
                "expression": condNode.Condition.Comparisons.Expression,
        }

        // Find then/else targets
        for _, e := range outgoingEdges[node.ID] </span><span class="cov8" title="1">{
                if targetNode, exists := nodeMap[e.TargetID]; exists </span><span class="cov8" title="1">{
                        switch e.SourceHandler </span>{
                        case edge.HandleThen:<span class="cov8" title="1">
                                step["then"] = targetNode.Name</span>
                        case edge.HandleElse:<span class="cov8" title="1">
                                step["else"] = targetNode.Name</span>
                        }
                }
        }

        // Add dependencies
        <span class="cov8" title="1">var dependencies []string
        for _, e := range incomingEdges[node.ID] </span><span class="cov8" title="1">{
                if e.SourceID != startNodeID </span><span class="cov0" title="0">{
                        if sourceNode, exists := nodeMap[e.SourceID]; exists &amp;&amp; sourceNode.Name != "" </span><span class="cov0" title="0">{
                                dependencies = append(dependencies, sourceNode.Name)
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(dependencies) &gt; 0 </span><span class="cov0" title="0">{
                step["depends_on"] = dependencies
        }</span>

        <span class="cov8" title="1">return map[string]any{"if": step}</span>
}

// convertForNodeClean converts a for node to clean format
func convertForNodeClean(node mnnode.MNode, incomingEdges map[idwrap.IDWrap][]edge.Edge,
        outgoingEdges map[idwrap.IDWrap][]edge.Edge, startNodeID idwrap.IDWrap,
        nodeMap map[idwrap.IDWrap]mnnode.MNode, workspaceData *ioworkspace.WorkspaceData) map[string]any <span class="cov0" title="0">{

        // Find for node data
        var forNode *mnfor.MNFor
        for i := range workspaceData.FlowForNodes </span><span class="cov0" title="0">{
                if workspaceData.FlowForNodes[i].FlowNodeID == node.ID </span><span class="cov0" title="0">{
                        forNode = &amp;workspaceData.FlowForNodes[i]
                        break</span>
                }
        }
        <span class="cov0" title="0">if forNode == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">step := map[string]any{
                "name": node.Name,
        }

        // Only add iter_count if it's non-zero
        if forNode.IterCount &gt; 0 </span><span class="cov0" title="0">{
                step["iter_count"] = forNode.IterCount
        }</span>

        // Find loop target
        <span class="cov0" title="0">for _, e := range outgoingEdges[node.ID] </span><span class="cov0" title="0">{
                if e.SourceHandler == edge.HandleLoop </span><span class="cov0" title="0">{
                        if targetNode, exists := nodeMap[e.TargetID]; exists &amp;&amp; targetNode.Name != "" </span><span class="cov0" title="0">{
                                step["loop"] = targetNode.Name
                        }</span>
                }
        }

        // Add dependencies
        <span class="cov0" title="0">var dependencies []string
        for _, e := range incomingEdges[node.ID] </span><span class="cov0" title="0">{
                if e.SourceID != startNodeID </span><span class="cov0" title="0">{
                        if sourceNode, exists := nodeMap[e.SourceID]; exists &amp;&amp; sourceNode.Name != "" </span><span class="cov0" title="0">{
                                dependencies = append(dependencies, sourceNode.Name)
                        }</span>
                }
        }
        <span class="cov0" title="0">if len(dependencies) &gt; 0 </span><span class="cov0" title="0">{
                step["depends_on"] = dependencies
        }</span>

        <span class="cov0" title="0">return map[string]any{"for": step}</span>
}

// convertForEachNodeClean converts a for_each node to clean format
func convertForEachNodeClean(node mnnode.MNode, incomingEdges map[idwrap.IDWrap][]edge.Edge,
        outgoingEdges map[idwrap.IDWrap][]edge.Edge, startNodeID idwrap.IDWrap,
        nodeMap map[idwrap.IDWrap]mnnode.MNode, workspaceData *ioworkspace.WorkspaceData) map[string]any <span class="cov0" title="0">{

        // Find ForEach node data
        var forEachNode *mnforeach.MNForEach
        for i := range workspaceData.FlowForEachNodes </span><span class="cov0" title="0">{
                if workspaceData.FlowForEachNodes[i].FlowNodeID == node.ID </span><span class="cov0" title="0">{
                        forEachNode = &amp;workspaceData.FlowForEachNodes[i]
                        break</span>
                }
        }

        <span class="cov0" title="0">step := map[string]any{
                "name": node.Name,
        }

        // Add items expression
        if forEachNode != nil &amp;&amp; forEachNode.IterExpression != "" </span><span class="cov0" title="0">{
                step["items"] = forEachNode.IterExpression
        }</span> else<span class="cov0" title="0"> {
                step["items"] = "response.items" // Default fallback
        }</span>

        // Find loop target
        <span class="cov0" title="0">for _, e := range outgoingEdges[node.ID] </span><span class="cov0" title="0">{
                if e.SourceHandler == edge.HandleLoop </span><span class="cov0" title="0">{
                        if targetNode, exists := nodeMap[e.TargetID]; exists &amp;&amp; targetNode.Name != "" </span><span class="cov0" title="0">{
                                step["loop"] = targetNode.Name
                        }</span>
                }
        }

        // Add dependencies
        <span class="cov0" title="0">var dependencies []string
        for _, e := range incomingEdges[node.ID] </span><span class="cov0" title="0">{
                if e.SourceID != startNodeID </span><span class="cov0" title="0">{
                        if sourceNode, exists := nodeMap[e.SourceID]; exists &amp;&amp; sourceNode.Name != "" </span><span class="cov0" title="0">{
                                dependencies = append(dependencies, sourceNode.Name)
                        }</span>
                }
        }
        <span class="cov0" title="0">if len(dependencies) &gt; 0 </span><span class="cov0" title="0">{
                step["depends_on"] = dependencies
        }</span>

        <span class="cov0" title="0">return map[string]any{"for_each": step}</span>
}

// buildRunEntries analyzes flows and their dependencies to build run entries
func buildRunEntries(workspaceData *ioworkspace.WorkspaceData) []RunEntry <span class="cov8" title="1">{
        // Create a run entry for each flow that was exported
        // This enables the exported YAML to specify which flows should be executed
        entries := make([]RunEntry, 0, len(workspaceData.Flows))

        for _, flow := range workspaceData.Flows </span><span class="cov8" title="1">{
                entry := RunEntry{
                        Flow: flow.Name,
                }
                entries = append(entries, entry)
        }</span>

        <span class="cov8" title="1">return entries</span>
}

// createRunEntryNode creates a YAML node for a run entry
func createRunEntryNode(entry RunEntry) *yaml.Node <span class="cov8" title="1">{
        node := &amp;yaml.Node{Kind: yaml.MappingNode}

        // Add flow field
        node.Content = append(node.Content,
                &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "flow"},
                &amp;yaml.Node{Kind: yaml.ScalarNode, Value: entry.Flow})

        // Add depends_on if present
        if len(entry.DependsOn) &gt; 0 </span><span class="cov0" title="0">{
                if len(entry.DependsOn) == 1 </span><span class="cov0" title="0">{
                        // Single dependency as string
                        node.Content = append(node.Content,
                                &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "depends_on"},
                                &amp;yaml.Node{Kind: yaml.ScalarNode, Value: entry.DependsOn[0]})
                }</span> else<span class="cov0" title="0"> {
                        // Multiple dependencies as array
                        var depsNode yaml.Node
                        depsNode.Kind = yaml.SequenceNode
                        for _, dep := range entry.DependsOn </span><span class="cov0" title="0">{
                                depsNode.Content = append(depsNode.Content,
                                        &amp;yaml.Node{Kind: yaml.ScalarNode, Value: dep})
                        }</span>
                        <span class="cov0" title="0">node.Content = append(node.Content,
                                &amp;yaml.Node{Kind: yaml.ScalarNode, Value: "depends_on"},
                                &amp;depsNode)</span>
                }
        }

        <span class="cov8" title="1">return node</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package yamlflowsimple

import (
        "fmt"
        "gopkg.in/yaml.v3"
        "the-dev-tools/server/pkg/flow/edge"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/ioworkspace"
        "the-dev-tools/server/pkg/model/massert"
        "the-dev-tools/server/pkg/model/massertres"
        "the-dev-tools/server/pkg/model/mbodyform"
        "the-dev-tools/server/pkg/model/mbodyraw"
        "the-dev-tools/server/pkg/model/mbodyurl"
        "the-dev-tools/server/pkg/model/mcollection"
        "the-dev-tools/server/pkg/model/menv"
        "the-dev-tools/server/pkg/model/mexampleheader"
        "the-dev-tools/server/pkg/model/mexamplequery"
        "the-dev-tools/server/pkg/model/mexampleresp"
        "the-dev-tools/server/pkg/model/mexamplerespheader"
        "the-dev-tools/server/pkg/model/mflow"
        "the-dev-tools/server/pkg/model/mflowvariable"
        "the-dev-tools/server/pkg/model/mitemapi"
        "the-dev-tools/server/pkg/model/mitemapiexample"
        "the-dev-tools/server/pkg/model/mitemfolder"
        "the-dev-tools/server/pkg/model/mnnode"
        "the-dev-tools/server/pkg/model/mnnode/mnfor"
        "the-dev-tools/server/pkg/model/mnnode/mnforeach"
        "the-dev-tools/server/pkg/model/mnnode/mnif"
        "the-dev-tools/server/pkg/model/mnnode/mnjs"
        "the-dev-tools/server/pkg/model/mnnode/mnnoop"
        "the-dev-tools/server/pkg/model/mnnode/mnrequest"
        "the-dev-tools/server/pkg/model/mvar"
        "the-dev-tools/server/pkg/model/mworkspace"
        "time"
)

// ImportYamlFlowYAML converts simplified yamlflow YAML to ioworkspace.WorkspaceData
func ImportYamlFlowYAML(data []byte) (*ioworkspace.WorkspaceData, error) <span class="cov8" title="1">{
        // Generate workspace ID first
        workspaceID := idwrap.NewNow()
        collectionID := idwrap.NewNow()

        // Use the new ConvertSimplifiedYAML function
        resolved, err := ConvertSimplifiedYAML(data, collectionID, workspaceID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to convert simplified workflow: %w", err)
        }</span>

        // Extract workspace name from the workflow
        <span class="cov8" title="1">workspaceName := "Imported Workspace"
        // Check for workspace name in the original YAML
        var yamlCheck map[string]any
        if err := yaml.Unmarshal(data, &amp;yamlCheck); err == nil </span><span class="cov8" title="1">{
                if name, ok := yamlCheck["workspace_name"].(string); ok &amp;&amp; name != "" </span><span class="cov8" title="1">{
                        workspaceName = name
                }</span>
        }
        // Parse the data to extract variables
        <span class="cov8" title="1">workflowData, err := Parse(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse workflow: %w", err)
        }</span>

        // Extract all variable references from the workflow
        <span class="cov8" title="1">variableRefs := ExtractVariableReferences(workflowData)

        // Separate into flow and environment variables
        _, envVarsToCreate := SeparateVariablesByType(variableRefs)

        // Create a default environment for the workspace
        defaultEnv := menv.Env{
                ID:          idwrap.NewNow(),
                WorkspaceID: workspaceID,
                Type:        menv.EnvNormal,
                Name:        "Default Environment",
                Description: "Default environment for imported workflows",
                Updated:     time.Now(),
        }

        // Convert environment variables to proper format with EnvID
        var environmentVariables []mvar.Var
        for _, v := range envVarsToCreate </span><span class="cov8" title="1">{
                envVar := mvar.Var{
                        ID:          idwrap.NewNow(),
                        EnvID:       defaultEnv.ID,
                        VarKey:      v.VarKey,
                        Value:       v.Value,
                        Enabled:     true,
                        Description: "Imported from workflow",
                }
                environmentVariables = append(environmentVariables, envVar)
        }</span>

        // Create workspace data
        <span class="cov8" title="1">workspaceData := &amp;ioworkspace.WorkspaceData{
                Workspace: mworkspace.Workspace{
                        ID:   workspaceID,
                        Name: workspaceName,
                },
                Collections:            resolved.Collections,
                Folders:                make([]mitemfolder.ItemFolder, 0),
                Endpoints:              resolved.Endpoints,
                Examples:               resolved.Examples,
                ExampleHeaders:         resolved.Headers,
                ExampleQueries:         resolved.Queries,
                ExampleAsserts:         make([]massert.Assert, 0),
                Rawbodies:              resolved.RawBodies,
                FormBodies:             make([]mbodyform.BodyForm, 0),
                UrlBodies:              make([]mbodyurl.BodyURLEncoded, 0),
                ExampleResponses:       make([]mexampleresp.ExampleResp, 0),
                ExampleResponseHeaders: make([]mexamplerespheader.ExampleRespHeader, 0),
                ExampleResponseAsserts: make([]massertres.AssertResult, 0),
                Flows:                  resolved.Flows,
                FlowNodes:              resolved.FlowNodes,
                FlowEdges:              resolved.FlowEdges,
                FlowVariables:          resolved.FlowVariables,
                FlowRequestNodes:       resolved.FlowRequestNodes,
                FlowConditionNodes:     resolved.FlowConditionNodes,
                FlowNoopNodes:          resolved.FlowNoopNodes,
                FlowForNodes:           resolved.FlowForNodes,
                FlowForEachNodes:       make([]mnforeach.MNForEach, 0),
                FlowJSNodes:            resolved.FlowJSNodes,
                Environments:           []menv.Env{defaultEnv},
                Variables:              environmentVariables,
        }

        // Copy for and for_each nodes directly
        workspaceData.FlowForNodes = resolved.FlowForNodes
        workspaceData.FlowForEachNodes = resolved.FlowForEachNodes

        return workspaceData, nil</span>
}

// ImportYamlFlowYAMLMultiFlow converts yamlflow YAML with multiple flows to ioworkspace.WorkspaceData
func ImportYamlFlowYAMLMultiFlow(data []byte) (*ioworkspace.WorkspaceData, error) <span class="cov0" title="0">{
        // Generate workspace ID first
        workspaceID := idwrap.NewNow()

        // Parse the workflow to get basic structure
        var workflow YamlFlowFormat
        if err := yaml.Unmarshal(data, &amp;workflow); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal yamlflow format: %w", err)
        }</span>

        <span class="cov0" title="0">if workflow.WorkspaceName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("workspace_name is required")
        }</span>

        // Create workspace data
        <span class="cov0" title="0">workspaceData := &amp;ioworkspace.WorkspaceData{
                Workspace: mworkspace.Workspace{
                        ID:   workspaceID,
                        Name: workflow.WorkspaceName,
                },
                Collections:            make([]mcollection.Collection, 0),
                Folders:                make([]mitemfolder.ItemFolder, 0),
                Endpoints:              make([]mitemapi.ItemApi, 0),
                Examples:               make([]mitemapiexample.ItemApiExample, 0),
                ExampleHeaders:         make([]mexampleheader.Header, 0),
                ExampleQueries:         make([]mexamplequery.Query, 0),
                ExampleAsserts:         make([]massert.Assert, 0),
                Rawbodies:              make([]mbodyraw.ExampleBodyRaw, 0),
                FormBodies:             make([]mbodyform.BodyForm, 0),
                UrlBodies:              make([]mbodyurl.BodyURLEncoded, 0),
                ExampleResponses:       make([]mexampleresp.ExampleResp, 0),
                ExampleResponseHeaders: make([]mexamplerespheader.ExampleRespHeader, 0),
                ExampleResponseAsserts: make([]massertres.AssertResult, 0),
                Flows:                  make([]mflow.Flow, 0),
                FlowNodes:              make([]mnnode.MNode, 0),
                FlowEdges:              make([]edge.Edge, 0),
                FlowVariables:          make([]mflowvariable.FlowVariable, 0),
                FlowRequestNodes:       make([]mnrequest.MNRequest, 0),
                FlowConditionNodes:     make([]mnif.MNIF, 0),
                FlowNoopNodes:          make([]mnnoop.NoopNode, 0),
                FlowForNodes:           make([]mnfor.MNFor, 0),
                FlowForEachNodes:       make([]mnforeach.MNForEach, 0),
                FlowJSNodes:            make([]mnjs.MNJS, 0),
                Environments:           make([]menv.Env, 0),
                Variables:              make([]mvar.Var, 0),
        }

        // Create a default environment
        defaultEnv := menv.Env{
                ID:          idwrap.NewNow(),
                WorkspaceID: workspaceID,
                Type:        menv.EnvNormal,
                Name:        "Default Environment",
                Description: "Default environment for imported workflows",
                Updated:     time.Now(),
        }
        workspaceData.Environments = append(workspaceData.Environments, defaultEnv)

        // Create one collection for all flows
        collectionID := idwrap.NewNow()
        collection := mcollection.Collection{
                ID:          collectionID,
                Name:        "Workflow Collection",
                WorkspaceID: workspaceID,
        }
        workspaceData.Collections = append(workspaceData.Collections, collection)

        // Process each flow
        for _, flowDef := range workflow.Flows </span><span class="cov0" title="0">{
                // Use ConvertSimplifiedYAML for each flow by creating a temporary workflow with single flow
                tempWorkflow := YamlFlowFormat{
                        WorkspaceName:    workflow.WorkspaceName,
                        RequestTemplates: workflow.RequestTemplates,
                        Requests:         workflow.Requests,
                        Flows:            []YamlFlowFlow{flowDef},
                }

                tempData, err := yaml.Marshal(tempWorkflow)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal temp workflow for flow %s: %w", flowDef.Name, err)
                }</span>

                <span class="cov0" title="0">resolved, err := ConvertSimplifiedYAML(tempData, collectionID, workspaceID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to convert flow %s: %w", flowDef.Name, err)
                }</span>

                // Merge the resolved data into workspace data
                <span class="cov0" title="0">workspaceData.Flows = append(workspaceData.Flows, resolved.Flows...)
                workspaceData.FlowNodes = append(workspaceData.FlowNodes, resolved.FlowNodes...)
                workspaceData.FlowEdges = append(workspaceData.FlowEdges, resolved.FlowEdges...)
                workspaceData.FlowVariables = append(workspaceData.FlowVariables, resolved.FlowVariables...)
                workspaceData.FlowRequestNodes = append(workspaceData.FlowRequestNodes, resolved.FlowRequestNodes...)
                workspaceData.FlowConditionNodes = append(workspaceData.FlowConditionNodes, resolved.FlowConditionNodes...)
                workspaceData.FlowNoopNodes = append(workspaceData.FlowNoopNodes, resolved.FlowNoopNodes...)
                workspaceData.FlowForNodes = append(workspaceData.FlowForNodes, resolved.FlowForNodes...)
                workspaceData.FlowForEachNodes = append(workspaceData.FlowForEachNodes, resolved.FlowForEachNodes...)
                workspaceData.FlowJSNodes = append(workspaceData.FlowJSNodes, resolved.FlowJSNodes...)

                // Merge endpoints and examples, avoiding duplicates
                endpointMap := make(map[string]bool)
                for _, e := range workspaceData.Endpoints </span><span class="cov0" title="0">{
                        endpointMap[e.Name] = true
                }</span>

                <span class="cov0" title="0">for _, e := range resolved.Endpoints </span><span class="cov0" title="0">{
                        if !endpointMap[e.Name] </span><span class="cov0" title="0">{
                                workspaceData.Endpoints = append(workspaceData.Endpoints, e)
                                endpointMap[e.Name] = true
                        }</span>
                }

                // Merge examples
                <span class="cov0" title="0">workspaceData.Examples = append(workspaceData.Examples, resolved.Examples...)
                workspaceData.ExampleHeaders = append(workspaceData.ExampleHeaders, resolved.Headers...)
                workspaceData.ExampleQueries = append(workspaceData.ExampleQueries, resolved.Queries...)
                workspaceData.Rawbodies = append(workspaceData.Rawbodies, resolved.RawBodies...)</span>
        }

        // Set Prev/Next for endpoints
        <span class="cov0" title="0">for i := range workspaceData.Endpoints </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        prevID := &amp;workspaceData.Endpoints[i-1].ID
                        workspaceData.Endpoints[i].Prev = prevID
                }</span>
                <span class="cov0" title="0">if i &lt; len(workspaceData.Endpoints)-1 </span><span class="cov0" title="0">{
                        nextID := &amp;workspaceData.Endpoints[i+1].ID
                        workspaceData.Endpoints[i].Next = nextID
                }</span>
        }

        // Set Prev/Next for examples
        <span class="cov0" title="0">for i := range workspaceData.Examples </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        prevID := &amp;workspaceData.Examples[i-1].ID
                        workspaceData.Examples[i].Prev = prevID
                }</span>
                <span class="cov0" title="0">if i &lt; len(workspaceData.Examples)-1 </span><span class="cov0" title="0">{
                        nextID := &amp;workspaceData.Examples[i+1].ID
                        workspaceData.Examples[i].Next = nextID
                }</span>
        }

        <span class="cov0" title="0">return workspaceData, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package yamlflowsimple

import (
        "errors"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mnnode"
        "the-dev-tools/server/pkg/model/mnnode/mnnoop"
)

// positionNodes arranges nodes using a level-based layout algorithm
func positionNodes(data *YamlFlowData) error <span class="cov8" title="1">{
        const (
                nodeSpacingX = 400 // Horizontal spacing between parallel nodes
                nodeSpacingY = 300 // Vertical spacing between levels
                startX       = 0   // Starting X position
                startY       = 0   // Starting Y position
        )

        // Map for quick node lookup
        nodeMap := make(map[idwrap.IDWrap]*mnnode.MNode)
        for i := range data.Nodes </span><span class="cov8" title="1">{
                nodeMap[data.Nodes[i].ID] = &amp;data.Nodes[i]
        }</span>

        // Find start node
        <span class="cov8" title="1">var startNode *mnnode.MNode
        for i := range data.NoopNodes </span><span class="cov8" title="1">{
                if data.NoopNodes[i].Type == mnnoop.NODE_NO_OP_KIND_START </span><span class="cov8" title="1">{
                        startNode = nodeMap[data.NoopNodes[i].FlowNodeID]
                        break</span>
                }
        }
        <span class="cov8" title="1">if startNode == nil </span><span class="cov0" title="0">{
                return errors.New("start node not found")
        }</span>

        // Build adjacency lists from edges
        <span class="cov8" title="1">outgoingEdges := make(map[idwrap.IDWrap][]idwrap.IDWrap)
        incomingEdges := make(map[idwrap.IDWrap][]idwrap.IDWrap)
        for _, e := range data.Edges </span><span class="cov8" title="1">{
                outgoingEdges[e.SourceID] = append(outgoingEdges[e.SourceID], e.TargetID)
                incomingEdges[e.TargetID] = append(incomingEdges[e.TargetID], e.SourceID)
        }</span>

        // Calculate dependency levels using BFS
        <span class="cov8" title="1">nodeLevels := make(map[idwrap.IDWrap]int)
        levelNodes := make(map[int][]idwrap.IDWrap) // level -&gt; nodes at that level

        // BFS to assign levels
        queue := []idwrap.IDWrap{startNode.ID}
        nodeLevels[startNode.ID] = 0
        levelNodes[0] = []idwrap.IDWrap{startNode.ID}

        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                currentNodeID := queue[0]
                queue = queue[1:]

                // Process all children
                for _, childID := range outgoingEdges[currentNodeID] </span><span class="cov8" title="1">{
                        // Calculate the maximum level of all parents + 1
                        maxParentLevel := -1
                        for _, parentID := range incomingEdges[childID] </span><span class="cov8" title="1">{
                                if parentLevel, exists := nodeLevels[parentID]; exists </span><span class="cov8" title="1">{
                                        if parentLevel &gt; maxParentLevel </span><span class="cov8" title="1">{
                                                maxParentLevel = parentLevel
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">childLevel := maxParentLevel + 1

                        // Only update if this is a new node or we found a deeper level
                        if existingLevel, exists := nodeLevels[childID]; !exists || childLevel &gt; existingLevel </span><span class="cov8" title="1">{
                                // Remove from old level if it existed
                                if exists </span><span class="cov8" title="1">{
                                        oldLevelNodes := levelNodes[existingLevel]
                                        for i, nodeID := range oldLevelNodes </span><span class="cov8" title="1">{
                                                if nodeID == childID </span><span class="cov8" title="1">{
                                                        levelNodes[existingLevel] = append(oldLevelNodes[:i], oldLevelNodes[i+1:]...)
                                                        break</span>
                                                }
                                        }
                                }

                                // Add to new level
                                <span class="cov8" title="1">nodeLevels[childID] = childLevel
                                levelNodes[childLevel] = append(levelNodes[childLevel], childID)
                                queue = append(queue, childID)</span>
                        }
                }
        }

        // Position nodes level by level
        <span class="cov8" title="1">for level := 0; level &lt;= len(levelNodes)-1; level++ </span><span class="cov8" title="1">{
                nodes := levelNodes[level]
                if len(nodes) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Calculate Y position for this level
                <span class="cov8" title="1">yPos := float64(startY + level*nodeSpacingY)

                // Calculate starting X position to center the nodes at this level
                totalWidth := float64((len(nodes) - 1) * nodeSpacingX)
                startXForLevel := float64(startX) - totalWidth/2

                // Position each node in this level
                for i, nodeID := range nodes </span><span class="cov8" title="1">{
                        if node := nodeMap[nodeID]; node != nil </span><span class="cov8" title="1">{
                                node.PositionX = startXForLevel + float64(i*nodeSpacingX)
                                node.PositionY = yPos
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package yamlflowsimple

import (
        "regexp"
        "strings"
        "the-dev-tools/server/pkg/model/menv"
        "the-dev-tools/server/pkg/model/mvar"
)

// VariableInfo holds information about a variable reference found in the YAML
type VariableInfo struct {
        Name     string
        IsEnvVar bool
        Value    string // For flow variables defined in YAML
        HasValue bool   // Whether this variable has a defined value
}

// ExtractVariableReferences extracts all variable references from workflow data
func ExtractVariableReferences(workflowData *YamlFlowData) map[string]*VariableInfo <span class="cov8" title="1">{
        variables := make(map[string]*VariableInfo)

        // First, add all flow variables that are defined in the YAML
        for _, v := range workflowData.Variables </span><span class="cov8" title="1">{
                variables[v.VarKey] = &amp;VariableInfo{
                        Name:     v.VarKey,
                        IsEnvVar: false,
                        Value:    v.Value,
                        HasValue: true,
                }
        }</span>

        // Regular expression to find variable references
        <span class="cov8" title="1">varPattern := regexp.MustCompile(`\{\{\s*([^}]+)\s*\}\}`)

        // Helper function to extract variables from a string
        extractFromString := func(s string) </span><span class="cov8" title="1">{
                matches := varPattern.FindAllStringSubmatch(s, -1)
                for _, match := range matches </span><span class="cov8" title="1">{
                        if len(match) &gt; 1 </span><span class="cov8" title="1">{
                                varName := strings.TrimSpace(match[1])

                                // Check if it's an environment variable
                                isEnv := strings.HasPrefix(varName, menv.EnvVariablePrefix)
                                if isEnv </span><span class="cov8" title="1">{
                                        varName = strings.TrimPrefix(varName, menv.EnvVariablePrefix)
                                }</span>

                                // Only add if not already defined as a flow variable
                                <span class="cov8" title="1">if _, exists := variables[varName]; !exists </span><span class="cov8" title="1">{
                                        variables[varName] = &amp;VariableInfo{
                                                Name:     varName,
                                                IsEnvVar: isEnv,
                                                HasValue: false,
                                        }
                                }</span>
                        }
                }
        }

        // Extract from headers
        <span class="cov8" title="1">for _, header := range workflowData.Headers </span><span class="cov8" title="1">{
                extractFromString(header.HeaderKey)
                extractFromString(header.Value)
        }</span>

        // Extract from queries
        <span class="cov8" title="1">for _, query := range workflowData.Queries </span><span class="cov8" title="1">{
                extractFromString(query.QueryKey)
                extractFromString(query.Value)
        }</span>

        // Extract from raw bodies
        <span class="cov8" title="1">for _, body := range workflowData.RawBodies </span><span class="cov8" title="1">{
                extractFromString(string(body.Data))
        }</span>

        // Extract from endpoints
        <span class="cov8" title="1">for _, endpoint := range workflowData.Endpoints </span><span class="cov8" title="1">{
                extractFromString(endpoint.Url)
                extractFromString(endpoint.Name)
        }</span>

        // Extract from examples
        <span class="cov8" title="1">for _, example := range workflowData.Examples </span><span class="cov8" title="1">{
                extractFromString(example.Name)
        }</span>

        // Extract from JS nodes
        <span class="cov8" title="1">for _, jsNode := range workflowData.JSNodes </span><span class="cov8" title="1">{
                extractFromString(string(jsNode.Code))
        }</span>

        // Extract from condition nodes
        <span class="cov8" title="1">for _, condNode := range workflowData.ConditionNodes </span><span class="cov8" title="1">{
                extractFromString(condNode.Condition.Comparisons.Expression)
        }</span>

        <span class="cov8" title="1">return variables</span>
}

// SeparateVariablesByType separates variables into flow and environment variables
func SeparateVariablesByType(variables map[string]*VariableInfo) (flowVars []mvar.Var, envVars []mvar.Var) <span class="cov8" title="1">{
        for _, varInfo := range variables </span><span class="cov8" title="1">{
                v := mvar.Var{
                        VarKey: varInfo.Name,
                        Value:  varInfo.Value,
                }

                if varInfo.IsEnvVar </span><span class="cov8" title="1">{
                        envVars = append(envVars, v)
                }</span> else<span class="cov8" title="1"> if varInfo.HasValue </span><span class="cov8" title="1">{
                        // Only add flow variables that have defined values
                        flowVars = append(flowVars, v)
                }</span>
        }

        <span class="cov8" title="1">return flowVars, envVars</span>
}

// CheckStringHasEnvVar checks if a string contains environment variable references
func CheckStringHasEnvVar(s string) bool <span class="cov8" title="1">{
        return strings.Contains(s, "{{") &amp;&amp; strings.Contains(s, menv.EnvVariablePrefix)
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package yamlflowsimple

import (
        "encoding/json"
        "fmt"
        "gopkg.in/yaml.v3"
        "the-dev-tools/server/pkg/compress"
        "the-dev-tools/server/pkg/flow/edge"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mbodyraw"
        "the-dev-tools/server/pkg/model/mcollection"
        "the-dev-tools/server/pkg/model/mcondition"
        "the-dev-tools/server/pkg/model/mexampleheader"
        "the-dev-tools/server/pkg/model/mexamplequery"
        "the-dev-tools/server/pkg/model/mflow"
        "the-dev-tools/server/pkg/model/mflowvariable"
        "the-dev-tools/server/pkg/model/mitemapi"
        "the-dev-tools/server/pkg/model/mitemapiexample"
        "the-dev-tools/server/pkg/model/mnnode"
        "the-dev-tools/server/pkg/model/mnnode/mnfor"
        "the-dev-tools/server/pkg/model/mnnode/mnforeach"
        "the-dev-tools/server/pkg/model/mnnode/mnif"
        "the-dev-tools/server/pkg/model/mnnode/mnjs"
        "the-dev-tools/server/pkg/model/mnnode/mnnoop"
        "the-dev-tools/server/pkg/model/mnnode/mnrequest"
        "the-dev-tools/server/pkg/model/mvar"
        "the-dev-tools/server/pkg/varsystem"
)

// ========================================
// Constants
// ========================================

const (
        // Field name constants
        fieldName        = "name"
        fieldValue       = "value"
        fieldMethod      = "method"
        fieldURL         = "url"
        fieldHeaders     = "headers"
        fieldQueryParams = "query_params"
        fieldBody        = "body"
        fieldCondition   = "condition"
        fieldIterCount   = "iter_count"
        fieldItems       = "items"
        fieldCode        = "code"
        fieldDependsOn   = "depends_on"
        fieldUseRequest  = "use_request"
        fieldThen        = "then"
        fieldElse        = "else"
        fieldLoop        = "loop"
        fieldSteps       = "steps"
        fieldFlows       = "flows"
        fieldRun         = "run"
        fieldFlow        = "flow"

        // Node type constants
        stepTypeRequest = "request"
        stepTypeIf      = "if"
        stepTypeFor     = "for"
        stepTypeForEach = "for_each"
        stepTypeJS      = "js"
)

// ========================================
// Error Types
// ========================================

// YamlFlowError provides structured error information
type YamlFlowError struct {
        Message string
        Field   string
        Value   interface{}
}

func (e YamlFlowError) Error() string <span class="cov8" title="1">{
        if e.Field != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s: field '%s' with value '%v'", e.Message, e.Field, e.Value)
        }</span>
        <span class="cov8" title="1">return e.Message</span>
}

func newYamlFlowError(message, field string, value interface{}) error <span class="cov8" title="1">{
        return YamlFlowError{
                Message: message,
                Field:   field,
                Value:   value,
        }
}</span>

// ========================================
// Configuration Types
// ========================================

// NameValue represents a name-value pair for headers, queries, etc.
type NameValue struct {
        Name  string
        Value string
}

// RequestConfig holds configuration for a request
type RequestConfig struct {
        Name        string
        Method      string
        URL         string
        Headers     []NameValue
        QueryParams []NameValue
        Body        interface{}
}

// requestContext holds all the IDs and data needed for request processing
type requestContext struct {
        nodeID           idwrap.IDWrap
        endpointID       idwrap.IDWrap
        deltaEndpointID  idwrap.IDWrap
        exampleID        idwrap.IDWrap
        defaultExampleID idwrap.IDWrap
        deltaExampleID   idwrap.IDWrap
}

// ========================================
// Main Entry Points
// ========================================

// ConvertSimplifiedYAML converts simplified YAML to all the entities needed for import
func ConvertSimplifiedYAML(data []byte, collectionID, workspaceID idwrap.IDWrap) (SimplifiedYAMLResolved, error) <span class="cov8" title="1">{
        result := SimplifiedYAMLResolved{}

        // Parse the YAML
        yamlflowData, err := Parse(data)
        if err != nil </span><span class="cov8" title="1">{
                return result, err
        }</span>

        // Create collection
        <span class="cov8" title="1">collection := mcollection.Collection{
                ID:          collectionID,
                Name:        "YamlFlow Collection",
                WorkspaceID: workspaceID,
        }
        result.Collections = append(result.Collections, collection)

        // Convert flow data
        flow := yamlflowData.Flow
        flow.WorkspaceID = workspaceID
        result.Flows = append(result.Flows, flow)

        // Copy all flow nodes
        result.FlowNodes = yamlflowData.Nodes

        // Copy all edges
        result.FlowEdges = yamlflowData.Edges

        // Convert variables to flow variables
        for _, v := range yamlflowData.Variables </span><span class="cov8" title="1">{
                flowVar := mflowvariable.FlowVariable{
                        ID:      idwrap.NewNow(),
                        FlowID:  flow.ID,
                        Name:    v.VarKey,
                        Value:   v.Value,
                        Enabled: true,
                }
                result.FlowVariables = append(result.FlowVariables, flowVar)
        }</span>

        // Copy node implementations
        <span class="cov8" title="1">result.FlowRequestNodes = yamlflowData.RequestNodes
        result.FlowConditionNodes = yamlflowData.ConditionNodes
        result.FlowNoopNodes = yamlflowData.NoopNodes
        result.FlowForNodes = yamlflowData.ForNodes
        result.FlowForEachNodes = yamlflowData.ForEachNodes
        result.FlowJSNodes = yamlflowData.JSNodes

        // Process endpoints and examples
        for _, endpoint := range yamlflowData.Endpoints </span><span class="cov8" title="1">{
                // Set collection ID
                endpoint.CollectionID = collectionID
                result.Endpoints = append(result.Endpoints, endpoint)
        }</span>

        // Process examples
        <span class="cov8" title="1">for _, example := range yamlflowData.Examples </span><span class="cov8" title="1">{
                // Set collection ID
                example.CollectionID = collectionID
                result.Examples = append(result.Examples, example)
        }</span>

        // Copy headers, queries, and bodies
        <span class="cov8" title="1">result.Headers = yamlflowData.Headers
        result.Queries = yamlflowData.Queries
        result.RawBodies = yamlflowData.RawBodies

        // Set Prev/Next for endpoints
        for i := range result.Endpoints </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        prevID := &amp;result.Endpoints[i-1].ID
                        result.Endpoints[i].Prev = prevID
                }</span>
                <span class="cov8" title="1">if i &lt; len(result.Endpoints)-1 </span><span class="cov8" title="1">{
                        nextID := &amp;result.Endpoints[i+1].ID
                        result.Endpoints[i].Next = nextID
                }</span>
        }

        // Set Prev/Next for examples
        <span class="cov8" title="1">for i := range result.Examples </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        prevID := &amp;result.Examples[i-1].ID
                        result.Examples[i].Prev = prevID
                }</span>
                <span class="cov8" title="1">if i &lt; len(result.Examples)-1 </span><span class="cov8" title="1">{
                        nextID := &amp;result.Examples[i+1].ID
                        result.Examples[i].Next = nextID
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// Parse parses the yamlflow YAML and returns YamlFlowData
func Parse(data []byte) (*YamlFlowData, error) <span class="cov8" title="1">{
        var yamlflow YamlFlowFormat
        var rawYamlFlow map[string]any

        // First unmarshal to a generic map to handle step types properly
        if err := yaml.Unmarshal(data, &amp;rawYamlFlow); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to unmarshal yamlflow format: %w", err)
        }</span>

        // Then unmarshal to structured format
        <span class="cov8" title="1">if err := yaml.Unmarshal(data, &amp;yamlflow); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal yamlflow format: %w", err)
        }</span>

        <span class="cov8" title="1">if yamlflow.WorkspaceName == "" </span><span class="cov8" title="1">{
                return nil, newYamlFlowError("workspace_name is required", "workspace_name", nil)
        }</span>

        // Parse run field if present
        <span class="cov8" title="1">var runEntries []RunEntry
        if len(yamlflow.Run) &gt; 0 </span><span class="cov8" title="1">{
                parsedEntries, err := parseRunField(yamlflow.Run)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse run field: %w", err)
                }</span>
                <span class="cov8" title="1">runEntries = parsedEntries</span>
        }

        // Parse request templates (support both old and new format)
        <span class="cov8" title="1">var templates map[string]*requestTemplate
        if yamlflow.RequestTemplates != nil </span><span class="cov8" title="1">{
                templates = parseRequestTemplates(yamlflow.RequestTemplates)
        }</span> else<span class="cov8" title="1"> if yamlflow.Requests != nil </span><span class="cov8" title="1">{
                templates = parseRequests(yamlflow.Requests)
        }</span> else<span class="cov8" title="1"> {
                templates = make(map[string]*requestTemplate)
        }</span>

        // Initialize yamlflow data
        <span class="cov8" title="1">yamlflowData := &amp;YamlFlowData{
                Nodes:          make([]mnnode.MNode, 0),
                Edges:          make([]edge.Edge, 0),
                Variables:      make([]mvar.Var, 0),
                NoopNodes:      make([]mnnoop.NoopNode, 0),
                RequestNodes:   make([]mnrequest.MNRequest, 0),
                ConditionNodes: make([]mnif.MNIF, 0),
                ForNodes:       make([]mnfor.MNFor, 0),
                ForEachNodes:   make([]mnforeach.MNForEach, 0),
                JSNodes:        make([]mnjs.MNJS, 0),
                Endpoints:      make([]mitemapi.ItemApi, 0),
                Examples:       make([]mitemapiexample.ItemApiExample, 0),
                Headers:        make([]mexampleheader.Header, 0),
                Queries:        make([]mexamplequery.Query, 0),
                RawBodies:      make([]mbodyraw.ExampleBodyRaw, 0),
        }

        // Determine which flow to process
        var flowToProcess YamlFlowFlow
        var flowName string

        if len(runEntries) &gt; 0 </span><span class="cov8" title="1">{
                // If run field is present, use the first flow specified there
                flowName = runEntries[0].Flow
                found := false
                for _, f := range yamlflow.Flows </span><span class="cov8" title="1">{
                        if f.Name == flowName </span><span class="cov8" title="1">{
                                flowToProcess = f
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("flow '%s' specified in run field not found", flowName)
                }</span>
        } else<span class="cov8" title="1"> {
                // Otherwise, process first flow (backward compatibility)
                if len(yamlflow.Flows) == 0 </span><span class="cov8" title="1">{
                        return nil, newYamlFlowError("at least one flow is required", "flows", nil)
                }</span>
                <span class="cov8" title="1">flowToProcess = yamlflow.Flows[0]
                flowName = flowToProcess.Name</span>
        }

        <span class="cov8" title="1">flowID := idwrap.NewNow()

        yamlflowData.Flow = mflow.Flow{
                ID:   flowID,
                Name: flowName,
        }

        // Process flow variables
        // Note: You can set a "timeout" variable to control flow execution timeout (in seconds)
        // Default is 60 seconds if not specified. Example: - name: timeout, value: "300"
        for _, v := range flowToProcess.Variables </span><span class="cov8" title="1">{
                yamlflowData.Variables = append(yamlflowData.Variables, mvar.Var{
                        VarKey: v.Name,
                        Value:  v.Value,
                })
        }</span>

        // Create variable map for resolution
        <span class="cov8" title="1">varMap := varsystem.NewVarMap(yamlflowData.Variables)

        // Create start node
        startNodeID := idwrap.NewNow()
        startNode := mnnode.MNode{
                ID:       startNodeID,
                FlowID:   flowID,
                Name:     "Start",
                NodeKind: mnnode.NODE_KIND_NO_OP,
        }
        yamlflowData.Nodes = append(yamlflowData.Nodes, startNode)

        noopNode := mnnoop.NoopNode{
                FlowNodeID: startNodeID,
                Type:       mnnoop.NODE_NO_OP_KIND_START,
        }
        yamlflowData.NoopNodes = append(yamlflowData.NoopNodes, noopNode)

        // Get raw steps
        rawFlows, ok := rawYamlFlow[fieldFlows].([]any)
        if !ok || len(rawFlows) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid flows format")
        }</span>

        <span class="cov8" title="1">var rawSteps []map[string]any
        for _, rf := range rawFlows </span><span class="cov8" title="1">{
                rfMap, ok := rf.(map[string]any)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if name, ok := rfMap[fieldName].(string); ok &amp;&amp; name == flowName </span><span class="cov8" title="1">{
                        if steps, ok := rfMap[fieldSteps].([]any); ok </span><span class="cov8" title="1">{
                                for _, step := range steps </span><span class="cov8" title="1">{
                                        if stepMap, ok := step.(map[string]any); ok &amp;&amp; len(stepMap) == 1 </span><span class="cov8" title="1">{
                                                rawSteps = append(rawSteps, stepMap)
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">break</span>
                }
        }

        // Process steps
        <span class="cov8" title="1">nodeInfoMap := make(map[string]*nodeInfo)
        nodeList := make([]*nodeInfo, 0)

        for i, rawStep := range rawSteps </span><span class="cov8" title="1">{
                for stepType, stepData := range rawStep </span><span class="cov8" title="1">{
                        dataMap, ok := stepData.(map[string]any)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid step data format")
                        }</span>

                        <span class="cov8" title="1">nodeName, ok := dataMap[fieldName].(string)
                        if !ok || nodeName == "" </span><span class="cov8" title="1">{
                                return nil, newYamlFlowError(fmt.Sprintf("missing required '%s' field", fieldName), "", nil)
                        }</span>

                        <span class="cov8" title="1">nodeID := idwrap.NewNow()
                        info := &amp;nodeInfo{
                                id:    nodeID,
                                name:  nodeName,
                                index: i,
                        }

                        // Get dependencies
                        if deps, ok := dataMap[fieldDependsOn].([]any); ok </span><span class="cov8" title="1">{
                                for _, dep := range deps </span><span class="cov8" title="1">{
                                        if depStr, ok := dep.(string); ok &amp;&amp; depStr != "" </span><span class="cov8" title="1">{
                                                info.dependsOn = append(info.dependsOn, depStr)
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">nodeInfoMap[nodeName] = info
                        nodeList = append(nodeList, info)

                        // Process step based on type
                        switch stepType </span>{
                        case stepTypeRequest:<span class="cov8" title="1">
                                if err := processRequestStepForNode(nodeName, nodeID, flowID, dataMap, templates, varMap, yamlflowData); err != nil </span><span class="cov8" title="1">{
                                        return nil, err
                                }</span>
                        case stepTypeIf:<span class="cov8" title="1">
                                if err := processIfStepForNode(nodeName, nodeID, flowID, dataMap, yamlflowData); err != nil </span><span class="cov8" title="1">{
                                        return nil, err
                                }</span>
                        case stepTypeFor:<span class="cov8" title="1">
                                if err := processForStepForNode(nodeName, nodeID, flowID, dataMap, yamlflowData); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        case stepTypeForEach:<span class="cov8" title="1">
                                if err := processForEachStepForNode(nodeName, nodeID, flowID, dataMap, yamlflowData); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        case stepTypeJS:<span class="cov8" title="1">
                                if err := processJSStepForNode(nodeName, nodeID, flowID, dataMap, yamlflowData); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        default:<span class="cov8" title="1">
                                return nil, newYamlFlowError("unknown step type", "stepType", stepType)</span>
                        }
                }
        }

        // Create edges
        <span class="cov8" title="1">createEdgesForFlow(flowID, startNodeID, nodeInfoMap, nodeList, rawSteps, yamlflowData)

        // Handle run dependencies if present
        if len(runEntries) &gt; 0 </span><span class="cov8" title="1">{
                processRunDependencies(runEntries, flowName, nodeInfoMap, yamlflowData)
        }</span>

        // Position nodes
        <span class="cov8" title="1">if err := positionNodes(yamlflowData); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return yamlflowData, nil</span>
}

// ========================================
// Parsing Helper Functions
// ========================================

// parseRunField parses the run field into RunEntry structs
func parseRunField(runArray []map[string]any) ([]RunEntry, error) <span class="cov8" title="1">{
        var entries []RunEntry

        for _, itemMap := range runArray </span><span class="cov8" title="1">{
                flowName, ok := itemMap[fieldFlow].(string)
                if !ok || flowName == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("each run entry must have a 'flow' field")
                }</span>

                <span class="cov8" title="1">entry := RunEntry{
                        Flow: flowName,
                }

                // Parse depends_on field
                if deps, ok := itemMap[fieldDependsOn]; ok </span><span class="cov8" title="1">{
                        switch v := deps.(type) </span>{
                        case string:<span class="cov8" title="1">
                                // Single dependency
                                entry.DependsOn = []string{v}</span>
                        case []any:<span class="cov8" title="1">
                                // Multiple dependencies
                                for _, dep := range v </span><span class="cov8" title="1">{
                                        if depStr, ok := dep.(string); ok </span><span class="cov8" title="1">{
                                                entry.DependsOn = append(entry.DependsOn, depStr)
                                        }</span>
                                }
                        default:<span class="cov8" title="1">
                                return nil, fmt.Errorf("depends_on must be a string or array of strings")</span>
                        }
                }

                <span class="cov8" title="1">entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">return entries, nil</span>
}

// parseRequestTemplates parses request templates into a map
func parseRequestTemplates(templates map[string]map[string]any) map[string]*requestTemplate <span class="cov8" title="1">{
        result := make(map[string]*requestTemplate)
        for name, tmpl := range templates </span><span class="cov8" title="1">{
                result[name] = parseRequestDataFromMap(tmpl)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// parseRequests parses the new requests format into templates
func parseRequests(requests []map[string]any) map[string]*requestTemplate <span class="cov8" title="1">{
        result := make(map[string]*requestTemplate)

        for _, req := range requests </span><span class="cov8" title="1">{
                // Get the request name
                name, ok := req[fieldName].(string)
                if !ok || name == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">result[name] = parseRequestDataFromMap(req)</span>
        }

        <span class="cov8" title="1">return result</span>
}

// parseRequestDataFromMap parses a single request template from data
func parseRequestDataFromMap(data map[string]any) *requestTemplate <span class="cov8" title="1">{
        rt := &amp;requestTemplate{}
        if method, ok := data[fieldMethod].(string); ok &amp;&amp; method != "" </span><span class="cov8" title="1">{
                rt.method = method
        }</span>
        <span class="cov8" title="1">if url, ok := data[fieldURL].(string); ok &amp;&amp; url != "" </span><span class="cov8" title="1">{
                rt.url = url
        }</span>

        // Parse headers - support both map and array formats
        <span class="cov8" title="1">if headers, ok := data[fieldHeaders].(map[string]any); ok </span><span class="cov8" title="1">{
                // Map format: {"X-Header": "value"}
                for k, v := range headers </span><span class="cov8" title="1">{
                        if str, ok := v.(string); ok </span><span class="cov8" title="1">{
                                rt.headers = append(rt.headers, map[string]string{
                                        fieldName:  k,
                                        fieldValue: str,
                                })
                        }</span>
                }
        } else<span class="cov8" title="1"> if headers, ok := data[fieldHeaders].([]any); ok </span><span class="cov8" title="1">{
                // Array format (for parseRequests compatibility)
                for _, h := range headers </span><span class="cov8" title="1">{
                        if hMap, ok := h.(map[string]any); ok </span><span class="cov8" title="1">{
                                strMap := make(map[string]string)
                                for k, v := range hMap </span><span class="cov8" title="1">{
                                        if str, ok := v.(string); ok </span><span class="cov8" title="1">{
                                                strMap[k] = str
                                        }</span>
                                }
                                <span class="cov8" title="1">rt.headers = append(rt.headers, strMap)</span>
                        } else<span class="cov0" title="0"> if hMap, ok := h.(map[string]string); ok </span><span class="cov0" title="0">{
                                rt.headers = append(rt.headers, hMap)
                        }</span>
                }
        }

        // Parse query params - support both map and array formats
        <span class="cov8" title="1">if queryParams, ok := data[fieldQueryParams].(map[string]any); ok </span><span class="cov8" title="1">{
                // Map format: {"param": "value"}
                for k, v := range queryParams </span><span class="cov8" title="1">{
                        if str, ok := v.(string); ok </span><span class="cov8" title="1">{
                                rt.queryParams = append(rt.queryParams, map[string]string{
                                        fieldName:  k,
                                        fieldValue: str,
                                })
                        }</span>
                }
        } else<span class="cov8" title="1"> if queryParams, ok := data[fieldQueryParams].([]any); ok </span><span class="cov0" title="0">{
                // Array format (for parseRequests compatibility)
                for _, q := range queryParams </span><span class="cov0" title="0">{
                        if qMap, ok := q.(map[string]any); ok </span><span class="cov0" title="0">{
                                strMap := make(map[string]string)
                                for k, v := range qMap </span><span class="cov0" title="0">{
                                        if str, ok := v.(string); ok </span><span class="cov0" title="0">{
                                                strMap[k] = str
                                        }</span>
                                }
                                <span class="cov0" title="0">rt.queryParams = append(rt.queryParams, strMap)</span>
                        } else<span class="cov0" title="0"> if qMap, ok := q.(map[string]string); ok </span><span class="cov0" title="0">{
                                rt.queryParams = append(rt.queryParams, qMap)
                        }</span>
                }
        }

        <span class="cov8" title="1">if body, ok := data[fieldBody].(map[string]any); ok </span><span class="cov8" title="1">{
                rt.body = body
        }</span>

        <span class="cov8" title="1">return rt</span>
}

// ========================================
// Node Processing Functions
// ========================================

// addNodeWithName adds a flow node with the given name
func addNodeWithName(nodeName string, nodeID, flowID idwrap.IDWrap, kind mnnode.NodeKind, data *YamlFlowData) <span class="cov8" title="1">{
        data.Nodes = append(data.Nodes, mnnode.MNode{
                ID:       nodeID,
                FlowID:   flowID,
                Name:     nodeName,
                NodeKind: kind,
        })
}</span>

// processRequestStepForNode processes a request step for a given node
func processRequestStepForNode(nodeName string, nodeID, flowID idwrap.IDWrap, stepData map[string]any, templates map[string]*requestTemplate, varMap varsystem.VarMap, data *YamlFlowData) error <span class="cov8" title="1">{
        // Initialize request configuration
        method, url := "GET", ""
        var templateHeaders, templateQueries, stepHeaderOverrides, stepQueryOverrides []map[string]string
        var templateBody, stepBodyOverride map[string]any
        var usingTemplate bool

        // Check if using template
        if useRequest, ok := stepData[fieldUseRequest].(string); ok &amp;&amp; useRequest != "" </span><span class="cov8" title="1">{
                if tmpl, exists := templates[useRequest]; exists </span><span class="cov8" title="1">{
                        usingTemplate = true
                        templateHeaders = tmpl.headers
                        templateQueries = tmpl.queryParams
                        templateBody = tmpl.body
                        if tmpl.method != "" </span><span class="cov8" title="1">{
                                method = tmpl.method
                        }</span>
                        <span class="cov8" title="1">if tmpl.url != "" </span><span class="cov8" title="1">{
                                url = tmpl.url
                        }</span>
                } else<span class="cov0" title="0"> {
                        return newYamlFlowError(fmt.Sprintf("request step '%s' references unknown template '%s'", nodeName, useRequest), fieldUseRequest, useRequest)
                }</span>
        }

        // Override with step-specific data
        <span class="cov8" title="1">if m, ok := stepData[fieldMethod].(string); ok &amp;&amp; m != "" </span><span class="cov8" title="1">{
                method = m
        }</span>
        <span class="cov8" title="1">if u, ok := stepData[fieldURL].(string); ok &amp;&amp; u != "" </span><span class="cov8" title="1">{
                url = u
        }</span>
        // URL is required either from template or step definition
        <span class="cov8" title="1">if url == "" </span><span class="cov8" title="1">{
                return newYamlFlowError(fmt.Sprintf("request step '%s' missing required url", nodeName), fieldURL, nil)
        }</span>

        // Parse step overrides
        <span class="cov8" title="1">if h, ok := stepData[fieldHeaders].(map[string]any); ok </span><span class="cov8" title="1">{
                for k, v := range h </span><span class="cov8" title="1">{
                        if vs, ok := v.(string); ok </span><span class="cov8" title="1">{
                                stepHeaderOverrides = append(stepHeaderOverrides, map[string]string{fieldName: k, fieldValue: vs})
                        }</span>
                }
        }
        <span class="cov8" title="1">if q, ok := stepData[fieldQueryParams].(map[string]any); ok </span><span class="cov8" title="1">{
                for k, v := range q </span><span class="cov8" title="1">{
                        if vs, ok := v.(string); ok </span><span class="cov8" title="1">{
                                stepQueryOverrides = append(stepQueryOverrides, map[string]string{fieldName: k, fieldValue: vs})
                        }</span>
                }
        }
        <span class="cov8" title="1">if b, ok := stepData[fieldBody].(map[string]any); ok </span><span class="cov8" title="1">{
                stepBodyOverride = b
        }</span>

        // Create all request entities
        <span class="cov8" title="1">ctx := createRequestEntitiesForNode(nodeName, nodeID, flowID, url, method, data)

        // Process headers
        processNameValuePairsForExamples(
                ctx.exampleID, ctx.defaultExampleID, ctx.deltaExampleID,
                templateHeaders, stepHeaderOverrides,
                usingTemplate,
                varMap,
                func(name, value string, id, exampleID idwrap.IDWrap, deltaParentID *idwrap.IDWrap) interface{} </span><span class="cov8" title="1">{
                        return mexampleheader.Header{
                                ID:            id,
                                ExampleID:     exampleID,
                                HeaderKey:     name,
                                Value:         value,
                                DeltaParentID: deltaParentID,
                                Enable:        true,
                        }
                }</span>,
                func(item interface{}) <span class="cov8" title="1">{
                        data.Headers = append(data.Headers, item.(mexampleheader.Header))
                }</span>,
                data,
        )

        // Process query parameters
        <span class="cov8" title="1">processNameValuePairsForExamples(
                ctx.exampleID, ctx.defaultExampleID, ctx.deltaExampleID,
                templateQueries, stepQueryOverrides,
                usingTemplate,
                varMap,
                func(name, value string, id, exampleID idwrap.IDWrap, deltaParentID *idwrap.IDWrap) interface{} </span><span class="cov8" title="1">{
                        return mexamplequery.Query{
                                ID:            id,
                                ExampleID:     exampleID,
                                QueryKey:      name,
                                Value:         value,
                                DeltaParentID: deltaParentID,
                                Enable:        true,
                        }
                }</span>,
                func(item interface{}) <span class="cov8" title="1">{
                        data.Queries = append(data.Queries, item.(mexamplequery.Query))
                }</span>,
                data,
        )

        // Process body
        <span class="cov8" title="1">var bodyData []byte
        if usingTemplate &amp;&amp; templateBody != nil </span><span class="cov8" title="1">{
                // Use template body for base
                bodyData, _ = json.Marshal(templateBody)
                addBodyToExamples(ctx, bodyData, data)

                // If there's an override, update delta only
                if stepBodyOverride != nil </span><span class="cov8" title="1">{
                        overrideData, err := json.Marshal(stepBodyOverride)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to marshal body: %w", err)
                        }</span>
                        // Update only the delta body
                        <span class="cov8" title="1">for i := range data.RawBodies </span><span class="cov8" title="1">{
                                if data.RawBodies[i].ExampleID == ctx.deltaExampleID </span><span class="cov8" title="1">{
                                        data.RawBodies[i].Data = overrideData
                                        break</span>
                                }
                        }
                }
        } else<span class="cov8" title="1"> if stepBodyOverride != nil </span><span class="cov8" title="1">{
                // No template, use step body for all
                bodyData, _ = json.Marshal(stepBodyOverride)
                addBodyToExamples(ctx, bodyData, data)
        }</span> else<span class="cov8" title="1"> {
                // No body at all
                addBodyToExamples(ctx, nil, data)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// processIfStepForNode processes an if step for a given node
func processIfStepForNode(nodeName string, nodeID, flowID idwrap.IDWrap, stepData map[string]any, data *YamlFlowData) error <span class="cov8" title="1">{
        addNodeWithName(nodeName, nodeID, flowID, mnnode.NODE_KIND_CONDITION, data)

        condition, ok := stepData[fieldCondition].(string)
        if !ok || condition == "" </span><span class="cov8" title="1">{
                return newYamlFlowError(fmt.Sprintf("if step '%s' missing required condition", nodeName), fieldCondition, nil)
        }</span>

        <span class="cov8" title="1">data.ConditionNodes = append(data.ConditionNodes, mnif.MNIF{
                FlowNodeID: nodeID,
                Condition: mcondition.Condition{
                        Comparisons: mcondition.Comparison{Expression: condition},
                },
        })
        return nil</span>
}

// processForStepForNode processes a for step for a given node
func processForStepForNode(nodeName string, nodeID, flowID idwrap.IDWrap, stepData map[string]any, data *YamlFlowData) error <span class="cov8" title="1">{
        addNodeWithName(nodeName, nodeID, flowID, mnnode.NODE_KIND_FOR, data)

        iterCount := 1 // Default to 1 if not specified
        if val, ok := stepData[fieldIterCount]; ok </span><span class="cov8" title="1">{
                if i, ok := val.(int); ok </span><span class="cov8" title="1">{
                        iterCount = i
                }</span> else<span class="cov0" title="0"> if f, ok := val.(float64); ok </span><span class="cov0" title="0">{
                        iterCount = int(f)
                }</span>
        }

        <span class="cov8" title="1">data.ForNodes = append(data.ForNodes, mnfor.MNFor{
                FlowNodeID: nodeID,
                IterCount:  int64(iterCount),
        })
        return nil</span>
}

// processForEachStepForNode processes a for_each step for a given node
func processForEachStepForNode(nodeName string, nodeID, flowID idwrap.IDWrap, stepData map[string]any, data *YamlFlowData) error <span class="cov8" title="1">{
        addNodeWithName(nodeName, nodeID, flowID, mnnode.NODE_KIND_FOR_EACH, data)

        items, ok := stepData[fieldItems].(string)
        if !ok || items == "" </span><span class="cov0" title="0">{
                return newYamlFlowError(fmt.Sprintf("for_each step '%s' missing required items", nodeName), fieldItems, nil)
        }</span>

        <span class="cov8" title="1">data.ForEachNodes = append(data.ForEachNodes, mnforeach.MNForEach{
                FlowNodeID:     nodeID,
                IterExpression: items,
        })
        return nil</span>
}

// processJSStepForNode processes a JavaScript step for a given node
func processJSStepForNode(nodeName string, nodeID, flowID idwrap.IDWrap, stepData map[string]any, data *YamlFlowData) error <span class="cov8" title="1">{
        addNodeWithName(nodeName, nodeID, flowID, mnnode.NODE_KIND_JS, data)

        code, ok := stepData[fieldCode].(string)
        if !ok || code == "" </span><span class="cov0" title="0">{
                return newYamlFlowError(fmt.Sprintf("js step '%s' missing required code", nodeName), fieldCode, nil)
        }</span>

        <span class="cov8" title="1">data.JSNodes = append(data.JSNodes, mnjs.MNJS{
                FlowNodeID: nodeID,
                Code:       []byte(code),
        })
        return nil</span>
}

// ========================================
// Request Helper Functions
// ========================================

// createRequestEntitiesForNode creates all the entities needed for a request node
func createRequestEntitiesForNode(nodeName string, nodeID, flowID idwrap.IDWrap, url, method string, data *YamlFlowData) *requestContext <span class="cov8" title="1">{
        ctx := &amp;requestContext{
                nodeID:           nodeID,
                endpointID:       idwrap.NewNow(),
                deltaEndpointID:  idwrap.NewNow(),
                exampleID:        idwrap.NewNow(),
                defaultExampleID: idwrap.NewNow(),
                deltaExampleID:   idwrap.NewNow(),
        }

        // Add node
        data.Nodes = append(data.Nodes, mnnode.MNode{
                ID:       nodeID,
                FlowID:   flowID,
                Name:     nodeName,
                NodeKind: mnnode.NODE_KIND_REQUEST,
        })

        // Add endpoints
        data.Endpoints = append(data.Endpoints,
                mitemapi.ItemApi{ID: ctx.endpointID, Name: nodeName, Url: url, Method: method},
                mitemapi.ItemApi{
                        ID:            ctx.deltaEndpointID,
                        Name:          fmt.Sprintf("%s (delta)", nodeName),
                        Url:           url,
                        Method:        method,
                        DeltaParentID: &amp;ctx.endpointID,
                        Hidden:        true,
                },
        )

        // Add examples
        data.Examples = append(data.Examples,
                mitemapiexample.ItemApiExample{
                        ID:        ctx.exampleID,
                        Name:      nodeName,
                        ItemApiID: ctx.endpointID,
                        IsDefault: true,
                        BodyType:  mitemapiexample.BodyTypeRaw,
                },
                mitemapiexample.ItemApiExample{
                        ID:        ctx.defaultExampleID,
                        Name:      fmt.Sprintf("%s (default)", nodeName),
                        ItemApiID: ctx.endpointID,
                        IsDefault: false,
                        BodyType:  mitemapiexample.BodyTypeRaw,
                },
                mitemapiexample.ItemApiExample{
                        ID:              ctx.deltaExampleID,
                        Name:            fmt.Sprintf("%s (delta)", nodeName),
                        ItemApiID:       ctx.deltaEndpointID,
                        IsDefault:       true,
                        VersionParentID: &amp;ctx.defaultExampleID,
                        BodyType:        mitemapiexample.BodyTypeRaw,
                },
        )

        // Add request node
        data.RequestNodes = append(data.RequestNodes, mnrequest.MNRequest{
                FlowNodeID:      nodeID,
                EndpointID:      &amp;ctx.endpointID,
                ExampleID:       &amp;ctx.exampleID,
                DeltaEndpointID: &amp;ctx.deltaEndpointID,
                DeltaExampleID:  &amp;ctx.deltaExampleID,
        })

        return ctx
}</span>

// addBodyToExamples adds body data for all three examples
func addBodyToExamples(ctx *requestContext, bodyData []byte, data *YamlFlowData) <span class="cov8" title="1">{
        if bodyData == nil </span><span class="cov8" title="1">{
                bodyData = []byte("{}")
        }</span>

        <span class="cov8" title="1">visualMode := mbodyraw.VisualizeModeJSON
        if !json.Valid(bodyData) </span><span class="cov0" title="0">{
                visualMode = mbodyraw.VisualizeModeText
        }</span>

        <span class="cov8" title="1">for _, exampleID := range []idwrap.IDWrap{ctx.exampleID, ctx.defaultExampleID, ctx.deltaExampleID} </span><span class="cov8" title="1">{
                data.RawBodies = append(data.RawBodies, mbodyraw.ExampleBodyRaw{
                        ID:            idwrap.NewNow(),
                        ExampleID:     exampleID,
                        Data:          bodyData,
                        CompressType:  compress.CompressTypeNone,
                        VisualizeMode: visualMode,
                })
        }</span>
}

// ========================================
// Name-Value Processing Functions
// ========================================

// convertToNameValueMap converts various formats to a simple name-value map
func convertToNameValueMap(pairs []map[string]string) map[string]string <span class="cov8" title="1">{
        result := make(map[string]string)
        for _, p := range pairs </span><span class="cov8" title="1">{
                if name, ok := p[fieldName]; ok </span><span class="cov8" title="1">{
                        if value, ok := p[fieldValue]; ok </span><span class="cov8" title="1">{
                                result[name] = value
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Direct map format
                        for k, v := range p </span><span class="cov0" title="0">{
                                if k != fieldName &amp;&amp; k != fieldValue </span><span class="cov0" title="0">{
                                        result[k] = v
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return result</span>
}

// processNameValuePairs processes headers or query parameters generically
func processNameValuePairsForExamples(
        exampleID, defaultExampleID, deltaExampleID idwrap.IDWrap,
        templatePairs, overridePairs []map[string]string,
        usingTemplate bool,
        varMap varsystem.VarMap,
        createFunc func(name, value string, id, exampleID idwrap.IDWrap, deltaParentID *idwrap.IDWrap) interface{},
        appendFunc func(interface{}),
        data *YamlFlowData,
) <span class="cov8" title="1">{
        if usingTemplate </span><span class="cov8" title="1">{
                templateMap := convertToNameValueMap(templatePairs)
                overrideMap := convertToNameValueMap(overridePairs)
                processedNames := make(map[string]bool)

                // Process template items
                for name, templateValue := range templateMap </span><span class="cov8" title="1">{
                        processedNames[name] = true

                        // Base item
                        baseItem := createFunc(name, templateValue, idwrap.NewNow(), exampleID, nil)
                        appendFunc(baseItem)

                        // Default item with resolved value
                        resolvedValue, _ := varMap.ReplaceVars(templateValue)
                        defaultItem := createFunc(name, resolvedValue, idwrap.NewNow(), defaultExampleID, nil)
                        appendFunc(defaultItem)

                        // Check if overridden
                        if overrideValue, isOverridden := overrideMap[name]; isOverridden </span><span class="cov8" title="1">{
                                // Need to get ID from the actual type
                                var defaultID idwrap.IDWrap
                                switch v := defaultItem.(type) </span>{
                                case mexampleheader.Header:<span class="cov8" title="1">
                                        defaultID = v.ID</span>
                                case mexamplequery.Query:<span class="cov8" title="1">
                                        defaultID = v.ID</span>
                                }
                                <span class="cov8" title="1">deltaItem := createFunc(name, overrideValue, idwrap.NewNow(), deltaExampleID, &amp;defaultID)
                                appendFunc(deltaItem)</span>
                        }
                }

                // Process override-only items
                <span class="cov8" title="1">for name, overrideValue := range overrideMap </span><span class="cov8" title="1">{
                        if !processedNames[name] </span><span class="cov8" title="1">{
                                // Base item
                                baseItem := createFunc(name, overrideValue, idwrap.NewNow(), exampleID, nil)
                                appendFunc(baseItem)

                                // Default item
                                resolvedValue, _ := varMap.ReplaceVars(overrideValue)
                                defaultItem := createFunc(name, resolvedValue, idwrap.NewNow(), defaultExampleID, nil)
                                appendFunc(defaultItem)

                                // Delta item
                                var defaultID idwrap.IDWrap
                                switch v := defaultItem.(type) </span>{
                                case mexampleheader.Header:<span class="cov8" title="1">
                                        defaultID = v.ID</span>
                                case mexamplequery.Query:<span class="cov8" title="1">
                                        defaultID = v.ID</span>
                                }
                                <span class="cov8" title="1">deltaItem := createFunc(name, overrideValue, idwrap.NewNow(), deltaExampleID, &amp;defaultID)
                                appendFunc(deltaItem)</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                // No template - process directly
                directMap := convertToNameValueMap(overridePairs)
                for name, value := range directMap </span><span class="cov8" title="1">{
                        // Base item
                        baseItem := createFunc(name, value, idwrap.NewNow(), exampleID, nil)
                        appendFunc(baseItem)

                        // Default item
                        resolvedValue, _ := varMap.ReplaceVars(value)
                        defaultItem := createFunc(name, resolvedValue, idwrap.NewNow(), defaultExampleID, nil)
                        appendFunc(defaultItem)

                        // Delta item if has variables
                        if varsystem.CheckStringHasAnyVarKey(value) </span><span class="cov8" title="1">{
                                var defaultID idwrap.IDWrap
                                switch v := defaultItem.(type) </span>{
                                case mexampleheader.Header:<span class="cov8" title="1">
                                        defaultID = v.ID</span>
                                case mexamplequery.Query:<span class="cov8" title="1">
                                        defaultID = v.ID</span>
                                }
                                <span class="cov8" title="1">deltaItem := createFunc(name, value, idwrap.NewNow(), deltaExampleID, &amp;defaultID)
                                appendFunc(deltaItem)</span>
                        }
                }
        }
}

// ========================================
// Edge Creation Functions
// ========================================

// createEdgesForFlow creates edges based on dependencies and sequential order
func createEdgesForFlow(flowID, startNodeID idwrap.IDWrap, nodeInfoMap map[string]*nodeInfo, nodeList []*nodeInfo, rawSteps []map[string]any, data *YamlFlowData) <span class="cov8" title="1">{
        // Track which nodes have incoming edges
        hasIncoming := make(map[idwrap.IDWrap]bool)

        // Create edges for explicit dependencies
        for _, info := range nodeList </span><span class="cov8" title="1">{
                for _, depName := range info.dependsOn </span><span class="cov8" title="1">{
                        if depInfo, exists := nodeInfoMap[depName]; exists </span><span class="cov8" title="1">{
                                edge := edge.Edge{
                                        ID:            idwrap.NewNow(),
                                        FlowID:        flowID,
                                        SourceID:      depInfo.id,
                                        TargetID:      info.id,
                                        SourceHandler: edge.HandleUnspecified,
                                }
                                data.Edges = append(data.Edges, edge)
                                hasIncoming[info.id] = true
                        }</span>
                }
        }

        // Create edges for sequential steps (implicit dependencies)
        <span class="cov8" title="1">for i := 0; i &lt; len(nodeList)-1; i++ </span><span class="cov8" title="1">{
                current := nodeList[i]
                next := nodeList[i+1]

                // Only create sequential edge if next node doesn't have explicit dependencies
                if len(next.dependsOn) == 0 &amp;&amp; !hasIncoming[next.id] </span><span class="cov8" title="1">{
                        edge := edge.Edge{
                                ID:            idwrap.NewNow(),
                                FlowID:        flowID,
                                SourceID:      current.id,
                                TargetID:      next.id,
                                SourceHandler: edge.HandleUnspecified,
                        }
                        data.Edges = append(data.Edges, edge)
                        hasIncoming[next.id] = true
                }</span>
        }

        // Connect nodes without incoming edges to start node
        <span class="cov8" title="1">for _, info := range nodeList </span><span class="cov8" title="1">{
                if !hasIncoming[info.id] </span><span class="cov8" title="1">{
                        edge := edge.Edge{
                                ID:            idwrap.NewNow(),
                                FlowID:        flowID,
                                SourceID:      startNodeID,
                                TargetID:      info.id,
                                SourceHandler: edge.HandleUnspecified,
                        }
                        data.Edges = append(data.Edges, edge)
                }</span>
        }

        // Create edges for control flow nodes
        // We need to parse the original step data to get then/else/loop targets
        <span class="cov8" title="1">for _, rawStep := range rawSteps </span><span class="cov8" title="1">{
                for stepType, stepData := range rawStep </span><span class="cov8" title="1">{
                        dataMap, _ := stepData.(map[string]any)
                        nodeName, _ := dataMap[fieldName].(string)
                        nodeID := nodeInfoMap[nodeName].id

                        switch stepType </span>{
                        case stepTypeIf:<span class="cov8" title="1">
                                // Create edges for then/else branches
                                if thenTarget, ok := dataMap[fieldThen].(string); ok &amp;&amp; thenTarget != "" </span><span class="cov8" title="1">{
                                        if targetID, exists := nodeInfoMap[thenTarget]; exists </span><span class="cov8" title="1">{
                                                edge := edge.Edge{
                                                        ID:            idwrap.NewNow(),
                                                        FlowID:        flowID,
                                                        SourceID:      nodeID,
                                                        TargetID:      targetID.id,
                                                        SourceHandler: edge.HandleThen,
                                                }
                                                data.Edges = append(data.Edges, edge)
                                                hasIncoming[targetID.id] = true
                                        }</span>
                                }

                                <span class="cov8" title="1">if elseTarget, ok := dataMap[fieldElse].(string); ok &amp;&amp; elseTarget != "" </span><span class="cov8" title="1">{
                                        if targetID, exists := nodeInfoMap[elseTarget]; exists </span><span class="cov8" title="1">{
                                                edge := edge.Edge{
                                                        ID:            idwrap.NewNow(),
                                                        FlowID:        flowID,
                                                        SourceID:      nodeID,
                                                        TargetID:      targetID.id,
                                                        SourceHandler: edge.HandleElse,
                                                }
                                                data.Edges = append(data.Edges, edge)
                                                hasIncoming[targetID.id] = true
                                        }</span>
                                }

                        case stepTypeFor, stepTypeForEach:<span class="cov8" title="1">
                                // Create edge for loop body
                                if loopTarget, ok := dataMap[fieldLoop].(string); ok &amp;&amp; loopTarget != "" </span><span class="cov8" title="1">{
                                        if targetID, exists := nodeInfoMap[loopTarget]; exists </span><span class="cov8" title="1">{
                                                edge := edge.Edge{
                                                        ID:            idwrap.NewNow(),
                                                        FlowID:        flowID,
                                                        SourceID:      nodeID,
                                                        TargetID:      targetID.id,
                                                        SourceHandler: edge.HandleLoop,
                                                }
                                                data.Edges = append(data.Edges, edge)
                                                hasIncoming[targetID.id] = true
                                        }</span>
                                }
                        }
                }
        }
}

// processRunDependencies handles dependencies specified in the run field
func processRunDependencies(runEntries []RunEntry, currentFlowName string, nodeInfoMap map[string]*nodeInfo, data *YamlFlowData) <span class="cov8" title="1">{
        // Find the current flow's run entry
        var currentEntry *RunEntry
        for i := range runEntries </span><span class="cov8" title="1">{
                if runEntries[i].Flow == currentFlowName </span><span class="cov8" title="1">{
                        currentEntry = &amp;runEntries[i]
                        break</span>
                }
        }

        <span class="cov8" title="1">if currentEntry == nil || len(currentEntry.DependsOn) == 0 </span><span class="cov8" title="1">{
                // No dependencies to process
                return
        }</span>

        // For the current implementation, we'll create implicit dependencies
        // by making the first node of the current flow depend on the last nodes
        // of the dependency flows/requests

        // Find the first node in the current flow (excluding Start node)
        <span class="cov0" title="0">var firstNode *nodeInfo
        for _, node := range nodeInfoMap </span><span class="cov0" title="0">{
                if firstNode == nil || node.index &lt; firstNode.index </span><span class="cov0" title="0">{
                        firstNode = node
                }</span>
        }

        <span class="cov0" title="0">if firstNode == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Process each dependency
        <span class="cov0" title="0">for _, dep := range currentEntry.DependsOn </span><span class="cov0" title="0">{
                // Check if dependency is a node in the current flow
                if depNode, exists := nodeInfoMap[dep]; exists </span><span class="cov0" title="0">{
                        // Add this dependency to the first node's dependsOn list
                        firstNode.dependsOn = append(firstNode.dependsOn, depNode.name)
                }</span>
                // Note: Cross-flow dependencies would require more complex handling
                // which is not currently supported by the single-flow architecture
        }
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package ioworkspace

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        devtoolsdb "the-dev-tools/db"
        "the-dev-tools/server/pkg/flow/edge"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/massert"
        "the-dev-tools/server/pkg/model/massertres"
        "the-dev-tools/server/pkg/model/mbodyform"
        "the-dev-tools/server/pkg/model/mbodyraw"
        "the-dev-tools/server/pkg/model/mbodyurl"
        "the-dev-tools/server/pkg/model/mcollection"
        "the-dev-tools/server/pkg/model/mcondition"
        "the-dev-tools/server/pkg/model/menv"
        "the-dev-tools/server/pkg/model/mexampleheader"
        "the-dev-tools/server/pkg/model/mexamplequery"
        "the-dev-tools/server/pkg/model/mexampleresp"
        "the-dev-tools/server/pkg/model/mexamplerespheader"
        "the-dev-tools/server/pkg/model/mflow"
        "the-dev-tools/server/pkg/model/mflowvariable"
        "the-dev-tools/server/pkg/model/mitemapi"
        "the-dev-tools/server/pkg/model/mitemapiexample"
        "the-dev-tools/server/pkg/model/mitemfolder"
        "the-dev-tools/server/pkg/model/mnnode"
        "the-dev-tools/server/pkg/model/mnnode/mnfor"
        "the-dev-tools/server/pkg/model/mnnode/mnforeach"
        "the-dev-tools/server/pkg/model/mnnode/mnif"
        "the-dev-tools/server/pkg/model/mnnode/mnjs"
        "the-dev-tools/server/pkg/model/mnnode/mnnoop"
        "the-dev-tools/server/pkg/model/mnnode/mnrequest"
        "the-dev-tools/server/pkg/model/mvar"
        "the-dev-tools/server/pkg/model/mworkspace"
        "the-dev-tools/server/pkg/service/flow/sedge"
        "the-dev-tools/server/pkg/service/sassert"
        "the-dev-tools/server/pkg/service/sassertres"
        "the-dev-tools/server/pkg/service/sbodyform"
        "the-dev-tools/server/pkg/service/sbodyraw"
        "the-dev-tools/server/pkg/service/sbodyurl"
        "the-dev-tools/server/pkg/service/scollection"
        "the-dev-tools/server/pkg/service/senv"
        "the-dev-tools/server/pkg/service/sexampleheader"
        "the-dev-tools/server/pkg/service/sexamplequery"
        "the-dev-tools/server/pkg/service/sexampleresp"
        "the-dev-tools/server/pkg/service/sexamplerespheader"
        "the-dev-tools/server/pkg/service/sflow"
        "the-dev-tools/server/pkg/service/sflowvariable"
        "the-dev-tools/server/pkg/service/sitemapi"
        "the-dev-tools/server/pkg/service/sitemapiexample"
        "the-dev-tools/server/pkg/service/sitemfolder"
        "the-dev-tools/server/pkg/service/snode"
        "the-dev-tools/server/pkg/service/snodefor"
        "the-dev-tools/server/pkg/service/snodeforeach"
        "the-dev-tools/server/pkg/service/snodeif"
        "the-dev-tools/server/pkg/service/snodejs"
        "the-dev-tools/server/pkg/service/snodenoop"
        "the-dev-tools/server/pkg/service/snoderequest"
        "the-dev-tools/server/pkg/service/svar"
        "the-dev-tools/server/pkg/service/sworkspace"

        "gopkg.in/yaml.v3"
)

type IOWorkspaceService struct {
        DB *sql.DB

        workspaceService sworkspace.WorkspaceService

        collectionService scollection.CollectionService
        folderservice     sitemfolder.ItemFolderService
        endpointService   sitemapi.ItemApiService
        exampleService    sitemapiexample.ItemApiExampleService

        exampleHeaderService sexampleheader.HeaderService
        exampleQueryService  sexamplequery.ExampleQueryService
        exampleAssertService sassert.AssertService

        rawBodyService  sbodyraw.BodyRawService
        formBodyService sbodyform.BodyFormService
        urlBodyService  sbodyurl.BodyURLEncodedService

        responseService       sexampleresp.ExampleRespService
        responseHeaderService sexamplerespheader.ExampleRespHeaderService
        responseAssertService sassertres.AssertResultService

        flowService sflow.FlowService

        flowNodeService     snode.NodeService
        flowEdgeService     sedge.EdgeService
        flowVariableService sflowvariable.FlowVariableService

        flowRequestService   snoderequest.NodeRequestService
        flowConditionService snodeif.NodeIfService
        flowNoopService      snodenoop.NodeNoopService
        flowForService       snodefor.NodeForService
        flowForEachService   snodeforeach.NodeForEachService
        flowJSService        snodejs.NodeJSService

        envService senv.EnvService
        varService svar.VarService
}

func NewIOWorkspaceService(
        DB *sql.DB,
        workspaceService sworkspace.WorkspaceService,
        collectionService scollection.CollectionService,
        folderservice sitemfolder.ItemFolderService,
        endpointService sitemapi.ItemApiService,
        exampleService sitemapiexample.ItemApiExampleService,
        exampleHeaderService sexampleheader.HeaderService,
        exampleQueryService sexamplequery.ExampleQueryService,
        exampleAssertService sassert.AssertService,
        rawBodyService sbodyraw.BodyRawService,
        formBodyService sbodyform.BodyFormService,
        urlBodyService sbodyurl.BodyURLEncodedService,
        responseService sexampleresp.ExampleRespService,
        responseHeaderService sexamplerespheader.ExampleRespHeaderService,
        responseAssertService sassertres.AssertResultService,

        // flow
        flowService sflow.FlowService,

        flowNodeService snode.NodeService,
        flowEdgeService sedge.EdgeService,
        flowVariableService sflowvariable.FlowVariableService,

        flowRequestService snoderequest.NodeRequestService,
        flowConditionService snodeif.NodeIfService,
        flowNoopService snodenoop.NodeNoopService,
        flowForService snodefor.NodeForService,
        flowForEachService snodeforeach.NodeForEachService,
        flowJSService snodejs.NodeJSService,

        envService senv.EnvService,
        varService svar.VarService,
) *IOWorkspaceService <span class="cov8" title="1">{
        return &amp;IOWorkspaceService{
                DB:                    DB,
                workspaceService:      workspaceService,
                collectionService:     collectionService,
                folderservice:         folderservice,
                endpointService:       endpointService,
                exampleService:        exampleService,
                exampleHeaderService:  exampleHeaderService,
                exampleQueryService:   exampleQueryService,
                exampleAssertService:  exampleAssertService,
                rawBodyService:        rawBodyService,
                formBodyService:       formBodyService,
                urlBodyService:        urlBodyService,
                responseService:       responseService,
                responseHeaderService: responseHeaderService,
                responseAssertService: responseAssertService,

                flowService: flowService,

                flowNodeService:     flowNodeService,
                flowEdgeService:     flowEdgeService,
                flowVariableService: flowVariableService,

                flowRequestService:   flowRequestService,
                flowConditionService: flowConditionService,
                flowNoopService:      flowNoopService,
                flowForService:       flowForService,
                flowForEachService:   flowForEachService,
                flowJSService:        flowJSService,

                envService: envService,
                varService: varService,
        }
}</span>

type WorkspaceData struct {
        Workspace mworkspace.Workspace `yaml:"workspace"`

        // collections
        Collections []mcollection.Collection         `yaml:"collections"`
        Folders     []mitemfolder.ItemFolder         `yaml:"folders"`
        Endpoints   []mitemapi.ItemApi               `yaml:"endpoints"`
        Examples    []mitemapiexample.ItemApiExample `yaml:"examples"`

        // example sub items
        ExampleHeaders []mexampleheader.Header `yaml:"example_headers"`
        ExampleQueries []mexamplequery.Query   `yaml:"example_queries"`
        ExampleAsserts []massert.Assert        `yaml:"example_asserts"`

        // body
        Rawbodies  []mbodyraw.ExampleBodyRaw `yaml:"rawbodies"`
        FormBodies []mbodyform.BodyForm      `yaml:"form_bodies"`
        UrlBodies  []mbodyurl.BodyURLEncoded `yaml:"url_bodies"`

        // response
        ExampleResponses       []mexampleresp.ExampleResp             `yaml:"example_responses"`
        ExampleResponseHeaders []mexamplerespheader.ExampleRespHeader `yaml:"example_response_headers"`
        ExampleResponseAsserts []massertres.AssertResult              `yaml:"example_response_asserts"`

        // flows
        Flows []mflow.Flow `yaml:"flows"`

        // Root nodes
        FlowNodes     []mnnode.MNode               `yaml:"flow_nodes"`
        FlowEdges     []edge.Edge                  `yaml:"flow_edges"`
        FlowVariables []mflowvariable.FlowVariable `yaml:"flow_variable"`

        // Sub nodes
        FlowRequestNodes   []mnrequest.MNRequest `yaml:"flow_request_nodes"`
        FlowConditionNodes []mnif.MNIF           `yaml:"flow_condition_nodes"`
        FlowNoopNodes      []mnnoop.NoopNode     `yaml:"flow_noop_nodes"`
        FlowForNodes       []mnfor.MNFor         `yaml:"flow_for_nodes"`
        FlowForEachNodes   []mnforeach.MNForEach `yaml:"flow_foreach_nodes"`
        FlowJSNodes        []mnjs.MNJS           `yaml:"flow_js_nodes"`

        // environments
        Environments []menv.Env `yaml:"environments"`
        Variables    []mvar.Var `yaml:"variables"`
}

func (s *IOWorkspaceService) ImportWorkspace(ctx context.Context, data WorkspaceData) error <span class="cov8" title="1">{
        tx, err := s.DB.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer devtoolsdb.TxnRollback(tx)

        err = s.workspaceService.TX(tx).Create(ctx, &amp;data.Workspace)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // services
        <span class="cov8" title="1">txCollectionService := s.collectionService.TX(tx)
        txFolderService := s.folderservice.TX(tx)
        txEndpointService := s.endpointService.TX(tx)
        txExampleService := s.exampleService.TX(tx)
        txExampleHeaderService := s.exampleHeaderService.TX(tx)
        txExampleQueryService := s.exampleQueryService.TX(tx)
        txExampleAssertService := s.exampleAssertService.TX(tx)
        txRawBodyService := s.rawBodyService.TX(tx)
        txFormBodyService := s.formBodyService.TX(tx)
        txUrlBodyService := s.urlBodyService.TX(tx)
        txResponseService := s.responseService.TX(tx)
        txResponseHeaderService := s.responseHeaderService.TX(tx)
        txResponseAssertService := s.responseAssertService.TX(tx)

        // // flow
        txFlowService := s.flowService.TX(tx)
        txFlowNodeService := s.flowNodeService.TX(tx)
        txFlowEdgeService := s.flowEdgeService.TX(tx)
        txFlowVariableService := s.flowVariableService.TX(tx)

        tdFlowRequestService := s.flowRequestService.TX(tx)
        txFlowConditionService := s.flowConditionService.TX(tx)
        txFlowNoopService := s.flowNoopService.TX(tx)
        txFlowForService := s.flowForService.TX(tx)
        txFlowForEachService := s.flowForEachService.TX(tx)
        txFlowJSService := s.flowJSService.TX(tx)

        // environment services
        txEnvService := s.envService.TX(tx)
        txVarService := s.varService.TX(tx)

        for _, collection := range data.Collections </span><span class="cov8" title="1">{
                err = txCollectionService.CreateCollection(ctx, &amp;collection)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">err = txFolderService.CreateItemFolderBulk(ctx, data.Folders)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txEndpointService.CreateItemApiBulk(ctx, data.Endpoints)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txExampleService.CreateApiExampleBulk(ctx, data.Examples)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txExampleHeaderService.AppendBulkHeader(ctx, data.ExampleHeaders)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txExampleQueryService.CreateBulkQuery(ctx, data.ExampleQueries)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txExampleAssertService.CreateAssertBulk(ctx, data.ExampleAsserts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txRawBodyService.CreateBulkBodyRaw(ctx, data.Rawbodies)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txFormBodyService.CreateBulkBodyForm(ctx, data.FormBodies)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txUrlBodyService.CreateBulkBodyURLEncoded(ctx, data.UrlBodies)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txResponseService.CreateExampleRespBulk(ctx, data.ExampleResponses)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txResponseHeaderService.CreateExampleRespHeaderBulk(ctx, data.ExampleResponseHeaders)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txResponseAssertService.CreateAssertResultBulk(ctx, data.ExampleResponseAsserts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txFlowService.CreateFlowBulk(ctx, data.Flows)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txFlowNodeService.CreateNodeBulk(ctx, data.FlowNodes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txFlowVariableService.CreateFlowVariableBulk(ctx, data.FlowVariables)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = tdFlowRequestService.CreateNodeRequestBulk(ctx, data.FlowRequestNodes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txFlowConditionService.CreateNodeIfBulk(ctx, data.FlowConditionNodes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txFlowNoopService.CreateNodeNoopBulk(ctx, data.FlowNoopNodes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txFlowJSService.CreateNodeJSBulk(ctx, data.FlowJSNodes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txFlowForService.CreateNodeForBulk(ctx, data.FlowForNodes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txFlowEdgeService.CreateEdgeBulk(ctx, data.FlowEdges)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = txFlowForEachService.CreateNodeForEachBulk(ctx, data.FlowForEachNodes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create environments
        <span class="cov8" title="1">for _, env := range data.Environments </span><span class="cov0" title="0">{
                err = txEnvService.Create(ctx, env)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Create environment variables
        <span class="cov8" title="1">for _, v := range data.Variables </span><span class="cov0" title="0">{
                err = txVarService.Create(ctx, v)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type FilterExport struct {
        FilterExampleIds *[]idwrap.IDWrap
        FilterFlowIds    *[]idwrap.IDWrap
}

func (s *IOWorkspaceService) ExportWorkspace(ctx context.Context, workspaceID idwrap.IDWrap, FilterExport FilterExport) (*WorkspaceData, error) <span class="cov8" title="1">{
        var data WorkspaceData

        workspace, err := s.workspaceService.Get(ctx, workspaceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">data.Workspace = *workspace

        requiredExampleIDs := make(map[idwrap.IDWrap]struct{})
        isFilteringExamples := FilterExport.FilterExampleIds != nil
        if isFilteringExamples </span><span class="cov8" title="1">{
                for _, id := range *FilterExport.FilterExampleIds </span><span class="cov8" title="1">{
                        requiredExampleIDs[id] = struct{}{}
                }</span>
        }

        <span class="cov8" title="1">collections, err := s.collectionService.ListCollections(ctx, workspace.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">data.Collections = collections

        flows, err := s.flowService.GetFlowsByWorkspaceID(ctx, workspace.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Filter flows if FilterFlowIds is provided
        <span class="cov8" title="1">if FilterExport.FilterFlowIds != nil &amp;&amp; len(*FilterExport.FilterFlowIds) &gt; 0 </span><span class="cov8" title="1">{
                filteredFlows := []mflow.Flow{}
                // Use string representation for reliable comparison
                filterMap := make(map[string]bool)
                for _, id := range *FilterExport.FilterFlowIds </span><span class="cov8" title="1">{
                        filterMap[id.String()] = true
                }</span>

                <span class="cov8" title="1">for _, flow := range flows </span><span class="cov8" title="1">{
                        if filterMap[flow.ID.String()] </span><span class="cov8" title="1">{
                                filteredFlows = append(filteredFlows, flow)
                        }</span>
                }
                <span class="cov8" title="1">data.Flows = filteredFlows</span>
        } else<span class="cov8" title="1"> {
                data.Flows = flows
        }</span>

        <span class="cov8" title="1">for _, flow := range data.Flows </span><span class="cov8" title="1">{
                // flow node
                flowNodes, err := s.flowNodeService.GetNodesByFlowID(ctx, flow.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">data.FlowNodes = append(data.FlowNodes, flowNodes...)

                flowVariables, err := s.flowVariableService.GetFlowVariablesByFlowID(ctx, flow.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">data.FlowVariables = append(data.FlowVariables, flowVariables...)

                // flow edge
                flowEdges, err := s.flowEdgeService.GetEdgesByFlowID(ctx, flow.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">data.FlowEdges = append(data.FlowEdges, flowEdges...)

                for _, node := range flowNodes </span><span class="cov8" title="1">{
                        switch node.NodeKind </span>{
                        case mnnode.NODE_KIND_REQUEST:<span class="cov8" title="1">
                                request, err := s.flowRequestService.GetNodeRequest(ctx, node.ID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                // Always track delta example IDs - we need to load them separately
                                // since they belong to hidden endpoints
                                <span class="cov8" title="1">if request.ExampleID != nil &amp;&amp; isFilteringExamples </span><span class="cov8" title="1">{
                                        requiredExampleIDs[*request.ExampleID] = struct{}{}
                                }</span>
                                <span class="cov8" title="1">if request.DeltaExampleID != nil </span><span class="cov0" title="0">{
                                        requiredExampleIDs[*request.DeltaExampleID] = struct{}{}
                                }</span>
                                <span class="cov8" title="1">data.FlowRequestNodes = append(data.FlowRequestNodes, *request)</span>
                        case mnnode.NODE_KIND_CONDITION:<span class="cov0" title="0">
                                condition, err := s.flowConditionService.GetNodeIf(ctx, node.ID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">data.FlowConditionNodes = append(data.FlowConditionNodes, *condition)</span>

                        case mnnode.NODE_KIND_NO_OP:<span class="cov0" title="0">
                                noOp, err := s.flowNoopService.GetNodeNoop(ctx, node.ID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">data.FlowNoopNodes = append(data.FlowNoopNodes, *noOp)</span>
                        case mnnode.NODE_KIND_FOR:<span class="cov0" title="0">
                                forNode, err := s.flowForService.GetNodeFor(ctx, node.ID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">data.FlowForNodes = append(data.FlowForNodes, *forNode)</span>
                        case mnnode.NODE_KIND_FOR_EACH:<span class="cov0" title="0">
                                forEachNode, err := s.flowForEachService.GetNodeForEach(ctx, node.ID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">data.FlowForEachNodes = append(data.FlowForEachNodes, *forEachNode)</span>
                        case mnnode.NODE_KIND_JS:<span class="cov0" title="0">
                                jsNode, err := s.flowJSService.GetNodeJS(ctx, node.ID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">data.FlowJSNodes = append(data.FlowJSNodes, jsNode)</span>
                        }
                }
        }

        <span class="cov8" title="1">for _, collection := range collections </span><span class="cov8" title="1">{
                folders, err := s.folderservice.GetFoldersWithCollectionID(ctx, collection.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">data.Folders = append(data.Folders, folders...)

                endpoints, err := s.endpointService.GetApisWithCollectionID(ctx, collection.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">data.Endpoints = append(data.Endpoints, endpoints...)

                // Load regular examples from collection
                if !isFilteringExamples </span><span class="cov8" title="1">{
                        examples, err := s.exampleService.GetApiExampleByCollection(ctx, collection.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">data.Examples = append(data.Examples, examples...)</span>
                }

                // Load specific examples (delta examples or filtered examples)
                // Delta examples belong to hidden endpoints and won't be returned by GetApiExampleByCollection
                <span class="cov8" title="1">if len(requiredExampleIDs) &gt; 0 </span><span class="cov8" title="1">{
                        for exampleID := range requiredExampleIDs </span><span class="cov8" title="1">{
                                // Skip if we already have this example
                                found := false
                                for _, e := range data.Examples </span><span class="cov8" title="1">{
                                        if e.ID == exampleID </span><span class="cov0" title="0">{
                                                found = true
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if found </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">example, err := s.exampleService.GetApiExample(ctx, exampleID)
                                if err != nil </span><span class="cov0" title="0">{
                                        if err == sql.ErrNoRows </span><span class="cov0" title="0">{ // Skip if example doesn't exist
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">return nil, err</span>
                                }
                                <span class="cov8" title="1">data.Examples = append(data.Examples, *example)</span>
                        }
                }

        }

        // Load endpoints for delta examples (they won't be included in the collection query)
        <span class="cov8" title="1">for _, example := range data.Examples </span><span class="cov8" title="1">{
                // Check if we already have this endpoint
                endpointFound := false
                for _, endpoint := range data.Endpoints </span><span class="cov8" title="1">{
                        if endpoint.ID == example.ItemApiID </span><span class="cov8" title="1">{
                                endpointFound = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if !endpointFound </span><span class="cov0" title="0">{
                        // Load the endpoint (likely a hidden delta endpoint)
                        endpoint, err := s.endpointService.GetItemApi(ctx, example.ItemApiID)
                        if err != nil </span><span class="cov0" title="0">{
                                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                                        continue</span> // Skip if endpoint doesn't exist
                                }
                                <span class="cov0" title="0">return nil, err</span>
                        }
                        <span class="cov0" title="0">data.Endpoints = append(data.Endpoints, *endpoint)</span>
                }
        }

        // Fetch details for the final list of examples
        <span class="cov8" title="1">for _, example := range data.Examples </span><span class="cov8" title="1">{
                // headers
                exampleHeaders, err := s.exampleHeaderService.GetHeaderByExampleID(ctx, example.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">data.ExampleHeaders = append(data.ExampleHeaders, exampleHeaders...)

                // queries
                exampleQueries, err := s.exampleQueryService.GetExampleQueriesByExampleID(ctx, example.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">data.ExampleQueries = append(data.ExampleQueries, exampleQueries...)

                // asserts
                exampleAsserts, err := s.exampleAssertService.GetAssertByExampleID(ctx, example.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">data.ExampleAsserts = append(data.ExampleAsserts, exampleAsserts...)

                // // body
                //

                // raw
                rawBody, err := s.rawBodyService.GetBodyRawByExampleID(ctx, example.ID)
                if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{ // Ignore not found errors
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err == nil &amp;&amp; rawBody != nil </span><span class="cov8" title="1">{ // Only append if found
                        data.Rawbodies = append(data.Rawbodies, *rawBody)
                }</span>

                // form
                <span class="cov8" title="1">formBodies, err := s.formBodyService.GetBodyFormsByExampleID(ctx, example.ID)
                if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{ // Ignore not found errors
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{ // Append if found (might be an empty slice)
                        data.FormBodies = append(data.FormBodies, formBodies...)
                }</span>

                // url
                <span class="cov8" title="1">urlBodies, err := s.urlBodyService.GetBodyURLEncodedByExampleID(ctx, example.ID)
                if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{ // Ignore not found errors
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{ // Append if found (might be an empty slice)
                        data.UrlBodies = append(data.UrlBodies, urlBodies...)
                }</span>

                // response
                <span class="cov8" title="1">response, err := s.responseService.GetExampleRespByExampleIDLatest(ctx, example.ID)
                if err != nil </span><span class="cov8" title="1">{
                        if err == sexampleresp.ErrNoRespFound </span><span class="cov8" title="1">{
                                // didn't find response so there will be no resp header etc...
                                continue</span>
                        } else<span class="cov0" title="0"> {
                                return nil, err
                        }</span>
                }
                <span class="cov8" title="1">data.ExampleResponses = append(data.ExampleResponses, *response)

                // response headers
                responseHeaders, err := s.responseHeaderService.GetHeaderByRespID(ctx, response.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">data.ExampleResponseHeaders = append(data.ExampleResponseHeaders, responseHeaders...)

                // response asserts
                responseAsserts, err := s.responseAssertService.GetAssertResultsByResponseID(ctx, response.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">data.ExampleResponseAsserts = append(data.ExampleResponseAsserts, responseAsserts...)</span>

        }

        <span class="cov8" title="1">return &amp;data, nil</span>
}

func UnmarshalWorkspace(data []byte) (*WorkspaceData, error) <span class="cov0" title="0">{
        var workspace WorkspaceData
        err := yaml.Unmarshal(data, &amp;workspace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal workspace: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;workspace, nil</span>
}

func (wd WorkspaceData) VerifyIds() error <span class="cov0" title="0">{
        exampleIds := make(map[idwrap.IDWrap]struct{}, len(wd.Examples))
        for _, example := range wd.Examples </span><span class="cov0" title="0">{
                exampleIds[example.ID] = struct{}{}
        }</span>

        <span class="cov0" title="0">for _, requestNode := range wd.FlowRequestNodes </span><span class="cov0" title="0">{
                exampleId := requestNode.ExampleID
                deltaExampleID := requestNode.DeltaExampleID
                if exampleId != nil </span><span class="cov0" title="0">{
                        _, ok := exampleIds[*exampleId]
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("request node %s referance %s example but it is not exists", requestNode.FlowNodeID, exampleId)
                        }</span>
                }
                <span class="cov0" title="0">if deltaExampleID != nil </span><span class="cov0" title="0">{
                        _, ok := exampleIds[*deltaExampleID]
                        if !ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("request node %s referance %s example but it is not exists", requestNode.FlowNodeID, deltaExampleID)
                        }</span>
                }

        }

        <span class="cov0" title="0">return nil</span>
}

func MarshalWorkspace(workspace *WorkspaceData) ([]byte, error) <span class="cov0" title="0">{
        data, err := yaml.Marshal(workspace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal workspace: %w", err)
        }</span>
        <span class="cov0" title="0">return data, nil</span>
}

// WorkflowFormat represents the simplified workflow-centric YAML structure
type WorkflowFormat struct {
        WorkspaceName string         `yaml:"workspace_name"`
        Flows         []WorkflowFlow `yaml:"flows"`
}

type WorkflowFlow struct {
        Name      string             `yaml:"name"`
        Variables []WorkflowVariable `yaml:"variables"`
        Steps     []WorkflowStep     `yaml:"steps"` // This will be used for initial unmarshal structure check if needed, but main logic uses raw map
}

type WorkflowVariable struct {
        Name  string `yaml:"name"`
        Value string `yaml:"value"`
}

// Base step that all step types implement
type WorkflowStep struct {
        StepType  string   `yaml:"-"` // Not directly unmarshalled, determined by map key
        DependsOn []string `yaml:"depends_on,omitempty"`
}

// RequestStep defines HTTP request configuration
type RequestStep struct {
        WorkflowStep `yaml:",inline"`
        Name         string              `yaml:"name"`
        Method       string              `yaml:"method"`
        URL          string              `yaml:"url"`
        Headers      []RequestStepHeader `yaml:"headers,omitempty"`
        Body         *RequestStepBody    `yaml:"body,omitempty"`
}

type RequestStepHeader struct {
        Name  string `yaml:"name"`
        Value string `yaml:"value"`
}

type RequestStepBody struct {
        BodyJSON map[string]any `yaml:"body_json,omitempty"`
}

// IfStep defines conditional branching
type IfStep struct {
        WorkflowStep `yaml:",inline"`
        Name         string `yaml:"name"`
        Expression   string `yaml:"expression"`
        Then         string `yaml:"then,omitempty"`
        Else         string `yaml:"else,omitempty"`
}

// ForStep defines loop iteration
type ForStep struct {
        WorkflowStep `yaml:",inline"`
        Name         string `yaml:"name"`
        IterCount    int    `yaml:"iter_count"`
        Loop         string `yaml:"loop,omitempty"`
}

// JSStep defines JavaScript execution
type JSStep struct {
        WorkflowStep `yaml:",inline"`
        Name         string `yaml:"name"`
        Code         string `yaml:"code"`
}

// UnmarshalWorkflowYAML parses the workflow-centric YAML format and converts it to WorkspaceData
func UnmarshalWorkflowYAML(data []byte) (*WorkspaceData, error) <span class="cov8" title="1">{
        var workflow WorkflowFormat
        var rawWorkflow map[string]any

        // First unmarshal to a generic map to handle the step types properly
        if err := yaml.Unmarshal(data, &amp;rawWorkflow); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal workflow format: %w", err)
        }</span>

        // Then unmarshal to our structured format (mainly for top-level fields and flow names/variables)
        <span class="cov8" title="1">if err := yaml.Unmarshal(data, &amp;workflow); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal workflow format: %w", err)
        }</span>

        <span class="cov8" title="1">collectionID := idwrap.NewNow()

        // Create workspace data structure with proper IDs
        workspaceID := idwrap.NewNow()
        workspaceData := &amp;WorkspaceData{
                Workspace: mworkspace.Workspace{
                        ID:   workspaceID,
                        Name: workflow.WorkspaceName,
                },
                Collections: []mcollection.Collection{
                        {
                                ID:          collectionID,
                                Name:        "Workflow Collection", // Default collection name
                                WorkspaceID: workspaceID,
                        },
                },
                Flows:              make([]mflow.Flow, 0),
                FlowNodes:          make([]mnnode.MNode, 0),
                FlowEdges:          make([]edge.Edge, 0),
                FlowVariables:      make([]mflowvariable.FlowVariable, 0),
                Endpoints:          make([]mitemapi.ItemApi, 0),
                Examples:           make([]mitemapiexample.ItemApiExample, 0),
                ExampleHeaders:     make([]mexampleheader.Header, 0),
                Rawbodies:          make([]mbodyraw.ExampleBodyRaw, 0),
                FlowRequestNodes:   make([]mnrequest.MNRequest, 0),
                FlowConditionNodes: make([]mnif.MNIF, 0),
                FlowForNodes:       make([]mnfor.MNFor, 0),
                FlowJSNodes:        make([]mnjs.MNJS, 0),
        }

        // Process each flow
        for _, wflow := range workflow.Flows </span><span class="cov8" title="1">{
                // Create flow
                flowID := idwrap.NewNow()
                flow := mflow.Flow{
                        ID:          flowID,
                        Name:        wflow.Name,
                        WorkspaceID: workspaceData.Workspace.ID,
                }
                workspaceData.Flows = append(workspaceData.Flows, flow)

                // Map to track node names to IDs for edge creation
                nodeNameToID := make(map[string]idwrap.IDWrap)
                nodeIndex := make(map[string]int) // Store node indices for dependency resolution

                // Process flow variables
                for _, v := range wflow.Variables </span><span class="cov8" title="1">{
                        variable := mflowvariable.FlowVariable{
                                ID:      idwrap.NewNow(),
                                FlowID:  flow.ID,
                                Name:    v.Name,
                                Value:   v.Value,
                                Enabled: true,
                        }
                        workspaceData.FlowVariables = append(workspaceData.FlowVariables, variable)
                }</span>

                <span class="cov8" title="1">startNodeID := idwrap.NewNow()

                startNodeRoot := mnnode.MNode{
                        ID:       startNodeID,
                        FlowID:   flowID,
                        Name:     "Start Node",
                        NodeKind: mnnode.NODE_KIND_NO_OP,
                }

                workspaceData.FlowNodes = append(workspaceData.FlowNodes, startNodeRoot)

                startNode := mnnoop.NoopNode{
                        FlowNodeID: startNodeID,
                        Type:       mnnoop.NODE_NO_OP_KIND_START,
                }

                workspaceData.FlowNoopNodes = append(workspaceData.FlowNoopNodes, startNode)

                // Process steps from raw data to correctly identify step types
                rawFlows, ok := rawWorkflow["flows"].([]any)
                if !ok || len(rawFlows) == 0 </span><span class="cov0" title="0">{
                        // If no flows are defined in the raw data, continue to the next flow definition
                        // This handles cases where a flow might be defined in the structured data but not raw, though unlikely
                        continue</span>
                }

                <span class="cov8" title="1">var rawSteps []map[string]any
                foundFlow := false
                for _, rf := range rawFlows </span><span class="cov8" title="1">{
                        rfMap, ok := rf.(map[string]any)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if name, ok := rfMap["name"].(string); ok &amp;&amp; name == wflow.Name </span><span class="cov8" title="1">{
                                foundFlow = true
                                if steps, ok := rfMap["steps"].([]any); ok </span><span class="cov8" title="1">{
                                        for _, step := range steps </span><span class="cov8" title="1">{
                                                // Expecting each step to be a map with a single key (the type)
                                                if stepMap, ok := step.(map[string]any); ok &amp;&amp; len(stepMap) == 1 </span><span class="cov8" title="1">{
                                                        rawSteps = append(rawSteps, stepMap)
                                                }</span> else<span class="cov0" title="0"> {
                                                        return nil, fmt.Errorf("invalid step format in flow '%s': expected map with single key", wflow.Name)
                                                }</span>
                                        }
                                }
                                <span class="cov8" title="1">break</span>
                        }
                }

                <span class="cov8" title="1">if !foundFlow </span><span class="cov0" title="0">{
                        // If the flow name from the structured data wasn't found in the raw data, skip processing its steps
                        continue</span>
                }

                // Process each step and create the appropriate node type
                <span class="cov8" title="1">for i, rawStep := range rawSteps </span><span class="cov8" title="1">{
                        // Since we validated len(rawStep) == 1 above, this loop runs once
                        for stepType, stepData := range rawStep </span><span class="cov8" title="1">{
                                dataMap, ok := stepData.(map[string]any)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("invalid step data format for type '%s' in flow '%s'", stepType, wflow.Name)
                                }</span>

                                <span class="cov8" title="1">nodeName, ok := dataMap["name"].(string)
                                if !ok || nodeName == "" </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("step type '%s' in flow '%s' missing required 'name' field", stepType, wflow.Name)
                                }</span>

                                <span class="cov8" title="1">if _, exists := nodeNameToID[nodeName]; exists </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("duplicate node name '%s' found in flow '%s'", nodeName, wflow.Name)
                                }</span>

                                <span class="cov8" title="1">nodeID := idwrap.NewNow()

                                // Process step based on type
                                var err error
                                switch stepType </span>{
                                case "request":<span class="cov8" title="1">
                                        err = processRequestStep(workspaceData, flow.ID, nodeID, nodeName, dataMap, collectionID)</span>
                                case "if":<span class="cov8" title="1">
                                        err = processIfStep(workspaceData, flow.ID, nodeID, nodeName, dataMap)</span>
                                case "for":<span class="cov8" title="1">
                                        err = processForStep(workspaceData, flow.ID, nodeID, nodeName, dataMap)</span>
                                case "js":<span class="cov8" title="1">
                                        err = processJSStep(workspaceData, flow.ID, nodeID, nodeName, dataMap)</span>
                                default:<span class="cov0" title="0">
                                        err = fmt.Errorf("unknown step type '%s' in flow '%s'", stepType, wflow.Name)</span>
                                }

                                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error processing step '%s' (type %s) in flow '%s': %w", nodeName, stepType, wflow.Name, err)
                                }</span>

                                <span class="cov8" title="1">nodeNameToID[nodeName] = nodeID
                                nodeIndex[nodeName] = i</span>
                        }
                }

                // Process all edges and dependencies at the end
                <span class="cov8" title="1">if err := processEdgesAndDependencies(workspaceData, flow.ID, rawSteps, nodeNameToID, nodeIndex); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error processing edges/dependencies in flow '%s': %w", wflow.Name, err)
                }</span>
        }

        // Set up linked list relationships for endpoints
        <span class="cov8" title="1">for i := 0; i &lt; len(workspaceData.Endpoints); i++ </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        prev := &amp;workspaceData.Endpoints[i-1].ID
                        workspaceData.Endpoints[i].Prev = prev
                }</span>
                <span class="cov8" title="1">if i &lt; len(workspaceData.Endpoints)-1 </span><span class="cov8" title="1">{
                        next := &amp;workspaceData.Endpoints[i+1].ID
                        workspaceData.Endpoints[i].Next = next
                }</span>
        }

        // Set up linked list relationships for examples
        <span class="cov8" title="1">for i := 0; i &lt; len(workspaceData.Examples); i++ </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        prev := &amp;workspaceData.Examples[i-1].ID
                        workspaceData.Examples[i].Prev = prev
                }</span>
                <span class="cov8" title="1">if i &lt; len(workspaceData.Examples)-1 </span><span class="cov8" title="1">{
                        next := &amp;workspaceData.Examples[i+1].ID
                        workspaceData.Examples[i].Next = next
                }</span>
        }

        <span class="cov8" title="1">return workspaceData, nil</span>
}

// Helper function to process request steps
func processRequestStep(workspaceData *WorkspaceData, flowID, nodeID idwrap.IDWrap, nodeName string, data map[string]any, collectionID idwrap.IDWrap) error <span class="cov8" title="1">{
        // Create base node
        node := mnnode.MNode{
                ID:       nodeID,
                FlowID:   flowID,
                Name:     nodeName,
                NodeKind: mnnode.NODE_KIND_REQUEST,
        }
        workspaceData.FlowNodes = append(workspaceData.FlowNodes, node)

        // Process request specific fields
        method, _ := data["method"].(string)
        if method == "" </span><span class="cov0" title="0">{
                method = "GET" // Default to GET if not specified
        }</span>

        <span class="cov8" title="1">url, ok := data["url"].(string)
        if !ok || url == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("request node '%s' is missing required 'url' field", nodeName)
        }</span>

        // Create endpoint and example
        <span class="cov8" title="1">endpointID := idwrap.NewNow()
        exampleID := idwrap.NewNow()

        endpoint := mitemapi.ItemApi{
                ID:           endpointID,
                Name:         fmt.Sprintf("%s Endpoint", nodeName), // Give endpoint a distinct name
                Url:          url,
                Method:       method,
                CollectionID: collectionID,
                // WorkspaceID: workspaceData.Workspace.ID, // Assuming ItemApi needs WorkspaceID
        }
        workspaceData.Endpoints = append(workspaceData.Endpoints, endpoint)

        example := mitemapiexample.ItemApiExample{
                ID:           exampleID,
                Name:         fmt.Sprintf("%s Example", nodeName), // Give example a distinct name
                ItemApiID:    endpointID,
                CollectionID: collectionID,
        }
        workspaceData.Examples = append(workspaceData.Examples, example)

        // Process headers
        headers := []mexampleheader.Header{}
        if headerData, ok := data["headers"].([]any); ok </span><span class="cov8" title="1">{
                for _, h := range headerData </span><span class="cov8" title="1">{
                        if headerMap, ok := h.(map[string]any); ok </span><span class="cov8" title="1">{
                                headerKey, _ := headerMap["name"].(string)
                                headerValue, _ := headerMap["value"].(string)
                                if headerKey == "" </span><span class="cov0" title="0">{
                                        continue</span> // Skip headers without a name
                                }
                                <span class="cov8" title="1">header := mexampleheader.Header{
                                        ID:        idwrap.NewNow(),
                                        ExampleID: exampleID,
                                        HeaderKey: headerKey,
                                        Value:     headerValue,
                                }
                                headers = append(headers, header)</span>
                        }
                }
        }
        <span class="cov8" title="1">workspaceData.ExampleHeaders = append(workspaceData.ExampleHeaders, headers...)

        bodyRaw := mbodyraw.ExampleBodyRaw{
                ID:        idwrap.NewNow(),
                ExampleID: exampleID,
        }
        // Process body
        if bodyData, ok := data["body"].(map[string]any); ok </span><span class="cov8" title="1">{
                if bodyJSON, ok := bodyData["body_json"].(map[string]any); ok </span><span class="cov8" title="1">{
                        jsonData, err := json.Marshal(bodyJSON)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to marshal body_json for node '%s': %w", nodeName, err)
                        }</span>
                        <span class="cov8" title="1">bodyRaw.Data = jsonData</span>
                }
                // TODO: Add handling for other body types like text, form-data etc.
        }
        <span class="cov8" title="1">workspaceData.Rawbodies = append(workspaceData.Rawbodies, bodyRaw)

        requestNode := mnrequest.MNRequest{
                FlowNodeID: nodeID, // This should be the MNode ID
                EndpointID: &amp;endpointID,
                ExampleID:  &amp;exampleID,
        }
        workspaceData.FlowRequestNodes = append(workspaceData.FlowRequestNodes, requestNode)

        return nil</span>
}

// Helper function to process if steps
func processIfStep(workspaceData *WorkspaceData, flowID, nodeID idwrap.IDWrap, nodeName string, data map[string]any) error <span class="cov8" title="1">{
        // Create base node
        node := mnnode.MNode{
                ID:       nodeID,
                FlowID:   flowID,
                Name:     nodeName,
                NodeKind: mnnode.NODE_KIND_CONDITION,
        }
        workspaceData.FlowNodes = append(workspaceData.FlowNodes, node)

        // Process if specific fields
        path, _ := data["expression"].(string) // Allow empty path for now, validation might be needed elsewhere

        ifNode := mnif.MNIF{
                FlowNodeID: nodeID, // This should be the MNode ID
                Condition: mcondition.Condition{
                        Comparisons: mcondition.Comparison{
                                Expression: path,
                        },
                },
        }
        workspaceData.FlowConditionNodes = append(workspaceData.FlowConditionNodes, ifNode)

        return nil
}</span>

// Helper function to process for steps
func processForStep(workspaceData *WorkspaceData, flowID, nodeID idwrap.IDWrap, nodeName string, data map[string]any) error <span class="cov8" title="1">{
        // Create base node
        node := mnnode.MNode{
                ID:       nodeID,
                FlowID:   flowID,
                Name:     nodeName,
                NodeKind: mnnode.NODE_KIND_FOR,
        }
        workspaceData.FlowNodes = append(workspaceData.FlowNodes, node)

        // Process for specific fields
        iterCount := 0
        // Handle potential float64 from YAML unmarshal into any
        if icFloat, ok := data["iter_count"].(float64); ok </span><span class="cov0" title="0">{
                iterCount = int(icFloat)
        }</span> else<span class="cov8" title="1"> if icInt, ok := data["iter_count"].(int); ok </span><span class="cov8" title="1">{
                iterCount = icInt
        }</span> else<span class="cov0" title="0"> {
                return fmt.Errorf("'iter_count' field for 'for' node '%s' must be an integer", nodeName)
        }</span>

        <span class="cov8" title="1">if iterCount &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("'iter_count' for 'for' node '%s' cannot be negative", nodeName)
        }</span>

        <span class="cov8" title="1">forNode := mnfor.MNFor{
                FlowNodeID: nodeID, // This should be the MNode ID
                IterCount:  int64(iterCount),
                // TODO: Add IterVariable based on YAML structure if needed
        }
        workspaceData.FlowForNodes = append(workspaceData.FlowForNodes, forNode)

        return nil</span>
}

// Helper function to process js steps
func processJSStep(workspaceData *WorkspaceData, flowID, nodeID idwrap.IDWrap, nodeName string, data map[string]any) error <span class="cov8" title="1">{
        // Create base node
        node := mnnode.MNode{
                ID:       nodeID,
                FlowID:   flowID,
                Name:     nodeName,
                NodeKind: mnnode.NODE_KIND_JS,
        }
        workspaceData.FlowNodes = append(workspaceData.FlowNodes, node)

        // Process js specific fields
        code, ok := data["code"].(string)
        if !ok </span><span class="cov0" title="0">{
                // Allow empty code? Or return error? Assuming empty code is valid for now.
                code = ""
                // return fmt.Errorf("'code' field for 'js' node '%s' must be a string", nodeName)
        }</span>

        <span class="cov8" title="1">jsNode := mnjs.MNJS{
                FlowNodeID: nodeID, // This should be the MNode ID
                Code:       []byte(code),
        }
        workspaceData.FlowJSNodes = append(workspaceData.FlowJSNodes, jsNode)

        return nil</span>
}

func findStartNodeID(workspaceData *WorkspaceData, flowID idwrap.IDWrap) idwrap.IDWrap <span class="cov8" title="1">{
        for i, node := range workspaceData.FlowNodes </span><span class="cov8" title="1">{
                if node.FlowID == flowID &amp;&amp; node.NodeKind == mnnode.NODE_KIND_NO_OP </span><span class="cov8" title="1">{
                        for _, noopNode := range workspaceData.FlowNoopNodes </span><span class="cov8" title="1">{
                                if noopNode.FlowNodeID == node.ID &amp;&amp; noopNode.Type == mnnoop.NODE_NO_OP_KIND_START </span><span class="cov8" title="1">{
                                        return workspaceData.FlowNodes[i].ID
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return idwrap.IDWrap{}</span> // Should never happen if flow initialization is correct
}

// Helper function to process all edges and dependencies
func processEdgesAndDependencies(workspaceData *WorkspaceData, flowID idwrap.IDWrap,
        rawSteps []map[string]any, nodeNameToID map[string]idwrap.IDWrap, nodeIndex map[string]int) error <span class="cov8" title="1">{

        startNodeID := findStartNodeID(workspaceData, flowID)
        createdEdges := make(map[string]struct{}) // Track edges to avoid duplicates "sourceID-&gt;targetID"

        addEdge := func(sourceID, targetID idwrap.IDWrap, sourceHandler edge.EdgeHandle) </span><span class="cov8" title="1">{
                key := fmt.Sprintf("%s-&gt;%s", sourceID.String(), targetID.String())
                if _, exists := createdEdges[key]; !exists </span><span class="cov8" title="1">{
                        edge := edge.Edge{
                                ID:            idwrap.NewNow(),
                                FlowID:        flowID,
                                SourceID:      sourceID,
                                TargetID:      targetID,
                                SourceHandler: sourceHandler, // Specify handler if needed (e.g., for if/for)
                        }
                        workspaceData.FlowEdges = append(workspaceData.FlowEdges, edge)
                        createdEdges[key] = struct{}{}
                }</span>
        }

        // First process explicit dependencies and special connections (then/else for if, loop for for)
        <span class="cov8" title="1">for _, step := range rawSteps </span><span class="cov8" title="1">{
                for stepType, stepData := range step </span><span class="cov8" title="1">{
                        dataMap, ok := stepData.(map[string]any)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span> // Should not happen based on earlier checks
                        }

                        <span class="cov8" title="1">nodeName, _ := dataMap["name"].(string)   //nolint:all // Already validated
                        sourceNodeID, _ := nodeNameToID[nodeName] //nolint:all // Already validated

                        // Handle special connections based on step type
                        switch stepType </span>{
                        case "if":<span class="cov8" title="1">
                                // Process then/else connections
                                if thenTarget, ok := dataMap["then"].(string); ok &amp;&amp; thenTarget != "" </span><span class="cov8" title="1">{
                                        if targetNodeID, exists := nodeNameToID[thenTarget]; exists </span><span class="cov8" title="1">{
                                                addEdge(sourceNodeID, targetNodeID, edge.HandleThen) // Use specific handler
                                        }</span> else<span class="cov0" title="0"> {
                                                return fmt.Errorf("target node '%s' for 'then' branch of '%s' not found", thenTarget, nodeName)
                                        }</span>
                                }

                                <span class="cov8" title="1">if elseTarget, ok := dataMap["else"].(string); ok &amp;&amp; elseTarget != "" </span><span class="cov8" title="1">{
                                        if targetNodeID, exists := nodeNameToID[elseTarget]; exists </span><span class="cov8" title="1">{
                                                addEdge(sourceNodeID, targetNodeID, edge.HandleElse) // Use specific handler
                                        }</span> else<span class="cov0" title="0"> {
                                                return fmt.Errorf("target node '%s' for 'else' branch of '%s' not found", elseTarget, nodeName)
                                        }</span>
                                }

                        case "for":<span class="cov8" title="1">
                                // Process loop connections
                                if loopTarget, ok := dataMap["loop"].(string); ok &amp;&amp; loopTarget != "" </span><span class="cov8" title="1">{
                                        if targetNodeID, exists := nodeNameToID[loopTarget]; exists </span><span class="cov8" title="1">{
                                                addEdge(sourceNodeID, targetNodeID, edge.HandleLoop) // Use specific handler
                                        }</span> else<span class="cov0" title="0"> {
                                                return fmt.Errorf("target node '%s' for 'loop' of '%s' not found", loopTarget, nodeName)
                                        }</span>
                                }
                        }

                        // Process explicit dependencies for all step types
                        <span class="cov8" title="1">if deps, ok := dataMap["depends_on"].([]any); ok </span><span class="cov8" title="1">{
                                for _, dep := range deps </span><span class="cov8" title="1">{
                                        depName, ok := dep.(string)
                                        if !ok || depName == "" </span><span class="cov0" title="0">{
                                                continue</span> // Skip invalid dependency entries
                                        }

                                        <span class="cov8" title="1">fromNodeID, exists := nodeNameToID[depName]
                                        if !exists </span><span class="cov0" title="0">{
                                                return fmt.Errorf("dependency node '%s' for node '%s' not found", depName, nodeName)
                                        }</span>
                                        // Ensure dependency is not on self
                                        <span class="cov8" title="1">if fromNodeID == sourceNodeID </span><span class="cov0" title="0">{
                                                return fmt.Errorf("node '%s' cannot depend on itself", nodeName)
                                        }</span>
                                        <span class="cov8" title="1">addEdge(fromNodeID, sourceNodeID, edge.HandleUnspecified)</span> // Default handler for dependencies
                                }
                        }
                }
        }

        // Then create sequential edges where no explicit dependency or special connection implies an order
        <span class="cov8" title="1">nodeHasIncomingEdge := make(map[idwrap.IDWrap]bool)
        for _, e := range workspaceData.FlowEdges </span><span class="cov8" title="1">{
                nodeHasIncomingEdge[e.TargetID] = true
        }</span>

        <span class="cov8" title="1">for i := 1; i &lt; len(rawSteps); i++ </span><span class="cov8" title="1">{
                // Get nodes at index i
                var currentStepNodes []idwrap.IDWrap
                for nodeName, idx := range nodeIndex </span><span class="cov8" title="1">{
                        if idx == i </span><span class="cov8" title="1">{
                                currentStepNodes = append(currentStepNodes, nodeNameToID[nodeName])
                        }</span>
                }

                // Get nodes at index i-1
                <span class="cov8" title="1">var prevStepNodes []idwrap.IDWrap
                for nodeName, idx := range nodeIndex </span><span class="cov8" title="1">{
                        if idx == i-1 </span><span class="cov8" title="1">{
                                prevStepNodes = append(prevStepNodes, nodeNameToID[nodeName])
                        }</span>
                }

                // If there's exactly one node in the previous step and one in the current step,
                // and the current node has no incoming edges yet, create a sequential link.
                // This is a simple heuristic; more complex scenarios might need different logic.
                <span class="cov8" title="1">if len(prevStepNodes) &gt; 0 &amp;&amp; len(currentStepNodes) &gt; 0 </span><span class="cov8" title="1">{
                        // Connect *all* previous nodes to *all* current nodes that don't have incoming edges yet?
                        // Or just connect the *first* previous node to the *first* current node without incoming?
                        // Let's connect *each* previous node to *each* current node *if* the current node has no incoming edge yet.
                        // This might create more edges than strictly necessary but ensures connectivity.

                        for _, nodeID := range nodeNameToID </span><span class="cov8" title="1">{
                                if !nodeHasIncomingEdge[nodeID] </span><span class="cov8" title="1">{
                                        addEdge(startNodeID, nodeID, edge.HandleUnspecified)
                                }</span>
                        }
                        <span class="cov8" title="1">for _, currentNodeID := range currentStepNodes </span><span class="cov8" title="1">{
                                if !nodeHasIncomingEdge[currentNodeID] </span><span class="cov8" title="1">{
                                        // Find *a* node from the previous step to connect from.
                                        // Connecting from all previous nodes might be too much. Let's pick the first one for simplicity.
                                        if len(prevStepNodes) &gt; 0 </span><span class="cov8" title="1">{
                                                prevNodeID := prevStepNodes[0] // Connect from the first node of the previous step
                                                addEdge(prevNodeID, currentNodeID, edge.HandleUnspecified)
                                                nodeHasIncomingEdge[currentNodeID] = true // Mark as having an incoming edge now
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// ImportWorkflowYAML parses workflow format YAML and imports it as a workspace
func (s *IOWorkspaceService) ImportWorkflowYAML(ctx context.Context, data []byte) error <span class="cov0" title="0">{
        workspace, err := UnmarshalWorkflowYAML(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse workflow YAML: %w", err)
        }</span>

        // Validate the workspace data before importing
        <span class="cov0" title="0">if len(workspace.Flows) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("workflow must contain at least one flow")
        }</span>

        // Check for any invalid references between nodes
        <span class="cov0" title="0">err = workspace.VerifyIds()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("workflow validation failed: %w", err)
        }</span>

        // Import the workspace
        <span class="cov0" title="0">err = s.ImportWorkspace(ctx, *workspace)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to import workflow: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// MarshalWorkflowYAML converts a WorkspaceData structure to the workflow-centric YAML format
func MarshalWorkflowYAML(workspaceData *WorkspaceData) ([]byte, error) <span class="cov8" title="1">{
        if workspaceData == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("workspace data cannot be nil")
        }</span>

        // Create workflow format structure
        <span class="cov8" title="1">workflow := WorkflowFormat{
                WorkspaceName: workspaceData.Workspace.Name,
                Flows:         make([]WorkflowFlow, 0, len(workspaceData.Flows)),
        }

        // Map node IDs to their details for easy lookup
        nodeMap := make(map[idwrap.IDWrap]mnnode.MNode)
        for _, node := range workspaceData.FlowNodes </span><span class="cov8" title="1">{
                nodeMap[node.ID] = node
        }</span>

        // Map for special node implementations
        <span class="cov8" title="1">requestNodeMap := make(map[idwrap.IDWrap]mnrequest.MNRequest)
        for _, n := range workspaceData.FlowRequestNodes </span><span class="cov8" title="1">{
                requestNodeMap[n.FlowNodeID] = n
        }</span>

        <span class="cov8" title="1">ifNodeMap := make(map[idwrap.IDWrap]mnif.MNIF)
        for _, n := range workspaceData.FlowConditionNodes </span><span class="cov8" title="1">{
                ifNodeMap[n.FlowNodeID] = n
        }</span>

        <span class="cov8" title="1">forNodeMap := make(map[idwrap.IDWrap]mnfor.MNFor)
        for _, n := range workspaceData.FlowForNodes </span><span class="cov8" title="1">{
                forNodeMap[n.FlowNodeID] = n
        }</span>

        <span class="cov8" title="1">jsNodeMap := make(map[idwrap.IDWrap]mnjs.MNJS)
        for _, n := range workspaceData.FlowJSNodes </span><span class="cov8" title="1">{
                jsNodeMap[n.FlowNodeID] = n
        }</span>

        // Map edges by source node ID for dependency resolution
        <span class="cov8" title="1">edgesBySource := make(map[idwrap.IDWrap][]edge.Edge)
        for _, e := range workspaceData.FlowEdges </span><span class="cov8" title="1">{
                edgesBySource[e.SourceID] = append(edgesBySource[e.SourceID], e)
        }</span>

        // Map endpoints and examples for request steps
        <span class="cov8" title="1">endpointMap := make(map[idwrap.IDWrap]mitemapi.ItemApi)
        for _, e := range workspaceData.Endpoints </span><span class="cov8" title="1">{
                endpointMap[e.ID] = e
        }</span>

        <span class="cov8" title="1">exampleMap := make(map[idwrap.IDWrap]mitemapiexample.ItemApiExample)
        for _, e := range workspaceData.Examples </span><span class="cov8" title="1">{
                exampleMap[e.ID] = e
        }</span>

        <span class="cov8" title="1">headersByExample := make(map[idwrap.IDWrap][]mexampleheader.Header)
        for _, h := range workspaceData.ExampleHeaders </span><span class="cov8" title="1">{
                headersByExample[h.ExampleID] = append(headersByExample[h.ExampleID], h)
        }</span>

        <span class="cov8" title="1">bodiesByExample := make(map[idwrap.IDWrap]mbodyraw.ExampleBodyRaw)
        for _, b := range workspaceData.Rawbodies </span><span class="cov8" title="1">{
                bodiesByExample[b.ExampleID] = b
        }</span>

        // Process each flow
        <span class="cov8" title="1">for _, flow := range workspaceData.Flows </span><span class="cov8" title="1">{
                workflowFlow := WorkflowFlow{
                        Name:      flow.Name,
                        Variables: make([]WorkflowVariable, 0),
                        Steps:     make([]WorkflowStep, 0),
                }

                // Extract variables
                for _, v := range workspaceData.FlowVariables </span><span class="cov8" title="1">{
                        if v.FlowID == flow.ID </span><span class="cov8" title="1">{
                                workflowFlow.Variables = append(workflowFlow.Variables, WorkflowVariable{
                                        Name:  v.Name,
                                        Value: v.Value,
                                })
                        }</span>
                }

                // Get all nodes for this flow
                <span class="cov8" title="1">var flowNodes []mnnode.MNode
                for _, node := range workspaceData.FlowNodes </span><span class="cov8" title="1">{
                        if node.FlowID == flow.ID </span><span class="cov8" title="1">{
                                flowNodes = append(flowNodes, node)
                        }</span>
                }

                // Create a step map for YAML structure (using map to properly structure output)
                <span class="cov8" title="1">stepMaps := make([]map[string]interface{}, 0, len(flowNodes))

                // Convert nodes to steps
                for _, node := range flowNodes </span><span class="cov8" title="1">{
                        // Get incoming edges to determine dependencies
                        var dependencies []string
                        for _, e := range workspaceData.FlowEdges </span><span class="cov8" title="1">{
                                if e.TargetID == node.ID &amp;&amp; e.SourceHandler == edge.HandleUnspecified </span><span class="cov8" title="1">{
                                        // This is a standard dependency
                                        if sourceNode, ok := nodeMap[e.SourceID]; ok </span><span class="cov8" title="1">{
                                                dependencies = append(dependencies, sourceNode.Name)
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">switch node.NodeKind </span>{
                        case mnnode.NODE_KIND_REQUEST:<span class="cov8" title="1">
                                requestNode, ok := requestNodeMap[node.ID]
                                if !ok </span><span class="cov0" title="0">{
                                        continue</span> // Skip if node implementation not found
                                }

                                <span class="cov8" title="1">stepData := map[string]interface{}{
                                        "name": node.Name,
                                }

                                if len(dependencies) &gt; 0 </span><span class="cov0" title="0">{
                                        stepData["depends_on"] = dependencies
                                }</span>

                                // Add request details if available
                                <span class="cov8" title="1">if requestNode.EndpointID != nil </span><span class="cov8" title="1">{
                                        if endpoint, ok := endpointMap[*requestNode.EndpointID]; ok </span><span class="cov8" title="1">{
                                                stepData["method"] = endpoint.Method
                                                stepData["url"] = endpoint.Url
                                        }</span>
                                }

                                // Add headers and body if available
                                <span class="cov8" title="1">if requestNode.ExampleID != nil </span><span class="cov8" title="1">{
                                        exampleID := *requestNode.ExampleID

                                        // Add headers
                                        if headers, ok := headersByExample[exampleID]; ok &amp;&amp; len(headers) &gt; 0 </span><span class="cov8" title="1">{
                                                headersData := make([]map[string]string, 0, len(headers))
                                                for _, h := range headers </span><span class="cov8" title="1">{
                                                        headersData = append(headersData, map[string]string{
                                                                "name":  h.HeaderKey,
                                                                "value": h.Value,
                                                        })
                                                }</span>
                                                <span class="cov8" title="1">stepData["headers"] = headersData</span>
                                        }

                                        // Add body if available
                                        <span class="cov8" title="1">if body, ok := bodiesByExample[exampleID]; ok </span><span class="cov8" title="1">{
                                                bodyData := map[string]interface{}{}

                                                // Try to unmarshal JSON body
                                                var jsonBody map[string]interface{}
                                                if err := json.Unmarshal(body.Data, &amp;jsonBody); err == nil </span><span class="cov8" title="1">{
                                                        bodyData["body_json"] = jsonBody
                                                }</span>

                                                <span class="cov8" title="1">if len(bodyData) &gt; 0 </span><span class="cov8" title="1">{
                                                        stepData["body"] = bodyData
                                                }</span>
                                        }
                                }

                                <span class="cov8" title="1">stepMaps = append(stepMaps, map[string]interface{}{
                                        "request": stepData,
                                })</span>

                        case mnnode.NODE_KIND_CONDITION:<span class="cov8" title="1">
                                ifNode, ok := ifNodeMap[node.ID]
                                if !ok </span><span class="cov0" title="0">{
                                        continue</span> // Skip if node implementation not found
                                }

                                <span class="cov8" title="1">stepData := map[string]interface{}{
                                        "name":       node.Name,
                                        "expression": ifNode.Condition.Comparisons.Expression, // Add double quotes
                                }

                                if len(dependencies) &gt; 0 </span><span class="cov8" title="1">{
                                        stepData["depends_on"] = dependencies
                                }</span>

                                // Look for then/else targets
                                <span class="cov8" title="1">for _, e := range edgesBySource[node.ID] </span><span class="cov8" title="1">{
                                        switch e.SourceHandler </span>{
                                        case edge.HandleThen:<span class="cov8" title="1">
                                                if targetNode, ok := nodeMap[e.TargetID]; ok </span><span class="cov8" title="1">{
                                                        stepData["then"] = targetNode.Name
                                                }</span>
                                        case edge.HandleElse:<span class="cov0" title="0">
                                                if targetNode, ok := nodeMap[e.TargetID]; ok </span><span class="cov0" title="0">{
                                                        stepData["else"] = targetNode.Name
                                                }</span>
                                        }
                                }

                                <span class="cov8" title="1">stepMaps = append(stepMaps, map[string]interface{}{
                                        "if": stepData,
                                })</span>

                        case mnnode.NODE_KIND_FOR:<span class="cov8" title="1">
                                forNode, ok := forNodeMap[node.ID]
                                if !ok </span><span class="cov0" title="0">{
                                        continue</span> // Skip if node implementation not found
                                }

                                <span class="cov8" title="1">stepData := map[string]interface{}{
                                        "name":       node.Name,
                                        "iter_count": forNode.IterCount,
                                }

                                if len(dependencies) &gt; 0 </span><span class="cov8" title="1">{
                                        stepData["depends_on"] = dependencies
                                }</span>

                                // Look for loop target
                                <span class="cov8" title="1">for _, e := range edgesBySource[node.ID] </span><span class="cov8" title="1">{
                                        if e.SourceHandler == edge.HandleLoop </span><span class="cov8" title="1">{
                                                if targetNode, ok := nodeMap[e.TargetID]; ok </span><span class="cov8" title="1">{
                                                        stepData["loop"] = targetNode.Name
                                                }</span>
                                        }
                                }

                                <span class="cov8" title="1">stepMaps = append(stepMaps, map[string]interface{}{
                                        "for": stepData,
                                })</span>

                        case mnnode.NODE_KIND_JS:<span class="cov8" title="1">
                                jsNode, ok := jsNodeMap[node.ID]
                                if !ok </span><span class="cov0" title="0">{
                                        continue</span> // Skip if node implementation not found
                                }

                                <span class="cov8" title="1">stepData := map[string]interface{}{
                                        "name": node.Name,
                                        "code": string(jsNode.Code),
                                }

                                if len(dependencies) &gt; 0 </span><span class="cov0" title="0">{
                                        stepData["depends_on"] = dependencies
                                }</span>

                                <span class="cov8" title="1">stepMaps = append(stepMaps, map[string]interface{}{
                                        "js": stepData,
                                })</span>
                        }
                }

                // Add steps array to flow
                <span class="cov8" title="1">workflowFlow.Steps = nil // Clear the typed field as we'll use the raw maps

                // Custom marshalling structure with steps as a dynamic field
                flowMap := map[string]interface{}{
                        "name":      workflowFlow.Name,
                        "variables": workflowFlow.Variables,
                        "steps":     stepMaps,
                }

                workflow.Flows = append(workflow.Flows, workflowFlow)
                // Replace the last flow with our custom map to ensure proper YAML structure
                rawFlows := make([]interface{}, 0, len(workflow.Flows))
                for i, f := range workflow.Flows </span><span class="cov8" title="1">{
                        if i == len(workflow.Flows)-1 </span><span class="cov8" title="1">{
                                rawFlows = append(rawFlows, flowMap)
                        }</span> else<span class="cov0" title="0"> {
                                rawFlows = append(rawFlows, f)
                        }</span>
                }

                // We need to create a raw structure for marshalling
                <span class="cov8" title="1">rawWorkflow := map[string]interface{}{
                        "workspace_name": workflow.WorkspaceName,
                        "flows":          rawFlows,
                }

                return yaml.Marshal(rawWorkflow)</span>
        }

        // If we have no flows, just marshal the empty structure
        <span class="cov0" title="0">return yaml.Marshal(workflow)</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package logconsole

import (
        "context"
        "fmt"
        "sync"
        "the-dev-tools/server/internal/api/middleware/mwauth"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/reference"
)

// LogLevel represents the severity level of a log message
type LogLevel int32

const (
        LogLevelUnspecified LogLevel = 0
        LogLevelWarning     LogLevel = 1
        LogLevelError       LogLevel = 2
)

type LogMessage struct {
        LogID idwrap.IDWrap
        Value string
        Level LogLevel
        Refs  []reference.ReferenceTreeItem
}

type LogChanMap struct {
        mt      *sync.Mutex
        chanMap map[idwrap.IDWrap]chan LogMessage
}

func NewLogChanMap() LogChanMap <span class="cov0" title="0">{
        chanMap := make(map[idwrap.IDWrap]chan LogMessage, 10)
        return LogChanMap{
                chanMap: chanMap,
                mt:      &amp;sync.Mutex{},
        }
}</span>

func NewLogChanMapWith(size int) LogChanMap <span class="cov0" title="0">{
        chanMap := make(map[idwrap.IDWrap]chan LogMessage, size)
        return LogChanMap{
                chanMap: chanMap,
                mt:      &amp;sync.Mutex{},
        }
}</span>

const bufferSize = 10

func (l *LogChanMap) AddLogChannel(userID idwrap.IDWrap) chan LogMessage <span class="cov0" title="0">{
        lm := make(chan LogMessage, bufferSize)
        l.mt.Lock()
        defer l.mt.Unlock()
        l.chanMap[userID] = lm
        return lm
}</span>

func (l *LogChanMap) DeleteLogChannel(userID idwrap.IDWrap) <span class="cov0" title="0">{
        l.mt.Lock()
        defer l.mt.Unlock()
        delete(l.chanMap, userID)
}</span>

func SendLogMessage(ch chan LogMessage, logID idwrap.IDWrap, value string, level LogLevel, refs []reference.ReferenceTreeItem) <span class="cov0" title="0">{
        ch &lt;- LogMessage{
                LogID: logID,
                Value: value,
                Level: level,
                Refs:  refs,
        }
}</span>

func (logChannels *LogChanMap) SendMsgToUserWithContext(ctx context.Context, logID idwrap.IDWrap, value string, level LogLevel, refs []reference.ReferenceTreeItem) error <span class="cov0" title="0">{
        logChannels.mt.Lock()
        defer logChannels.mt.Unlock()
        userID, err := mwauth.GetContextUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ch, ok := logChannels.chanMap[userID]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("userID's log channel not found")
        }</span>
        <span class="cov0" title="0">SendLogMessage(ch, logID, value, level, refs)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package mocklogger

import (
        "context"
        "log/slog"
)

// MockHandler is a mock implementation of slog.Handler
type MockHandler struct {
        // You can add fields here to track calls for testing if needed
        // For example:
        LoggedMessages []string
        LoggedLevels   []slog.Level
}

// Enabled implements slog.Handler.
func (h *MockHandler) Enabled(_ context.Context, _ slog.Level) bool <span class="cov0" title="0">{
        return true
}</span>

// Handle implements slog.Handler.
func (h *MockHandler) Handle(_ context.Context, r slog.Record) error <span class="cov0" title="0">{
        // In a real test, you might want to store the record information
        if h.LoggedMessages != nil </span><span class="cov0" title="0">{
                h.LoggedMessages = append(h.LoggedMessages, r.Message)
        }</span>
        <span class="cov0" title="0">if h.LoggedLevels != nil </span><span class="cov0" title="0">{
                h.LoggedLevels = append(h.LoggedLevels, r.Level)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// WithAttrs implements slog.Handler.
func (h *MockHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov0" title="0">{
        return h
}</span>

// WithGroup implements slog.Handler.
func (h *MockHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        return h
}</span>

// NewMockLogger creates a new logger with the mock handler
func NewMockLogger() *slog.Logger <span class="cov0" title="0">{
        handler := &amp;MockHandler{
                LoggedMessages: []string{},
                LoggedLevels:   []slog.Level{},
        }
        return slog.New(handler)
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package migrate

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "os"
        devtoolsdb "the-dev-tools/db"
        "the-dev-tools/server/pkg/idwrap"
)

type MigrateManager struct {
        db *sql.DB
}

type Migration struct {
        ID          idwrap.IDWrap `json:"id"`
        Version     int           `json:"version"`
        Description string        `json:"description"`
        Apply_at    int           `json:"apply_at"`
        Sql         []string      `json:"sql"`
}

type MigrationRaw struct {
        ID          string   `json:"id"`
        Version     int      `json:"version"`
        Description string   `json:"description"`
        Apply_at    int      `json:"apply_at"`
        Sql         []string `json:"sql"`
}

func NewTX(db *sql.DB) MigrateManager <span class="cov8" title="1">{
        return MigrateManager{db: db}
}</span>

func CreateNewDBForTesting(currentDBPath, testDBPath string) error <span class="cov8" title="1">{
        allDBData, err := os.ReadFile(currentDBPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = os.WriteFile(testDBPath, allDBData, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ParsePath(path string) ([]Migration, error) <span class="cov8" title="1">{
        // Get All Files in path

        files, err := os.ReadDir(path)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov8" title="1">var migrationsRaw []MigrationRaw

        for _, file := range files </span><span class="cov8" title="1">{
                jsonFile, err := os.Open(path + "/" + file.Name())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">data, err := io.ReadAll(jsonFile)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">var migration MigrationRaw
                err = json.Unmarshal(data, &amp;migration)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">migrationsRaw = append(migrationsRaw, migration)</span>
        }

        <span class="cov8" title="1">var migrations []Migration
        for _, migrationRaw := range migrationsRaw </span><span class="cov8" title="1">{
                id, err := idwrap.NewText(migrationRaw.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">migrations = append(migrations, Migration{
                        ID:          id,
                        Version:     migrationRaw.Version,
                        Description: migrationRaw.Description,
                        Apply_at:    migrationRaw.Apply_at,
                        Sql:         migrationRaw.Sql,
                })</span>
        }

        <span class="cov8" title="1">return migrations, nil</span>
}

func (m MigrateManager) ApplyMigration(migration Migration) error <span class="cov8" title="1">{
        db := m.db
        tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer devtoolsdb.TxnRollback(tx)

        fmt.Println("Applying migration", migration.ID)
        for i, sql := range migration.Sql </span><span class="cov8" title="1">{
                fmt.Println("Applying migration sql", i)
                _, err := tx.Exec(sql)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">err = tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package massert

import (
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mcondition"
        deltav1 "the-dev-tools/spec/dist/buf/go/delta/v1"
)

type AssertType int8

type AssertService interface {
        Get(key, value string) (interface{}, error)
}

// AssertSource represents the source kind of assert for delta operations
type AssertSource int8

const (
        AssertSourceOrigin AssertSource = 1 // SOURCE_KIND_ORIGIN
        AssertSourceMixed  AssertSource = 2 // SOURCE_KIND_MIXED
        AssertSourceDelta  AssertSource = 3 // SOURCE_KIND_DELTA
)

// ToSourceKind converts AssertSource to deltav1.SourceKind
func (s AssertSource) ToSourceKind() deltav1.SourceKind <span class="cov0" title="0">{
        switch s </span>{
        case AssertSourceOrigin:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_ORIGIN</span>
        case AssertSourceMixed:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_MIXED</span>
        case AssertSourceDelta:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_DELTA</span>
        default:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_UNSPECIFIED</span>
        }
}

// FromSourceKind converts deltav1.SourceKind to AssertSource
func FromSourceKind(kind deltav1.SourceKind) AssertSource <span class="cov0" title="0">{
        switch kind </span>{
        case deltav1.SourceKind_SOURCE_KIND_ORIGIN:<span class="cov0" title="0">
                return AssertSourceOrigin</span>
        case deltav1.SourceKind_SOURCE_KIND_MIXED:<span class="cov0" title="0">
                return AssertSourceMixed</span>
        case deltav1.SourceKind_SOURCE_KIND_DELTA:<span class="cov0" title="0">
                return AssertSourceDelta</span>
        default:<span class="cov0" title="0">
                return AssertSourceOrigin</span> // default to origin
        }
}

const (
        AssertTypeUndefined      AssertType = 0
        AssertTypeEqual          AssertType = 1
        AssertTypeNotEqual       AssertType = 2
        AssertTypeContains       AssertType = 3
        AssertTypeNotContains    AssertType = 4
        AssertTypeGreater        AssertType = 5
        AssertTypeLess           AssertType = 6
        AssertTypeGreaterOrEqual AssertType = 7
        AssertTypeLessOrEqual    AssertType = 8
)

func MapAssertType() map[AssertType]string <span class="cov0" title="0">{
        return map[AssertType]string{
                AssertTypeUndefined:      "undefined",
                AssertTypeEqual:          "==",
                AssertTypeNotEqual:       "!=",
                AssertTypeContains:       "contains",
                AssertTypeNotContains:    "not contains",
                AssertTypeGreater:        "&gt;",
                AssertTypeLess:           "&lt;",
                AssertTypeGreaterOrEqual: "&gt;=",
                AssertTypeLessOrEqual:    "&lt;=",
        }
}</span>

type AssertDotPath string

// Dot notation paths keys
// Root
const (
        RDNResp   = "response"
        RDNBody   = "body"
        RDNHeader = "header"
)

type Assert struct {
        ID            idwrap.IDWrap
        ExampleID     idwrap.IDWrap
        DeltaParentID *idwrap.IDWrap
        Condition     mcondition.Condition

        Enable bool
        Prev   *idwrap.IDWrap
        Next   *idwrap.IDWrap
}

// DetermineDeltaType determines the delta type based on the assert's relationships
// This function replaces the need for storing Source explicitly
func (a *Assert) DetermineDeltaType(exampleHasVersionParent bool) AssertSource <span class="cov0" title="0">{
        // If no DeltaParentID, determine based on example type
        if a.DeltaParentID == nil </span><span class="cov0" title="0">{
                if exampleHasVersionParent </span><span class="cov0" title="0">{
                        // No parent in a delta example = standalone DELTA item
                        return AssertSourceDelta
                }</span>
                // No parent in origin example = ORIGIN item
                <span class="cov0" title="0">return AssertSourceOrigin</span>
        }

        // Has DeltaParentID - determine based on example type
        <span class="cov0" title="0">if exampleHasVersionParent </span><span class="cov0" title="0">{
                // In delta example with parent reference = MIXED (modified from parent)
                return AssertSourceMixed
        }</span>

        // In origin example with parent reference = MIXED
        <span class="cov0" title="0">return AssertSourceMixed</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package mbodyform

import (
        "the-dev-tools/server/pkg/idwrap"
        deltav1 "the-dev-tools/spec/dist/buf/go/delta/v1"
)

// BodyFormSource represents the source type for body forms
type BodyFormSource int8

const (
        BodyFormSourceOrigin BodyFormSource = 1
        BodyFormSourceMixed  BodyFormSource = 2
        BodyFormSourceDelta  BodyFormSource = 3
)

// ToSourceKind converts BodyFormSource to deltav1.SourceKind
func (s BodyFormSource) ToSourceKind() deltav1.SourceKind <span class="cov0" title="0">{
        switch s </span>{
        case BodyFormSourceOrigin:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_ORIGIN</span>
        case BodyFormSourceMixed:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_MIXED</span>
        case BodyFormSourceDelta:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_DELTA</span>
        default:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_UNSPECIFIED</span>
        }
}

// FromSourceKind converts deltav1.SourceKind to BodyFormSource
func FromSourceKind(kind deltav1.SourceKind) BodyFormSource <span class="cov0" title="0">{
        switch kind </span>{
        case deltav1.SourceKind_SOURCE_KIND_ORIGIN:<span class="cov0" title="0">
                return BodyFormSourceOrigin</span>
        case deltav1.SourceKind_SOURCE_KIND_MIXED:<span class="cov0" title="0">
                return BodyFormSourceMixed</span>
        case deltav1.SourceKind_SOURCE_KIND_DELTA:<span class="cov0" title="0">
                return BodyFormSourceDelta</span>
        default:<span class="cov0" title="0">
                return BodyFormSourceOrigin</span>
        }
}

type BodyForm struct {
        BodyKey       string         `json:"body_key"`
        Description   string         `json:"description"`
        Value         string         `json:"value"`
        Enable        bool           `json:"enable"`
        DeltaParentID *idwrap.IDWrap `json:"delta_parent_id"`
        ID            idwrap.IDWrap  `json:"id"`
        ExampleID     idwrap.IDWrap  `json:"example_id"`
}

func (bf BodyForm) IsEnabled() bool <span class="cov0" title="0">{
        return bf.Enable
}</span>

// DetermineDeltaType determines the delta type based on the body form's relationships
// This function replaces the need for storing Source explicitly
func (bf *BodyForm) DetermineDeltaType(exampleHasVersionParent bool) BodyFormSource <span class="cov0" title="0">{
        // If no DeltaParentID, this is not a delta body form
        if bf.DeltaParentID == nil </span><span class="cov0" title="0">{
                return BodyFormSourceOrigin
        }</span>

        // If example has VersionParentID, this is a delta example
        <span class="cov0" title="0">if exampleHasVersionParent </span><span class="cov0" title="0">{
                // BodyForm has DeltaParentID and example is delta -&gt; DELTA body form
                return BodyFormSourceDelta
        }</span>

        // If example has no VersionParentID, it's an original example
        // BodyForm has DeltaParentID but example is original -&gt; MIXED body form
        <span class="cov0" title="0">return BodyFormSourceMixed</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package mbodyurl

import (
        "the-dev-tools/server/pkg/idwrap"
        deltav1 "the-dev-tools/spec/dist/buf/go/delta/v1"
)

type BodyURLEncodedSource int8

const (
        BodyURLEncodedSourceOrigin BodyURLEncodedSource = 1
        BodyURLEncodedSourceDelta  BodyURLEncodedSource = 2
        BodyURLEncodedSourceMixed  BodyURLEncodedSource = 3
)

func (s BodyURLEncodedSource) ToSourceKind() deltav1.SourceKind <span class="cov0" title="0">{
        switch s </span>{
        case BodyURLEncodedSourceOrigin:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_ORIGIN</span>
        case BodyURLEncodedSourceDelta:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_DELTA</span>
        case BodyURLEncodedSourceMixed:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_MIXED</span>
        default:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_UNSPECIFIED</span>
        }
}

func FromSourceKind(kind deltav1.SourceKind) BodyURLEncodedSource <span class="cov0" title="0">{
        switch kind </span>{
        case deltav1.SourceKind_SOURCE_KIND_ORIGIN:<span class="cov0" title="0">
                return BodyURLEncodedSourceOrigin</span>
        case deltav1.SourceKind_SOURCE_KIND_DELTA:<span class="cov0" title="0">
                return BodyURLEncodedSourceDelta</span>
        case deltav1.SourceKind_SOURCE_KIND_MIXED:<span class="cov0" title="0">
                return BodyURLEncodedSourceMixed</span>
        default:<span class="cov0" title="0">
                return BodyURLEncodedSourceOrigin</span>
        }
}

type BodyURLEncoded struct {
        BodyKey       string         `json:"body_key"`
        Description   string         `json:"description"`
        Value         string         `json:"value"`
        Enable        bool           `json:"enable"`
        DeltaParentID *idwrap.IDWrap `json:"delta_parent_id"`
        ID            idwrap.IDWrap  `json:"id"`
        ExampleID     idwrap.IDWrap  `json:"example_id"`
}

func (bue BodyURLEncoded) IsEnabled() bool <span class="cov0" title="0">{
        return bue.Enable
}</span>

// DetermineDeltaType determines the delta type based on the body URL encoded's relationships
// This function replaces the need for storing Source explicitly
func (bue *BodyURLEncoded) DetermineDeltaType(exampleHasVersionParent bool) BodyURLEncodedSource <span class="cov0" title="0">{
        // If no DeltaParentID, this is not a delta body URL encoded
        if bue.DeltaParentID == nil </span><span class="cov0" title="0">{
                return BodyURLEncodedSourceOrigin
        }</span>

        // If example has VersionParentID, this is a delta example
        <span class="cov0" title="0">if exampleHasVersionParent </span><span class="cov0" title="0">{
                // BodyURLEncoded has DeltaParentID and example is delta -&gt; DELTA body URL encoded
                return BodyURLEncodedSourceDelta
        }</span>

        // If example has no VersionParentID, it's an original example
        // BodyURLEncoded has DeltaParentID but example is original -&gt; MIXED body URL encoded
        <span class="cov0" title="0">return BodyURLEncodedSourceMixed</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package mcollection

import (
        "fmt"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/movable"
        "time"
)

const (
        CollectionNodeTypeUnspecified int32 = 0
        CollectionNodeTypeRequest     int32 = 1
        CollectionNodeTypeFolder      int32 = 2
)

type Collection struct {
        Updated     time.Time
        Name        string
        ID          idwrap.IDWrap
        WorkspaceID idwrap.IDWrap
}

func (c Collection) GetCreatedTime() time.Time <span class="cov0" title="0">{
        return c.ID.Time()
}</span>

func (c Collection) GetCreatedTimeUnix() int64 <span class="cov0" title="0">{
        return idwrap.GetUnixMilliFromULID(c.ID)
}</span>

type MetaCollection struct {
        Name string
        ID   idwrap.IDWrap
}

func (mc MetaCollection) GetCreatedTime() time.Time <span class="cov0" title="0">{
        return mc.ID.Time()
}</span>

// Implement movable.Movable interface for Collection

// GetID returns the unique identifier of the collection
func (c Collection) GetID() idwrap.IDWrap <span class="cov0" title="0">{
        return c.ID
}</span>

// GetListTypes returns all list types this collection can participate in
// Collections only participate in the collections list type within workspaces
func (c Collection) GetListTypes() []movable.ListType <span class="cov0" title="0">{
        return []movable.ListType{movable.CollectionListTypeCollections}
}</span>

// GetPosition returns the current position of the collection in the specified list type
// For collections, this requires database access, so we'll implement this in the service layer
func (c Collection) GetPosition(listType movable.ListType) (int, error) <span class="cov0" title="0">{
        // This method requires database access, so it should be implemented via the repository
        // We'll return an error here to indicate this needs to be handled at the service level
        return 0, fmt.Errorf("GetPosition must be called through the repository layer")
}</span>

// SetPosition updates the position of the collection in the specified list type
// For collections, this requires database access, so we'll implement this in the service layer
func (c Collection) SetPosition(listType movable.ListType, position int) error <span class="cov0" title="0">{
        // This method requires database access, so it should be implemented via the repository
        // We'll return an error here to indicate this needs to be handled at the service level
        return fmt.Errorf("SetPosition must be called through the repository layer")
}</span>

// GetParentID returns the parent container ID for the specified list type
// For collections, the parent is always the workspace
func (c Collection) GetParentID(listType movable.ListType) (*idwrap.IDWrap, error) <span class="cov0" title="0">{
        switch listType </span>{
        case movable.CollectionListTypeCollections:<span class="cov0" title="0">
                return &amp;c.WorkspaceID, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("collection does not support list type: %s", listType.String())</span>
        }
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package mexampleheader

import (
        "the-dev-tools/server/pkg/idwrap"
        deltav1 "the-dev-tools/spec/dist/buf/go/delta/v1"
)

// HeaderSource represents the source kind of header for delta operations
type HeaderSource int8

const (
        HeaderSourceOrigin HeaderSource = 1 // SOURCE_KIND_ORIGIN
        HeaderSourceMixed  HeaderSource = 2 // SOURCE_KIND_MIXED
        HeaderSourceDelta  HeaderSource = 3 // SOURCE_KIND_DELTA
)

// ToSourceKind converts HeaderSource to deltav1.SourceKind
func (s HeaderSource) ToSourceKind() deltav1.SourceKind <span class="cov0" title="0">{
        switch s </span>{
        case HeaderSourceOrigin:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_ORIGIN</span>
        case HeaderSourceMixed:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_MIXED</span>
        case HeaderSourceDelta:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_DELTA</span>
        default:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_UNSPECIFIED</span>
        }
}

// FromSourceKind converts deltav1.SourceKind to HeaderSource
func FromSourceKind(kind deltav1.SourceKind) HeaderSource <span class="cov0" title="0">{
        switch kind </span>{
        case deltav1.SourceKind_SOURCE_KIND_ORIGIN:<span class="cov0" title="0">
                return HeaderSourceOrigin</span>
        case deltav1.SourceKind_SOURCE_KIND_MIXED:<span class="cov0" title="0">
                return HeaderSourceMixed</span>
        case deltav1.SourceKind_SOURCE_KIND_DELTA:<span class="cov0" title="0">
                return HeaderSourceDelta</span>
        default:<span class="cov0" title="0">
                return HeaderSourceOrigin</span> // default to origin
        }
}

type Header struct {
        HeaderKey     string
        Description   string
        Value         string
        Enable        bool
        ID            idwrap.IDWrap
        DeltaParentID *idwrap.IDWrap
        ExampleID     idwrap.IDWrap
        Prev          *idwrap.IDWrap
        Next          *idwrap.IDWrap
}

func (h Header) IsEnabled() bool <span class="cov0" title="0">{
        return h.Enable
}</span>

// DetermineDeltaType determines the delta type based on the header's relationships
// This function will replace the need for storing Source explicitly
func (h *Header) DetermineDeltaType(exampleHasVersionParent bool) HeaderSource <span class="cov0" title="0">{
        // If no DeltaParentID, determine based on example type
        if h.DeltaParentID == nil </span><span class="cov0" title="0">{
                if exampleHasVersionParent </span><span class="cov0" title="0">{
                        // No parent in a delta example = standalone DELTA item
                        return HeaderSourceDelta
                }</span>
                // No parent in origin example = ORIGIN item
                <span class="cov0" title="0">return HeaderSourceOrigin</span>
        }

        // Has DeltaParentID - determine based on example type
        <span class="cov0" title="0">if exampleHasVersionParent </span><span class="cov0" title="0">{
                // In delta example with parent reference = MIXED (modified from parent)
                return HeaderSourceMixed
        }</span>

        // In origin example with parent reference = MIXED
        <span class="cov0" title="0">return HeaderSourceMixed</span>
}

// IsModified checks if the header has been modified from its parent
// This would need to be implemented based on your modification tracking logic
func (h *Header) IsModified() bool <span class="cov0" title="0">{
        // TODO: Implement modification detection logic
        // This could involve:
        // 1. Comparing with parent header values
        // 2. Checking a modification timestamp
        // 3. Using a separate modification tracking table
        return false
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package mexamplequery

import (
        "the-dev-tools/server/pkg/idwrap"
        deltav1 "the-dev-tools/spec/dist/buf/go/delta/v1"
)

// QuerySource represents the source kind of query for delta operations
type QuerySource int8

const (
        QuerySourceOrigin QuerySource = 1 // SOURCE_KIND_ORIGIN
        QuerySourceMixed  QuerySource = 2 // SOURCE_KIND_MIXED
        QuerySourceDelta  QuerySource = 3 // SOURCE_KIND_DELTA
)

// ToSourceKind converts QuerySource to deltav1.SourceKind
func (s QuerySource) ToSourceKind() deltav1.SourceKind <span class="cov0" title="0">{
        switch s </span>{
        case QuerySourceOrigin:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_ORIGIN</span>
        case QuerySourceMixed:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_MIXED</span>
        case QuerySourceDelta:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_DELTA</span>
        default:<span class="cov0" title="0">
                return deltav1.SourceKind_SOURCE_KIND_UNSPECIFIED</span>
        }
}

// FromSourceKind converts deltav1.SourceKind to QuerySource
func FromSourceKind(kind deltav1.SourceKind) QuerySource <span class="cov0" title="0">{
        switch kind </span>{
        case deltav1.SourceKind_SOURCE_KIND_ORIGIN:<span class="cov0" title="0">
                return QuerySourceOrigin</span>
        case deltav1.SourceKind_SOURCE_KIND_MIXED:<span class="cov0" title="0">
                return QuerySourceMixed</span>
        case deltav1.SourceKind_SOURCE_KIND_DELTA:<span class="cov0" title="0">
                return QuerySourceDelta</span>
        default:<span class="cov0" title="0">
                return QuerySourceOrigin</span> // default to origin
        }
}

type Query struct {
        QueryKey      string
        Description   string
        Value         string
        Enable        bool
        DeltaParentID *idwrap.IDWrap
        ID            idwrap.IDWrap
        ExampleID     idwrap.IDWrap
}

func (q Query) IsEnabled() bool <span class="cov0" title="0">{
        return q.Enable
}</span>

// DetermineDeltaType determines the delta type based on the query's relationships
// This function dynamically determines the source type without storing it explicitly
//
// Logic Matrix:
// | Has DeltaParentID | Example Has VersionParent | Result | Meaning |
// |-------------------|---------------------------|--------|---------|
// | No                | No                        | ORIGIN | Standalone item in origin example |
// | No                | Yes                       | DELTA  | New item created in delta example |
// | Yes               | No                        | MIXED  | Item referencing another in origin example |
// | Yes               | Yes                       | MIXED  | Item in delta example modified from parent |
//
// The key principle is:
// - **Has parent + unchanged** = ORIGIN (determined by value comparison at runtime)
// - **Has parent + changed** = MIXED (items that differ from their parent)
// - **No parent** = DELTA (standalone items created in delta example)
func (q *Query) DetermineDeltaType(exampleHasVersionParent bool) QuerySource <span class="cov0" title="0">{
        // If no DeltaParentID, determine based on example type
        if q.DeltaParentID == nil </span><span class="cov0" title="0">{
                if exampleHasVersionParent </span><span class="cov0" title="0">{
                        // No parent in a delta example = standalone DELTA item
                        return QuerySourceDelta
                }</span>
                // No parent in origin example = ORIGIN item
                <span class="cov0" title="0">return QuerySourceOrigin</span>
        }

        // Has DeltaParentID - determine based on example type
        <span class="cov0" title="0">if exampleHasVersionParent </span><span class="cov0" title="0">{
                // In delta example with parent reference = MIXED (modified from parent)
                return QuerySourceMixed
        }</span>

        // In origin example with parent reference = MIXED
        <span class="cov0" title="0">return QuerySourceMixed</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package mflowvariable

import (
        "the-dev-tools/server/pkg/idwrap"
)

// FlowVariable represents a variable associated with a flow
type FlowVariable struct {
        ID          idwrap.IDWrap `json:"id"`
        FlowID      idwrap.IDWrap `json:"flow_id"`
        Name        string        `json:"key"`
        Value       string        `json:"value"`
        Enabled     bool          `json:"enabled"`
        Description string        `json:"description"`
}

type FlowVariableUpdate struct {
        ID          idwrap.IDWrap `json:"id"`
        Name        *string       `json:"key"`
        Value       *string       `json:"value"`
        Enabled     *bool         `json:"enabled"`
        Description *string       `json:"description"`
}

func (fv FlowVariable) IsEnabled() bool <span class="cov0" title="0">{
        return fv.Enabled
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package mitemapiexample

import (
        "the-dev-tools/server/pkg/idwrap"
        "time"
)

type BodyType int8

const (
        BodyTypeNone BodyType = iota
        BodyTypeForm
        BodyTypeUrlencoded
        BodyTypeRaw
)

type ItemApiExampleMeta struct {
        Name string
        ID   idwrap.IDWrap
}

type ItemApiExample struct {
        Prev      *idwrap.IDWrap
        Next      *idwrap.IDWrap
        Updated   time.Time
        Name      string
        IsDefault bool
        BodyType  BodyType

        VersionParentID *idwrap.IDWrap

        ID           idwrap.IDWrap
        ItemApiID    idwrap.IDWrap
        CollectionID idwrap.IDWrap
}

func (i ItemApiExample) GetCreatedTime() time.Time <span class="cov0" title="0">{
        return i.ID.Time()
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package mnnode

import (
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mnnode/mnfor"
        "the-dev-tools/server/pkg/model/mnnode/mnif"
        "the-dev-tools/server/pkg/model/mnnode/mnrequest"
)

type NodeKind = int32

const (
        NODE_KIND_UNSPECIFIED NodeKind = 0
        NODE_KIND_NO_OP       NodeKind = 1
        NODE_KIND_REQUEST     NodeKind = 2
        NODE_KIND_CONDITION   NodeKind = 3
        NODE_KIND_FOR         NodeKind = 4
        NODE_KIND_FOR_EACH    NodeKind = 5
        NODE_KIND_JS          NodeKind = 6
)

type NodeState = int8

const (
        NODE_STATE_UNSPECIFIED NodeState = 0
        NODE_STATE_RUNNING     NodeState = 1
        NODE_STATE_SUCCESS     NodeState = 2
        NODE_STATE_FAILURE     NodeState = 3
        NODE_STATE_CANCELED    NodeState = 4
)

func StringNodeState(a NodeState) string <span class="cov0" title="0">{
        return [...]string{"Unspecified", "Running", "Success", "Failure", "Canceled"}[a]
}</span>

func StringNodeStateWithIcons(a NodeState) string <span class="cov0" title="0">{
        return [...]string{"🔄 Starting", "⏳ Running", "✅ Success", "❌ Failed", "Canceled"}[a]
}</span>

type MNode struct {
        ID        idwrap.IDWrap
        FlowID    idwrap.IDWrap
        Name      string
        NodeKind  NodeKind
        PositionX float64
        PositionY float64
}

type NodeInterface interface {
        mnfor.MNFor | mnif.MNIF | mnrequest.MNRequest
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package mnodeexecution

import (
        "encoding/json"
        "the-dev-tools/server/pkg/compress"
        "the-dev-tools/server/pkg/idwrap"
)

type NodeExecution struct {
        ID                     idwrap.IDWrap  `json:"id"`
        NodeID                 idwrap.IDWrap  `json:"node_id"`
        Name                   string         `json:"name"`
        State                  int8           `json:"state"`
        Error                  *string        `json:"error,omitempty"`
        InputData              []byte         `json:"input_data,omitempty"`
        InputDataCompressType  int8           `json:"input_data_compress_type"`
        OutputData             []byte         `json:"output_data,omitempty"`
        OutputDataCompressType int8           `json:"output_data_compress_type"`
        ResponseID             *idwrap.IDWrap `json:"response_id,omitempty"`
        CompletedAt            *int64         `json:"completed_at,omitempty"`
}

// Helper methods for JSON handling with compression
func (ne *NodeExecution) GetInputJSON() (json.RawMessage, error) <span class="cov0" title="0">{
        if ne.InputData == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if ne.InputDataCompressType == compress.CompressTypeNone </span><span class="cov0" title="0">{
                return ne.InputData, nil
        }</span>
        <span class="cov0" title="0">return compress.Decompress(ne.InputData, ne.InputDataCompressType)</span>
}

func (ne *NodeExecution) SetInputJSON(data json.RawMessage) error <span class="cov0" title="0">{
        // For small data (&lt; 1KB), don't compress
        if len(data) &lt; 1024 </span><span class="cov0" title="0">{
                ne.InputData = data
                ne.InputDataCompressType = compress.CompressTypeNone
                return nil
        }</span>

        // Use zstd compression for larger data
        <span class="cov0" title="0">compressed, err := compress.Compress(data, compress.CompressTypeZstd)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Only use compressed if it's actually smaller
        <span class="cov0" title="0">if len(compressed) &lt; len(data) </span><span class="cov0" title="0">{
                ne.InputData = compressed
                ne.InputDataCompressType = compress.CompressTypeZstd
        }</span> else<span class="cov0" title="0"> {
                ne.InputData = data
                ne.InputDataCompressType = compress.CompressTypeNone
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Similar methods for output data
func (ne *NodeExecution) GetOutputJSON() (json.RawMessage, error) <span class="cov0" title="0">{
        if ne.OutputData == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if ne.OutputDataCompressType == compress.CompressTypeNone </span><span class="cov0" title="0">{
                return ne.OutputData, nil
        }</span>
        <span class="cov0" title="0">return compress.Decompress(ne.OutputData, ne.OutputDataCompressType)</span>
}

func (ne *NodeExecution) SetOutputJSON(data json.RawMessage) error <span class="cov0" title="0">{
        // Same compression logic as SetInputJSON
        if len(data) &lt; 1024 </span><span class="cov0" title="0">{
                ne.OutputData = data
                ne.OutputDataCompressType = compress.CompressTypeNone
                return nil
        }</span>

        <span class="cov0" title="0">compressed, err := compress.Compress(data, compress.CompressTypeZstd)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(compressed) &lt; len(data) </span><span class="cov0" title="0">{
                ne.OutputData = compressed
                ne.OutputDataCompressType = compress.CompressTypeZstd
        }</span> else<span class="cov0" title="0"> {
                ne.OutputData = data
                ne.OutputDataCompressType = compress.CompressTypeNone
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package mworkspace

import (
        "the-dev-tools/server/pkg/idwrap"
        "time"
)

type Workspace struct {
        FlowCount       int32
        CollectionCount int32
        Updated         time.Time
        Name            string
        ActiveEnv       idwrap.IDWrap
        GlobalEnv       idwrap.IDWrap
        ID              idwrap.IDWrap
}

func (w Workspace) GetCreatedTime() time.Time <span class="cov0" title="0">{
        return w.ID.Time()
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package mresultapi

import (
        "database/sql/driver"
        "errors"
        "net/http"
        "the-dev-tools/server/pkg/idwrap"
        "time"

        "github.com/goccy/go-json"
)

type TriggerType int16

var (
        TRIGGER_TYPE_UNSPECIFIED TriggerType = 0
        TRIGGER_TYPE_COLLECTION  TriggerType = 1
        TRIGGER_TYPE_FLOW        TriggerType = 2
        TRIGGER_TYPE_CRON        TriggerType = 3
        TRIGGER_TYPE_WEBHOOK     TriggerType = 4
)

type MResultAPI struct {
        Time        time.Time     `json:"time"`
        Name        string        `json:"name"`
        HttpResp    HttpResp      `json:"httpResp"`
        Duration    time.Duration `json:"duration"`
        TriggerType TriggerType   `json:"triggerdBy"`
        ID          idwrap.IDWrap `json:"id"`
        TriggerBy   idwrap.IDWrap `json:"rootID"`
}

type HttpResp struct {
        Header     http.Header `json:"header"`
        Proto      string      `json:"proto"`
        Body       []byte      `json:"body"`
        StatusCode int         `json:"statusCode"`
        ProtoMajor int         `json:"protoMajor"`
        ProtoMinor int         `json:"protoMinor"`
}

func (h HttpResp) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(h)
}</span>

func (h *HttpResp) Scan(value interface{}) error <span class="cov0" title="0">{
        data, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("type assertion to []byte failed")
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(data, &amp;h)</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package permcheck

import (
        "connectrpc.com/connect"
)

func CheckPerm(ok bool, error error) *connect.Error <span class="cov0" title="0">{
        if error != nil </span><span class="cov0" title="0">{
                // If error is already a connect.Error, preserve it
                if connectErr, isConnectErr := error.(*connect.Error); isConnectErr </span><span class="cov0" title="0">{
                        return connectErr
                }</span>
                <span class="cov0" title="0">return connect.NewError(connect.CodeInternal, error)</span>
        }
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                return connect.NewError(connect.CodePermissionDenied, nil)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package reference

import (
        "errors"
        "fmt"
        "reflect"
        "strings"
        referencev1 "the-dev-tools/spec/dist/buf/go/reference/v1"
)

type ReferenceKeyKind int32

const (
        ReferenceKeyKind_REFERENCE_KEY_KIND_UNSPECIFIED ReferenceKeyKind = 0
        ReferenceKeyKind_REFERENCE_KEY_KIND_GROUP       ReferenceKeyKind = 1
        ReferenceKeyKind_REFERENCE_KEY_KIND_KEY         ReferenceKeyKind = 2
        ReferenceKeyKind_REFERENCE_KEY_KIND_INDEX       ReferenceKeyKind = 3
        ReferenceKeyKind_REFERENCE_KEY_KIND_ANY         ReferenceKeyKind = 4
)

type ReferenceKind int32

const (
        ReferenceKind_REFERENCE_KIND_UNSPECIFIED ReferenceKind = 0
        ReferenceKind_REFERENCE_KIND_MAP         ReferenceKind = 1
        ReferenceKind_REFERENCE_KIND_ARRAY       ReferenceKind = 2
        ReferenceKind_REFERENCE_KIND_VALUE       ReferenceKind = 3
        ReferenceKind_REFERENCE_KIND_VARIABLE    ReferenceKind = 4
)

type ReferenceKey struct {
        Kind  ReferenceKeyKind `protobuf:"varint,6661032,opt,name=kind,proto3,enum=reference.v1.ReferenceKeyKind" json:"kind,omitempty"`
        Group string           `protobuf:"bytes,49400938,opt,name=group,proto3,oneof" json:"group,omitempty"`
        Key   string           `protobuf:"bytes,7735364,opt,name=key,proto3,oneof" json:"key,omitempty"`
        Index int32            `protobuf:"varint,15866608,opt,name=index,proto3,oneof" json:"index,omitempty"`
}

type ReferenceTreeItem struct {
        Kind     ReferenceKind       `protobuf:"varint,9499794,opt,name=kind,proto3,enum=reference.v1.ReferenceKind" json:"kind,omitempty"`
        Key      ReferenceKey        `protobuf:"bytes,1233330,opt,name=key,proto3" json:"key,omitempty"`
        Map      []ReferenceTreeItem `protobuf:"bytes,15377576,rep,name=map,proto3" json:"map,omitempty"`           // Child map references
        Array    []ReferenceTreeItem `protobuf:"bytes,885261,rep,name=array,proto3" json:"array,omitempty"`         // Child array references
        Value    string              `protobuf:"bytes,24220210,opt,name=value,proto3,oneof" json:"value,omitempty"` // Primitive value as JSON string
        Variable []string            `protobuf:"bytes,24548959,rep,name=variable,proto3" json:"variable,omitempty"` // Environment names containing the variable
}

var (
        ErrNilMap   = errors.New("map is nil")
        ErrEmptyMap = errors.New("map is empty")
)

func ConvertMapToReference(m map[string]interface{}, key string) (ReferenceTreeItem, error) <span class="cov0" title="0">{
        var ref ReferenceTreeItem
        if m == nil </span><span class="cov0" title="0">{
                return ref, ErrNilMap
        }</span>

        <span class="cov0" title="0">var subRefs []ReferenceTreeItem
        for k, v := range m </span><span class="cov0" title="0">{
                vMap, ok := v.(map[string]interface{})
                key := ReferenceKey{
                        Kind: ReferenceKeyKind_REFERENCE_KEY_KIND_KEY,
                        Key:  k,
                }
                if !ok </span><span class="cov0" title="0">{
                        vStr, ok := v.(string)
                        if !ok </span><span class="cov0" title="0">{
                                vStr = fmt.Sprintf("%v", v)
                        }</span>
                        <span class="cov0" title="0">valueRef := ReferenceTreeItem{
                                Key:   key,
                                Kind:  ReferenceKind_REFERENCE_KIND_VALUE,
                                Value: vStr,
                        }
                        subRefs = append(subRefs, valueRef)</span>
                } else<span class="cov0" title="0"> {
                        vRef, err := ConvertMapToReference(vMap, k)
                        if err != nil </span><span class="cov0" title="0">{
                                return ref, err
                        }</span>
                        <span class="cov0" title="0">subRefs = append(subRefs, vRef)</span>
                }
        }

        <span class="cov0" title="0">ref = ReferenceTreeItem{
                Key: ReferenceKey{
                        Kind: ReferenceKeyKind_REFERENCE_KEY_KIND_KEY,
                        Key:  key,
                },
                Kind: ReferenceKind_REFERENCE_KIND_MAP,
                Map:  subRefs,
        }

        return ref, nil</span>
}

func ConvertPkgToRpcTree(ref ReferenceTreeItem) *referencev1.ReferenceTreeItem <span class="cov0" title="0">{
        return &amp;referencev1.ReferenceTreeItem{
                Kind: referencev1.ReferenceKind(ref.Kind),
                Key: &amp;referencev1.ReferenceKey{
                        Kind:  referencev1.ReferenceKeyKind(ref.Key.Kind),
                        Key:   &amp;ref.Key.Key,
                        Index: &amp;ref.Key.Index,
                        Group: &amp;ref.Key.Group,
                },
                Value:    &amp;ref.Value,
                Map:      convertReferenceMap(ref.Map),
                Array:    convertReferenceMap(ref.Array),
                Variable: ref.Variable,
        }
}</span>

func ConvertPkgKeyToRpc(ref ReferenceKey) *referencev1.ReferenceKey <span class="cov0" title="0">{
        return &amp;referencev1.ReferenceKey{
                Kind:  referencev1.ReferenceKeyKind(ref.Kind),
                Group: &amp;ref.Group,
                Key:   &amp;ref.Key,
                Index: &amp;ref.Index,
        }
}</span>

func ConvertRpcToPkg(ref *referencev1.ReferenceTreeItem) ReferenceTreeItem <span class="cov0" title="0">{
        mapRefs := make([]ReferenceTreeItem, len(ref.Map))
        arrayRefs := make([]ReferenceTreeItem, len(ref.Array))
        value := ""

        for i, v := range ref.Map </span><span class="cov0" title="0">{
                mapRefs[i] = ConvertRpcToPkg(v)
        }</span>

        <span class="cov0" title="0">for i, v := range ref.Array </span><span class="cov0" title="0">{
                arrayRefs[i] = ConvertRpcToPkg(v)
        }</span>

        <span class="cov0" title="0">if ref.Value != nil </span><span class="cov0" title="0">{
                value = *ref.Value
        }</span>

        <span class="cov0" title="0">return ReferenceTreeItem{
                Kind:     ReferenceKind(ref.Kind),
                Key:      ConvertRpcKeyToPkgKey(ref.Key),
                Map:      mapRefs,
                Array:    arrayRefs,
                Value:    value,
                Variable: ref.Variable,
        }</span>
}

func ConvertRpcKeyToPkgKey(ref *referencev1.ReferenceKey) ReferenceKey <span class="cov0" title="0">{
        if ref == nil </span><span class="cov0" title="0">{
                return ReferenceKey{}
        }</span>
        <span class="cov0" title="0">group := ""
        key := ""
        index := int32(0)
        if ref.Group != nil </span><span class="cov0" title="0">{
                group = *ref.Group
        }</span>
        <span class="cov0" title="0">if ref.Key != nil </span><span class="cov0" title="0">{
                key = *ref.Key
        }</span>
        <span class="cov0" title="0">if ref.Index != nil </span><span class="cov0" title="0">{
                index = *ref.Index
        }</span>

        <span class="cov0" title="0">return ReferenceKey{
                Kind:  ReferenceKeyKind(ref.Kind),
                Group: group,
                Key:   key,
                Index: index,
        }</span>
}

func convertReferenceMap(refs []ReferenceTreeItem) []*referencev1.ReferenceTreeItem <span class="cov0" title="0">{
        var result []*referencev1.ReferenceTreeItem
        for _, ref := range refs </span><span class="cov0" title="0">{
                result = append(result, ConvertPkgToRpcTree(ref))
        }</span>
        <span class="cov0" title="0">return result</span>
}

func ConvertRefernceKeyArrayToStringPath(refKey []ReferenceKey) (string, error) <span class="cov0" title="0">{
        var path string

        for i, v := range refKey </span><span class="cov0" title="0">{
                switch v.Kind </span>{
                case ReferenceKeyKind_REFERENCE_KEY_KIND_GROUP:<span class="cov0" title="0">
                        if v.Group == "" </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("group is nil")
                        }</span>
                        <span class="cov0" title="0">if i != 0 </span><span class="cov0" title="0">{
                                path += "."
                        }</span>
                        <span class="cov0" title="0">path += v.Group</span>
                case ReferenceKeyKind_REFERENCE_KEY_KIND_KEY:<span class="cov0" title="0">
                        if v.Key == "" </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("key is nil")
                        }</span>
                        <span class="cov0" title="0">if i != 0 </span><span class="cov0" title="0">{
                                path += "."
                        }</span>
                        <span class="cov0" title="0">path += v.Key</span>
                case ReferenceKeyKind_REFERENCE_KEY_KIND_INDEX:<span class="cov0" title="0">
                        if i != 0 </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("cannot use index as first key")
                        }</span>
                        <span class="cov0" title="0">path += fmt.Sprintf("[%d]", v.Index)</span>
                default:<span class="cov0" title="0">
                        // TODO: Add other types of reference keys here
                        return "", fmt.Errorf("unknown reference key kind: %v", v.Kind)</span>
                }
        }
        <span class="cov0" title="0">return path, nil</span>
}

func ConvertStringPathToReferenceKeyArray(path string) ([]ReferenceKey, error) <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                return []ReferenceKey{}, nil
        }</span>

        <span class="cov0" title="0">parts := strings.Split(path, ".")
        var refKeys []ReferenceKey

        for _, part := range parts </span><span class="cov0" title="0">{
                refKeys = append(refKeys, ReferenceKey{
                        Kind: ReferenceKeyKind_REFERENCE_KEY_KIND_KEY,
                        Key:  part,
                })
        }</span>
        <span class="cov0" title="0">return refKeys, nil</span>
}

func NewReferenceFromInterfaceWithKey(value any, key string) ReferenceTreeItem <span class="cov0" title="0">{
        return NewReferenceFromInterface(value, ReferenceKey{Kind: ReferenceKeyKind_REFERENCE_KEY_KIND_KEY, Key: key})
}</span>

func NewReferenceFromInterface(value any, key ReferenceKey) ReferenceTreeItem <span class="cov8" title="1">{
        val := reflect.ValueOf(value)
        switch val.Kind() </span>{
        case reflect.Map:<span class="cov8" title="1">
                mapRefs := make([]ReferenceTreeItem, 0, val.Len())
                keys := val.MapKeys()
                for _, mapKey := range keys </span><span class="cov8" title="1">{
                        if mapKey.Kind() != reflect.String </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">keyStr := mapKey.String()
                        subKey := ReferenceKey{Kind: ReferenceKeyKind_REFERENCE_KEY_KIND_KEY, Key: keyStr}
                        mapRefs = append(mapRefs, NewReferenceFromInterface(val.MapIndex(mapKey).Interface(), subKey))</span>
                }
                <span class="cov8" title="1">return ReferenceTreeItem{Key: key, Kind: ReferenceKind_REFERENCE_KIND_MAP, Map: mapRefs}</span>
        case reflect.Slice, reflect.Array:<span class="cov8" title="1">
                arrayRefs := make([]ReferenceTreeItem, val.Len())
                for i := range val.Len() </span><span class="cov8" title="1">{
                        subKey := ReferenceKey{Kind: ReferenceKeyKind_REFERENCE_KEY_KIND_INDEX, Index: int32(i)}
                        arrayRefs[i] = NewReferenceFromInterface(val.Index(i).Interface(), subKey)
                }</span>
                <span class="cov8" title="1">return ReferenceTreeItem{Key: key, Kind: ReferenceKind_REFERENCE_KIND_ARRAY, Array: arrayRefs}</span>
        case reflect.Struct:<span class="cov8" title="1">
                mapRefs := make([]ReferenceTreeItem, 0, val.NumField())
                for i := range val.NumField() </span><span class="cov8" title="1">{
                        field := val.Type().Field(i)
                        if !field.IsExported() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">subKey := ReferenceKey{Kind: ReferenceKeyKind_REFERENCE_KEY_KIND_KEY, Key: field.Name}
                        fieldValue := NewReferenceFromInterface(val.Field(i).Interface(), subKey)
                        mapRefs = append(mapRefs, fieldValue)</span>
                }
                <span class="cov8" title="1">return ReferenceTreeItem{Key: key, Kind: ReferenceKind_REFERENCE_KIND_MAP, Map: mapRefs}</span>
        case reflect.String:<span class="cov8" title="1">
                return ReferenceTreeItem{Key: key, Kind: ReferenceKind_REFERENCE_KIND_VALUE, Value: val.String()}</span>
        case reflect.Int, reflect.Int32, reflect.Int64, reflect.Float32, reflect.Float64, reflect.Bool:<span class="cov8" title="1">
                return ReferenceTreeItem{Key: key, Kind: ReferenceKind_REFERENCE_KIND_VALUE, Value: fmt.Sprintf("%v", val.Interface())}</span>
        case reflect.Ptr:<span class="cov0" title="0">
                return NewReferenceFromInterface(val.Elem().Interface(), key)</span>
        case reflect.Int8:<span class="cov0" title="0">
                return ReferenceTreeItem{Key: key, Kind: ReferenceKind_REFERENCE_KIND_VALUE, Value: fmt.Sprintf("%v", val.Interface())}</span>
        default:<span class="cov0" title="0">
                return ReferenceTreeItem{}</span>
        }
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package referencecompletion

import (
        "errors"
        "fmt"
        "reflect"
        "regexp"
        "sort"
        "strconv"
        "strings"
        "the-dev-tools/server/pkg/fuzzyfinder"
        "the-dev-tools/server/pkg/reference"
)

const ArrayStringValuePrefix = "Array"
const MapStringValuePrefix = "Map"

// smartCompare compares two strings with smart numeric suffix handling
// First by length (shorter first), then alphabetically, then numerically for suffixes
func smartCompare(a, b string) bool <span class="cov8" title="1">{
        // First compare by length
        if len(a) != len(b) </span><span class="cov8" title="1">{
                return len(a) &lt; len(b)
        }</span>

        // If same length, check for numeric suffixes
        <span class="cov8" title="1">re := regexp.MustCompile(`^(.+?)(\d+)$`)
        aMatches := re.FindStringSubmatch(a)
        bMatches := re.FindStringSubmatch(b)

        // If both have numeric suffixes and same prefix, compare numerically
        if len(aMatches) == 3 &amp;&amp; len(bMatches) == 3 &amp;&amp; aMatches[1] == bMatches[1] </span><span class="cov8" title="1">{
                aNum, aErr := strconv.Atoi(aMatches[2])
                bNum, bErr := strconv.Atoi(bMatches[2])
                if aErr == nil &amp;&amp; bErr == nil </span><span class="cov8" title="1">{
                        return aNum &lt; bNum
                }</span>
        }

        // Otherwise, fall back to alphabetical comparison
        <span class="cov8" title="1">return a &lt; b</span>
}

type ReferenceCompletionDetails struct {
        Count uint
}

type ReferenceCompletionCreator struct {
        PathMap map[string]ReferenceCompletionDetails
}

type ReferenceCompletionLookUp struct {
        LookUpMap map[string]string
}

func NewReferenceCompletionCreator() ReferenceCompletionCreator <span class="cov8" title="1">{
        return ReferenceCompletionCreator{
                PathMap: make(map[string]ReferenceCompletionDetails, 0),
        }
}</span>

func NewReferenceCompletionLookup() ReferenceCompletionLookUp <span class="cov8" title="1">{
        return ReferenceCompletionLookUp{
                LookUpMap: make(map[string]string, 0),
        }
}</span>

func (c ReferenceCompletionCreator) Add(value any) <span class="cov8" title="1">{
        addPaths("", value, c.PathMap)
}</span>

func (c *ReferenceCompletionCreator) AddWithKey(key string, data any) <span class="cov8" title="1">{
        // Add nested paths prefixed with the key
        addPaths(key, data, c.PathMap)
}</span>

func addPaths(currentPath string, value any, pathMap map[string]ReferenceCompletionDetails) <span class="cov8" title="1">{
        // Use reflection to inspect the value's type and structure.
        v := reflect.ValueOf(value)

        // Handle pointers: dereference them to get the actual value.
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if v.IsNil() </span><span class="cov0" title="0">{
                        return // Stop traversal if the pointer is nil.
                }</span>
                <span class="cov0" title="0">v = v.Elem()</span> // Get the value pointed to.
        }

        <span class="cov8" title="1">var count uint

        // Based on the kind of the value, decide how to proceed.
        switch v.Kind() </span>{
        case reflect.Map:<span class="cov8" title="1">
                // Iterate through the key-value pairs of the map.
                iter := v.MapRange()
                for iter.Next() </span><span class="cov8" title="1">{
                        k := iter.Key()     // The map key.
                        val := iter.Value() // The map value.

                        // Convert the map key to a string representation.
                        keyStr := fmt.Sprintf("%v", k.Interface())

                        // Construct the path for the map entry.
                        var nextPath string
                        if currentPath == "" </span><span class="cov8" title="1">{
                                // If at the root, the path is just the key.
                                nextPath = keyStr
                        }</span> else<span class="cov8" title="1"> {
                                // Otherwise, append the key with a dot separator.
                                nextPath = currentPath + "." + keyStr
                        }</span>

                        // Recursively process the map value
                        <span class="cov8" title="1">addPaths(nextPath, val.Interface(), pathMap)</span>
                }
                <span class="cov8" title="1">count = uint(v.Len())</span>

        case reflect.Slice, reflect.Array:<span class="cov8" title="1">
                count = uint(v.Len())

                // Iterate through the elements of the slice or array.
                for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                        elem := v.Index(i) // The element at index i.

                        // Construct the path for the array/slice element using bracket notation.
                        // Path for a nested array/slice element: "parent[index]"
                        nextPath := fmt.Sprintf("%s[%d]", currentPath, i)

                        // Recursively process the array element
                        addPaths(nextPath, elem.Interface(), pathMap)
                }</span>
        }

        <span class="cov8" title="1">if currentPath != "" </span><span class="cov8" title="1">{
                // Store the details for the current path
                pathMap[currentPath] = ReferenceCompletionDetails{
                        Count: count,
                }
        }</span>
}

func (c ReferenceCompletionCreator) FindMatch(query string) []fuzzyfinder.Rank <span class="cov8" title="1">{
        // Return all paths for empty queries
        if query == "" </span><span class="cov8" title="1">{
                ranks := make([]fuzzyfinder.Rank, 0, len(c.PathMap))
                for path := range c.PathMap </span><span class="cov8" title="1">{
                        ranks = append(ranks, fuzzyfinder.Rank{Target: path})
                }</span>
                // Sort by length, then alphabetically, then numerically for suffixes
                <span class="cov8" title="1">sort.Slice(ranks, func(i, j int) bool </span><span class="cov8" title="1">{
                        return smartCompare(ranks[i].Target, ranks[j].Target)
                }</span>)
                <span class="cov8" title="1">return ranks</span>
        }

        // Check for exact matches first
        <span class="cov8" title="1">exactMatches := make(map[string]struct{})
        for path := range c.PathMap </span><span class="cov8" title="1">{
                if strings.EqualFold(path, query) </span><span class="cov8" title="1">{
                        exactMatches[path] = struct{}{}
                }</span>
        }

        // If we have exact matches, only return those
        <span class="cov8" title="1">if len(exactMatches) &gt; 0 </span><span class="cov8" title="1">{
                ranks := make([]fuzzyfinder.Rank, 0, len(exactMatches))
                for match := range exactMatches </span><span class="cov8" title="1">{
                        ranks = append(ranks, fuzzyfinder.Rank{Target: match})
                }</span>
                <span class="cov8" title="1">return ranks</span>
        }

        // Otherwise find prefix matches
        <span class="cov8" title="1">completions := make(map[string]struct{})
        for path := range c.PathMap </span><span class="cov8" title="1">{
                if strings.HasPrefix(strings.ToLower(path), strings.ToLower(query)) </span><span class="cov8" title="1">{
                        completions[path] = struct{}{}
                }</span>
        }

        // Convert completions to ranks
        <span class="cov8" title="1">ranks := make([]fuzzyfinder.Rank, 0, len(completions))
        for completion := range completions </span><span class="cov8" title="1">{
                ranks = append(ranks, fuzzyfinder.Rank{Target: completion})
        }</span>
        // Sort by length, then alphabetically, then numerically for suffixes
        <span class="cov8" title="1">sort.Slice(ranks, func(i int, j int) bool </span><span class="cov8" title="1">{
                return smartCompare(ranks[i].Target, ranks[j].Target)
        }</span>)

        <span class="cov8" title="1">return ranks</span>
}

func (c ReferenceCompletionCreator) FindMatchAndCalcCompletionData(query string) []ReferenceCompletionItem <span class="cov0" title="0">{
        ranks := c.FindMatch(query)

        referenceCompletionItems := make([]ReferenceCompletionItem, len(ranks))
        for i, rank := range ranks </span><span class="cov0" title="0">{
                matchedPath := rank.Target                               // The full path that matched
                pathKind := reference.ReferenceKind_REFERENCE_KIND_VALUE // Default kind

                // Determine if the path has children (it's a map)
                prefix := matchedPath + "."
                hasChildren := false
                for path := range c.PathMap </span><span class="cov0" title="0">{
                        if strings.HasPrefix(path, prefix) </span><span class="cov0" title="0">{
                                hasChildren = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if hasChildren </span><span class="cov0" title="0">{
                        pathKind = reference.ReferenceKind_REFERENCE_KIND_MAP
                }</span>

                <span class="cov0" title="0">endIndex := len(query)

                Details := c.PathMap[matchedPath]
                itemCount := int32(Details.Count)

                referenceCompletionItems[i] = ReferenceCompletionItem{
                        Kind:         pathKind,
                        EndToken:     matchedPath,
                        EndIndex:     int32(endIndex),
                        ItemCount:    &amp;itemCount,
                        Environments: nil,
                }</span>
        }
        <span class="cov0" title="0">return referenceCompletionItems</span>
}

type ReferenceCompletionItem struct {
        Kind reference.ReferenceKind

        /** End token of the string to be completed, i.e. 'body' in 'response.bo|dy' */
        EndToken string
        /** Index of the completion start in the end token, i.e. 2 in 'bo|dy' of 'response.bo|dy' */
        EndIndex int32
        /** Number of items when reference is a map or an array */
        ItemCount *int32
        /** Environment names when reference is a variable */
        Environments []string
}

func (c ReferenceCompletionLookUp) GetValue(path string) (string, error) <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                return c.LookUpMap[""], nil
        }</span>

        // Direct lookup - check if we have the exact path in the map
        <span class="cov8" title="1">if value, exists := c.LookUpMap[path]; exists </span><span class="cov8" title="1">{
                return value, nil
        }</span>

        <span class="cov8" title="1">return "", errors.New("not found")</span>
}

func (c ReferenceCompletionLookUp) Add(value any) <span class="cov8" title="1">{
        // Store the root value
        c.LookUpMap[""] = fmt.Sprint(value)

        // Add all paths from the value
        addPathsWithValues("", value, c.LookUpMap)
}</span>

func (c ReferenceCompletionLookUp) AddWithKey(key string, value any) <span class="cov8" title="1">{
        // Store the value at the specified key
        c.LookUpMap[key] = fmt.Sprint(value)

        // Add all paths from this key
        addPathsWithValues(key, value, c.LookUpMap)
}</span>

// addPathsWithValues is similar to addPaths but stores the actual values
func addPathsWithValues(currentPath string, value any, lookupMap map[string]string) <span class="cov8" title="1">{

        var strValue string
        // Store the current value at its path

        // Use reflection to inspect the value's type and structure
        v := reflect.ValueOf(value)

        // Handle pointers: dereference them to get the actual value
        if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if v.IsNil() </span><span class="cov0" title="0">{
                        return // Stop traversal if the pointer is nil
                }</span>
                <span class="cov0" title="0">v = v.Elem()</span> // Get the value pointed to
        }

        // Based on the kind of the value, decide how to proceed
        <span class="cov8" title="1">switch v.Kind() </span>{
        case reflect.Map:<span class="cov8" title="1">
                // Format map as Map[key_type]value_type
                mapType := v.Type()
                strValue = fmt.Sprintf("%s[%s]%s", MapStringValuePrefix, mapType.Key(), mapType.Elem())

                // Iterate through the key-value pairs of the map
                iter := v.MapRange()
                for iter.Next() </span><span class="cov8" title="1">{
                        k := iter.Key()     // The map key
                        val := iter.Value() // The map value

                        // Convert the map key to a string representation
                        keyStr := fmt.Sprintf("%v", k.Interface())

                        // Construct the path for the map entry
                        var nextPath string
                        if currentPath == "" </span><span class="cov8" title="1">{
                                // If at the root, the path is just the key
                                nextPath = keyStr
                        }</span> else<span class="cov8" title="1"> {
                                // Otherwise, append the key with a dot separator
                                nextPath = currentPath + "." + keyStr
                        }</span>

                        // Recursively call addPathsWithValues for the map value
                        <span class="cov8" title="1">if val.IsValid() &amp;&amp; val.CanInterface() </span><span class="cov8" title="1">{
                                valInterface := val.Interface()
                                addPathsWithValues(nextPath, valInterface, lookupMap)
                        }</span>
                }
        case reflect.Slice, reflect.Array:<span class="cov8" title="1">
                // Format array/slice as Array[size]
                arrayType := v.Type()
                strValue = fmt.Sprintf("%s[%d]", arrayType.Elem(), v.Len())

                // Iterate through the elements of the slice or array
                for i := range v.Len() </span><span class="cov8" title="1">{
                        elem := v.Index(i) // The element at index i

                        // Construct the path for the array/slice element using bracket notation
                        indexStr := strconv.Itoa(i)
                        var nextPath string
                        if currentPath == "" </span><span class="cov0" title="0">{
                                // Path for a root-level array/slice element: "[index]"
                                nextPath = "[" + indexStr + "]"
                        }</span> else<span class="cov8" title="1"> {
                                // Path for a nested array/slice element: "parent[index]"
                                nextPath = currentPath + "[" + indexStr + "]"
                        }</span>

                        // Recursively call addPathsWithValues for the element
                        <span class="cov8" title="1">if elem.IsValid() &amp;&amp; elem.CanInterface() </span><span class="cov8" title="1">{
                                elemInterface := elem.Interface()
                                addPathsWithValues(nextPath, elemInterface, lookupMap)
                        }</span>
                }
        default:<span class="cov8" title="1">
                strValue = fmt.Sprint(v)</span>
        }
        <span class="cov8" title="1">lookupMap[currentPath] = strValue</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package sedge

import (
        "context"
        "database/sql"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/flow/edge"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

type EdgeService struct {
        queries *gen.Queries
}

func New(queries *gen.Queries) EdgeService <span class="cov0" title="0">{
        return EdgeService{queries: queries}
}</span>

func (es EdgeService) TX(tx *sql.Tx) EdgeService <span class="cov0" title="0">{
        return EdgeService{queries: es.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx gen.DBTX) (*EdgeService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;EdgeService{
                queries: queries,
        }, nil</span>
}

func ConvertToDBEdge(e edge.Edge) gen.FlowEdge <span class="cov0" title="0">{
        return gen.FlowEdge{
                ID:           e.ID,
                FlowID:       e.FlowID,
                SourceID:     e.SourceID,
                TargetID:     e.TargetID,
                SourceHandle: int32(e.SourceHandler),
                EdgeKind:     e.Kind,
        }
}</span>

func ConvertToModelEdge(e gen.FlowEdge) *edge.Edge <span class="cov0" title="0">{
        return &amp;edge.Edge{
                ID:            e.ID,
                FlowID:        e.FlowID,
                SourceID:      e.SourceID,
                TargetID:      e.TargetID,
                SourceHandler: edge.EdgeHandle(e.SourceHandle),
                Kind:          e.EdgeKind,
        }
}</span>

func (es EdgeService) GetEdge(ctx context.Context, id idwrap.IDWrap) (*edge.Edge, error) <span class="cov0" title="0">{
        edge, err := es.queries.GetFlowEdge(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ConvertToModelEdge(edge), nil</span>
}

func (es EdgeService) GetEdgesByFlowID(ctx context.Context, flowID idwrap.IDWrap) ([]edge.Edge, error) <span class="cov0" title="0">{
        edge, err := es.queries.GetFlowEdgesByFlowID(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return tgeneric.MassConvertPtr(edge, ConvertToModelEdge), nil</span>
}

func (es EdgeService) CreateEdge(ctx context.Context, e edge.Edge) error <span class="cov0" title="0">{
        edge := ConvertToDBEdge(e)
        return es.queries.CreateFlowEdge(ctx, gen.CreateFlowEdgeParams{
                ID:           edge.ID,
                FlowID:       edge.FlowID,
                SourceID:     edge.SourceID,
                TargetID:     edge.TargetID,
                SourceHandle: edge.SourceHandle,
                EdgeKind:     edge.EdgeKind,
        })
}</span>

func (es EdgeService) CreateEdgeBulk(ctx context.Context, edges []edge.Edge) error <span class="cov0" title="0">{
        for _, e := range edges </span><span class="cov0" title="0">{
                err := es.CreateEdge(ctx, e)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (es EdgeService) UpdateEdge(ctx context.Context, e edge.Edge) error <span class="cov0" title="0">{
        edge := ConvertToDBEdge(e)
        return es.queries.UpdateFlowEdge(ctx, gen.UpdateFlowEdgeParams{
                ID:           edge.ID,
                SourceID:     edge.SourceID,
                TargetID:     edge.TargetID,
                SourceHandle: edge.SourceHandle,
                EdgeKind:     edge.EdgeKind,
        })
}</span>

func (es EdgeService) DeleteEdge(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        err := es.queries.DeleteFlowEdge(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package sassert

import (
        "context"
        "database/sql"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/massert"
        "the-dev-tools/server/pkg/model/mcondition"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

type AssertService struct {
        queries *gen.Queries
}

var ErrNoAssertFound = sql.ErrNoRows

func ConvertAssertDBToModel(assert gen.Assertion) massert.Assert <span class="cov0" title="0">{
        return massert.Assert{
                ID:            assert.ID,
                ExampleID:     assert.ExampleID,
                DeltaParentID: assert.DeltaParentID,
                Condition: mcondition.Condition{
                        Comparisons: mcondition.Comparison{
                                Expression: assert.Expression,
                        },
                },
                Enable: assert.Enable,
                Prev:   assert.Prev,
                Next:   assert.Next,
        }
}</span>

func ConvertAssertModelToDB(assert massert.Assert) gen.Assertion <span class="cov0" title="0">{
        return gen.Assertion{
                ID:            assert.ID,
                ExampleID:     assert.ExampleID,
                DeltaParentID: assert.DeltaParentID,
                Expression:    assert.Condition.Comparisons.Expression,
                Enable:        assert.Enable,
                Prev:          assert.Prev,
                Next:          assert.Next,
        }
}</span>

func New(queries *gen.Queries) AssertService <span class="cov0" title="0">{
        return AssertService{queries: queries}
}</span>

func (as AssertService) TX(tx *sql.Tx) AssertService <span class="cov0" title="0">{
        return AssertService{queries: as.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*AssertService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">service := AssertService{queries: queries}
        return &amp;service, nil</span>
}

func (as AssertService) GetAssert(ctx context.Context, id idwrap.IDWrap) (*massert.Assert, error) <span class="cov0" title="0">{
        assert, err := as.queries.GetAssert(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">a := ConvertAssertDBToModel(assert)
        return &amp;a, nil</span>
}

func (as AssertService) GetAssertByExampleID(ctx context.Context, id idwrap.IDWrap) ([]massert.Assert, error) <span class="cov0" title="0">{
        asserts, err := as.queries.GetAssertsByExampleID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoAssertFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return tgeneric.MassConvert(asserts, ConvertAssertDBToModel), nil</span>
}

func (as AssertService) UpdateAssert(ctx context.Context, assert massert.Assert) error <span class="cov0" title="0">{
        arg := ConvertAssertModelToDB(assert)
        return as.queries.UpdateAssert(ctx, gen.UpdateAssertParams{
                ID:            arg.ID,
                Enable:        arg.Enable,
                Expression:    arg.Expression,
                DeltaParentID: arg.DeltaParentID,
        })
}</span>

func (as AssertService) CreateAssert(ctx context.Context, assert massert.Assert) error <span class="cov0" title="0">{
        arg := ConvertAssertModelToDB(assert)
        return as.queries.CreateAssert(ctx, gen.CreateAssertParams{
                ID:            arg.ID,
                ExampleID:     arg.ExampleID,
                DeltaParentID: arg.DeltaParentID,
                Enable:        arg.Enable,
                Expression:    assert.Condition.Comparisons.Expression,
                Prev:          arg.Prev,
                Next:          arg.Next,
        })
}</span>

// TODO: create bulk query
func (as AssertService) CreateAssertBulk(ctx context.Context, asserts []massert.Assert) error <span class="cov0" title="0">{
        var err error
        for _, a := range asserts </span><span class="cov0" title="0">{
                err = as.CreateAssert(ctx, a)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// CreateBulkAssert is an alias for CreateAssertBulk
func (as AssertService) CreateBulkAssert(ctx context.Context, asserts []massert.Assert) error <span class="cov0" title="0">{
        return as.CreateAssertBulk(ctx, asserts)
}</span>

func (as AssertService) DeleteAssert(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        return as.queries.DeleteAssert(ctx, id)
}</span>

func (as AssertService) ResetAssertDelta(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        assert, err := as.GetAssert(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">assert.DeltaParentID = nil
        assert.Condition.Comparisons.Expression = ""
        assert.Enable = false

        return as.UpdateAssert(ctx, *assert)</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package sassertres

import (
        "context"
        "database/sql"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/massertres"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

type AssertResultService struct {
        queries *gen.Queries
}

func ConvertAssertResultDBToModel(assertResponse gen.AssertionResult) massertres.AssertResult <span class="cov0" title="0">{
        return massertres.AssertResult{
                ID:         assertResponse.ID,
                ResponseID: assertResponse.ResponseID,
                AssertID:   assertResponse.AssertionID,
                Result:     assertResponse.Result,
        }
}</span>

func ConvertAssertResultModelToDB(assertResponse massertres.AssertResult) gen.AssertionResult <span class="cov0" title="0">{
        return gen.AssertionResult{
                ID:          assertResponse.ID,
                ResponseID:  assertResponse.ResponseID,
                AssertionID: assertResponse.AssertID,
                Result:      assertResponse.Result,
        }
}</span>

func New(queries *gen.Queries) AssertResultService <span class="cov0" title="0">{
        return AssertResultService{queries: queries}
}</span>

func (ars AssertResultService) TX(tx *sql.Tx) AssertResultService <span class="cov0" title="0">{
        return AssertResultService{queries: ars.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*AssertResultService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">service := AssertResultService{queries: queries}
        return &amp;service, nil</span>
}

func (ars AssertResultService) GetAssertResult(ctx context.Context, id idwrap.IDWrap) (*massertres.AssertResult, error) <span class="cov0" title="0">{
        assertResult, err := ars.queries.GetAssertResult(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">a := ConvertAssertResultDBToModel(assertResult)
        return &amp;a, nil</span>
}

func (ars AssertResultService) GetAssertResultsByResponseID(ctx context.Context, responseID idwrap.IDWrap) ([]massertres.AssertResult, error) <span class="cov0" title="0">{
        assertResaultsRaw, err := ars.queries.GetAssertResultsByResponseID(ctx, responseID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return tgeneric.MassConvert(assertResaultsRaw, ConvertAssertResultDBToModel), nil</span>
}

func (ars AssertResultService) CreateAssertResult(ctx context.Context, assertResult massertres.AssertResult) error <span class="cov0" title="0">{
        assertResultDB := ConvertAssertResultModelToDB(assertResult)
        return ars.queries.CreateAssertResult(ctx, gen.CreateAssertResultParams{
                ID:          assertResultDB.ID,
                ResponseID:  assertResultDB.ResponseID,
                AssertionID: assertResultDB.AssertionID,
                Result:      assertResultDB.Result,
        })
}</span>

// TODO: make it a query
func (ars AssertResultService) CreateAssertResultBulk(ctx context.Context, assertResult []massertres.AssertResult) error <span class="cov0" title="0">{
        var err error
        for _, assertResult := range assertResult </span><span class="cov0" title="0">{
                err = ars.CreateAssertResult(ctx, assertResult)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (ars AssertResultService) UpdateAssertResult(ctx context.Context, assertResult massertres.AssertResult) error <span class="cov0" title="0">{
        assertResultDB := ConvertAssertResultModelToDB(assertResult)
        return ars.queries.UpdateAssertResult(ctx, gen.UpdateAssertResultParams{
                ID:     assertResultDB.ID,
                Result: assertResultDB.Result,
        })
}</span>

func (ars AssertResultService) DeleteAssertResult(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        return ars.queries.DeleteAssertResult(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">package sbodyform

import (
        "context"
        "database/sql"
        "errors"
        "slices"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mbodyform"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

type BodyFormService struct {
        queries *gen.Queries
}

var ErrNoBodyFormFound = errors.New("no form body found")

func SeralizeModeltoGen(body mbodyform.BodyForm) gen.ExampleBodyForm <span class="cov0" title="0">{
        return gen.ExampleBodyForm{
                ID:            body.ID,
                ExampleID:     body.ExampleID,
                DeltaParentID: body.DeltaParentID,
                BodyKey:       body.BodyKey,
                Description:   body.Description,
                Enable:        body.Enable,
                Value:         body.Value,
        }
}</span>

func DeserializeGenToModel(body gen.ExampleBodyForm) mbodyform.BodyForm <span class="cov0" title="0">{
        return mbodyform.BodyForm{
                ID:            body.ID,
                ExampleID:     body.ExampleID,
                DeltaParentID: body.DeltaParentID,
                BodyKey:       body.BodyKey,
                Description:   body.Description,
                Enable:        body.Enable,
                Value:         body.Value,
        }
}</span>

func New(queries *gen.Queries) BodyFormService <span class="cov0" title="0">{
        return BodyFormService{queries: queries}
}</span>

func (bfs BodyFormService) TX(tx *sql.Tx) BodyFormService <span class="cov0" title="0">{
        return BodyFormService{queries: bfs.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*BodyFormService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">service := BodyFormService{queries: queries}
        return &amp;service, nil</span>
}

func (bfs BodyFormService) GetBodyForm(ctx context.Context, id idwrap.IDWrap) (*mbodyform.BodyForm, error) <span class="cov0" title="0">{
        bodyForm, err := bfs.queries.GetBodyForm(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoBodyFormFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">body := DeserializeGenToModel(bodyForm)
        return &amp;body, nil</span>
}

func (bfs BodyFormService) CreateBulkBodyForm(ctx context.Context, bodyForms []mbodyform.BodyForm) error <span class="cov0" title="0">{
        const sizeOfChunks = 10
        convertedItems := tgeneric.MassConvert(bodyForms, SeralizeModeltoGen)
        for bodyFormChunk := range slices.Chunk(convertedItems, sizeOfChunks) </span><span class="cov0" title="0">{
                if len(bodyFormChunk) &lt; sizeOfChunks </span><span class="cov0" title="0">{
                        for _, bodyForm := range bodyFormChunk </span><span class="cov0" title="0">{
                                err := bfs.CreateBodyFormRaw(ctx, bodyForm)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">item1 := bodyFormChunk[0]
                item2 := bodyFormChunk[1]
                item3 := bodyFormChunk[2]
                item4 := bodyFormChunk[3]
                item5 := bodyFormChunk[4]
                item6 := bodyFormChunk[5]
                item7 := bodyFormChunk[6]
                item8 := bodyFormChunk[7]
                item9 := bodyFormChunk[8]
                item10 := bodyFormChunk[9]

                params := gen.CreateBodyFormBulkParams{
                        // 1
                        ID:            item1.ID,
                        ExampleID:     item1.ExampleID,
                        DeltaParentID: item1.DeltaParentID,
                        BodyKey:       item1.BodyKey,
                        Enable:        item1.Enable,
                        Description:   item1.Description,
                        Value:         item1.Value,
                        // 2
                        ID_2:            item2.ID,
                        ExampleID_2:     item2.ExampleID,
                        DeltaParentID_2: item2.DeltaParentID,
                        BodyKey_2:       item2.BodyKey,
                        Enable_2:        item2.Enable,
                        Description_2:   item2.Description,
                        Value_2:         item2.Value,
                        // 3
                        ID_3:            item3.ID,
                        ExampleID_3:     item3.ExampleID,
                        DeltaParentID_3: item3.DeltaParentID,
                        BodyKey_3:       item3.BodyKey,
                        Enable_3:        item3.Enable,
                        Description_3:   item3.Description,
                        Value_3:         item3.Value,
                        // 4
                        ID_4:            item4.ID,
                        ExampleID_4:     item4.ExampleID,
                        DeltaParentID_4: item4.DeltaParentID,
                        BodyKey_4:       item4.BodyKey,
                        Enable_4:        item4.Enable,
                        Description_4:   item4.Description,
                        Value_4:         item4.Value,
                        // 5
                        ID_5:            item5.ID,
                        ExampleID_5:     item5.ExampleID,
                        DeltaParentID_5: item5.DeltaParentID,
                        BodyKey_5:       item5.BodyKey,
                        Enable_5:        item5.Enable,
                        Description_5:   item5.Description,
                        Value_5:         item5.Value,
                        // 6
                        ID_6:            item6.ID,
                        ExampleID_6:     item6.ExampleID,
                        DeltaParentID_6: item6.DeltaParentID,
                        BodyKey_6:       item6.BodyKey,
                        Enable_6:        item6.Enable,
                        Description_6:   item6.Description,
                        Value_6:         item6.Value,
                        // 7
                        ID_7:            item7.ID,
                        ExampleID_7:     item7.ExampleID,
                        DeltaParentID_7: item7.DeltaParentID,
                        BodyKey_7:       item7.BodyKey,
                        Enable_7:        item7.Enable,
                        Description_7:   item7.Description,
                        Value_7:         item7.Value,
                        // 8
                        ID_8:            item8.ID,
                        ExampleID_8:     item8.ExampleID,
                        DeltaParentID_8: item8.DeltaParentID,
                        BodyKey_8:       item8.BodyKey,
                        Enable_8:        item8.Enable,
                        Description_8:   item8.Description,
                        Value_8:         item8.Value,
                        // 9
                        ID_9:            item9.ID,
                        ExampleID_9:     item9.ExampleID,
                        DeltaParentID_9: item9.DeltaParentID,
                        BodyKey_9:       item9.BodyKey,
                        Enable_9:        item9.Enable,
                        Description_9:   item9.Description,
                        Value_9:         item9.Value,
                        // 10
                        ID_10:            item10.ID,
                        ExampleID_10:     item10.ExampleID,
                        DeltaParentID_10: item10.DeltaParentID,
                        BodyKey_10:       item10.BodyKey,
                        Enable_10:        item10.Enable,
                        Description_10:   item10.Description,
                        Value_10:         item10.Value,
                }
                if err := bfs.queries.CreateBodyFormBulk(ctx, params); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (bfs BodyFormService) GetBodyFormsByExampleID(ctx context.Context, exampleID idwrap.IDWrap) ([]mbodyform.BodyForm, error) <span class="cov0" title="0">{
        bodyForms, err := bfs.queries.GetBodyFormsByExampleID(ctx, exampleID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoBodyFormFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return tgeneric.MassConvert(bodyForms, DeserializeGenToModel), nil</span>
}

func (bfs BodyFormService) CreateBodyForm(ctx context.Context, body *mbodyform.BodyForm) error <span class="cov0" title="0">{
        bf := SeralizeModeltoGen(*body)
        return bfs.queries.CreateBodyForm(ctx, gen.CreateBodyFormParams{
                ID:            bf.ID,
                ExampleID:     bf.ExampleID,
                DeltaParentID: bf.DeltaParentID,
                BodyKey:       bf.BodyKey,
                Description:   bf.Description,
                Enable:        bf.Enable,
                Value:         bf.Value,
        })
}</span>

func (bfs BodyFormService) CreateBodyFormRaw(ctx context.Context, bf gen.ExampleBodyForm) error <span class="cov0" title="0">{
        return bfs.queries.CreateBodyForm(ctx, gen.CreateBodyFormParams{
                ID:            bf.ID,
                ExampleID:     bf.ExampleID,
                DeltaParentID: bf.DeltaParentID,
                BodyKey:       bf.BodyKey,
                Description:   bf.Description,
                Enable:        bf.Enable,
                Value:         bf.Value,
        })
}</span>

func (bfs BodyFormService) UpdateBodyForm(ctx context.Context, body *mbodyform.BodyForm) error <span class="cov0" title="0">{
        bf := SeralizeModeltoGen(*body)
        return bfs.queries.UpdateBodyForm(ctx, gen.UpdateBodyFormParams{
                ID:          bf.ID,
                BodyKey:     bf.BodyKey,
                Description: bf.Description,
                Enable:      bf.Enable,
                Value:       bf.Value,
        })
}</span>

func (bfs BodyFormService) DeleteBodyForm(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        return bfs.queries.DeleteBodyForm(ctx, id)
}</span>

func (bfs BodyFormService) ResetBodyFormDelta(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        bodyForm, err := bfs.GetBodyForm(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bodyForm.DeltaParentID = nil
        bodyForm.BodyKey = ""
        bodyForm.Enable = false
        bodyForm.Description = ""
        bodyForm.Value = ""

        return bfs.UpdateBodyForm(ctx, bodyForm)</span>
}

func (bfs BodyFormService) GetBodyFormsByDeltaParentID(ctx context.Context, deltaParentID idwrap.IDWrap) ([]mbodyform.BodyForm, error) <span class="cov0" title="0">{
        bodyForms, err := bfs.queries.GetBodyFormsByDeltaParentID(ctx, &amp;deltaParentID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []mbodyform.BodyForm{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return tgeneric.MassConvert(bodyForms, DeserializeGenToModel), nil</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package sbodyraw

import (
        "context"
        "database/sql"
        "errors"
        "slices"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/compress"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mbodyraw"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

type BodyRawService struct {
        queries *gen.Queries
}

var ErrNoBodyRawFound = errors.New("no raw body found")

func ConvertModelToGen(body mbodyraw.ExampleBodyRaw) gen.ExampleBodyRaw <span class="cov0" title="0">{
        return gen.ExampleBodyRaw{
                ID:            body.ID,
                ExampleID:     body.ExampleID,
                VisualizeMode: int8(body.VisualizeMode),
                CompressType:  int8(body.CompressType),
                Data:          body.Data,
        }
}</span>

func ConvertGenToModel(body gen.ExampleBodyRaw) mbodyraw.ExampleBodyRaw <span class="cov0" title="0">{
        return mbodyraw.ExampleBodyRaw{
                ID:            body.ID,
                ExampleID:     body.ExampleID,
                VisualizeMode: mbodyraw.VisualizeMode(body.VisualizeMode),
                CompressType:  compress.CompressType(body.CompressType),
                Data:          body.Data,
        }
}</span>

func New(queries *gen.Queries) BodyRawService <span class="cov0" title="0">{
        return BodyRawService{queries: queries}
}</span>

func (brs BodyRawService) TX(tx *sql.Tx) BodyRawService <span class="cov0" title="0">{
        return BodyRawService{queries: brs.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*BodyRawService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">service := BodyRawService{queries: queries}
        return &amp;service, nil</span>
}

func (brs BodyRawService) GetBodyRaw(ctx context.Context, id idwrap.IDWrap) (*mbodyraw.ExampleBodyRaw, error) <span class="cov0" title="0">{
        bodyRaw, err := brs.queries.GetBodyRaw(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoBodyRawFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">body := ConvertGenToModel(bodyRaw)
        return &amp;body, nil</span>
}

func (brs BodyRawService) GetBodyRawByExampleID(ctx context.Context, exampleID idwrap.IDWrap) (*mbodyraw.ExampleBodyRaw, error) <span class="cov0" title="0">{
        bodyRaw, err := brs.queries.GetBodyRawsByExampleID(ctx, exampleID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoBodyRawFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">body := ConvertGenToModel(bodyRaw)
        return &amp;body, nil</span>
}

func (brs BodyRawService) CreateBodyRaw(ctx context.Context, body mbodyraw.ExampleBodyRaw) error <span class="cov0" title="0">{
        bodyRaw := ConvertModelToGen(body)
        return brs.queries.CreateBodyRaw(ctx, gen.CreateBodyRawParams{
                ID:            bodyRaw.ID,
                ExampleID:     bodyRaw.ExampleID,
                VisualizeMode: bodyRaw.VisualizeMode,
                CompressType:  bodyRaw.CompressType,
                Data:          bodyRaw.Data,
        })
}</span>

func (brs BodyRawService) CreateBodyRawGen(ctx context.Context, bodyGen gen.ExampleBodyRaw) error <span class="cov0" title="0">{
        return brs.queries.CreateBodyRaw(ctx, gen.CreateBodyRawParams{
                ID:            bodyGen.ID,
                ExampleID:     bodyGen.ExampleID,
                VisualizeMode: bodyGen.VisualizeMode,
                CompressType:  bodyGen.CompressType,
                Data:          bodyGen.Data,
        })
}</span>

func (brs BodyRawService) CreateBulkBodyRaw(ctx context.Context, bodyRawArr []mbodyraw.ExampleBodyRaw) error <span class="cov0" title="0">{
        const sizeOfChunks = 5
        convertedItems := tgeneric.MassConvert(bodyRawArr, ConvertModelToGen)
        for bodyFormChunk := range slices.Chunk(convertedItems, sizeOfChunks) </span><span class="cov0" title="0">{
                if len(bodyFormChunk) &lt; sizeOfChunks </span><span class="cov0" title="0">{
                        for _, bodyForm := range bodyFormChunk </span><span class="cov0" title="0">{
                                err := brs.CreateBodyRawGen(ctx, bodyForm)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">item1 := bodyFormChunk[0]
                item2 := bodyFormChunk[1]
                item3 := bodyFormChunk[2]
                item4 := bodyFormChunk[3]
                item5 := bodyFormChunk[4]

                params := gen.CreateBodyRawBulkParams{
                        // 1
                        ID:            item1.ID,
                        ExampleID:     item1.ExampleID,
                        VisualizeMode: item1.VisualizeMode,
                        CompressType:  item1.CompressType,
                        Data:          item1.Data,
                        // 2
                        ID_2:            item2.ID,
                        ExampleID_2:     item2.ExampleID,
                        VisualizeMode_2: item2.VisualizeMode,
                        CompressType_2:  item2.CompressType,
                        Data_2:          item2.Data,
                        // 3
                        ID_3:            item3.ID,
                        ExampleID_3:     item3.ExampleID,
                        VisualizeMode_3: item3.VisualizeMode,
                        CompressType_3:  item3.CompressType,
                        Data_3:          item3.Data,
                        // 4
                        ID_4:            item4.ID,
                        ExampleID_4:     item4.ExampleID,
                        VisualizeMode_4: item4.VisualizeMode,
                        CompressType_4:  item4.CompressType,
                        Data_4:          item4.Data,
                        // 5
                        ID_5:            item5.ID,
                        ExampleID_5:     item5.ExampleID,
                        VisualizeMode_5: item5.VisualizeMode,
                        CompressType_5:  item5.CompressType,
                        Data_5:          item5.Data,
                }
                if err := brs.queries.CreateBodyRawBulk(ctx, params); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (brs BodyRawService) UpdateBodyRawBody(ctx context.Context, body mbodyraw.ExampleBodyRaw) error <span class="cov0" title="0">{
        bodyRaw := ConvertModelToGen(body)
        return brs.queries.UpdateBodyRawData(ctx, gen.UpdateBodyRawDataParams{
                ID:           bodyRaw.ID,
                CompressType: bodyRaw.CompressType,
                Data:         bodyRaw.Data,
        })
}</span>

func (brs BodyRawService) UpdateBodyRawVisualize(ctx context.Context, body mbodyraw.ExampleBodyRaw) error <span class="cov0" title="0">{
        bodyRaw := ConvertModelToGen(body)
        return brs.queries.UpdateVisualizeMode(ctx, gen.UpdateVisualizeModeParams{
                ID:            bodyRaw.ID,
                VisualizeMode: bodyRaw.VisualizeMode,
        })
}</span>

func (brs BodyRawService) DeleteBodyRaw(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        err := brs.queries.DeleteBodyRaw(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package sbodyurl

import (
        "context"
        "database/sql"
        "errors"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mbodyurl"
)

var (
        ErrNoBodyUrlEncodedFound = errors.New("no url encoded body found")
)

type BodyURLEncodedService struct {
        queries *gen.Queries
}

func New(queries *gen.Queries) BodyURLEncodedService <span class="cov0" title="0">{
        return BodyURLEncodedService{queries: queries}
}</span>

func (bues BodyURLEncodedService) TX(tx *sql.Tx) BodyURLEncodedService <span class="cov0" title="0">{
        return BodyURLEncodedService{queries: bues.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*BodyURLEncodedService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">service := BodyURLEncodedService{queries: queries}
        return &amp;service, nil</span>
}

// ----- Serializers -----

func SeralizeModeltoGen(body mbodyurl.BodyURLEncoded) gen.ExampleBodyUrlencoded <span class="cov0" title="0">{
        var deltaParentID *idwrap.IDWrap
        if body.DeltaParentID != nil </span><span class="cov0" title="0">{
                deltaParentID = body.DeltaParentID
        }</span>

        <span class="cov0" title="0">return gen.ExampleBodyUrlencoded{
                ID:            body.ID,
                ExampleID:     body.ExampleID,
                DeltaParentID: deltaParentID,
                BodyKey:       body.BodyKey,
                Enable:        body.Enable,
                Description:   body.Description,
                Value:         body.Value,
        }</span>
}

func DeserializeGenToModel(body gen.ExampleBodyUrlencoded) mbodyurl.BodyURLEncoded <span class="cov0" title="0">{
        return mbodyurl.BodyURLEncoded{
                ID:            body.ID,
                ExampleID:     body.ExampleID,
                DeltaParentID: body.DeltaParentID,
                BodyKey:       body.BodyKey,
                Enable:        body.Enable,
                Description:   body.Description,
                Value:         body.Value,
        }
}</span>

func (bues BodyURLEncodedService) GetBodyURLEncoded(ctx context.Context, id idwrap.IDWrap) (*mbodyurl.BodyURLEncoded, error) <span class="cov0" title="0">{
        body, err := bues.queries.GetBodyUrlEncoded(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoBodyUrlEncodedFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">urlEncoded := DeserializeGenToModel(body)
        return &amp;urlEncoded, nil</span>
}

func (bues BodyURLEncodedService) GetBodyURLEncodedByExampleID(ctx context.Context, exampleID idwrap.IDWrap) ([]mbodyurl.BodyURLEncoded, error) <span class="cov0" title="0">{
        bodys, err := bues.queries.GetBodyUrlEncodedsByExampleID(ctx, exampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var bodyURLEncodeds []mbodyurl.BodyURLEncoded
        for _, body := range bodys </span><span class="cov0" title="0">{
                bodyURLEncodeds = append(bodyURLEncodeds, DeserializeGenToModel(body))
        }</span>
        <span class="cov0" title="0">return bodyURLEncodeds, nil</span>
}

// TODO: Re-enable after code regeneration
// func (bues BodyURLEncodedService) GetBodyURLEncodedByDeltaParentID(ctx context.Context, deltaParentID idwrap.IDWrap) ([]mbodyurl.BodyURLEncoded, error) {
//         bodys, err := bues.queries.GetBodyUrlEncodedsByDeltaParentID(ctx, &amp;deltaParentID)
//         if err != nil {
//                 return nil, err
//         }
//         var bodyURLEncodeds []mbodyurl.BodyURLEncoded
//         for _, body := range bodys {
//                 bodyURLEncodeds = append(bodyURLEncodeds, DeserializeGenToModel(body))
//         }
//         return bodyURLEncodeds, nil
// }

func (bues BodyURLEncodedService) CreateBodyURLEncoded(ctx context.Context, body *mbodyurl.BodyURLEncoded) error <span class="cov0" title="0">{
        err := bues.queries.CreateBodyUrlEncoded(ctx, gen.CreateBodyUrlEncodedParams{
                ID:            body.ID,
                ExampleID:     body.ExampleID,
                DeltaParentID: body.DeltaParentID,
                BodyKey:       body.BodyKey,
                Enable:        body.Enable,
                Description:   body.Description,
                Value:         body.Value,
        })
        return err
}</span>

func (bues BodyURLEncodedService) CreateBodyFormRaw(ctx context.Context, bodyForm gen.ExampleBodyUrlencoded) error <span class="cov0" title="0">{
        err := bues.queries.CreateBodyUrlEncoded(ctx, gen.CreateBodyUrlEncodedParams{
                ID:            bodyForm.ID,
                ExampleID:     bodyForm.ExampleID,
                DeltaParentID: bodyForm.DeltaParentID,
                BodyKey:       bodyForm.BodyKey,
                Enable:        bodyForm.Enable,
                Description:   bodyForm.Description,
                Value:         bodyForm.Value,
        })
        return err
}</span>

func (bues BodyURLEncodedService) CreateBulkBodyURLEncoded(ctx context.Context, bodyForms []mbodyurl.BodyURLEncoded) error <span class="cov0" title="0">{
        if len(bodyForms) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // The bulk insert SQL expects exactly 7 items per batch
        <span class="cov0" title="0">const batchSize = 7
        for i := 0; i &lt; len(bodyForms); i += batchSize </span><span class="cov0" title="0">{
                end := i + batchSize
                if end &gt; len(bodyForms) </span><span class="cov0" title="0">{
                        end = len(bodyForms)
                }</span>

                <span class="cov0" title="0">batch := bodyForms[i:end]

                // For batches with fewer than 7 items, use individual inserts
                if len(batch) &lt; batchSize </span><span class="cov0" title="0">{
                        for _, body := range batch </span><span class="cov0" title="0">{
                                err := bues.CreateBodyURLEncoded(ctx, &amp;body)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">params := gen.CreateBodyUrlEncodedBulkParams{}

                // Set all 7 batch parameters
                params.ID = batch[0].ID
                params.ExampleID = batch[0].ExampleID
                params.DeltaParentID = batch[0].DeltaParentID
                params.BodyKey = batch[0].BodyKey
                params.Enable = batch[0].Enable
                params.Description = batch[0].Description
                params.Value = batch[0].Value

                params.ID_2 = batch[1].ID
                params.ExampleID_2 = batch[1].ExampleID
                params.DeltaParentID_2 = batch[1].DeltaParentID
                params.BodyKey_2 = batch[1].BodyKey
                params.Enable_2 = batch[1].Enable
                params.Description_2 = batch[1].Description
                params.Value_2 = batch[1].Value

                params.ID_3 = batch[2].ID
                params.ExampleID_3 = batch[2].ExampleID
                params.DeltaParentID_3 = batch[2].DeltaParentID
                params.BodyKey_3 = batch[2].BodyKey
                params.Enable_3 = batch[2].Enable
                params.Description_3 = batch[2].Description
                params.Value_3 = batch[2].Value

                params.ID_4 = batch[3].ID
                params.ExampleID_4 = batch[3].ExampleID
                params.DeltaParentID_4 = batch[3].DeltaParentID
                params.BodyKey_4 = batch[3].BodyKey
                params.Enable_4 = batch[3].Enable
                params.Description_4 = batch[3].Description
                params.Value_4 = batch[3].Value

                params.ID_5 = batch[4].ID
                params.ExampleID_5 = batch[4].ExampleID
                params.DeltaParentID_5 = batch[4].DeltaParentID
                params.BodyKey_5 = batch[4].BodyKey
                params.Enable_5 = batch[4].Enable
                params.Description_5 = batch[4].Description
                params.Value_5 = batch[4].Value

                params.ID_6 = batch[5].ID
                params.ExampleID_6 = batch[5].ExampleID
                params.DeltaParentID_6 = batch[5].DeltaParentID
                params.BodyKey_6 = batch[5].BodyKey
                params.Enable_6 = batch[5].Enable
                params.Description_6 = batch[5].Description
                params.Value_6 = batch[5].Value

                params.ID_7 = batch[6].ID
                params.ExampleID_7 = batch[6].ExampleID
                params.DeltaParentID_7 = batch[6].DeltaParentID
                params.BodyKey_7 = batch[6].BodyKey
                params.Enable_7 = batch[6].Enable
                params.Description_7 = batch[6].Description
                params.Value_7 = batch[6].Value

                err := bues.queries.CreateBodyUrlEncodedBulk(ctx, params)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (bues BodyURLEncodedService) UpdateBodyURLEncoded(ctx context.Context, body *mbodyurl.BodyURLEncoded) error <span class="cov0" title="0">{
        err := bues.queries.UpdateBodyUrlEncoded(ctx, gen.UpdateBodyUrlEncodedParams{
                BodyKey:     body.BodyKey,
                Enable:      body.Enable,
                Description: body.Description,
                Value:       body.Value,
                ID:          body.ID,
        })
        return err
}</span>

func (bues BodyURLEncodedService) DeleteBodyURLEncoded(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        err := bues.queries.DeleteBodyURLEncoded(ctx, id)
        return err
}</span>

func (bues BodyURLEncodedService) ResetBodyURLEncodedDelta(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        bodyURLEncoded, err := bues.GetBodyURLEncoded(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">bodyURLEncoded.DeltaParentID = nil
        bodyURLEncoded.BodyKey = ""
        bodyURLEncoded.Enable = false
        bodyURLEncoded.Description = ""
        bodyURLEncoded.Value = ""

        return bues.UpdateBodyURLEncoded(ctx, bodyURLEncoded)</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package scollection

import (
        "context"
        "database/sql"
        "fmt"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/movable"
)

// CollectionMovableRepository implements movable.MovableRepository for Collections
// It adapts position-based operations to linked list operations using prev/next pointers
type CollectionMovableRepository struct {
        queries *gen.Queries
}

// NewCollectionMovableRepository creates a new CollectionMovableRepository
func NewCollectionMovableRepository(queries *gen.Queries) *CollectionMovableRepository <span class="cov8" title="1">{
        return &amp;CollectionMovableRepository{
                queries: queries,
        }
}</span>

// TX returns a new repository instance with transaction support
func (r *CollectionMovableRepository) TX(tx *sql.Tx) *CollectionMovableRepository <span class="cov8" title="1">{
        return &amp;CollectionMovableRepository{
                queries: r.queries.WithTx(tx),
        }
}</span>

// UpdatePosition updates the position of a collection in the linked list
// For collections, parentID is the workspace_id and listType is ignored
func (r *CollectionMovableRepository) UpdatePosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap, listType movable.ListType, position int) error <span class="cov8" title="1">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov8" title="1">{
                repo = r.TX(tx)
        }</span>

        // Get collection to find workspace_id
        <span class="cov8" title="1">collection, err := repo.queries.GetCollection(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get collection: %w", err)
        }</span>

        // Get ordered list of collections in workspace
        <span class="cov8" title="1">orderedCollections, err := repo.queries.GetCollectionsInOrder(ctx, gen.GetCollectionsInOrderParams{
                WorkspaceID:   collection.WorkspaceID,
                WorkspaceID_2: collection.WorkspaceID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get collections in order: %w", err)
        }</span>

        // Find current position and validate new position
        <span class="cov8" title="1">currentIdx := -1
        for i, col := range orderedCollections </span><span class="cov8" title="1">{
                if idwrap.NewFromBytesMust(col.ID).Compare(itemID) == 0 </span><span class="cov8" title="1">{
                        currentIdx = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if currentIdx == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("collection not found in workspace")
        }</span>

        <span class="cov8" title="1">if position &lt; 0 || position &gt;= len(orderedCollections) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid position: %d (valid range: 0-%d)", position, len(orderedCollections)-1)
        }</span>

        <span class="cov8" title="1">if currentIdx == position </span><span class="cov8" title="1">{
                // No change needed
                return nil
        }</span>

        // Calculate new prev and next pointers
        <span class="cov8" title="1">var newPrev, newNext *idwrap.IDWrap

        if position == 0 </span><span class="cov8" title="1">{
                // Moving to head position
                newPrev = nil
                if len(orderedCollections) &gt; 1 </span><span class="cov8" title="1">{
                        nextID := idwrap.NewFromBytesMust(orderedCollections[1].ID)
                        newNext = &amp;nextID
                }</span>
        } else<span class="cov8" title="1"> if position == len(orderedCollections)-1 </span><span class="cov0" title="0">{
                // Moving to tail position  
                prevID := idwrap.NewFromBytesMust(orderedCollections[len(orderedCollections)-2].ID)
                newPrev = &amp;prevID
                newNext = nil
        }</span> else<span class="cov8" title="1"> {
                // Moving to middle position
                prevID := idwrap.NewFromBytesMust(orderedCollections[position-1].ID)
                nextID := idwrap.NewFromBytesMust(orderedCollections[position+1].ID)
                newPrev = &amp;prevID
                newNext = &amp;nextID
        }</span>

        // Update the collection's position
        <span class="cov8" title="1">return repo.queries.UpdateCollectionOrder(ctx, gen.UpdateCollectionOrderParams{
                Prev:        newPrev,
                Next:        newNext,
                ID:          itemID,
                WorkspaceID: collection.WorkspaceID,
        })</span>
}

// UpdatePositions updates positions for multiple collections in batch
func (r *CollectionMovableRepository) UpdatePositions(ctx context.Context, tx *sql.Tx, updates []movable.PositionUpdate) error <span class="cov8" title="1">{
        if len(updates) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        
        // Get repository with transaction support
        <span class="cov8" title="1">repo := r
        if tx != nil </span><span class="cov8" title="1">{
                repo = r.TX(tx)
        }</span>

        // Get the workspace ID from the first collection to validate all are in same workspace
        <span class="cov8" title="1">firstCollection, err := repo.queries.GetCollection(ctx, updates[0].ItemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get first collection: %w", err)
        }</span>
        <span class="cov8" title="1">workspaceID := firstCollection.WorkspaceID
        
        // Validate all collections are in the same workspace and create ID position map
        positionMap := make(map[idwrap.IDWrap]int)
        for _, update := range updates </span><span class="cov8" title="1">{
                collection, err := repo.queries.GetCollection(ctx, update.ItemID)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to get collection %s: %w", update.ItemID.String(), err)
                }</span>
                <span class="cov8" title="1">if collection.WorkspaceID.Compare(workspaceID) != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("all collections must be in the same workspace")
                }</span>
                <span class="cov8" title="1">positionMap[update.ItemID] = update.Position</span>
        }
        
        // Build the complete ordered list with all collections at their new positions
        <span class="cov8" title="1">orderedIDs := make([]idwrap.IDWrap, len(updates))
        for _, update := range updates </span><span class="cov8" title="1">{
                if update.Position &lt; 0 || update.Position &gt;= len(updates) </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid position %d for collection %s (valid range: 0-%d)", 
                                update.Position, update.ItemID.String(), len(updates)-1)
                }</span>
                <span class="cov8" title="1">orderedIDs[update.Position] = update.ItemID</span>
        }
        
        // Calculate prev/next pointers for each collection in the new order
        <span class="cov8" title="1">type ptrUpdate struct {
                id   idwrap.IDWrap
                prev *idwrap.IDWrap
                next *idwrap.IDWrap
        }
        
        ptrUpdates := make([]ptrUpdate, len(orderedIDs))
        for i, id := range orderedIDs </span><span class="cov8" title="1">{
                var prev, next *idwrap.IDWrap
                
                if i &gt; 0 </span><span class="cov8" title="1">{
                        prev = &amp;orderedIDs[i-1]
                }</span>
                <span class="cov8" title="1">if i &lt; len(orderedIDs)-1 </span><span class="cov8" title="1">{
                        next = &amp;orderedIDs[i+1]
                }</span>
                
                <span class="cov8" title="1">ptrUpdates[i] = ptrUpdate{
                        id:   id,
                        prev: prev,
                        next: next,
                }</span>
        }
        
        // Apply all updates atomically
        <span class="cov8" title="1">for _, update := range ptrUpdates </span><span class="cov8" title="1">{
                if err := repo.queries.UpdateCollectionOrder(ctx, gen.UpdateCollectionOrderParams{
                        Prev:        update.prev,
                        Next:        update.next,
                        ID:          update.id,
                        WorkspaceID: workspaceID,
                }); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to update collection %s order: %w", update.id.String(), err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetMaxPosition returns the maximum position value for collections in a workspace
// For linked lists, this is the count of collections minus 1
func (r *CollectionMovableRepository) GetMaxPosition(ctx context.Context, parentID idwrap.IDWrap, listType movable.ListType) (int, error) <span class="cov8" title="1">{
        // For collections, parentID is the workspace_id
        orderedCollections, err := r.queries.GetCollectionsInOrder(ctx, gen.GetCollectionsInOrderParams{
                WorkspaceID:   parentID,
                WorkspaceID_2: parentID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return -1, nil // No collections means no max position
                }</span>
                <span class="cov0" title="0">return 0, fmt.Errorf("failed to get collections in order: %w", err)</span>
        }

        <span class="cov8" title="1">if len(orderedCollections) == 0 </span><span class="cov0" title="0">{
                return -1, nil
        }</span>

        <span class="cov8" title="1">return len(orderedCollections) - 1, nil</span>
}

// GetItemsByParent returns all collections under a workspace, ordered by position
func (r *CollectionMovableRepository) GetItemsByParent(ctx context.Context, parentID idwrap.IDWrap, listType movable.ListType) ([]movable.MovableItem, error) <span class="cov8" title="1">{
        // For collections, parentID is the workspace_id
        orderedCollections, err := r.queries.GetCollectionsInOrder(ctx, gen.GetCollectionsInOrderParams{
                WorkspaceID:   parentID,
                WorkspaceID_2: parentID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []movable.MovableItem{}, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get collections in order: %w", err)</span>
        }

        // Convert to MovableItem structs
        <span class="cov8" title="1">items := make([]movable.MovableItem, len(orderedCollections))
        for i, col := range orderedCollections </span><span class="cov8" title="1">{
                items[i] = movable.MovableItem{
                        ID:       idwrap.NewFromBytesMust(col.ID),
                        ParentID: &amp;parentID, // workspace_id as parent
                        Position: int(col.Position),
                        ListType: listType,
                }
        }</span>

        <span class="cov8" title="1">return items, nil</span>
}

// insertAtPosition inserts a collection at a specific position in the linked list
// This is a helper method for operations that need to insert new collections
func (r *CollectionMovableRepository) insertAtPosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap, workspaceID idwrap.IDWrap, position int) error <span class="cov0" title="0">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get ordered list of collections in workspace
        <span class="cov0" title="0">orderedCollections, err := repo.queries.GetCollectionsInOrder(ctx, gen.GetCollectionsInOrderParams{
                WorkspaceID:   workspaceID,
                WorkspaceID_2: workspaceID,
        })
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get collections in order: %w", err)
        }</span>

        <span class="cov0" title="0">var newPrev, newNext *idwrap.IDWrap

        if len(orderedCollections) == 0 </span><span class="cov0" title="0">{
                // First collection in workspace
                newPrev = nil
                newNext = nil
        }</span> else<span class="cov0" title="0"> if position == 0 </span><span class="cov0" title="0">{
                // Insert at head
                newPrev = nil
                if len(orderedCollections) &gt; 0 </span><span class="cov0" title="0">{
                        nextID := idwrap.NewFromBytesMust(orderedCollections[0].ID)
                        newNext = &amp;nextID
                        
                        // Update the current head to point back to new item
                        err = repo.queries.UpdateCollectionOrder(ctx, gen.UpdateCollectionOrderParams{
                                Prev:        &amp;itemID,
                                Next:        newNext,
                                ID:          nextID,
                                WorkspaceID: workspaceID,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update current head: %w", err)
                        }</span>
                }
        } else<span class="cov0" title="0"> if position &gt;= len(orderedCollections) </span><span class="cov0" title="0">{
                // Insert at tail
                if len(orderedCollections) &gt; 0 </span><span class="cov0" title="0">{
                        prevID := idwrap.NewFromBytesMust(orderedCollections[len(orderedCollections)-1].ID)
                        newPrev = &amp;prevID
                        
                        // Update the current tail to point forward to new item
                        err = repo.queries.UpdateCollectionOrder(ctx, gen.UpdateCollectionOrderParams{
                                Prev:        newPrev,
                                Next:        &amp;itemID,
                                ID:          prevID,
                                WorkspaceID: workspaceID,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update current tail: %w", err)
                        }</span>
                }
                <span class="cov0" title="0">newNext = nil</span>
        } else<span class="cov0" title="0"> {
                // Insert in middle
                prevID := idwrap.NewFromBytesMust(orderedCollections[position-1].ID)
                nextID := idwrap.NewFromBytesMust(orderedCollections[position].ID)
                newPrev = &amp;prevID
                newNext = &amp;nextID
                
                // Update prev item to point to new item
                err = repo.queries.UpdateCollectionOrder(ctx, gen.UpdateCollectionOrderParams{
                        Prev:        newPrev,
                        Next:        &amp;itemID,
                        ID:          prevID,
                        WorkspaceID: workspaceID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update prev item: %w", err)
                }</span>
                
                // Update next item to point back to new item
                <span class="cov0" title="0">err = repo.queries.UpdateCollectionOrder(ctx, gen.UpdateCollectionOrderParams{
                        Prev:        &amp;itemID,
                        Next:        newNext,
                        ID:          nextID,
                        WorkspaceID: workspaceID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update next item: %w", err)
                }</span>
        }

        // Set the new item's position
        <span class="cov0" title="0">return repo.queries.UpdateCollectionOrder(ctx, gen.UpdateCollectionOrderParams{
                Prev:        newPrev,
                Next:        newNext,
                ID:          itemID,
                WorkspaceID: workspaceID,
        })</span>
}

// removeFromPosition removes a collection from its current position in the linked list
// This is a helper method for operations that need to remove collections
func (r *CollectionMovableRepository) removeFromPosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap) error <span class="cov0" title="0">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get the collection to remove
        <span class="cov0" title="0">collection, err := repo.queries.GetCollection(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get collection: %w", err)
        }</span>

        // Get ordered collections to find prev and next
        <span class="cov0" title="0">orderedCollections, err := repo.queries.GetCollectionsInOrder(ctx, gen.GetCollectionsInOrderParams{
                WorkspaceID:   collection.WorkspaceID,
                WorkspaceID_2: collection.WorkspaceID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get collections in order: %w", err)
        }</span>

        // Find the item and its neighbors
        <span class="cov0" title="0">var prevID, nextID *idwrap.IDWrap
        for i, col := range orderedCollections </span><span class="cov0" title="0">{
                if idwrap.NewFromBytesMust(col.ID).Compare(itemID) == 0 </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                prev := idwrap.NewFromBytesMust(orderedCollections[i-1].ID)
                                prevID = &amp;prev
                        }</span>
                        <span class="cov0" title="0">if i &lt; len(orderedCollections)-1 </span><span class="cov0" title="0">{
                                next := idwrap.NewFromBytesMust(orderedCollections[i+1].ID)
                                nextID = &amp;next
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }

        // Update prev item's next pointer to skip the removed item
        <span class="cov0" title="0">if prevID != nil </span><span class="cov0" title="0">{
                // Get the prev item's current prev pointer to preserve it
                for _, col := range orderedCollections </span><span class="cov0" title="0">{
                        if idwrap.NewFromBytesMust(col.ID).Compare(*prevID) == 0 </span><span class="cov0" title="0">{
                                var currentPrev *idwrap.IDWrap
                                if col.Prev != nil </span><span class="cov0" title="0">{
                                        prev := idwrap.NewFromBytesMust(col.Prev)
                                        currentPrev = &amp;prev
                                }</span>
                                
                                <span class="cov0" title="0">err = repo.queries.UpdateCollectionOrder(ctx, gen.UpdateCollectionOrderParams{
                                        Prev:        currentPrev, // Preserve the prev item's own prev pointer
                                        Next:        nextID,      // Point to the item after the removed one  
                                        ID:          *prevID,
                                        WorkspaceID: collection.WorkspaceID,
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to update prev item: %w", err)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
        }

        // Update next item's prev pointer to skip the removed item
        <span class="cov0" title="0">if nextID != nil </span><span class="cov0" title="0">{
                // Get the next item's current next pointer to preserve it
                for _, col := range orderedCollections </span><span class="cov0" title="0">{
                        if idwrap.NewFromBytesMust(col.ID).Compare(*nextID) == 0 </span><span class="cov0" title="0">{
                                var currentNext *idwrap.IDWrap
                                if col.Next != nil </span><span class="cov0" title="0">{
                                        next := idwrap.NewFromBytesMust(col.Next)
                                        currentNext = &amp;next
                                }</span>
                                
                                <span class="cov0" title="0">err = repo.queries.UpdateCollectionOrder(ctx, gen.UpdateCollectionOrderParams{
                                        Prev:        prevID,      // Point to the item before the removed one
                                        Next:        currentNext, // Preserve the next item's own next pointer
                                        ID:          *nextID,
                                        WorkspaceID: collection.WorkspaceID,
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to update next item: %w", err)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file86" style="display: none">package scollection

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mcollection"
        "the-dev-tools/server/pkg/movable"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

var ErrNoCollectionFound = sql.ErrNoRows

type CollectionService struct {
        queries              *gen.Queries
        logger               *slog.Logger
        linkedListManager    movable.LinkedListManager
        movableRepository    movable.MovableRepository
}

func ConvertToDBCollection(collection mcollection.Collection) gen.Collection <span class="cov0" title="0">{
        return gen.Collection{
                ID:          collection.ID,
                WorkspaceID: collection.WorkspaceID,
                Name:        collection.Name,
        }
}</span>

func ConvertToModelCollection(collection gen.Collection) *mcollection.Collection <span class="cov8" title="1">{
        return &amp;mcollection.Collection{
                ID:          collection.ID,
                WorkspaceID: collection.WorkspaceID,
                Name:        collection.Name,
        }
}</span>

func ConvertGetCollectionByWorkspaceIDRowToModel(row gen.GetCollectionByWorkspaceIDRow) *mcollection.Collection <span class="cov0" title="0">{
        return &amp;mcollection.Collection{
                ID:          row.ID,
                WorkspaceID: row.WorkspaceID,
                Name:        row.Name,
        }
}</span>


func New(queries *gen.Queries, logger *slog.Logger) CollectionService <span class="cov8" title="1">{
        // Create the movable repository for collections
        movableRepo := NewCollectionMovableRepository(queries)
        
        // Create the linked list manager with the movable repository
        linkedListManager := movable.NewDefaultLinkedListManager(movableRepo)
        
        return CollectionService{
                queries:              queries,
                logger:               logger,
                linkedListManager:    linkedListManager,
                movableRepository:    movableRepo,
        }
}</span>

func (cs CollectionService) TX(tx *sql.Tx) CollectionService <span class="cov8" title="1">{
        // Create new instances with transaction support
        txQueries := cs.queries.WithTx(tx)
        movableRepo := NewCollectionMovableRepository(txQueries)
        linkedListManager := movable.NewDefaultLinkedListManager(movableRepo)
        
        return CollectionService{
                queries:              txQueries,
                logger:               cs.logger,
                linkedListManager:    linkedListManager,
                movableRepository:    movableRepo,
        }
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*CollectionService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Create movable repository and linked list manager
        <span class="cov0" title="0">movableRepo := NewCollectionMovableRepository(queries)
        linkedListManager := movable.NewDefaultLinkedListManager(movableRepo)
        
        service := CollectionService{
                queries:              queries,
                linkedListManager:    linkedListManager,
                movableRepository:    movableRepo,
        }
        return &amp;service, nil</span>
}

func (cs CollectionService) ListCollections(ctx context.Context, workspaceID idwrap.IDWrap) ([]mcollection.Collection, error) <span class="cov0" title="0">{
        rows, err := cs.queries.GetCollectionByWorkspaceID(ctx, workspaceID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        cs.logger.InfoContext(ctx, fmt.Sprintf("workspaceID: %s not found", workspaceID.String()))
                        return nil, ErrNoCollectionFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return tgeneric.MassConvertPtr(rows, ConvertGetCollectionByWorkspaceIDRowToModel), nil</span>
}

func (cs CollectionService) CreateCollection(ctx context.Context, collection *mcollection.Collection) error <span class="cov8" title="1">{
        // Find the current tail of the linked list (last collection in workspace)
        existingCollections, err := cs.GetCollectionsOrdered(ctx, collection.WorkspaceID)
        if err != nil &amp;&amp; err != ErrNoCollectionFound </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get existing collections: %w", err)
        }</span>
        
        <span class="cov8" title="1">var prev *idwrap.IDWrap
        
        // If there are existing collections, set prev to point to the last one
        // and update that collection's next pointer to point to the new one
        if len(existingCollections) &gt; 0 </span><span class="cov8" title="1">{
                lastCollection := existingCollections[len(existingCollections)-1]
                prev = &amp;lastCollection.ID
                
                // Get the database version to access prev/next fields
                dbLastCollection, err := cs.queries.GetCollection(ctx, lastCollection.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get last collection from database: %w", err)
                }</span>
                
                // Update the current tail's next pointer to point to new collection
                <span class="cov8" title="1">err = cs.queries.UpdateCollectionOrder(ctx, gen.UpdateCollectionOrderParams{
                        Prev:        dbLastCollection.Prev, // Keep existing prev pointer
                        Next:        &amp;collection.ID,       // Set next to new collection
                        ID:          lastCollection.ID,    // Update the last collection
                        WorkspaceID: collection.WorkspaceID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update previous tail collection: %w", err)
                }</span>
        }
        
        // Create the collection with proper linked list pointers
        <span class="cov8" title="1">return cs.queries.CreateCollection(ctx, gen.CreateCollectionParams{
                ID:          collection.ID,
                WorkspaceID: collection.WorkspaceID,
                Name:        collection.Name,
                Prev:        prev, // Points to current tail (or nil if first)
                Next:        nil,  // Always nil for new collections (they become the new tail)
        })</span>
}

func (cs CollectionService) GetCollection(ctx context.Context, id idwrap.IDWrap) (*mcollection.Collection, error) <span class="cov8" title="1">{
        collection, err := cs.queries.GetCollection(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        cs.logger.DebugContext(ctx, fmt.Sprintf("CollectionID: %s not found", id.String()))
                        return nil, ErrNoCollectionFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return ConvertToModelCollection(collection), nil</span>
}

func (cs CollectionService) UpdateCollection(ctx context.Context, collection *mcollection.Collection) error <span class="cov0" title="0">{
        err := cs.queries.UpdateCollection(ctx, gen.UpdateCollectionParams{
                ID:          collection.ID,
                WorkspaceID: collection.WorkspaceID,
                Name:        collection.Name,
        })
        return err
}</span>

func (cs CollectionService) DeleteCollection(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        return cs.queries.DeleteCollection(ctx, id)
}</span>

func (cs CollectionService) GetWorkspaceID(ctx context.Context, id idwrap.IDWrap) (idwrap.IDWrap, error) <span class="cov8" title="1">{
        ulidData, err := cs.queries.GetCollectionWorkspaceID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return idwrap.IDWrap{}, ErrNoCollectionFound
                }</span>
                <span class="cov0" title="0">return idwrap.IDWrap{}, err</span>
        }
        <span class="cov8" title="1">return ulidData, nil</span>
}

func (cs CollectionService) CheckWorkspaceID(ctx context.Context, id, ownerID idwrap.IDWrap) (bool, error) <span class="cov0" title="0">{
        CollectionWorkspaceID, err := cs.GetWorkspaceID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return false, ErrNoCollectionFound
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov0" title="0">return ownerID.Compare(CollectionWorkspaceID) == 0, nil</span>
}

func (cs CollectionService) GetCollectionByWorkspaceIDAndName(ctx context.Context, workspaceID idwrap.IDWrap, name string) (*mcollection.Collection, error) <span class="cov0" title="0">{
        collection, err := cs.queries.GetCollectionByWorkspaceIDAndName(ctx, gen.GetCollectionByWorkspaceIDAndNameParams{
                WorkspaceID: workspaceID,
                Name:        name,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoCollectionFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;mcollection.Collection{
                ID:          collection.ID,
                Name:        collection.Name,
                WorkspaceID: collection.WorkspaceID,
        }, nil</span>
}

// Movable operations for collections

// MoveCollectionAfter moves a collection to be positioned after the target collection
func (cs CollectionService) MoveCollectionAfter(ctx context.Context, collectionID, targetID idwrap.IDWrap) error <span class="cov8" title="1">{
        return cs.MoveCollectionAfterTX(ctx, nil, collectionID, targetID)
}</span>

// MoveCollectionAfterTX moves a collection to be positioned after the target collection within a transaction
func (cs CollectionService) MoveCollectionAfterTX(ctx context.Context, tx *sql.Tx, collectionID, targetID idwrap.IDWrap) error <span class="cov8" title="1">{
        service := cs
        if tx != nil </span><span class="cov8" title="1">{
                service = cs.TX(tx)
        }</span>
        
        // Get workspace ID for both collections to ensure they're in the same workspace
        <span class="cov8" title="1">sourceWorkspaceID, err := service.GetWorkspaceID(ctx, collectionID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get source collection workspace: %w", err)
        }</span>
        
        <span class="cov8" title="1">targetWorkspaceID, err := service.GetWorkspaceID(ctx, targetID)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to get target collection workspace: %w", err)
        }</span>
        
        <span class="cov8" title="1">if sourceWorkspaceID.Compare(targetWorkspaceID) != 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("collections must be in the same workspace")
        }</span>
        
        // Get all collections in the workspace in order
        <span class="cov8" title="1">collections, err := service.GetCollectionsOrdered(ctx, sourceWorkspaceID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get collections in order: %w", err)
        }</span>
        
        // Find positions of source and target collections
        <span class="cov8" title="1">var sourcePos, targetPos int = -1, -1
        for i, col := range collections </span><span class="cov8" title="1">{
                if col.ID.Compare(collectionID) == 0 </span><span class="cov8" title="1">{
                        sourcePos = i
                }</span>
                <span class="cov8" title="1">if col.ID.Compare(targetID) == 0 </span><span class="cov8" title="1">{
                        targetPos = i
                }</span>
        }
        
        <span class="cov8" title="1">if sourcePos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("source collection not found in workspace")
        }</span>
        <span class="cov8" title="1">if targetPos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("target collection not found in workspace")
        }</span>
        
        <span class="cov8" title="1">if sourcePos == targetPos </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot move collection relative to itself")
        }</span>
        
        // Calculate new order: move source to be after target
        <span class="cov8" title="1">newOrder := make([]idwrap.IDWrap, 0, len(collections))
        
        for i, col := range collections </span><span class="cov8" title="1">{
                if i == sourcePos </span><span class="cov8" title="1">{
                        continue</span> // Skip source collection
                }
                <span class="cov8" title="1">newOrder = append(newOrder, col.ID)
                if i == targetPos </span><span class="cov8" title="1">{
                        newOrder = append(newOrder, collectionID) // Insert source after target
                }</span>
        }
        
        // Reorder collections
        <span class="cov8" title="1">return service.ReorderCollectionsTX(ctx, tx, sourceWorkspaceID, newOrder)</span>
}

// MoveCollectionBefore moves a collection to be positioned before the target collection
func (cs CollectionService) MoveCollectionBefore(ctx context.Context, collectionID, targetID idwrap.IDWrap) error <span class="cov8" title="1">{
        return cs.MoveCollectionBeforeTX(ctx, nil, collectionID, targetID)
}</span>

// MoveCollectionBeforeTX moves a collection to be positioned before the target collection within a transaction
func (cs CollectionService) MoveCollectionBeforeTX(ctx context.Context, tx *sql.Tx, collectionID, targetID idwrap.IDWrap) error <span class="cov8" title="1">{
        service := cs
        if tx != nil </span><span class="cov8" title="1">{
                service = cs.TX(tx)
        }</span>
        
        // Get workspace ID for both collections to ensure they're in the same workspace
        <span class="cov8" title="1">sourceWorkspaceID, err := service.GetWorkspaceID(ctx, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get source collection workspace: %w", err)
        }</span>
        
        <span class="cov8" title="1">targetWorkspaceID, err := service.GetWorkspaceID(ctx, targetID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get target collection workspace: %w", err)
        }</span>
        
        <span class="cov8" title="1">if sourceWorkspaceID.Compare(targetWorkspaceID) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("collections must be in the same workspace")
        }</span>
        
        // Get all collections in the workspace in order
        <span class="cov8" title="1">collections, err := service.GetCollectionsOrdered(ctx, sourceWorkspaceID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get collections in order: %w", err)
        }</span>
        
        // Find positions of source and target collections
        <span class="cov8" title="1">var sourcePos, targetPos int = -1, -1
        for i, col := range collections </span><span class="cov8" title="1">{
                if col.ID.Compare(collectionID) == 0 </span><span class="cov8" title="1">{
                        sourcePos = i
                }</span>
                <span class="cov8" title="1">if col.ID.Compare(targetID) == 0 </span><span class="cov8" title="1">{
                        targetPos = i
                }</span>
        }
        
        <span class="cov8" title="1">if sourcePos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("source collection not found in workspace")
        }</span>
        <span class="cov8" title="1">if targetPos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("target collection not found in workspace")
        }</span>
        
        <span class="cov8" title="1">if sourcePos == targetPos </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot move collection relative to itself")
        }</span>
        
        // Calculate new order: move source to be before target
        <span class="cov8" title="1">newOrder := make([]idwrap.IDWrap, 0, len(collections))
        
        for i, col := range collections </span><span class="cov8" title="1">{
                if i == sourcePos </span><span class="cov8" title="1">{
                        continue</span> // Skip source collection
                }
                <span class="cov8" title="1">if i == targetPos </span><span class="cov8" title="1">{
                        newOrder = append(newOrder, collectionID) // Insert source before target
                }</span>
                <span class="cov8" title="1">newOrder = append(newOrder, col.ID)</span>
        }
        
        // Reorder collections
        <span class="cov8" title="1">return service.ReorderCollectionsTX(ctx, tx, sourceWorkspaceID, newOrder)</span>
}

// GetCollectionsOrdered returns collections in the workspace in their proper order
func (cs CollectionService) GetCollectionsOrdered(ctx context.Context, workspaceID idwrap.IDWrap) ([]mcollection.Collection, error) <span class="cov8" title="1">{
        // Use the underlying query that maintains the linked list order
        orderedCollections, err := cs.queries.GetCollectionsInOrder(ctx, gen.GetCollectionsInOrderParams{
                WorkspaceID:   workspaceID,
                WorkspaceID_2: workspaceID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        cs.logger.InfoContext(ctx, fmt.Sprintf("workspaceID: %s has no collections", workspaceID.String()))
                        return []mcollection.Collection{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        
        // Convert to model collections
        <span class="cov8" title="1">collections := make([]mcollection.Collection, len(orderedCollections))
        for i, col := range orderedCollections </span><span class="cov8" title="1">{
                collections[i] = mcollection.Collection{
                        ID:          idwrap.NewFromBytesMust(col.ID),
                        WorkspaceID: idwrap.NewFromBytesMust(col.WorkspaceID),
                        Name:        col.Name,
                        // Note: Updated field not available in the ordered query result
                        // If needed, we could make a separate query to get this field
                }
        }</span>
        
        <span class="cov8" title="1">return collections, nil</span>
}

// ReorderCollections performs a bulk reorder of collections using the movable system
func (cs CollectionService) ReorderCollections(ctx context.Context, workspaceID idwrap.IDWrap, orderedIDs []idwrap.IDWrap) error <span class="cov8" title="1">{
        return cs.ReorderCollectionsTX(ctx, nil, workspaceID, orderedIDs)
}</span>

// ReorderCollectionsTX performs a bulk reorder of collections using the movable system within a transaction
func (cs CollectionService) ReorderCollectionsTX(ctx context.Context, tx *sql.Tx, workspaceID idwrap.IDWrap, orderedIDs []idwrap.IDWrap) error <span class="cov8" title="1">{
        service := cs
        if tx != nil </span><span class="cov8" title="1">{
                service = cs.TX(tx)
        }</span>
        
        // Build position updates
        <span class="cov8" title="1">updates := make([]movable.PositionUpdate, len(orderedIDs))
        for i, id := range orderedIDs </span><span class="cov8" title="1">{
                updates[i] = movable.PositionUpdate{
                        ItemID:   id,
                        ListType: movable.CollectionListTypeCollections,
                        Position: i,
                }
        }</span>
        
        // Execute the batch update using the movable repository
        <span class="cov8" title="1">if err := service.movableRepository.UpdatePositions(ctx, tx, updates); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to reorder collections: %w", err)
        }</span>
        
        <span class="cov8" title="1">cs.logger.DebugContext(ctx, "Collections reordered", 
                "workspaceID", workspaceID.String(),
                "collectionCount", len(orderedIDs))
        
        return nil</span>
}

// CompactCollectionPositions recalculates and compacts position values to eliminate gaps
func (cs CollectionService) CompactCollectionPositions(ctx context.Context, workspaceID idwrap.IDWrap) error <span class="cov8" title="1">{
        return cs.CompactCollectionPositionsTX(ctx, nil, workspaceID)
}</span>

// CompactCollectionPositionsTX recalculates and compacts position values within a transaction
func (cs CollectionService) CompactCollectionPositionsTX(ctx context.Context, tx *sql.Tx, workspaceID idwrap.IDWrap) error <span class="cov8" title="1">{
        service := cs
        if tx != nil </span><span class="cov8" title="1">{
                service = cs.TX(tx)
        }</span>
        
        <span class="cov8" title="1">if err := service.linkedListManager.CompactPositions(ctx, tx, workspaceID, movable.CollectionListTypeCollections); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to compact collection positions: %w", err)
        }</span>
        
        <span class="cov8" title="1">cs.logger.DebugContext(ctx, "Collection positions compacted", "workspaceID", workspaceID.String())
        return nil</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package scollectionitem

import (
        "context"
        "database/sql"
        "fmt"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/movable"
)

// CollectionItemsMovableRepository implements movable.MovableRepository for CollectionItems
// It handles mixed folder/endpoint ordering using the unified collection_items table with prev_id/next_id linked list
type CollectionItemsMovableRepository struct {
        queries *gen.Queries
}

// NewCollectionItemsMovableRepository creates a new CollectionItemsMovableRepository
func NewCollectionItemsMovableRepository(queries *gen.Queries) *CollectionItemsMovableRepository <span class="cov8" title="1">{
        return &amp;CollectionItemsMovableRepository{
                queries: queries,
        }
}</span>

// TX returns a new repository instance with transaction support
func (r *CollectionItemsMovableRepository) TX(tx *sql.Tx) *CollectionItemsMovableRepository <span class="cov8" title="1">{
        return &amp;CollectionItemsMovableRepository{
                queries: r.queries.WithTx(tx),
        }
}</span>

// UpdatePosition updates the position of a collection item in the linked list
// For collection items, parentID can be either collection_id (for root items) or parent_folder_id
func (r *CollectionItemsMovableRepository) UpdatePosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap, listType movable.ListType, position int) error <span class="cov0" title="0">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get the collection item to understand its context
        <span class="cov0" title="0">item, err := repo.queries.GetCollectionItem(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get collection item: %w", err)
        }</span>

        // Get ordered list of items in the same parent context
        <span class="cov0" title="0">orderedItems, err := repo.getOrderedItemsInSameParent(ctx, item)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get items in order: %w", err)
        }</span>

        // Find current position and validate new position
        <span class="cov0" title="0">currentIdx := -1
        for i, orderItem := range orderedItems </span><span class="cov0" title="0">{
                if idwrap.NewFromBytesMust(orderItem.ID).Compare(itemID) == 0 </span><span class="cov0" title="0">{
                        currentIdx = i
                        break</span>
                }
        }

        <span class="cov0" title="0">if currentIdx == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("collection item not found in parent context")
        }</span>

        <span class="cov0" title="0">if position &lt; 0 || position &gt;= len(orderedItems) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid position: %d (valid range: 0-%d)", position, len(orderedItems)-1)
        }</span>

        <span class="cov0" title="0">if currentIdx == position </span><span class="cov0" title="0">{
                // No change needed
                return nil
        }</span>

        // Calculate new prev and next pointers
        <span class="cov0" title="0">var newPrev, newNext *idwrap.IDWrap

        if position == 0 </span><span class="cov0" title="0">{
                // Moving to head position
                newPrev = nil
                if len(orderedItems) &gt; 1 </span><span class="cov0" title="0">{
                        nextID := idwrap.NewFromBytesMust(orderedItems[1].ID)
                        newNext = &amp;nextID
                }</span>
        } else<span class="cov0" title="0"> if position == len(orderedItems)-1 </span><span class="cov0" title="0">{
                // Moving to tail position
                prevID := idwrap.NewFromBytesMust(orderedItems[len(orderedItems)-2].ID)
                newPrev = &amp;prevID
                newNext = nil
        }</span> else<span class="cov0" title="0"> {
                // Moving to middle position
                prevID := idwrap.NewFromBytesMust(orderedItems[position-1].ID)
                nextID := idwrap.NewFromBytesMust(orderedItems[position+1].ID)
                newPrev = &amp;prevID
                newNext = &amp;nextID
        }</span>

        // Update the collection item's position using SQLC generated query
        <span class="cov0" title="0">return repo.queries.UpdateCollectionItemOrder(ctx, gen.UpdateCollectionItemOrderParams{
                PrevID: newPrev,
                NextID: newNext,
                ID:     itemID,
        })</span>
}

// UpdatePositions updates positions for multiple collection items in batch
func (r *CollectionItemsMovableRepository) UpdatePositions(ctx context.Context, tx *sql.Tx, updates []movable.PositionUpdate) error <span class="cov0" title="0">{
        if len(updates) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get repository with transaction support
        <span class="cov0" title="0">repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get the first item to establish parent context and validate all items are in same context
        <span class="cov0" title="0">firstItem, err := repo.queries.GetCollectionItem(ctx, updates[0].ItemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get first collection item: %w", err)
        }</span>

        // Create ID position map and validate all items are in same parent context
        <span class="cov0" title="0">positionMap := make(map[idwrap.IDWrap]int)
        for _, update := range updates </span><span class="cov0" title="0">{
                item, err := repo.queries.GetCollectionItem(ctx, update.ItemID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get collection item %s: %w", update.ItemID.String(), err)
                }</span>

                // Validate items are in same parent context
                <span class="cov0" title="0">if !areInSameParentContext(firstItem, item) </span><span class="cov0" title="0">{
                        return fmt.Errorf("all collection items must be in the same parent context")
                }</span>

                <span class="cov0" title="0">positionMap[update.ItemID] = update.Position</span>
        }

        // Build the complete ordered list with all items at their new positions
        <span class="cov0" title="0">orderedIDs := make([]idwrap.IDWrap, len(updates))
        for _, update := range updates </span><span class="cov0" title="0">{
                if update.Position &lt; 0 || update.Position &gt;= len(updates) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid position %d for collection item %s (valid range: 0-%d)",
                                update.Position, update.ItemID.String(), len(updates)-1)
                }</span>
                <span class="cov0" title="0">orderedIDs[update.Position] = update.ItemID</span>
        }

        // Calculate prev/next pointers for each item in the new order
        <span class="cov0" title="0">type ptrUpdate struct {
                id   idwrap.IDWrap
                prev *idwrap.IDWrap
                next *idwrap.IDWrap
        }

        ptrUpdates := make([]ptrUpdate, len(orderedIDs))
        for i, id := range orderedIDs </span><span class="cov0" title="0">{
                var prev, next *idwrap.IDWrap

                if i &gt; 0 </span><span class="cov0" title="0">{
                        prev = &amp;orderedIDs[i-1]
                }</span>
                <span class="cov0" title="0">if i &lt; len(orderedIDs)-1 </span><span class="cov0" title="0">{
                        next = &amp;orderedIDs[i+1]
                }</span>

                <span class="cov0" title="0">ptrUpdates[i] = ptrUpdate{
                        id:   id,
                        prev: prev,
                        next: next,
                }</span>
        }

        // Apply all updates atomically
        <span class="cov0" title="0">for _, update := range ptrUpdates </span><span class="cov0" title="0">{
                if err := repo.queries.UpdateCollectionItemOrder(ctx, gen.UpdateCollectionItemOrderParams{
                        PrevID: update.prev,
                        NextID: update.next,
                        ID:     update.id,
                }); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update collection item %s order: %w", update.id.String(), err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetMaxPosition returns the maximum position value for collection items in a parent context
func (r *CollectionItemsMovableRepository) GetMaxPosition(ctx context.Context, parentID idwrap.IDWrap, listType movable.ListType) (int, error) <span class="cov8" title="1">{
        // Determine the appropriate parent context based on listType
        var orderedItems []gen.GetCollectionItemsInOrderRow
        var err error

        switch listType </span>{
        case movable.CollectionListTypeItems:<span class="cov8" title="1">
                // For mixed items, parentID could be collection_id or parent_folder_id
                // We need to get items where the parent matches the parentID
                orderedItems, err = r.queries.GetCollectionItemsInOrder(ctx, gen.GetCollectionItemsInOrderParams{
                        CollectionID:   parentID,
                        ParentFolderID: nil, // Root level items
                        CollectionID_2: parentID,
                })
                if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                        // Try as folder parent if collection root fails
                        orderedItems, err = r.queries.GetCollectionItemsInOrder(ctx, gen.GetCollectionItemsInOrderParams{
                                CollectionID:   parentID, // This needs to be collection_id, but we need it from context
                                ParentFolderID: &amp;parentID,
                                CollectionID_2: parentID,
                        })
                }</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("unsupported list type for collection items: %s", listType.String())</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return -1, nil // No items means no max position
                }</span>
                <span class="cov0" title="0">return 0, fmt.Errorf("failed to get collection items in order: %w", err)</span>
        }

        <span class="cov8" title="1">if len(orderedItems) == 0 </span><span class="cov8" title="1">{
                return -1, nil
        }</span>

        <span class="cov8" title="1">return len(orderedItems) - 1, nil</span>
}

// GetItemsByParent returns all collection items under a parent, ordered by position
func (r *CollectionItemsMovableRepository) GetItemsByParent(ctx context.Context, parentID idwrap.IDWrap, listType movable.ListType) ([]movable.MovableItem, error) <span class="cov0" title="0">{
        var orderedItems []gen.GetCollectionItemsInOrderRow
        var err error

        switch listType </span>{
        case movable.CollectionListTypeItems:<span class="cov0" title="0">
                // For mixed items, try as root level first
                orderedItems, err = r.queries.GetCollectionItemsInOrder(ctx, gen.GetCollectionItemsInOrderParams{
                        CollectionID:   parentID,
                        ParentFolderID: nil,
                        CollectionID_2: parentID,
                })
                if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get collection items in order: %w", err)
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported list type for collection items: %s", listType.String())</span>
        }

        <span class="cov0" title="0">if err == sql.ErrNoRows || len(orderedItems) == 0 </span><span class="cov0" title="0">{
                return []movable.MovableItem{}, nil
        }</span>

        // Convert to MovableItem structs
        <span class="cov0" title="0">items := make([]movable.MovableItem, len(orderedItems))
        for i, item := range orderedItems </span><span class="cov0" title="0">{
                items[i] = movable.MovableItem{
                        ID:       idwrap.NewFromBytesMust(item.ID),
                        ParentID: &amp;parentID,
                        Position: int(item.Position),
                        ListType: listType,
                }
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

// Helper function to get ordered items in the same parent context as the given item
func (r *CollectionItemsMovableRepository) getOrderedItemsInSameParent(ctx context.Context, item gen.CollectionItem) ([]gen.GetCollectionItemsInOrderRow, error) <span class="cov8" title="1">{
        return r.queries.GetCollectionItemsInOrder(ctx, gen.GetCollectionItemsInOrderParams{
                CollectionID:   item.CollectionID,
                ParentFolderID: item.ParentFolderID,
                CollectionID_2: item.CollectionID,
        })
}</span>

// Helper function to check if two collection items are in the same parent context
func areInSameParentContext(item1, item2 gen.CollectionItem) bool <span class="cov8" title="1">{
        // Items are in same context if they have same collection_id and parent_folder_id
        if item1.CollectionID.Compare(item2.CollectionID) != 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Both have nil parent_folder_id (root level)
        <span class="cov8" title="1">if item1.ParentFolderID == nil &amp;&amp; item2.ParentFolderID == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        // Both have same non-nil parent_folder_id
        <span class="cov8" title="1">if item1.ParentFolderID != nil &amp;&amp; item2.ParentFolderID != nil </span><span class="cov8" title="1">{
                return item1.ParentFolderID.Compare(*item2.ParentFolderID) == 0
        }</span>

        // One has nil, other doesn't
        <span class="cov8" title="1">return false</span>
}

// CalculateInsertPosition calculates the correct prev/next IDs for inserting a new item at a position
// This method should be used BEFORE calling InsertCollectionItem to avoid linked list corruption
func (r *CollectionItemsMovableRepository) CalculateInsertPosition(ctx context.Context, collectionID idwrap.IDWrap, parentFolderID *idwrap.IDWrap, position int) (*idwrap.IDWrap, *idwrap.IDWrap, error) <span class="cov8" title="1">{
        // Get ordered list of items in the same parent context
        orderedItems, err := r.queries.GetCollectionItemsInOrder(ctx, gen.GetCollectionItemsInOrderParams{
                CollectionID:   collectionID,
                ParentFolderID: parentFolderID,
                CollectionID_2: collectionID,
        })
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get collection items in order: %w", err)
        }</span>

        <span class="cov8" title="1">var newPrev, newNext *idwrap.IDWrap

        if len(orderedItems) == 0 </span><span class="cov8" title="1">{
                // First item in this parent context
                newPrev = nil
                newNext = nil
        }</span> else<span class="cov8" title="1"> if position &lt;= 0 </span><span class="cov0" title="0">{
                // Insert at head
                newPrev = nil
                if len(orderedItems) &gt; 0 </span><span class="cov0" title="0">{
                        nextID := idwrap.NewFromBytesMust(orderedItems[0].ID)
                        newNext = &amp;nextID
                }</span>
        } else<span class="cov8" title="1"> if position &gt;= len(orderedItems) </span><span class="cov8" title="1">{
                // Insert at tail
                if len(orderedItems) &gt; 0 </span><span class="cov8" title="1">{
                        prevID := idwrap.NewFromBytesMust(orderedItems[len(orderedItems)-1].ID)
                        newPrev = &amp;prevID
                }</span>
                <span class="cov8" title="1">newNext = nil</span>
        } else<span class="cov0" title="0"> {
                // Insert in middle
                prevID := idwrap.NewFromBytesMust(orderedItems[position-1].ID)
                nextID := idwrap.NewFromBytesMust(orderedItems[position].ID)
                newPrev = &amp;prevID
                newNext = &amp;nextID
        }</span>

        <span class="cov8" title="1">return newPrev, newNext, nil</span>
}

// InsertNewItemAtPosition inserts a new collection item directly at the specified position
// This is the correct method to use for new items (replaces InsertCollectionItem + InsertAtPosition pattern)
func (r *CollectionItemsMovableRepository) InsertNewItemAtPosition(ctx context.Context, tx *sql.Tx, params gen.InsertCollectionItemParams, position int) error <span class="cov8" title="1">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov8" title="1">{
                repo = r.TX(tx)
        }</span>

        // Calculate correct prev/next positions
        <span class="cov8" title="1">newPrev, newNext, err := repo.CalculateInsertPosition(ctx, params.CollectionID, params.ParentFolderID, position)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to calculate insert position: %w", err)
        }</span>

        // Set the calculated prev/next values
        <span class="cov8" title="1">params.PrevID = newPrev
        params.NextID = newNext

        // Insert the item with correct positioning
        err = repo.queries.InsertCollectionItem(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert collection item: %w", err)
        }</span>

        // Now update existing items to link to the new item
        <span class="cov8" title="1">if newPrev != nil </span><span class="cov8" title="1">{
                // Get the previous item to preserve its PrevID
                prevItem, err := repo.queries.GetCollectionItem(ctx, *newPrev)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get previous item: %w", err)
                }</span>
                
                // Update the previous item to point to the new item
                <span class="cov8" title="1">err = repo.queries.UpdateCollectionItemOrder(ctx, gen.UpdateCollectionItemOrderParams{
                        PrevID: prevItem.PrevID, // Keep existing PrevID
                        NextID: &amp;params.ID,      // Point to new item
                        ID:     *newPrev,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update previous item: %w", err)
                }</span>
        }

        <span class="cov8" title="1">if newNext != nil </span><span class="cov0" title="0">{
                // Get the next item to preserve its NextID
                nextItem, err := repo.queries.GetCollectionItem(ctx, *newNext)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get next item: %w", err)
                }</span>
                
                // Update the next item to point back to the new item
                <span class="cov0" title="0">err = repo.queries.UpdateCollectionItemOrder(ctx, gen.UpdateCollectionItemOrderParams{
                        PrevID: &amp;params.ID,      // Point back to new item
                        NextID: nextItem.NextID, // Keep existing NextID
                        ID:     *newNext,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update next item: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// DEPRECATED: InsertAtPosition should not be used for new items - use InsertNewItemAtPosition instead
// This method is kept for backward compatibility but should be avoided for new item insertion
// InsertAtPosition inserts a collection item at a specific position in the linked list
// This is a helper method for operations that need to insert new items
func (r *CollectionItemsMovableRepository) InsertAtPosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap, collectionID idwrap.IDWrap, parentFolderID *idwrap.IDWrap, position int) error <span class="cov8" title="1">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov8" title="1">{
                repo = r.TX(tx)
        }</span>

        // Get ordered list of items in the same parent context
        <span class="cov8" title="1">orderedItems, err := repo.queries.GetCollectionItemsInOrder(ctx, gen.GetCollectionItemsInOrderParams{
                CollectionID:   collectionID,
                ParentFolderID: parentFolderID,
                CollectionID_2: collectionID,
        })
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get collection items in order: %w", err)
        }</span>

        <span class="cov8" title="1">var newPrev, newNext *idwrap.IDWrap

        if len(orderedItems) == 0 </span><span class="cov0" title="0">{
                // First item in this parent context
                newPrev = nil
                newNext = nil
        }</span> else<span class="cov8" title="1"> if position == 0 </span><span class="cov8" title="1">{
                // Insert at head
                newPrev = nil
                if len(orderedItems) &gt; 0 </span><span class="cov8" title="1">{
                        nextID := idwrap.NewFromBytesMust(orderedItems[0].ID)
                        newNext = &amp;nextID

                        // Update the current head to point back to new item
                        // Keep the current head's existing NextID
                        currentHeadNextID := convertBytesToIDWrap(orderedItems[0].NextID)
                        err = repo.queries.UpdateCollectionItemOrder(ctx, gen.UpdateCollectionItemOrderParams{
                                PrevID: &amp;itemID,
                                NextID: currentHeadNextID,
                                ID:     nextID,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update current head: %w", err)
                        }</span>
                }
        } else<span class="cov8" title="1"> if position &gt;= len(orderedItems) </span><span class="cov8" title="1">{
                // Insert at tail
                if len(orderedItems) &gt; 0 </span><span class="cov8" title="1">{
                        prevID := idwrap.NewFromBytesMust(orderedItems[len(orderedItems)-1].ID)
                        newPrev = &amp;prevID

                        // Update the current tail to point forward to new item
                        // Keep the current tail's existing PrevID
                        currentTailPrevID := convertBytesToIDWrap(orderedItems[len(orderedItems)-1].PrevID)
                        err = repo.queries.UpdateCollectionItemOrder(ctx, gen.UpdateCollectionItemOrderParams{
                                PrevID: currentTailPrevID,
                                NextID: &amp;itemID,
                                ID:     prevID,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update current tail: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">newNext = nil</span>
        } else<span class="cov0" title="0"> {
                // Insert in middle
                prevID := idwrap.NewFromBytesMust(orderedItems[position-1].ID)
                nextID := idwrap.NewFromBytesMust(orderedItems[position].ID)
                newPrev = &amp;prevID
                newNext = &amp;nextID

                // Update prev item to point to new item
                // Keep the prev item's existing PrevID
                prevItemPrevID := convertBytesToIDWrap(orderedItems[position-1].PrevID)
                err = repo.queries.UpdateCollectionItemOrder(ctx, gen.UpdateCollectionItemOrderParams{
                        PrevID: prevItemPrevID,
                        NextID: &amp;itemID,
                        ID:     prevID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update prev item: %w", err)
                }</span>

                // Update next item to point back to new item
                // Keep the next item's existing NextID
                <span class="cov0" title="0">nextItemNextID := convertBytesToIDWrap(orderedItems[position].NextID)
                err = repo.queries.UpdateCollectionItemOrder(ctx, gen.UpdateCollectionItemOrderParams{
                        PrevID: &amp;itemID,
                        NextID: nextItemNextID,
                        ID:     nextID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update next item: %w", err)
                }</span>
        }

        // Set the new item's position (this assumes the item was already inserted via InsertCollectionItem)
        <span class="cov8" title="1">return repo.queries.UpdateCollectionItemOrder(ctx, gen.UpdateCollectionItemOrderParams{
                PrevID: newPrev,
                NextID: newNext,
                ID:     itemID,
        })</span>
}

// RemoveFromPosition removes a collection item from its current position in the linked list
// This is a helper method for operations that need to remove items
func (r *CollectionItemsMovableRepository) RemoveFromPosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap) error <span class="cov8" title="1">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov8" title="1">{
                repo = r.TX(tx)
        }</span>

        // Get the collection item to remove
        <span class="cov8" title="1">item, err := repo.queries.GetCollectionItem(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get collection item: %w", err)
        }</span>

        // Get ordered items to find prev and next
        <span class="cov8" title="1">orderedItems, err := repo.getOrderedItemsInSameParent(ctx, item)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get collection items in order: %w", err)
        }</span>

        // Find the item and its neighbors
        <span class="cov8" title="1">var prevID, nextID *idwrap.IDWrap
        for i, orderItem := range orderedItems </span><span class="cov8" title="1">{
                if idwrap.NewFromBytesMust(orderItem.ID).Compare(itemID) == 0 </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                prev := idwrap.NewFromBytesMust(orderedItems[i-1].ID)
                                prevID = &amp;prev
                        }</span>
                        <span class="cov8" title="1">if i &lt; len(orderedItems)-1 </span><span class="cov8" title="1">{
                                next := idwrap.NewFromBytesMust(orderedItems[i+1].ID)
                                nextID = &amp;next
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
        }

        // Update prev item's next pointer to skip the removed item
        <span class="cov8" title="1">if prevID != nil </span><span class="cov0" title="0">{
                // Get the prev item's current prev pointer to preserve it
                for _, orderItem := range orderedItems </span><span class="cov0" title="0">{
                        if idwrap.NewFromBytesMust(orderItem.ID).Compare(*prevID) == 0 </span><span class="cov0" title="0">{
                                var currentPrev *idwrap.IDWrap
                                if len(orderItem.PrevID) &gt; 0 </span><span class="cov0" title="0">{
                                        prev := idwrap.NewFromBytesMust(orderItem.PrevID)
                                        currentPrev = &amp;prev
                                }</span>

                                <span class="cov0" title="0">err = repo.queries.UpdateCollectionItemOrder(ctx, gen.UpdateCollectionItemOrderParams{
                                        PrevID: currentPrev, // Preserve the prev item's own prev pointer
                                        NextID: nextID,      // Point to the item after the removed one
                                        ID:     *prevID,
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to update prev item: %w", err)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
        }

        // Update next item's prev pointer to skip the removed item
        <span class="cov8" title="1">if nextID != nil </span><span class="cov8" title="1">{
                // Get the next item's current next pointer to preserve it
                for _, orderItem := range orderedItems </span><span class="cov8" title="1">{
                        if idwrap.NewFromBytesMust(orderItem.ID).Compare(*nextID) == 0 </span><span class="cov8" title="1">{
                                var currentNext *idwrap.IDWrap
                                if len(orderItem.NextID) &gt; 0 </span><span class="cov0" title="0">{
                                        next := idwrap.NewFromBytesMust(orderItem.NextID)
                                        currentNext = &amp;next
                                }</span>

                                <span class="cov8" title="1">err = repo.queries.UpdateCollectionItemOrder(ctx, gen.UpdateCollectionItemOrderParams{
                                        PrevID: prevID,      // Point to the item before the removed one
                                        NextID: currentNext, // Preserve the next item's own next pointer
                                        ID:     *nextID,
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to update next item: %w", err)
                                }</span>
                                <span class="cov8" title="1">break</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package scollectionitem

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mitemapi"
        "the-dev-tools/server/pkg/model/mitemfolder"
        "the-dev-tools/server/pkg/movable"
        "the-dev-tools/server/pkg/service/sitemapi"
        "the-dev-tools/server/pkg/service/sitemfolder"
        "github.com/oklog/ulid/v2"
)

// CollectionItemService provides operations for managing collection items using the simplified reference-based architecture
// where collection_items is the PRIMARY table containing ordering logic, and legacy tables reference it via FK.
type CollectionItemService struct {
        queries           *gen.Queries
        repository        *CollectionItemsMovableRepository
        folderService     sitemfolder.ItemFolderService
        apiService        sitemapi.ItemApiService
        logger            *slog.Logger
}

// CollectionItemType represents the type of collection item
type CollectionItemType int8

const (
        CollectionItemTypeFolder   CollectionItemType = 0
        CollectionItemTypeEndpoint CollectionItemType = 1
)

// CollectionItem represents a unified collection item with type-specific data
type CollectionItem struct {
        ID             idwrap.IDWrap
        CollectionID   idwrap.IDWrap
        ParentFolderID *idwrap.IDWrap
        Name           string
        ItemType       CollectionItemType
        URL            *string // Only for endpoints
        Method         *string // Only for endpoints
        PrevID         *idwrap.IDWrap
        NextID         *idwrap.IDWrap
        // Reference IDs to legacy tables
        FolderID   *idwrap.IDWrap
        EndpointID *idwrap.IDWrap
}

var (
        ErrCollectionItemNotFound = fmt.Errorf("collection item not found")
        ErrInvalidItemType        = fmt.Errorf("invalid item type")
        ErrPositionOutOfRange     = fmt.Errorf("position out of range")
        ErrInvalidTargetPosition  = fmt.Errorf("invalid target position")
        ErrCrossWorkspaceMove     = fmt.Errorf("cannot move items between different workspaces")
        ErrTargetCollectionNotFound = fmt.Errorf("target collection not found")
)

// New creates a new CollectionItemService
func New(queries *gen.Queries, logger *slog.Logger) *CollectionItemService <span class="cov8" title="1">{
        return &amp;CollectionItemService{
                queries:       queries,
                repository:    NewCollectionItemsMovableRepository(queries),
                folderService: sitemfolder.New(queries),
                apiService:    sitemapi.New(queries),
                logger:        logger,
        }
}</span>

// TX returns a new service instance with transaction support
func (s *CollectionItemService) TX(tx *sql.Tx) *CollectionItemService <span class="cov8" title="1">{
        return &amp;CollectionItemService{
                queries:       s.queries.WithTx(tx),
                repository:    s.repository.TX(tx),
                folderService: s.folderService.TX(tx),
                apiService:    s.apiService.TX(tx),
                logger:        s.logger,
        }
}</span>

// NewTX creates a new service instance with prepared transaction queries
func NewTX(ctx context.Context, tx *sql.Tx, logger *slog.Logger) (*CollectionItemService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to prepare transaction queries: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;CollectionItemService{
                queries:       queries,
                repository:    NewCollectionItemsMovableRepository(queries),
                folderService: sitemfolder.New(queries),
                apiService:    sitemapi.New(queries),
                logger:        logger,
        }, nil</span>
}

// ListCollectionItems retrieves all collection items in a parent context, ordered by position
// This reads from the collection_items table only for core data and ordering
func (s *CollectionItemService) ListCollectionItems(ctx context.Context, collectionID idwrap.IDWrap, parentFolderID *idwrap.IDWrap) ([]CollectionItem, error) <span class="cov8" title="1">{
        s.logger.Debug("Listing collection items",
                "collection_id", collectionID.String(),
                "parent_folder_id", getIDString(parentFolderID))

        // Get items in order from the primary collection_items table
        orderedItems, err := s.queries.GetCollectionItemsInOrder(ctx, gen.GetCollectionItemsInOrderParams{
                CollectionID:   collectionID,
                ParentFolderID: parentFolderID,
                CollectionID_2: collectionID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        s.logger.Debug("No collection items found")
                        return []CollectionItem{}, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get collection items in order: %w", err)</span>
        }

        // Convert to CollectionItem structs
        <span class="cov8" title="1">items := make([]CollectionItem, len(orderedItems))
        for i, item := range orderedItems </span><span class="cov8" title="1">{
                items[i] = CollectionItem{
                        ID:             idwrap.NewFromBytesMust(item.ID),
                        CollectionID:   collectionID,
                        ParentFolderID: parentFolderID,
                        Name:           item.Name,
                        ItemType:       CollectionItemType(item.ItemType),
                        URL:            nil, // Note: URL and Method not available in GetCollectionItemsInOrderRow
                        Method:         nil, // Would need separate query to get these from legacy tables
                        PrevID:         convertBytesToIDWrap(item.PrevID),
                        NextID:         convertBytesToIDWrap(item.NextID),
                        FolderID:       convertBytesToIDWrap(item.FolderID),
                        EndpointID:     convertBytesToIDWrap(item.EndpointID),
                }
        }</span>

        <span class="cov8" title="1">s.logger.Debug("Successfully retrieved collection items", "count", len(items))
        return items, nil</span>
}

// MoveCollectionItemToFolder moves a collection item to a specific parent folder with optional positioning
// This method supports both intra-collection moves and cross-collection moves
// If targetCollectionID is provided, it performs a cross-collection move
func (s *CollectionItemService) MoveCollectionItemToFolder(ctx context.Context, itemID idwrap.IDWrap, targetParentFolderID *idwrap.IDWrap, targetItemID *idwrap.IDWrap, position movable.MovePosition, targetCollectionID *idwrap.IDWrap) error <span class="cov0" title="0">{
        s.logger.Debug("Moving collection item to specific parent folder",
                "item_id", itemID.String(),
                "target_parent_folder_id", getIDString(targetParentFolderID),
                "target_item_id", getIDString(targetItemID),
                "target_collection_id", getIDString(targetCollectionID),
                "position", position)

        // Get the item to validate it exists
        item, err := s.queries.GetCollectionItem(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return ErrCollectionItemNotFound
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get collection item: %w", err)</span>
        }

        // Check if this is a cross-collection move
        <span class="cov0" title="0">if targetCollectionID != nil &amp;&amp; item.CollectionID.Compare(*targetCollectionID) != 0 </span><span class="cov0" title="0">{
                s.logger.Debug("Detected cross-collection move, delegating to cross-collection method")
                return s.MoveCollectionItemCrossCollection(ctx, itemID, *targetCollectionID, targetParentFolderID, targetItemID, position)
        }</span>

        // Determine the effective target collection (use current collection if not specified)
        <span class="cov0" title="0">effectiveTargetCollectionID := item.CollectionID
        if targetCollectionID != nil </span><span class="cov0" title="0">{
                effectiveTargetCollectionID = *targetCollectionID
        }</span>

        // Validate target parent folder if specified
        <span class="cov0" title="0">if targetParentFolderID != nil </span><span class="cov0" title="0">{
                targetParentItem, err := s.queries.GetCollectionItem(ctx, *targetParentFolderID)
                if err != nil </span><span class="cov0" title="0">{
                        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                                return fmt.Errorf("target parent folder not found")
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to get target parent folder: %w", err)</span>
                }
                
                // Ensure target parent is actually a folder
                <span class="cov0" title="0">if targetParentItem.ItemType != int8(CollectionItemTypeFolder) </span><span class="cov0" title="0">{
                        return fmt.Errorf("target parent must be a folder")
                }</span>
                
                // Validate target parent is in the effective target collection
                <span class="cov0" title="0">if targetParentItem.CollectionID.Compare(effectiveTargetCollectionID) != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("target parent folder must be in the target collection")
                }</span>
        }

        // Validate target item if specified
        <span class="cov0" title="0">if targetItemID != nil </span><span class="cov0" title="0">{
                targetItem, err := s.queries.GetCollectionItem(ctx, *targetItemID)
                if err != nil </span><span class="cov0" title="0">{
                        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                                return fmt.Errorf("target item not found")
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to get target item: %w", err)</span>
                }
                
                // Validate target item is in the effective target collection
                <span class="cov0" title="0">if targetItem.CollectionID.Compare(effectiveTargetCollectionID) != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("target item must be in the target collection")
                }</span>
                
                // Ensure target item is in the target parent folder context
                <span class="cov0" title="0">if (targetItem.ParentFolderID == nil) != (targetParentFolderID == nil) </span><span class="cov0" title="0">{
                        return fmt.Errorf("target item must be in the same parent context as the target parent folder")
                }</span>
                <span class="cov0" title="0">if targetItem.ParentFolderID != nil &amp;&amp; targetParentFolderID != nil </span><span class="cov0" title="0">{
                        if targetItem.ParentFolderID.Compare(*targetParentFolderID) != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("target item must be in the same parent context as the target parent folder")
                        }</span>
                }
        }

        // Prevent moving item relative to itself
        <span class="cov0" title="0">if targetItemID != nil &amp;&amp; itemID.Compare(*targetItemID) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot move item relative to itself")
        }</span>

        // Check if this is actually a cross-folder move
        <span class="cov0" title="0">isCrossFolderMove := false
        if (item.ParentFolderID == nil) != (targetParentFolderID == nil) </span><span class="cov0" title="0">{
                isCrossFolderMove = true
        }</span> else<span class="cov0" title="0"> if item.ParentFolderID != nil &amp;&amp; targetParentFolderID != nil </span><span class="cov0" title="0">{
                if item.ParentFolderID.Compare(*targetParentFolderID) != 0 </span><span class="cov0" title="0">{
                        isCrossFolderMove = true
                }</span>
        }

        <span class="cov0" title="0">s.logger.Debug("Move to folder analysis",
                "item_id", itemID.String(),
                "item_parent", getIDString(item.ParentFolderID),
                "target_parent", getIDString(targetParentFolderID),
                "is_cross_folder_move", isCrossFolderMove)

        if isCrossFolderMove </span><span class="cov0" title="0">{
                // Cross-folder move: need to update parent_folder_id and handle two different lists
                return s.performCrossFolderMove(ctx, itemID, item, targetItemID, targetParentFolderID, position)
        }</span> else<span class="cov0" title="0"> {
                // Same-folder move: use existing logic
                return s.performSameFolderMove(ctx, itemID, item, targetItemID, position)
        }</span>
}

// MoveCollectionItem moves a collection item to a new position, supporting cross-folder moves
// Updates prev/next pointers and parent_folder_id in the collection_items table
func (s *CollectionItemService) MoveCollectionItem(ctx context.Context, itemID idwrap.IDWrap, targetID *idwrap.IDWrap, position movable.MovePosition) error <span class="cov8" title="1">{
        s.logger.Debug("Moving collection item",
                "item_id", itemID.String(),
                "target_id", getIDString(targetID),
                "position", position)

        // Get the item to validate it exists
        item, err := s.queries.GetCollectionItem(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return ErrCollectionItemNotFound
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get collection item: %w", err)</span>
        }

        // Validate target exists if specified and determine target parent context
        <span class="cov8" title="1">var targetItem *gen.CollectionItem
        var targetParentFolderID *idwrap.IDWrap
        if targetID != nil </span><span class="cov8" title="1">{
                target, err := s.queries.GetCollectionItem(ctx, *targetID)
                if err != nil </span><span class="cov0" title="0">{
                        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                                return fmt.Errorf("target item not found")
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to get target item: %w", err)</span>
                }
                <span class="cov8" title="1">targetItem = &amp;target
                
                // Validate items are in same collection (still required)
                if item.CollectionID.Compare(targetItem.CollectionID) != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("items must be in same collection")
                }</span>
                
                // Determine target parent context based on move semantics:
                // We need to distinguish between two cases when target is a folder:
                // 1. "Drop into folder" - move item to be inside the target folder
                // 2. "Position relative to folder" - position item before/after folder at the same level
                
                
                <span class="cov8" title="1">if targetItem.ItemType == int8(CollectionItemTypeFolder) </span><span class="cov8" title="1">{
                        targetFolderID := idwrap.NewFromBytesMust(targetItem.ID.Bytes())
                        
                        // Check if item is already inside the target folder
                        itemAlreadyInTargetFolder := item.ParentFolderID != nil &amp;&amp; 
                                item.ParentFolderID.Compare(targetFolderID) == 0
                        
                        
                        if itemAlreadyInTargetFolder </span><span class="cov0" title="0">{
                                // Item is already in the target folder and we're targeting that folder.
                                // This means "move this item to be positioned relative to the folder itself"
                                // i.e., move OUT of the folder to the same level as the folder.
                                targetParentFolderID = targetItem.ParentFolderID
                                s.logger.Debug("Item in target folder, moving out to folder's level")
                        }</span> else<span class="cov8" title="1"> {
                                // Item is NOT currently in the target folder
                                // 
                                // Key insight: When targeting a folder with BEFORE/AFTER position,
                                // the item should be positioned at the SAME LEVEL as the target folder,
                                // regardless of where the item currently is.
                                // This provides consistent behavior for positioning operations.
                                
                                targetParentFolderID = targetItem.ParentFolderID
                                s.logger.Debug("Position relative to target folder level")
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Target is not a folder: use target's parent context (normal positioning)
                        targetParentFolderID = targetItem.ParentFolderID
                }</span>
        } else<span class="cov0" title="0"> {
                // No target specified - use current parent context
                targetParentFolderID = item.ParentFolderID
        }</span>

        // Check if this is a cross-folder move (parent folder change)
        <span class="cov8" title="1">isCrossFolderMove := false
        if (item.ParentFolderID == nil) != (targetParentFolderID == nil) </span><span class="cov0" title="0">{
                isCrossFolderMove = true
        }</span> else<span class="cov8" title="1"> if item.ParentFolderID != nil &amp;&amp; targetParentFolderID != nil </span><span class="cov0" title="0">{
                if item.ParentFolderID.Compare(*targetParentFolderID) != 0 </span><span class="cov0" title="0">{
                        isCrossFolderMove = true
                }</span>
        }

        <span class="cov8" title="1">s.logger.Debug("Move operation analysis",
                "item_id", itemID.String(),
                "target_id", getIDString(targetID),
                "item_parent", getIDString(item.ParentFolderID),
                "target_parent", getIDString(targetParentFolderID),
                "target_item_type", func() string </span><span class="cov8" title="1">{
                        if targetItem != nil </span><span class="cov8" title="1">{
                                return fmt.Sprintf("type_%d", targetItem.ItemType)
                        }</span>
                        <span class="cov0" title="0">return "nil"</span>
                }(),
                "is_cross_folder_move", isCrossFolderMove)


        <span class="cov8" title="1">if isCrossFolderMove </span><span class="cov0" title="0">{
                // Cross-folder move: need to update parent_folder_id and handle two different lists
                return s.performCrossFolderMove(ctx, itemID, item, targetID, targetParentFolderID, position)
        }</span> else<span class="cov8" title="1"> {
                // Same-folder move: use existing logic
                return s.performSameFolderMove(ctx, itemID, item, targetID, position)
        }</span>
}

// CreateFolderTX creates a folder using the reference-based architecture
// 1. Creates collection_items entry (type=0, name, prev/next positioning)
// 2. Creates item_folder entry with collection_item_id FK
// 3. Single transaction ensures consistency
func (s *CollectionItemService) CreateFolderTX(ctx context.Context, tx *sql.Tx, folder *mitemfolder.ItemFolder) error <span class="cov8" title="1">{
        s.logger.Debug("Creating folder with collection item reference",
                "folder_id", folder.ID.String(),
                "collection_id", folder.CollectionID.String(),
                "name", folder.Name)

        // Get service with transaction support
        txService := s.TX(tx)

        // Find position to insert (append to end by default)
        maxPosition, err := txService.repository.GetMaxPosition(ctx, folder.CollectionID, movable.CollectionListTypeItems)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get max position: %w", err)
        }</span>
        
        <span class="cov8" title="1">insertPosition := 0
        if maxPosition &gt;= 0 </span><span class="cov8" title="1">{
                insertPosition = maxPosition + 1
        }</span>

        // Step 1: Create item_folder entry (LEGACY TABLE) first to satisfy foreign key constraints
        <span class="cov8" title="1">err = txService.folderService.CreateItemFolder(ctx, folder)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create folder reference: %w", err)
        }</span>

        // Step 2: Create collection_items entry (PRIMARY) with correct linked list position
        // Now we can safely reference folder.ID since it exists in item_folder table
        <span class="cov8" title="1">collectionItemID := idwrap.New(ulid.Make())
        err = txService.repository.InsertNewItemAtPosition(ctx, tx, gen.InsertCollectionItemParams{
                ID:             collectionItemID,
                CollectionID:   folder.CollectionID,
                ParentFolderID: folder.ParentID,
                ItemType:       int8(CollectionItemTypeFolder),
                FolderID:       &amp;folder.ID, // Reference to legacy folder table (now exists)
                EndpointID:     nil,
                Name:           folder.Name,
                PrevID:         nil, // Will be calculated by InsertNewItemAtPosition
                NextID:         nil, // Will be calculated by InsertNewItemAtPosition
        }, insertPosition)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert collection item at position: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Debug("Successfully created folder with collection item reference",
                "folder_id", folder.ID.String(),
                "collection_item_id", collectionItemID.String())
        return nil</span>
}

// CreateEndpointTX creates an endpoint using the reference-based architecture  
// 1. Creates collection_items entry (type=1, name, url, method, prev/next positioning)
// 2. Creates item_api entry with collection_item_id FK
// 3. Single transaction ensures consistency
func (s *CollectionItemService) CreateEndpointTX(ctx context.Context, tx *sql.Tx, endpoint *mitemapi.ItemApi) error <span class="cov8" title="1">{
        s.logger.Debug("Creating endpoint with collection item reference",
                "endpoint_id", endpoint.ID.String(),
                "collection_id", endpoint.CollectionID.String(),
                "name", endpoint.Name,
                "url", endpoint.Url,
                "method", endpoint.Method)

        // Get service with transaction support
        txService := s.TX(tx)

        // Find position to insert (append to end by default)
        maxPosition, err := txService.repository.GetMaxPosition(ctx, endpoint.CollectionID, movable.CollectionListTypeItems)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get max position: %w", err)
        }</span>
        
        <span class="cov8" title="1">insertPosition := 0
        if maxPosition &gt;= 0 </span><span class="cov8" title="1">{
                insertPosition = maxPosition + 1
        }</span>

        // Step 1: Create item_api entry (LEGACY TABLE) first to satisfy foreign key constraints
        <span class="cov8" title="1">err = txService.apiService.CreateItemApi(ctx, endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create endpoint reference: %w", err)
        }</span>

        // Step 2: Create collection_items entry (PRIMARY) with correct linked list position
        // Now we can safely reference endpoint.ID since it exists in item_api table
        <span class="cov8" title="1">collectionItemID := idwrap.New(ulid.Make())
        err = txService.repository.InsertNewItemAtPosition(ctx, tx, gen.InsertCollectionItemParams{
                ID:             collectionItemID,
                CollectionID:   endpoint.CollectionID,
                ParentFolderID: endpoint.FolderID,
                ItemType:       int8(CollectionItemTypeEndpoint),
                FolderID:       nil,
                EndpointID:     &amp;endpoint.ID, // Reference to legacy endpoint table (now exists)
                Name:           endpoint.Name,
                PrevID:         nil, // Will be calculated by InsertNewItemAtPosition
                NextID:         nil, // Will be calculated by InsertNewItemAtPosition
        }, insertPosition)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert collection item at position: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Debug("Successfully created endpoint with collection item reference",
                "endpoint_id", endpoint.ID.String(),
                "collection_item_id", collectionItemID.String())
        return nil</span>
}

// GetCollectionItem retrieves a collection item by ID
func (s *CollectionItemService) GetCollectionItem(ctx context.Context, id idwrap.IDWrap) (*CollectionItem, error) <span class="cov8" title="1">{
        item, err := s.queries.GetCollectionItem(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, ErrCollectionItemNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get collection item: %w", err)</span>
        }

        <span class="cov8" title="1">collectionItem := &amp;CollectionItem{
                ID:             item.ID,
                CollectionID:   item.CollectionID,
                ParentFolderID: item.ParentFolderID,
                Name:           item.Name,
                ItemType:       CollectionItemType(item.ItemType),
                PrevID:         item.PrevID,
                NextID:         item.NextID,
                FolderID:       item.FolderID,
                EndpointID:     item.EndpointID,
        }

        return collectionItem, nil</span>
}

// DeleteCollectionItem removes a collection item and its linked list connections
func (s *CollectionItemService) DeleteCollectionItem(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap) error <span class="cov8" title="1">{
        s.logger.Debug("Deleting collection item", "item_id", itemID.String())

        // Get service with transaction support
        txService := s.TX(tx)

        // Remove from linked list position first
        err := txService.repository.RemoveFromPosition(ctx, tx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove from position: %w", err)
        }</span>

        // Delete the collection item
        <span class="cov8" title="1">err = txService.queries.DeleteCollectionItem(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete collection item: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Debug("Successfully deleted collection item", "item_id", itemID.String())
        return nil</span>
}

// Utility functions for type conversion

func convertBytesToIDWrap(bytes []byte) *idwrap.IDWrap <span class="cov8" title="1">{
        if len(bytes) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">id := idwrap.NewFromBytesMust(bytes)
        return &amp;id</span>
}

func convertByteToString(bytes []byte) *string <span class="cov0" title="0">{
        if len(bytes) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">str := string(bytes)
        return &amp;str</span>
}

func getIDString(id *idwrap.IDWrap) string <span class="cov8" title="1">{
        if id == nil </span><span class="cov8" title="1">{
                return "nil"
        }</span>
        <span class="cov8" title="1">return id.String()</span>
}

// GetWorkspaceID retrieves the workspace ID for a collection item
func (s *CollectionItemService) GetWorkspaceID(ctx context.Context, itemID idwrap.IDWrap) (idwrap.IDWrap, error) <span class="cov8" title="1">{
        item, err := s.queries.GetCollectionItem(ctx, itemID)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return idwrap.IDWrap{}, ErrCollectionItemNotFound
                }</span>
                <span class="cov0" title="0">return idwrap.IDWrap{}, fmt.Errorf("failed to get collection item: %w", err)</span>
        }

        // Get workspace ID through collection
        <span class="cov8" title="1">collection, err := s.queries.GetCollection(ctx, item.CollectionID)
        if err != nil </span><span class="cov0" title="0">{
                return idwrap.IDWrap{}, fmt.Errorf("failed to get collection: %w", err)
        }</span>

        <span class="cov8" title="1">return collection.WorkspaceID, nil</span>
}

// CheckWorkspaceID verifies if a collection item belongs to a specific workspace
func (s *CollectionItemService) CheckWorkspaceID(ctx context.Context, itemID, workspaceID idwrap.IDWrap) (bool, error) <span class="cov8" title="1">{
        itemWorkspaceID, err := s.GetWorkspaceID(ctx, itemID)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">return itemWorkspaceID.Compare(workspaceID) == 0, nil</span>
}

// GetCollectionItemIDByLegacyID converts a legacy table ID (folder_id or endpoint_id) to collection_items table ID
// This is needed for backward compatibility with move operations that receive legacy IDs
func (s *CollectionItemService) GetCollectionItemIDByLegacyID(ctx context.Context, legacyID idwrap.IDWrap) (idwrap.IDWrap, error) <span class="cov0" title="0">{
        s.logger.Debug("Converting legacy ID to collection_items ID", "legacy_id", legacyID.String())
        
        // Try to find by folder_id first
        folderItem, err := s.queries.GetCollectionItemByFolderID(ctx, &amp;legacyID)
        if err == nil </span><span class="cov0" title="0">{
                s.logger.Debug("Found collection item by folder_id", 
                        "legacy_id", legacyID.String(),
                        "collection_item_id", folderItem.ID.String())
                return folderItem.ID, nil
        }</span>
        
        // If not found by folder_id, try endpoint_id
        <span class="cov0" title="0">if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                endpointItem, err := s.queries.GetCollectionItemByEndpointID(ctx, &amp;legacyID)
                if err == nil </span><span class="cov0" title="0">{
                        s.logger.Debug("Found collection item by endpoint_id", 
                                "legacy_id", legacyID.String(),
                                "collection_item_id", endpointItem.ID.String())
                        return endpointItem.ID, nil
                }</span>
                
                <span class="cov0" title="0">if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        s.logger.Debug("Legacy ID not found in collection_items table", "legacy_id", legacyID.String())
                        return idwrap.IDWrap{}, ErrCollectionItemNotFound
                }</span>
                
                <span class="cov0" title="0">return idwrap.IDWrap{}, fmt.Errorf("failed to get collection item by endpoint_id: %w", err)</span>
        }
        
        <span class="cov0" title="0">return idwrap.IDWrap{}, fmt.Errorf("failed to get collection item by folder_id: %w", err)</span>
}

// moveItemToPosition performs a simple move by rebuilding the entire linked list
// This approach is less efficient but much more reliable than complex pointer manipulation
func (s *CollectionItemService) moveItemToPosition(ctx context.Context, itemID idwrap.IDWrap, orderedItems []gen.GetCollectionItemsInOrderRow, fromPos, toPos int) error <span class="cov8" title="1">{
        if fromPos == toPos </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Create a new order by moving the item from fromPos to toPos
        <span class="cov8" title="1">newOrder := make([]idwrap.IDWrap, len(orderedItems))
        movingItem := idwrap.NewFromBytesMust(orderedItems[fromPos].ID)
        
        // Build new order: copy items skipping the moving item, insert moving item at toPos
        newIdx := 0
        movingItemInserted := false
        
        for i, item := range orderedItems </span><span class="cov8" title="1">{
                if i == fromPos </span><span class="cov8" title="1">{
                        continue</span> // Skip the moving item
                }
                
                // Check if we should insert the moving item before this position
                <span class="cov8" title="1">if newIdx == toPos &amp;&amp; !movingItemInserted </span><span class="cov8" title="1">{
                        newOrder[newIdx] = movingItem
                        newIdx++
                        movingItemInserted = true
                }</span>
                
                <span class="cov8" title="1">newOrder[newIdx] = idwrap.NewFromBytesMust(item.ID)
                newIdx++</span>
        }
        
        // If we haven't inserted the moving item yet, it goes at the end
        <span class="cov8" title="1">if !movingItemInserted </span><span class="cov0" title="0">{
                newOrder[len(newOrder)-1] = movingItem
        }</span>

        // Rebuild the linked list with the new order
        <span class="cov8" title="1">return s.rebuildLinkedList(ctx, newOrder)</span>
}

// rebuildLinkedList rebuilds the linked list structure for the given ordered items
func (s *CollectionItemService) rebuildLinkedList(ctx context.Context, orderedIDs []idwrap.IDWrap) error <span class="cov8" title="1">{
        for i, itemID := range orderedIDs </span><span class="cov8" title="1">{
                var prevID, nextID *idwrap.IDWrap
                
                if i &gt; 0 </span><span class="cov8" title="1">{
                        prevID = &amp;orderedIDs[i-1]
                }</span>
                <span class="cov8" title="1">if i &lt; len(orderedIDs)-1 </span><span class="cov8" title="1">{
                        nextID = &amp;orderedIDs[i+1]
                }</span>
                
                <span class="cov8" title="1">err := s.queries.UpdateCollectionItemOrder(ctx, gen.UpdateCollectionItemOrderParams{
                        PrevID: prevID,
                        NextID: nextID,
                        ID:     itemID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update item %s: %w", itemID.String(), err)
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

// performCrossFolderMove handles moving an item from one parent folder context to another
func (s *CollectionItemService) performCrossFolderMove(ctx context.Context, itemID idwrap.IDWrap, item gen.CollectionItem, targetID *idwrap.IDWrap, newParentFolderID *idwrap.IDWrap, position movable.MovePosition) error <span class="cov0" title="0">{
        s.logger.Debug("Performing cross-folder move",
                "item_id", itemID.String(),
                "from_parent", getIDString(item.ParentFolderID),
                "to_parent", getIDString(newParentFolderID),
                "target_id", getIDString(targetID))

        // Step 1: Remove item from current parent's linked list
        currentParentItems, err := s.queries.GetCollectionItemsInOrder(ctx, gen.GetCollectionItemsInOrderParams{
                CollectionID:   item.CollectionID,
                ParentFolderID: item.ParentFolderID,
                CollectionID_2: item.CollectionID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current parent items: %w", err)
        }</span>

        // Find current position and remove from list
        <span class="cov0" title="0">currentPos := -1
        for i, orderedItem := range currentParentItems </span><span class="cov0" title="0">{
                orderItemID := idwrap.NewFromBytesMust(orderedItem.ID)
                if orderItemID.Compare(itemID) == 0 </span><span class="cov0" title="0">{
                        currentPos = i
                        break</span>
                }
        }
        
        <span class="cov0" title="0">if currentPos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("item not found in current parent list")
        }</span>

        // Rebuild current parent list without the moving item
        <span class="cov0" title="0">newCurrentParentOrder := make([]idwrap.IDWrap, 0, len(currentParentItems)-1)
        for i, orderedItem := range currentParentItems </span><span class="cov0" title="0">{
                if i != currentPos </span><span class="cov0" title="0">{
                        newCurrentParentOrder = append(newCurrentParentOrder, idwrap.NewFromBytesMust(orderedItem.ID))
                }</span>
        }

        // Step 2: Get target parent's current items BEFORE changing parent_folder_id
        // This prevents the moving item from appearing in the target parent list
        <span class="cov0" title="0">targetParentItems, err := s.queries.GetCollectionItemsInOrder(ctx, gen.GetCollectionItemsInOrderParams{
                CollectionID:   item.CollectionID,
                ParentFolderID: newParentFolderID,
                CollectionID_2: item.CollectionID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get target parent items: %w", err)
        }</span>

        // Step 3: Update item's parent_folder_id
        <span class="cov0" title="0">s.logger.Debug("Updating parent_folder_id", 
                "item_id", itemID.String(), 
                "new_parent", getIDString(newParentFolderID))
        err = s.queries.UpdateCollectionItemParentFolder(ctx, gen.UpdateCollectionItemParentFolderParams{
                ParentFolderID: newParentFolderID,
                ID:             itemID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update item parent folder: %w", err)
        }</span>

        // Step 4: Calculate insertion position
        <span class="cov0" title="0">var insertPos int
        if targetID != nil </span><span class="cov0" title="0">{
                // Look for the target item within the new parent context
                targetPos := -1
                for i, orderedItem := range targetParentItems </span><span class="cov0" title="0">{
                        orderItemID := idwrap.NewFromBytesMust(orderedItem.ID)
                        if orderItemID.Compare(*targetID) == 0 </span><span class="cov0" title="0">{
                                targetPos = i
                                break</span>
                        }
                }
                
                <span class="cov0" title="0">if targetPos != -1 </span><span class="cov0" title="0">{
                        // Target found within new parent context: normal positioning relative to target
                        if position == movable.MovePositionAfter </span><span class="cov0" title="0">{
                                insertPos = targetPos + 1
                        }</span> else<span class="cov0" title="0"> {
                                insertPos = targetPos
                        }</span>
                        <span class="cov0" title="0">s.logger.Debug("Target found in new parent context, positioning relative to it", 
                                "target_pos", targetPos, "insert_pos", insertPos)</span>
                } else<span class="cov0" title="0"> {
                        // Target not found in new parent context: add to end
                        // This can happen when the target is a reference point from a different context
                        insertPos = len(targetParentItems)
                        s.logger.Debug("Target not in new parent context, adding to end", "pos", insertPos)
                }</span>
        } else<span class="cov0" title="0"> {
                // No target specified, add to end
                insertPos = len(targetParentItems)
        }</span>

        // Clamp insert position
        <span class="cov0" title="0">if insertPos &lt; 0 </span><span class="cov0" title="0">{
                insertPos = 0
        }</span>
        <span class="cov0" title="0">if insertPos &gt; len(targetParentItems) </span><span class="cov0" title="0">{
                insertPos = len(targetParentItems)
        }</span>

        // Step 5: Insert item into target parent's list at calculated position
        <span class="cov0" title="0">newTargetParentOrder := make([]idwrap.IDWrap, 0, len(targetParentItems)+1)
        for i, orderedItem := range targetParentItems </span><span class="cov0" title="0">{
                if i == insertPos </span><span class="cov0" title="0">{
                        newTargetParentOrder = append(newTargetParentOrder, itemID)
                }</span>
                <span class="cov0" title="0">newTargetParentOrder = append(newTargetParentOrder, idwrap.NewFromBytesMust(orderedItem.ID))</span>
        }
        // Handle case where item is inserted at the end
        <span class="cov0" title="0">if insertPos == len(targetParentItems) </span><span class="cov0" title="0">{
                newTargetParentOrder = append(newTargetParentOrder, itemID)
        }</span>

        // Step 6: Rebuild both linked lists
        <span class="cov0" title="0">if len(newCurrentParentOrder) &gt; 0 </span><span class="cov0" title="0">{
                s.logger.Debug("Rebuilding current parent linked list", 
                        "items_count", len(newCurrentParentOrder),
                        "items", func() []string </span><span class="cov0" title="0">{
                                strs := make([]string, len(newCurrentParentOrder))
                                for i, id := range newCurrentParentOrder </span><span class="cov0" title="0">{
                                        strs[i] = id.String()
                                }</span>
                                <span class="cov0" title="0">return strs</span>
                        }())
                <span class="cov0" title="0">err = s.rebuildLinkedList(ctx, newCurrentParentOrder)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to rebuild current parent linked list: %w", err)
                }</span>
        }

        <span class="cov0" title="0">s.logger.Debug("Rebuilding target parent linked list", 
                "items_count", len(newTargetParentOrder),
                "items", func() []string </span><span class="cov0" title="0">{
                        strs := make([]string, len(newTargetParentOrder))
                        for i, id := range newTargetParentOrder </span><span class="cov0" title="0">{
                                strs[i] = id.String()
                        }</span>
                        <span class="cov0" title="0">return strs</span>
                }())
        <span class="cov0" title="0">err = s.rebuildLinkedList(ctx, newTargetParentOrder)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to rebuild target parent linked list: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Debug("Successfully completed cross-folder move",
                "item_id", itemID.String(),
                "insert_pos", insertPos,
                "target_parent_items", len(newTargetParentOrder),
                "new_parent_folder_id", getIDString(newParentFolderID))
        
        
        return nil</span>
}

// performSameFolderMove handles moving an item within the same parent folder context
func (s *CollectionItemService) performSameFolderMove(ctx context.Context, itemID idwrap.IDWrap, item gen.CollectionItem, targetID *idwrap.IDWrap, position movable.MovePosition) error <span class="cov8" title="1">{
        s.logger.Debug("Performing same-folder move",
                "item_id", itemID.String(),
                "parent", getIDString(item.ParentFolderID))

        // Get current ordered list
        orderedItems, err := s.queries.GetCollectionItemsInOrder(ctx, gen.GetCollectionItemsInOrderParams{
                CollectionID:   item.CollectionID,
                ParentFolderID: item.ParentFolderID,
                CollectionID_2: item.CollectionID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get ordered items: %w", err)
        }</span>

        // Find current and target positions
        <span class="cov8" title="1">currentPos := -1
        targetPos := -1
        
        for i, orderedItem := range orderedItems </span><span class="cov8" title="1">{
                orderItemID := idwrap.NewFromBytesMust(orderedItem.ID)
                if orderItemID.Compare(itemID) == 0 </span><span class="cov8" title="1">{
                        currentPos = i
                }</span>
                <span class="cov8" title="1">if targetID != nil &amp;&amp; orderItemID.Compare(*targetID) == 0 </span><span class="cov8" title="1">{
                        targetPos = i
                }</span>
        }
        
        <span class="cov8" title="1">if currentPos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("item not found in ordered list")
        }</span>
        <span class="cov8" title="1">if targetID != nil &amp;&amp; targetPos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("target item not found in ordered list")
        }</span>

        // Calculate new position based on move position
        <span class="cov8" title="1">var newPos int
        if targetID == nil </span><span class="cov0" title="0">{
                // No target specified, use position as absolute
                if position == movable.MovePositionAfter </span><span class="cov0" title="0">{
                        newPos = len(orderedItems) - 1 // Move to end
                }</span> else<span class="cov0" title="0"> {
                        newPos = 0 // Move to beginning
                }</span>
        } else<span class="cov8" title="1"> {
                // Position relative to target
                // We need to account for the fact that we'll remove the item first
                if position == movable.MovePositionAfter </span><span class="cov8" title="1">{
                        if currentPos &lt; targetPos </span><span class="cov8" title="1">{
                                // Moving forward: target position shifts left by 1 after removal
                                newPos = targetPos
                        }</span> else<span class="cov0" title="0"> {
                                // Moving backward: target position stays the same, insert after
                                newPos = targetPos + 1
                        }</span>
                } else<span class="cov8" title="1"> { // MovePositionBefore
                        if currentPos &lt; targetPos </span><span class="cov8" title="1">{
                                // Moving forward: target position shifts left by 1 after removal
                                newPos = targetPos - 1
                        }</span> else<span class="cov0" title="0"> {
                                // Moving backward: target position stays the same
                                newPos = targetPos
                        }</span>
                }
        }
        
        // Clamp to valid range
        <span class="cov8" title="1">if newPos &lt; 0 </span><span class="cov0" title="0">{
                newPos = 0
        }</span>
        <span class="cov8" title="1">if newPos &gt;= len(orderedItems) </span><span class="cov0" title="0">{
                newPos = len(orderedItems) - 1
        }</span>
        
        // If no change needed
        <span class="cov8" title="1">if currentPos == newPos </span><span class="cov0" title="0">{
                s.logger.Debug("No position change needed", "current_pos", currentPos, "new_pos", newPos)
                return nil
        }</span>
        
        // Use existing move logic
        <span class="cov8" title="1">err = s.moveItemToPosition(ctx, itemID, orderedItems, currentPos, newPos)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to move item to position: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Debug("Successfully moved collection item within same folder",
                "item_id", itemID.String(),
                "from_pos", currentPos,
                "to_pos", newPos)
        return nil</span>
}

// MoveCollectionItemCrossCollection moves a collection item to a different collection
// This is the main method for handling cross-collection moves while maintaining workspace boundaries
func (s *CollectionItemService) MoveCollectionItemCrossCollection(ctx context.Context, itemID idwrap.IDWrap, targetCollectionID idwrap.IDWrap, targetParentFolderID *idwrap.IDWrap, targetItemID *idwrap.IDWrap, position movable.MovePosition) error <span class="cov0" title="0">{
        s.logger.Debug("Moving collection item across collections",
                "item_id", itemID.String(),
                "target_collection_id", targetCollectionID.String(),
                "target_parent_folder_id", getIDString(targetParentFolderID),
                "target_item_id", getIDString(targetItemID),
                "position", position)

        // Step 1: Validate the cross-collection move
        sourceCollectionID, err := s.ValidateCrossCollectionMove(ctx, itemID, targetCollectionID, targetParentFolderID, targetItemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cross-collection move validation failed: %w", err)
        }</span>

        // Step 2: Perform the cross-collection move
        <span class="cov0" title="0">err = s.PerformCrossCollectionMove(ctx, itemID, sourceCollectionID, targetCollectionID, targetParentFolderID, targetItemID, position)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to perform cross-collection move: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Debug("Successfully moved collection item across collections",
                "item_id", itemID.String(),
                "source_collection_id", sourceCollectionID.String(),
                "target_collection_id", targetCollectionID.String())

        return nil</span>
}

// ValidateCrossCollectionMove validates that a cross-collection move is valid
// Returns the source collection ID if validation passes
func (s *CollectionItemService) ValidateCrossCollectionMove(ctx context.Context, itemID idwrap.IDWrap, targetCollectionID idwrap.IDWrap, targetParentFolderID *idwrap.IDWrap, targetItemID *idwrap.IDWrap) (idwrap.IDWrap, error) <span class="cov0" title="0">{
        s.logger.Debug("Validating cross-collection move",
                "item_id", itemID.String(),
                "target_collection_id", targetCollectionID.String())

        // Get the item to validate it exists and get source collection
        item, err := s.queries.GetCollectionItem(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return idwrap.IDWrap{}, ErrCollectionItemNotFound
                }</span>
                <span class="cov0" title="0">return idwrap.IDWrap{}, fmt.Errorf("failed to get collection item: %w", err)</span>
        }

        <span class="cov0" title="0">sourceCollectionID := item.CollectionID

        // Prevent move to same collection (this should use intra-collection methods)
        if sourceCollectionID.Compare(targetCollectionID) == 0 </span><span class="cov0" title="0">{
                return idwrap.IDWrap{}, fmt.Errorf("item is already in target collection, use intra-collection move methods")
        }</span>

        // Validate that both collections exist and are in the same workspace
        <span class="cov0" title="0">validation, err := s.queries.ValidateCollectionsInSameWorkspace(ctx, gen.ValidateCollectionsInSameWorkspaceParams{
                ID:   sourceCollectionID,
                ID_2: targetCollectionID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return idwrap.IDWrap{}, ErrTargetCollectionNotFound
                }</span>
                <span class="cov0" title="0">return idwrap.IDWrap{}, fmt.Errorf("failed to validate collections: %w", err)</span>
        }

        <span class="cov0" title="0">if !validation.SameWorkspace </span><span class="cov0" title="0">{
                s.logger.Warn("Attempted cross-workspace move",
                        "source_workspace_id", validation.SourceWorkspaceID.String(),
                        "target_workspace_id", validation.TargetWorkspaceID.String())
                return idwrap.IDWrap{}, ErrCrossWorkspaceMove
        }</span>

        // Validate target parent folder if specified
        <span class="cov0" title="0">if targetParentFolderID != nil </span><span class="cov0" title="0">{
                targetParentItem, err := s.queries.GetCollectionItem(ctx, *targetParentFolderID)
                if err != nil </span><span class="cov0" title="0">{
                        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                                return idwrap.IDWrap{}, fmt.Errorf("target parent folder not found")
                        }</span>
                        <span class="cov0" title="0">return idwrap.IDWrap{}, fmt.Errorf("failed to get target parent folder: %w", err)</span>
                }

                // Ensure target parent is in the target collection
                <span class="cov0" title="0">if targetParentItem.CollectionID.Compare(targetCollectionID) != 0 </span><span class="cov0" title="0">{
                        return idwrap.IDWrap{}, fmt.Errorf("target parent folder must be in target collection")
                }</span>

                // Ensure target parent is actually a folder
                <span class="cov0" title="0">if targetParentItem.ItemType != int8(CollectionItemTypeFolder) </span><span class="cov0" title="0">{
                        return idwrap.IDWrap{}, fmt.Errorf("target parent must be a folder")
                }</span>
        }

        // Validate target item if specified
        <span class="cov0" title="0">if targetItemID != nil </span><span class="cov0" title="0">{
                targetItem, err := s.queries.GetCollectionItem(ctx, *targetItemID)
                if err != nil </span><span class="cov0" title="0">{
                        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                                return idwrap.IDWrap{}, fmt.Errorf("target item not found")
                        }</span>
                        <span class="cov0" title="0">return idwrap.IDWrap{}, fmt.Errorf("failed to get target item: %w", err)</span>
                }

                // Ensure target item is in the target collection
                <span class="cov0" title="0">if targetItem.CollectionID.Compare(targetCollectionID) != 0 </span><span class="cov0" title="0">{
                        return idwrap.IDWrap{}, fmt.Errorf("target item must be in target collection")
                }</span>

                // Ensure target item is in the target parent folder context
                <span class="cov0" title="0">if (targetItem.ParentFolderID == nil) != (targetParentFolderID == nil) </span><span class="cov0" title="0">{
                        return idwrap.IDWrap{}, fmt.Errorf("target item must be in the same parent context as the target parent folder")
                }</span>
                <span class="cov0" title="0">if targetItem.ParentFolderID != nil &amp;&amp; targetParentFolderID != nil </span><span class="cov0" title="0">{
                        if targetItem.ParentFolderID.Compare(*targetParentFolderID) != 0 </span><span class="cov0" title="0">{
                                return idwrap.IDWrap{}, fmt.Errorf("target item must be in the same parent context as the target parent folder")
                        }</span>
                }
        }

        // Prevent moving item relative to itself
        <span class="cov0" title="0">if targetItemID != nil &amp;&amp; itemID.Compare(*targetItemID) == 0 </span><span class="cov0" title="0">{
                return idwrap.IDWrap{}, fmt.Errorf("cannot move item relative to itself")
        }</span>

        <span class="cov0" title="0">s.logger.Debug("Cross-collection move validation passed",
                "item_id", itemID.String(),
                "source_collection_id", sourceCollectionID.String(),
                "target_collection_id", targetCollectionID.String())

        return sourceCollectionID, nil</span>
}

// PerformCrossCollectionMove performs the actual cross-collection move operation
func (s *CollectionItemService) PerformCrossCollectionMove(ctx context.Context, itemID idwrap.IDWrap, sourceCollectionID idwrap.IDWrap, targetCollectionID idwrap.IDWrap, targetParentFolderID *idwrap.IDWrap, targetItemID *idwrap.IDWrap, position movable.MovePosition) error <span class="cov0" title="0">{
        s.logger.Debug("Performing cross-collection move",
                "item_id", itemID.String(),
                "source_collection_id", sourceCollectionID.String(),
                "target_collection_id", targetCollectionID.String())

        // Get current item details
        item, err := s.queries.GetCollectionItem(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get collection item: %w", err)
        }</span>

        // Step 1: Remove item from source collection's linked list
        <span class="cov0" title="0">sourceItems, err := s.queries.GetCollectionItemsInOrder(ctx, gen.GetCollectionItemsInOrderParams{
                CollectionID:   sourceCollectionID,
                ParentFolderID: item.ParentFolderID,
                CollectionID_2: sourceCollectionID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get source collection items: %w", err)
        }</span>

        // Find current position and remove from source list
        <span class="cov0" title="0">currentPos := -1
        for i, orderedItem := range sourceItems </span><span class="cov0" title="0">{
                orderItemID := idwrap.NewFromBytesMust(orderedItem.ID)
                if orderItemID.Compare(itemID) == 0 </span><span class="cov0" title="0">{
                        currentPos = i
                        break</span>
                }
        }

        <span class="cov0" title="0">if currentPos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("item not found in source collection list")
        }</span>

        // Rebuild source collection list without the moving item
        <span class="cov0" title="0">newSourceOrder := make([]idwrap.IDWrap, 0, len(sourceItems)-1)
        for i, orderedItem := range sourceItems </span><span class="cov0" title="0">{
                if i != currentPos </span><span class="cov0" title="0">{
                        newSourceOrder = append(newSourceOrder, idwrap.NewFromBytesMust(orderedItem.ID))
                }</span>
        }

        // Step 2: Get target collection's current items
        <span class="cov0" title="0">targetItems, err := s.queries.GetCollectionItemsInOrder(ctx, gen.GetCollectionItemsInOrderParams{
                CollectionID:   targetCollectionID,
                ParentFolderID: targetParentFolderID,
                CollectionID_2: targetCollectionID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get target collection items: %w", err)
        }</span>

        // Step 3: Update item's collection_id and parent_folder_id
        <span class="cov0" title="0">s.logger.Debug("Updating collection_id and parent_folder_id",
                "item_id", itemID.String(),
                "new_collection_id", targetCollectionID.String(),
                "new_parent_folder_id", getIDString(targetParentFolderID))

        err = s.queries.UpdateCollectionItemCollectionId(ctx, gen.UpdateCollectionItemCollectionIdParams{
                CollectionID:   targetCollectionID,
                ParentFolderID: targetParentFolderID,
                ID:             itemID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update collection item collection_id: %w", err)
        }</span>

        // Step 4: Update legacy table collection_ids
        <span class="cov0" title="0">err = s.UpdateLegacyTableCollectionIds(ctx, item, targetCollectionID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update legacy table collection_ids: %w", err)
        }</span>

        // Step 5: Calculate insertion position in target collection
        <span class="cov0" title="0">var insertPos int
        if targetItemID != nil </span><span class="cov0" title="0">{
                // Look for the target item within the target collection context
                targetPos := -1
                for i, orderedItem := range targetItems </span><span class="cov0" title="0">{
                        orderItemID := idwrap.NewFromBytesMust(orderedItem.ID)
                        if orderItemID.Compare(*targetItemID) == 0 </span><span class="cov0" title="0">{
                                targetPos = i
                                break</span>
                        }
                }

                <span class="cov0" title="0">if targetPos != -1 </span><span class="cov0" title="0">{
                        // Target found within target collection: normal positioning relative to target
                        if position == movable.MovePositionAfter </span><span class="cov0" title="0">{
                                insertPos = targetPos + 1
                        }</span> else<span class="cov0" title="0"> {
                                insertPos = targetPos
                        }</span>
                        <span class="cov0" title="0">s.logger.Debug("Target found in target collection, positioning relative to it",
                                "target_pos", targetPos, "insert_pos", insertPos)</span>
                } else<span class="cov0" title="0"> {
                        // Target not found in target collection: add to end
                        insertPos = len(targetItems)
                        s.logger.Debug("Target not in target collection, adding to end", "pos", insertPos)
                }</span>
        } else<span class="cov0" title="0"> {
                // No target specified, add to end
                insertPos = len(targetItems)
        }</span>

        // Clamp insert position
        <span class="cov0" title="0">if insertPos &lt; 0 </span><span class="cov0" title="0">{
                insertPos = 0
        }</span>
        <span class="cov0" title="0">if insertPos &gt; len(targetItems) </span><span class="cov0" title="0">{
                insertPos = len(targetItems)
        }</span>

        // Step 6: Insert item into target collection's list at calculated position
        <span class="cov0" title="0">newTargetOrder := make([]idwrap.IDWrap, 0, len(targetItems)+1)
        for i, orderedItem := range targetItems </span><span class="cov0" title="0">{
                if i == insertPos </span><span class="cov0" title="0">{
                        newTargetOrder = append(newTargetOrder, itemID)
                }</span>
                <span class="cov0" title="0">newTargetOrder = append(newTargetOrder, idwrap.NewFromBytesMust(orderedItem.ID))</span>
        }
        // Handle case where item is inserted at the end
        <span class="cov0" title="0">if insertPos == len(targetItems) </span><span class="cov0" title="0">{
                newTargetOrder = append(newTargetOrder, itemID)
        }</span>

        // Step 7: Rebuild both linked lists
        <span class="cov0" title="0">if len(newSourceOrder) &gt; 0 </span><span class="cov0" title="0">{
                s.logger.Debug("Rebuilding source collection linked list",
                        "items_count", len(newSourceOrder))
                err = s.rebuildLinkedList(ctx, newSourceOrder)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to rebuild source collection linked list: %w", err)
                }</span>
        }

        <span class="cov0" title="0">s.logger.Debug("Rebuilding target collection linked list",
                "items_count", len(newTargetOrder))
        err = s.rebuildLinkedList(ctx, newTargetOrder)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to rebuild target collection linked list: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Debug("Successfully completed cross-collection move",
                "item_id", itemID.String(),
                "insert_pos", insertPos,
                "target_collection_items", len(newTargetOrder))

        return nil</span>
}

// UpdateLegacyTableCollectionIds updates the collection_id in legacy tables (item_api and item_folder)
// to maintain consistency after cross-collection moves
func (s *CollectionItemService) UpdateLegacyTableCollectionIds(ctx context.Context, item gen.CollectionItem, targetCollectionID idwrap.IDWrap) error <span class="cov0" title="0">{
        s.logger.Debug("Updating legacy table collection_ids",
                "item_type", item.ItemType,
                "target_collection_id", targetCollectionID.String())

        if item.ItemType == int8(CollectionItemTypeFolder) &amp;&amp; item.FolderID != nil </span><span class="cov0" title="0">{
                // Update item_folder table
                err := s.queries.UpdateItemFolderCollectionId(ctx, gen.UpdateItemFolderCollectionIdParams{
                        CollectionID: targetCollectionID,
                        ID:           *item.FolderID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update item_folder collection_id: %w", err)
                }</span>
                <span class="cov0" title="0">s.logger.Debug("Updated item_folder collection_id", "folder_id", item.FolderID.String())</span>
        }

        <span class="cov0" title="0">if item.ItemType == int8(CollectionItemTypeEndpoint) &amp;&amp; item.EndpointID != nil </span><span class="cov0" title="0">{
                // Update item_api table
                err := s.queries.UpdateItemApiCollectionId(ctx, gen.UpdateItemApiCollectionIdParams{
                        CollectionID: targetCollectionID,
                        ID:           *item.EndpointID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update item_api collection_id: %w", err)
                }</span>
                <span class="cov0" title="0">s.logger.Debug("Updated item_api collection_id", "endpoint_id", item.EndpointID.String())</span>
        }

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file89" style="display: none">package senv

import (
        "context"
        "database/sql"
        "fmt"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/movable"
)

// EnvironmentMovableRepository implements movable.MovableRepository for Environments
// It adapts position-based operations to linked list operations using prev/next pointers
type EnvironmentMovableRepository struct {
        queries *gen.Queries
}

// NewEnvironmentMovableRepository creates a new EnvironmentMovableRepository
func NewEnvironmentMovableRepository(queries *gen.Queries) *EnvironmentMovableRepository <span class="cov0" title="0">{
        return &amp;EnvironmentMovableRepository{
                queries: queries,
        }
}</span>

// TX returns a new repository instance with transaction support
func (r *EnvironmentMovableRepository) TX(tx *sql.Tx) *EnvironmentMovableRepository <span class="cov0" title="0">{
        return &amp;EnvironmentMovableRepository{
                queries: r.queries.WithTx(tx),
        }
}</span>

// UpdatePosition updates the position of an environment in the linked list
// For environments, parentID is the workspace_id and listType is ignored
func (r *EnvironmentMovableRepository) UpdatePosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap, listType movable.ListType, position int) error <span class="cov0" title="0">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get environment to find workspace_id
        <span class="cov0" title="0">environment, err := repo.queries.GetEnvironment(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get environment: %w", err)
        }</span>

        // Get ordered list of environments in workspace
        <span class="cov0" title="0">orderedEnvironments, err := repo.queries.GetEnvironmentsByWorkspaceIDOrdered(ctx, gen.GetEnvironmentsByWorkspaceIDOrderedParams{
                WorkspaceID:   environment.WorkspaceID,
                WorkspaceID_2: environment.WorkspaceID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get environments in order: %w", err)
        }</span>

        // Find current position and validate new position
        <span class="cov0" title="0">currentIdx := -1
        for i, env := range orderedEnvironments </span><span class="cov0" title="0">{
                if idwrap.NewFromBytesMust(env.ID).Compare(itemID) == 0 </span><span class="cov0" title="0">{
                        currentIdx = i
                        break</span>
                }
        }

        <span class="cov0" title="0">if currentIdx == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("environment not found in workspace")
        }</span>

        <span class="cov0" title="0">if position &lt; 0 || position &gt;= len(orderedEnvironments) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid position: %d (valid range: 0-%d)", position, len(orderedEnvironments)-1)
        }</span>

        <span class="cov0" title="0">if currentIdx == position </span><span class="cov0" title="0">{
                // No change needed
                return nil
        }</span>

        // Calculate new prev and next pointers
        <span class="cov0" title="0">var newPrev, newNext *idwrap.IDWrap

        if position == 0 </span><span class="cov0" title="0">{
                // Moving to head position
                newPrev = nil
                if len(orderedEnvironments) &gt; 1 </span><span class="cov0" title="0">{
                        nextID := idwrap.NewFromBytesMust(orderedEnvironments[1].ID)
                        newNext = &amp;nextID
                }</span>
        } else<span class="cov0" title="0"> if position == len(orderedEnvironments)-1 </span><span class="cov0" title="0">{
                // Moving to tail position  
                prevID := idwrap.NewFromBytesMust(orderedEnvironments[len(orderedEnvironments)-2].ID)
                newPrev = &amp;prevID
                newNext = nil
        }</span> else<span class="cov0" title="0"> {
                // Moving to middle position
                prevID := idwrap.NewFromBytesMust(orderedEnvironments[position-1].ID)
                nextID := idwrap.NewFromBytesMust(orderedEnvironments[position+1].ID)
                newPrev = &amp;prevID
                newNext = &amp;nextID
        }</span>

        // Update the environment's position
        <span class="cov0" title="0">return repo.queries.UpdateEnvironmentOrder(ctx, gen.UpdateEnvironmentOrderParams{
                Prev:        newPrev,
                Next:        newNext,
                ID:          itemID,
                WorkspaceID: environment.WorkspaceID,
        })</span>
}

// UpdatePositions updates positions for multiple environments in batch
func (r *EnvironmentMovableRepository) UpdatePositions(ctx context.Context, tx *sql.Tx, updates []movable.PositionUpdate) error <span class="cov0" title="0">{
        if len(updates) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Get repository with transaction support
        <span class="cov0" title="0">repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get the workspace ID from the first environment to validate all are in same workspace
        <span class="cov0" title="0">firstEnvironment, err := repo.queries.GetEnvironment(ctx, updates[0].ItemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get first environment: %w", err)
        }</span>
        <span class="cov0" title="0">workspaceID := firstEnvironment.WorkspaceID
        
        // Validate all environments are in the same workspace and create ID position map
        positionMap := make(map[idwrap.IDWrap]int)
        for _, update := range updates </span><span class="cov0" title="0">{
                environment, err := repo.queries.GetEnvironment(ctx, update.ItemID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get environment %s: %w", update.ItemID.String(), err)
                }</span>
                <span class="cov0" title="0">if environment.WorkspaceID.Compare(workspaceID) != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("all environments must be in the same workspace")
                }</span>
                <span class="cov0" title="0">positionMap[update.ItemID] = update.Position</span>
        }
        
        // Build the complete ordered list with all environments at their new positions
        <span class="cov0" title="0">orderedIDs := make([]idwrap.IDWrap, len(updates))
        for _, update := range updates </span><span class="cov0" title="0">{
                if update.Position &lt; 0 || update.Position &gt;= len(updates) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid position %d for environment %s (valid range: 0-%d)", 
                                update.Position, update.ItemID.String(), len(updates)-1)
                }</span>
                <span class="cov0" title="0">orderedIDs[update.Position] = update.ItemID</span>
        }
        
        // Calculate prev/next pointers for each environment in the new order
        <span class="cov0" title="0">type ptrUpdate struct {
                id   idwrap.IDWrap
                prev *idwrap.IDWrap
                next *idwrap.IDWrap
        }
        
        ptrUpdates := make([]ptrUpdate, len(orderedIDs))
        for i, id := range orderedIDs </span><span class="cov0" title="0">{
                var prev, next *idwrap.IDWrap
                
                if i &gt; 0 </span><span class="cov0" title="0">{
                        prev = &amp;orderedIDs[i-1]
                }</span>
                <span class="cov0" title="0">if i &lt; len(orderedIDs)-1 </span><span class="cov0" title="0">{
                        next = &amp;orderedIDs[i+1]
                }</span>
                
                <span class="cov0" title="0">ptrUpdates[i] = ptrUpdate{
                        id:   id,
                        prev: prev,
                        next: next,
                }</span>
        }
        
        // Apply all updates atomically
        <span class="cov0" title="0">for _, update := range ptrUpdates </span><span class="cov0" title="0">{
                if err := repo.queries.UpdateEnvironmentOrder(ctx, gen.UpdateEnvironmentOrderParams{
                        Prev:        update.prev,
                        Next:        update.next,
                        ID:          update.id,
                        WorkspaceID: workspaceID,
                }); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update environment %s order: %w", update.id.String(), err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetMaxPosition returns the maximum position value for environments in a workspace
// For linked lists, this is the count of environments minus 1
func (r *EnvironmentMovableRepository) GetMaxPosition(ctx context.Context, parentID idwrap.IDWrap, listType movable.ListType) (int, error) <span class="cov0" title="0">{
        // For environments, parentID is the workspace_id
        orderedEnvironments, err := r.queries.GetEnvironmentsByWorkspaceIDOrdered(ctx, gen.GetEnvironmentsByWorkspaceIDOrderedParams{
                WorkspaceID:   parentID,
                WorkspaceID_2: parentID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return -1, nil // No environments means no max position
                }</span>
                <span class="cov0" title="0">return 0, fmt.Errorf("failed to get environments in order: %w", err)</span>
        }

        <span class="cov0" title="0">if len(orderedEnvironments) == 0 </span><span class="cov0" title="0">{
                return -1, nil
        }</span>

        <span class="cov0" title="0">return len(orderedEnvironments) - 1, nil</span>
}

// GetItemsByParent returns all environments under a workspace, ordered by position
func (r *EnvironmentMovableRepository) GetItemsByParent(ctx context.Context, parentID idwrap.IDWrap, listType movable.ListType) ([]movable.MovableItem, error) <span class="cov0" title="0">{
        // For environments, parentID is the workspace_id
        orderedEnvironments, err := r.queries.GetEnvironmentsByWorkspaceIDOrdered(ctx, gen.GetEnvironmentsByWorkspaceIDOrderedParams{
                WorkspaceID:   parentID,
                WorkspaceID_2: parentID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []movable.MovableItem{}, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get environments in order: %w", err)</span>
        }

        // Convert to MovableItem structs
        <span class="cov0" title="0">items := make([]movable.MovableItem, len(orderedEnvironments))
        for i, env := range orderedEnvironments </span><span class="cov0" title="0">{
                items[i] = movable.MovableItem{
                        ID:       idwrap.NewFromBytesMust(env.ID),
                        ParentID: &amp;parentID, // workspace_id as parent
                        Position: int(env.Position),
                        ListType: listType,
                }
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

// insertAtPosition inserts an environment at a specific position in the linked list
// This is a helper method for operations that need to insert new environments
func (r *EnvironmentMovableRepository) insertAtPosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap, workspaceID idwrap.IDWrap, position int) error <span class="cov0" title="0">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get ordered list of environments in workspace
        <span class="cov0" title="0">orderedEnvironments, err := repo.queries.GetEnvironmentsByWorkspaceIDOrdered(ctx, gen.GetEnvironmentsByWorkspaceIDOrderedParams{
                WorkspaceID:   workspaceID,
                WorkspaceID_2: workspaceID,
        })
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get environments in order: %w", err)
        }</span>

        <span class="cov0" title="0">var newPrev, newNext *idwrap.IDWrap

        if len(orderedEnvironments) == 0 </span><span class="cov0" title="0">{
                // First environment in workspace
                newPrev = nil
                newNext = nil
        }</span> else<span class="cov0" title="0"> if position == 0 </span><span class="cov0" title="0">{
                // Insert at head
                newPrev = nil
                if len(orderedEnvironments) &gt; 0 </span><span class="cov0" title="0">{
                        nextID := idwrap.NewFromBytesMust(orderedEnvironments[0].ID)
                        newNext = &amp;nextID
                        
                        // Update the current head to point back to new item
                        err = repo.queries.UpdateEnvironmentOrder(ctx, gen.UpdateEnvironmentOrderParams{
                                Prev:        &amp;itemID,
                                Next:        newNext,
                                ID:          nextID,
                                WorkspaceID: workspaceID,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update current head: %w", err)
                        }</span>
                }
        } else<span class="cov0" title="0"> if position &gt;= len(orderedEnvironments) </span><span class="cov0" title="0">{
                // Insert at tail
                if len(orderedEnvironments) &gt; 0 </span><span class="cov0" title="0">{
                        prevID := idwrap.NewFromBytesMust(orderedEnvironments[len(orderedEnvironments)-1].ID)
                        newPrev = &amp;prevID
                        
                        // Update the current tail to point forward to new item
                        err = repo.queries.UpdateEnvironmentOrder(ctx, gen.UpdateEnvironmentOrderParams{
                                Prev:        newPrev,
                                Next:        &amp;itemID,
                                ID:          prevID,
                                WorkspaceID: workspaceID,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update current tail: %w", err)
                        }</span>
                }
                <span class="cov0" title="0">newNext = nil</span>
        } else<span class="cov0" title="0"> {
                // Insert in middle
                prevID := idwrap.NewFromBytesMust(orderedEnvironments[position-1].ID)
                nextID := idwrap.NewFromBytesMust(orderedEnvironments[position].ID)
                newPrev = &amp;prevID
                newNext = &amp;nextID
                
                // Update prev item to point to new item
                err = repo.queries.UpdateEnvironmentOrder(ctx, gen.UpdateEnvironmentOrderParams{
                        Prev:        newPrev,
                        Next:        &amp;itemID,
                        ID:          prevID,
                        WorkspaceID: workspaceID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update prev item: %w", err)
                }</span>
                
                // Update next item to point back to new item
                <span class="cov0" title="0">err = repo.queries.UpdateEnvironmentOrder(ctx, gen.UpdateEnvironmentOrderParams{
                        Prev:        &amp;itemID,
                        Next:        newNext,
                        ID:          nextID,
                        WorkspaceID: workspaceID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update next item: %w", err)
                }</span>
        }

        // Set the new item's position
        <span class="cov0" title="0">return repo.queries.UpdateEnvironmentOrder(ctx, gen.UpdateEnvironmentOrderParams{
                Prev:        newPrev,
                Next:        newNext,
                ID:          itemID,
                WorkspaceID: workspaceID,
        })</span>
}

// removeFromPosition removes an environment from its current position in the linked list
// This is a helper method for operations that need to remove environments
func (r *EnvironmentMovableRepository) removeFromPosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap) error <span class="cov0" title="0">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get the environment to remove
        <span class="cov0" title="0">environment, err := repo.queries.GetEnvironment(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get environment: %w", err)
        }</span>

        // Get ordered environments to find prev and next
        <span class="cov0" title="0">orderedEnvironments, err := repo.queries.GetEnvironmentsByWorkspaceIDOrdered(ctx, gen.GetEnvironmentsByWorkspaceIDOrderedParams{
                WorkspaceID:   environment.WorkspaceID,
                WorkspaceID_2: environment.WorkspaceID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get environments in order: %w", err)
        }</span>

        // Find the item and its neighbors
        <span class="cov0" title="0">var prevID, nextID *idwrap.IDWrap
        for i, env := range orderedEnvironments </span><span class="cov0" title="0">{
                if idwrap.NewFromBytesMust(env.ID).Compare(itemID) == 0 </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                prev := idwrap.NewFromBytesMust(orderedEnvironments[i-1].ID)
                                prevID = &amp;prev
                        }</span>
                        <span class="cov0" title="0">if i &lt; len(orderedEnvironments)-1 </span><span class="cov0" title="0">{
                                next := idwrap.NewFromBytesMust(orderedEnvironments[i+1].ID)
                                nextID = &amp;next
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }

        // Update prev item's next pointer to skip the removed item
        <span class="cov0" title="0">if prevID != nil </span><span class="cov0" title="0">{
                // Get the prev item's current prev pointer to preserve it
                for _, env := range orderedEnvironments </span><span class="cov0" title="0">{
                        if idwrap.NewFromBytesMust(env.ID).Compare(*prevID) == 0 </span><span class="cov0" title="0">{
                                var currentPrev *idwrap.IDWrap
                                if env.Prev != nil </span><span class="cov0" title="0">{
                                        prev := idwrap.NewFromBytesMust(env.Prev)
                                        currentPrev = &amp;prev
                                }</span>
                                
                                <span class="cov0" title="0">err = repo.queries.UpdateEnvironmentOrder(ctx, gen.UpdateEnvironmentOrderParams{
                                        Prev:        currentPrev, // Preserve the prev item's own prev pointer
                                        Next:        nextID,      // Point to the item after the removed one  
                                        ID:          *prevID,
                                        WorkspaceID: environment.WorkspaceID,
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to update prev item: %w", err)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
        }

        // Update next item's prev pointer to skip the removed item
        <span class="cov0" title="0">if nextID != nil </span><span class="cov0" title="0">{
                // Get the next item's current next pointer to preserve it
                for _, env := range orderedEnvironments </span><span class="cov0" title="0">{
                        if idwrap.NewFromBytesMust(env.ID).Compare(*nextID) == 0 </span><span class="cov0" title="0">{
                                var currentNext *idwrap.IDWrap
                                if env.Next != nil </span><span class="cov0" title="0">{
                                        next := idwrap.NewFromBytesMust(env.Next)
                                        currentNext = &amp;next
                                }</span>
                                
                                <span class="cov0" title="0">err = repo.queries.UpdateEnvironmentOrder(ctx, gen.UpdateEnvironmentOrderParams{
                                        Prev:        prevID,      // Point to the item before the removed one
                                        Next:        currentNext, // Preserve the next item's own next pointer
                                        ID:          *nextID,
                                        WorkspaceID: environment.WorkspaceID,
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to update next item: %w", err)
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file90" style="display: none">package senv

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/menv"
        "the-dev-tools/server/pkg/movable"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

type EnvironmentService struct {
        queries              *gen.Queries
        logger               *slog.Logger
        linkedListManager    movable.LinkedListManager
        movableRepository    movable.MovableRepository
}

// Type alias for backward compatibility
type EnvService = EnvironmentService

var (
        ErrNoEnvironmentFound         = sql.ErrNoRows
        ErrNoEnvFound                = sql.ErrNoRows  // Backward compatibility alias
        ErrInvalidMoveOperation       = fmt.Errorf("invalid move operation")
        ErrWorkspaceBoundaryViolation = fmt.Errorf("environments must be in same workspace")
        ErrSelfReferentialMove        = fmt.Errorf("cannot move environment relative to itself")
)

func New(queries *gen.Queries, logger *slog.Logger) EnvironmentService <span class="cov0" title="0">{
        // Create the movable repository for environments
        movableRepo := NewEnvironmentMovableRepository(queries)
        
        // Create the linked list manager with the movable repository
        linkedListManager := movable.NewDefaultLinkedListManager(movableRepo)
        
        return EnvironmentService{
                queries:              queries,
                logger:               logger,
                linkedListManager:    linkedListManager,
                movableRepository:    movableRepo,
        }
}</span>

func (e EnvironmentService) TX(tx *sql.Tx) EnvironmentService <span class="cov0" title="0">{
        // Create new instances with transaction support
        txQueries := e.queries.WithTx(tx)
        movableRepo := NewEnvironmentMovableRepository(txQueries)
        linkedListManager := movable.NewDefaultLinkedListManager(movableRepo)
        
        return EnvironmentService{
                queries:              txQueries,
                logger:               e.logger,
                linkedListManager:    linkedListManager,
                movableRepository:    movableRepo,
        }
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*EnvironmentService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Create movable repository and linked list manager
        <span class="cov0" title="0">movableRepo := NewEnvironmentMovableRepository(queries)
        linkedListManager := movable.NewDefaultLinkedListManager(movableRepo)
        
        // Use a default logger for transaction services
        logger := slog.Default()
        
        service := EnvironmentService{
                queries:              queries,
                logger:               logger,
                linkedListManager:    linkedListManager,
                movableRepository:    movableRepo,
        }
        return &amp;service, nil</span>
}

func ConvertToDBEnv(env menv.Env) gen.Environment <span class="cov0" title="0">{
        return gen.Environment{
                ID:          env.ID,
                WorkspaceID: env.WorkspaceID,
                Type:        int8(env.Type),
                Name:        env.Name,
                Description: env.Description,
        }
}</span>

func ConvertToModelEnv(env gen.Environment) *menv.Env <span class="cov0" title="0">{
        return &amp;menv.Env{
                ID:          env.ID,
                WorkspaceID: env.WorkspaceID,
                Type:        menv.EnvType(env.Type),
                Name:        env.Name,
                Description: env.Description,
        }
}</span>

func (e EnvironmentService) GetEnvironment(ctx context.Context, id idwrap.IDWrap) (*menv.Env, error) <span class="cov0" title="0">{
        env, err := e.queries.GetEnvironment(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        e.logger.DebugContext(ctx, fmt.Sprintf("EnvironmentID: %s not found", id.String()))
                        return nil, ErrNoEnvironmentFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return ConvertToModelEnv(env), nil</span>
}

func (e EnvironmentService) ListEnvironments(ctx context.Context, workspaceID idwrap.IDWrap) ([]menv.Env, error) <span class="cov0" title="0">{
        envs, err := e.queries.GetEnvironmentsByWorkspaceID(ctx, workspaceID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        e.logger.InfoContext(ctx, fmt.Sprintf("workspaceID: %s not found", workspaceID.String()))
                        return nil, ErrNoEnvironmentFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return tgeneric.MassConvertPtr(envs, ConvertToModelEnv), nil</span>
}

func (e EnvironmentService) CreateEnvironment(ctx context.Context, env *menv.Env) error <span class="cov0" title="0">{
        // Find the current tail of the linked list (last environment in workspace)
        existingEnvironments, err := e.GetEnvironmentsByWorkspaceIDOrdered(ctx, env.WorkspaceID)
        if err != nil &amp;&amp; err != ErrNoEnvironmentFound </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get existing environments: %w", err)
        }</span>
        
        <span class="cov0" title="0">var prev *idwrap.IDWrap
        
        // If there are existing environments, set prev to point to the last one
        // and update that environment's next pointer to point to the new one
        if len(existingEnvironments) &gt; 0 </span><span class="cov0" title="0">{
                lastEnvironment := existingEnvironments[len(existingEnvironments)-1]
                prev = &amp;lastEnvironment.ID
                
                // Get the database version to access prev/next fields
                dbLastEnvironment, err := e.queries.GetEnvironment(ctx, lastEnvironment.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get last environment from database: %w", err)
                }</span>
                
                // Update the current tail's next pointer to point to new environment
                <span class="cov0" title="0">err = e.queries.UpdateEnvironmentOrder(ctx, gen.UpdateEnvironmentOrderParams{
                        Prev:        dbLastEnvironment.Prev, // Keep existing prev pointer
                        Next:        &amp;env.ID,                // Set next to new environment
                        ID:          lastEnvironment.ID,     // Update the last environment
                        WorkspaceID: env.WorkspaceID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update previous tail environment: %w", err)
                }</span>
        }
        
        // Create the environment with proper linked list pointers
        <span class="cov0" title="0">return e.queries.CreateEnvironment(ctx, gen.CreateEnvironmentParams{
                ID:          env.ID,
                WorkspaceID: env.WorkspaceID,
                Type:        int8(env.Type),
                Name:        env.Name,
                Description: env.Description,
                Prev:        prev, // Points to current tail (or nil if first)
                Next:        nil,  // Always nil for new environments (they become the new tail)
        })</span>
}

func (e EnvironmentService) UpdateEnvironment(ctx context.Context, env *menv.Env) error <span class="cov0" title="0">{
        dbEnv := ConvertToDBEnv(*env)
        return e.queries.UpdateEnvironment(ctx, gen.UpdateEnvironmentParams{
                ID:          dbEnv.ID,
                Name:        dbEnv.Name,
                Description: dbEnv.Description,
        })
}</span>

func (e EnvironmentService) DeleteEnvironment(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        return e.DeleteEnvironmentTX(ctx, nil, id)
}</span>

// Backward compatibility methods for the RPC layer

// Create provides backward compatibility for the RPC layer
func (e EnvironmentService) Create(ctx context.Context, env menv.Env) error <span class="cov0" title="0">{
        return e.CreateEnvironment(ctx, &amp;env)
}</span>

// Get provides backward compatibility for the RPC layer
func (e EnvironmentService) Get(ctx context.Context, id idwrap.IDWrap) (*menv.Env, error) <span class="cov0" title="0">{
        return e.GetEnvironment(ctx, id)
}</span>

// GetByWorkspace provides backward compatibility for the RPC layer
func (e EnvironmentService) GetByWorkspace(ctx context.Context, workspaceID idwrap.IDWrap) ([]menv.Env, error) <span class="cov0" title="0">{
        return e.GetEnvironmentsByWorkspaceIDOrdered(ctx, workspaceID)
}</span>

// Update provides backward compatibility for the RPC layer
func (e EnvironmentService) Update(ctx context.Context, env *menv.Env) error <span class="cov0" title="0">{
        return e.UpdateEnvironment(ctx, env)
}</span>

// Delete provides backward compatibility for the RPC layer
func (e EnvironmentService) Delete(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        return e.DeleteEnvironment(ctx, id)
}</span>

// DeleteEnvironmentTX deletes an environment while maintaining linked-list integrity within a transaction
func (e EnvironmentService) DeleteEnvironmentTX(ctx context.Context, tx *sql.Tx, id idwrap.IDWrap) error <span class="cov0" title="0">{
        service := e
        if tx != nil </span><span class="cov0" title="0">{
                service = e.TX(tx)
        }</span>
        
        // 1. Get the environment being deleted to find its prev/next pointers
        <span class="cov0" title="0">env, err := service.queries.GetEnvironment(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        e.logger.DebugContext(ctx, fmt.Sprintf("Environment %s not found for deletion", id.String()))
                        return ErrNoEnvironmentFound
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get environment for deletion: %w", err)</span>
        }
        
        // 2. Fix linked-list pointers before deletion
        // Update prev environment's next pointer to skip the deleted environment
        <span class="cov0" title="0">if env.Prev != nil </span><span class="cov0" title="0">{
                err = service.queries.UpdateEnvironmentNext(ctx, gen.UpdateEnvironmentNextParams{
                        Next:        env.Next,      // Point to the deleted environment's next
                        ID:          *env.Prev,
                        WorkspaceID: env.WorkspaceID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update previous environment's next pointer: %w", err)
                }</span>
        }
        
        // Update next environment's prev pointer to skip the deleted environment
        <span class="cov0" title="0">if env.Next != nil </span><span class="cov0" title="0">{
                err = service.queries.UpdateEnvironmentPrev(ctx, gen.UpdateEnvironmentPrevParams{
                        Prev:        env.Prev,      // Point to the deleted environment's prev
                        ID:          *env.Next,
                        WorkspaceID: env.WorkspaceID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update next environment's prev pointer: %w", err)
                }</span>
        }
        
        // 3. Now safely delete the environment
        <span class="cov0" title="0">err = service.queries.DeleteEnvironment(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete environment after fixing linked-list: %w", err)
        }</span>
        
        <span class="cov0" title="0">e.logger.DebugContext(ctx, "Environment deleted with linked-list integrity maintained", 
                "environmentID", id.String())
        
        return nil</span>
}

func (e EnvironmentService) GetWorkspaceID(ctx context.Context, envID idwrap.IDWrap) (idwrap.IDWrap, error) <span class="cov0" title="0">{
        ulidData, err := e.queries.GetEnvironmentWorkspaceID(ctx, envID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return idwrap.IDWrap{}, ErrNoEnvironmentFound
                }</span>
                <span class="cov0" title="0">return idwrap.IDWrap{}, err</span>
        }
        <span class="cov0" title="0">return ulidData, nil</span>
}

func (e EnvironmentService) CheckWorkspaceID(ctx context.Context, envID, ownerID idwrap.IDWrap) (bool, error) <span class="cov0" title="0">{
        environmentWorkspaceID, err := e.GetWorkspaceID(ctx, envID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return false, ErrNoEnvironmentFound
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov0" title="0">return ownerID.Compare(environmentWorkspaceID) == 0, nil</span>
}

// Movable operations for environments

// MoveEnvironmentAfter moves an environment to be positioned after the target environment
func (e EnvironmentService) MoveEnvironmentAfter(ctx context.Context, envID, targetEnvID idwrap.IDWrap) error <span class="cov0" title="0">{
        return e.MoveEnvironmentAfterTX(ctx, nil, envID, targetEnvID)
}</span>

// MoveEnvironmentAfterTX moves an environment to be positioned after the target environment within a transaction
func (e EnvironmentService) MoveEnvironmentAfterTX(ctx context.Context, tx *sql.Tx, envID, targetEnvID idwrap.IDWrap) error <span class="cov0" title="0">{
        service := e
        if tx != nil </span><span class="cov0" title="0">{
                service = e.TX(tx)
        }</span>
        
        // Get workspace ID for both environments to ensure they're in the same workspace
        <span class="cov0" title="0">sourceWorkspaceID, err := service.GetWorkspaceID(ctx, envID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get source environment workspace: %w", err)
        }</span>
        
        <span class="cov0" title="0">targetWorkspaceID, err := service.GetWorkspaceID(ctx, targetEnvID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get target environment workspace: %w", err)
        }</span>
        
        <span class="cov0" title="0">if sourceWorkspaceID.Compare(targetWorkspaceID) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("environments must be in the same workspace")
        }</span>
        
        // Get all environments in the workspace in order
        <span class="cov0" title="0">environments, err := service.GetEnvironmentsByWorkspaceIDOrdered(ctx, sourceWorkspaceID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get environments in order: %w", err)
        }</span>
        
        // Find positions of source and target environments
        <span class="cov0" title="0">var sourcePos, targetPos int = -1, -1
        for i, env := range environments </span><span class="cov0" title="0">{
                if env.ID.Compare(envID) == 0 </span><span class="cov0" title="0">{
                        sourcePos = i
                }</span>
                <span class="cov0" title="0">if env.ID.Compare(targetEnvID) == 0 </span><span class="cov0" title="0">{
                        targetPos = i
                }</span>
        }
        
        <span class="cov0" title="0">if sourcePos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("source environment not found in workspace")
        }</span>
        <span class="cov0" title="0">if targetPos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("target environment not found in workspace")
        }</span>
        
        <span class="cov0" title="0">if sourcePos == targetPos </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot move environment relative to itself")
        }</span>
        
        // Calculate new order: move source to be after target
        <span class="cov0" title="0">newOrder := make([]idwrap.IDWrap, 0, len(environments))
        
        for i, env := range environments </span><span class="cov0" title="0">{
                if i == sourcePos </span><span class="cov0" title="0">{
                        continue</span> // Skip source environment
                }
                <span class="cov0" title="0">newOrder = append(newOrder, env.ID)
                if i == targetPos </span><span class="cov0" title="0">{
                        newOrder = append(newOrder, envID) // Insert source after target
                }</span>
        }
        
        // Reorder environments
        <span class="cov0" title="0">return service.ReorderEnvironmentsTX(ctx, tx, sourceWorkspaceID, newOrder)</span>
}

// MoveEnvironmentBefore moves an environment to be positioned before the target environment
func (e EnvironmentService) MoveEnvironmentBefore(ctx context.Context, envID, targetEnvID idwrap.IDWrap) error <span class="cov0" title="0">{
        return e.MoveEnvironmentBeforeTX(ctx, nil, envID, targetEnvID)
}</span>

// MoveEnvironmentBeforeTX moves an environment to be positioned before the target environment within a transaction
func (e EnvironmentService) MoveEnvironmentBeforeTX(ctx context.Context, tx *sql.Tx, envID, targetEnvID idwrap.IDWrap) error <span class="cov0" title="0">{
        service := e
        if tx != nil </span><span class="cov0" title="0">{
                service = e.TX(tx)
        }</span>
        
        // Get workspace ID for both environments to ensure they're in the same workspace
        <span class="cov0" title="0">sourceWorkspaceID, err := service.GetWorkspaceID(ctx, envID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get source environment workspace: %w", err)
        }</span>
        
        <span class="cov0" title="0">targetWorkspaceID, err := service.GetWorkspaceID(ctx, targetEnvID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get target environment workspace: %w", err)
        }</span>
        
        <span class="cov0" title="0">if sourceWorkspaceID.Compare(targetWorkspaceID) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("environments must be in the same workspace")
        }</span>
        
        // Get all environments in the workspace in order
        <span class="cov0" title="0">environments, err := service.GetEnvironmentsByWorkspaceIDOrdered(ctx, sourceWorkspaceID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get environments in order: %w", err)
        }</span>
        
        // Find positions of source and target environments
        <span class="cov0" title="0">var sourcePos, targetPos int = -1, -1
        for i, env := range environments </span><span class="cov0" title="0">{
                if env.ID.Compare(envID) == 0 </span><span class="cov0" title="0">{
                        sourcePos = i
                }</span>
                <span class="cov0" title="0">if env.ID.Compare(targetEnvID) == 0 </span><span class="cov0" title="0">{
                        targetPos = i
                }</span>
        }
        
        <span class="cov0" title="0">if sourcePos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("source environment not found in workspace")
        }</span>
        <span class="cov0" title="0">if targetPos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("target environment not found in workspace")
        }</span>
        
        <span class="cov0" title="0">if sourcePos == targetPos </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot move environment relative to itself")
        }</span>
        
        // Calculate new order: move source to be before target
        <span class="cov0" title="0">newOrder := make([]idwrap.IDWrap, 0, len(environments))
        
        for i, env := range environments </span><span class="cov0" title="0">{
                if i == sourcePos </span><span class="cov0" title="0">{
                        continue</span> // Skip source environment
                }
                <span class="cov0" title="0">if i == targetPos </span><span class="cov0" title="0">{
                        newOrder = append(newOrder, envID) // Insert source before target
                }</span>
                <span class="cov0" title="0">newOrder = append(newOrder, env.ID)</span>
        }
        
        // Reorder environments
        <span class="cov0" title="0">return service.ReorderEnvironmentsTX(ctx, tx, sourceWorkspaceID, newOrder)</span>
}

// GetEnvironmentsByWorkspaceIDOrdered returns environments in the workspace in their proper order
func (e EnvironmentService) GetEnvironmentsByWorkspaceIDOrdered(ctx context.Context, workspaceID idwrap.IDWrap) ([]menv.Env, error) <span class="cov0" title="0">{
        // Use the underlying query that maintains the linked list order
        orderedEnvironments, err := e.queries.GetEnvironmentsByWorkspaceIDOrdered(ctx, gen.GetEnvironmentsByWorkspaceIDOrderedParams{
                WorkspaceID:   workspaceID,
                WorkspaceID_2: workspaceID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        e.logger.InfoContext(ctx, fmt.Sprintf("workspaceID: %s has no environments", workspaceID.String()))
                        return []menv.Env{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        
        // Convert to model environments
        <span class="cov0" title="0">environments := make([]menv.Env, len(orderedEnvironments))
        for i, env := range orderedEnvironments </span><span class="cov0" title="0">{
                environments[i] = menv.Env{
                        ID:          idwrap.NewFromBytesMust(env.ID),
                        WorkspaceID: idwrap.NewFromBytesMust(env.WorkspaceID),
                        Type:        menv.EnvType(env.Type),
                        Name:        env.Name,
                        Description: env.Description,
                        // Note: Updated field not available in the ordered query result
                        // If needed, we could make a separate query to get this field
                }
        }</span>
        
        <span class="cov0" title="0">return environments, nil</span>
}

// ReorderEnvironments performs a bulk reorder of environments using the movable system
func (e EnvironmentService) ReorderEnvironments(ctx context.Context, workspaceID idwrap.IDWrap, orderedIDs []idwrap.IDWrap) error <span class="cov0" title="0">{
        return e.ReorderEnvironmentsTX(ctx, nil, workspaceID, orderedIDs)
}</span>

// ReorderEnvironmentsTX performs a bulk reorder of environments using the movable system within a transaction
func (e EnvironmentService) ReorderEnvironmentsTX(ctx context.Context, tx *sql.Tx, workspaceID idwrap.IDWrap, orderedIDs []idwrap.IDWrap) error <span class="cov0" title="0">{
        service := e
        if tx != nil </span><span class="cov0" title="0">{
                service = e.TX(tx)
        }</span>
        
        // Build position updates
        <span class="cov0" title="0">updates := make([]movable.PositionUpdate, len(orderedIDs))
        for i, id := range orderedIDs </span><span class="cov0" title="0">{
                updates[i] = movable.PositionUpdate{
                        ItemID:   id,
                        ListType: movable.WorkspaceListTypeEnvironments,
                        Position: i,
                }
        }</span>
        
        // Execute the batch update using the movable repository
        <span class="cov0" title="0">if err := service.movableRepository.UpdatePositions(ctx, tx, updates); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reorder environments: %w", err)
        }</span>
        
        <span class="cov0" title="0">e.logger.DebugContext(ctx, "Environments reordered", 
                "workspaceID", workspaceID.String(),
                "environmentCount", len(orderedIDs))
        
        return nil</span>
}

// CompactEnvironmentPositions recalculates and compacts position values to eliminate gaps
func (e EnvironmentService) CompactEnvironmentPositions(ctx context.Context, workspaceID idwrap.IDWrap) error <span class="cov0" title="0">{
        return e.CompactEnvironmentPositionsTX(ctx, nil, workspaceID)
}</span>

// CompactEnvironmentPositionsTX recalculates and compacts position values within a transaction
func (e EnvironmentService) CompactEnvironmentPositionsTX(ctx context.Context, tx *sql.Tx, workspaceID idwrap.IDWrap) error <span class="cov0" title="0">{
        service := e
        if tx != nil </span><span class="cov0" title="0">{
                service = e.TX(tx)
        }</span>
        
        <span class="cov0" title="0">if err := service.linkedListManager.CompactPositions(ctx, tx, workspaceID, movable.WorkspaceListTypeEnvironments); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to compact environment positions: %w", err)
        }</span>
        
        <span class="cov0" title="0">e.logger.DebugContext(ctx, "Environment positions compacted", "workspaceID", workspaceID.String())
        return nil</span>
}

// validateMoveOperation validates that a move operation is safe and valid
func (e EnvironmentService) validateMoveOperation(ctx context.Context, envID, targetEnvID idwrap.IDWrap) error <span class="cov0" title="0">{
        if envID.Compare(targetEnvID) == 0 </span><span class="cov0" title="0">{
                return ErrSelfReferentialMove
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// checkWorkspaceBoundaries ensures both environments are in the same workspace
func (e EnvironmentService) checkWorkspaceBoundaries(ctx context.Context, envID, targetEnvID idwrap.IDWrap) error <span class="cov0" title="0">{
        sourceWorkspaceID, err := e.GetWorkspaceID(ctx, envID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get source environment workspace: %w", err)
        }</span>
        
        <span class="cov0" title="0">targetWorkspaceID, err := e.GetWorkspaceID(ctx, targetEnvID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get target environment workspace: %w", err)
        }</span>
        
        <span class="cov0" title="0">if sourceWorkspaceID.Compare(targetWorkspaceID) != 0 </span><span class="cov0" title="0">{
                return ErrWorkspaceBoundaryViolation
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package sexampleheader

import (
        "context"
        "database/sql"
        "errors"
        "slices"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mexampleheader"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

var ErrNoHeaderFound = errors.New("not header found")

type HeaderService struct {
        queries *gen.Queries
}

func New(queries *gen.Queries) HeaderService <span class="cov0" title="0">{
        return HeaderService{queries: queries}
}</span>

func (h HeaderService) TX(tx *sql.Tx) HeaderService <span class="cov0" title="0">{
        return HeaderService{queries: h.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*HeaderService, error) <span class="cov0" title="0">{
        queries := gen.New(tx)
        headerService := HeaderService{
                queries: queries,
        }

        return &amp;headerService, nil
}</span>

func SerializeHeaderModelToDB(header gen.ExampleHeader) mexampleheader.Header <span class="cov0" title="0">{
        return mexampleheader.Header{
                ID:            header.ID,
                ExampleID:     header.ExampleID,
                DeltaParentID: header.DeltaParentID,
                HeaderKey:     header.HeaderKey,
                Enable:        header.Enable,
                Description:   header.Description,
                Value:         header.Value,
                Prev:          header.Prev,
                Next:          header.Next,
        }
}</span>

func SerializeHeaderDBToModel(header mexampleheader.Header) gen.ExampleHeader <span class="cov0" title="0">{
        return gen.ExampleHeader{
                ID:            header.ID,
                ExampleID:     header.ExampleID,
                DeltaParentID: header.DeltaParentID,
                HeaderKey:     header.HeaderKey,
                Enable:        header.Enable,
                Description:   header.Description,
                Value:         header.Value,
                Prev:          header.Prev,
                Next:          header.Next,
        }
}</span>

func (h HeaderService) GetHeaderByExampleID(ctx context.Context, exampleID idwrap.IDWrap) ([]mexampleheader.Header, error) <span class="cov0" title="0">{
        dbHeaders, err := h.queries.GetHeadersByExampleID(ctx, exampleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var headers []mexampleheader.Header
        for _, dbHeader := range dbHeaders </span><span class="cov0" title="0">{
                header := SerializeHeaderModelToDB(dbHeader)
                headers = append(headers, header)
        }</span>

        <span class="cov0" title="0">return headers, nil</span>
}

func (h HeaderService) GetHeaderByExampleIDOrdered(ctx context.Context, exampleID idwrap.IDWrap) ([]mexampleheader.Header, error) <span class="cov0" title="0">{
        // Use the ordered query that traverses the linked list
        dbHeaders, err := h.queries.GetHeadersByExampleIDOrdered(ctx, gen.GetHeadersByExampleIDOrderedParams{
                ExampleID:   exampleID,
                ExampleID_2: exampleID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var headers []mexampleheader.Header
        for _, dbHeader := range dbHeaders </span><span class="cov0" title="0">{
                // Convert the query row to model Header
                var deltaParentID *idwrap.IDWrap
                if dbHeader.DeltaParentID != nil </span><span class="cov0" title="0">{
                        id := idwrap.NewFromBytesMust(dbHeader.DeltaParentID)
                        deltaParentID = &amp;id
                }</span>

                <span class="cov0" title="0">var prev *idwrap.IDWrap
                if dbHeader.Prev != nil </span><span class="cov0" title="0">{
                        id := idwrap.NewFromBytesMust(dbHeader.Prev)
                        prev = &amp;id
                }</span>

                <span class="cov0" title="0">var next *idwrap.IDWrap
                if dbHeader.Next != nil </span><span class="cov0" title="0">{
                        id := idwrap.NewFromBytesMust(dbHeader.Next)
                        next = &amp;id
                }</span>

                <span class="cov0" title="0">header := mexampleheader.Header{
                        ID:            idwrap.NewFromBytesMust(dbHeader.ID),
                        ExampleID:     idwrap.NewFromBytesMust(dbHeader.ExampleID),
                        DeltaParentID: deltaParentID,
                        HeaderKey:     dbHeader.HeaderKey,
                        Enable:        dbHeader.Enable,
                        Description:   dbHeader.Description,
                        Value:         dbHeader.Value,
                        Prev:          prev,
                        Next:          next,
                }
                headers = append(headers, header)</span>
        }

        <span class="cov0" title="0">return headers, nil</span>
}

func (h HeaderService) GetHeaderByDeltaParentID(ctx context.Context, deltaParentID idwrap.IDWrap) ([]mexampleheader.Header, error) <span class="cov0" title="0">{
        dbHeader, err := h.queries.GetHeaderByDeltaParentID(ctx, &amp;deltaParentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">header := SerializeHeaderModelToDB(dbHeader)
        return []mexampleheader.Header{header}, nil</span>
}

func (h HeaderService) GetHeaderByID(ctx context.Context, headerID idwrap.IDWrap) (mexampleheader.Header, error) <span class="cov0" title="0">{
        dbHeader, err := h.queries.GetHeader(ctx, headerID)
        if err != nil </span><span class="cov0" title="0">{
                return mexampleheader.Header{}, err
        }</span>

        <span class="cov0" title="0">header := SerializeHeaderModelToDB(dbHeader)
        return header, nil</span>
}

func (h HeaderService) CreateHeader(ctx context.Context, header mexampleheader.Header) error <span class="cov0" title="0">{
        return h.queries.CreateHeader(ctx, gen.CreateHeaderParams{
                ID:            header.ID,
                ExampleID:     header.ExampleID,
                DeltaParentID: header.DeltaParentID,
                HeaderKey:     header.HeaderKey,
                Enable:        header.Enable,
                Description:   header.Description,
                Value:         header.Value,
                Prev:          header.Prev,
                Next:          header.Next,
        })
}</span>

func (h HeaderService) CreateHeaderModel(ctx context.Context, header gen.ExampleHeader) error <span class="cov0" title="0">{
        return h.queries.CreateHeader(ctx, gen.CreateHeaderParams{
                ID:            header.ID,
                ExampleID:     header.ExampleID,
                DeltaParentID: header.DeltaParentID,
                HeaderKey:     header.HeaderKey,
                Enable:        header.Enable,
                Description:   header.Description,
                Value:         header.Value,
                Prev:          header.Prev,
                Next:          header.Next,
        })
}</span>

func (h HeaderService) CreateBulkHeader(ctx context.Context, headers []mexampleheader.Header) error <span class="cov0" title="0">{
        const sizeOfChunks = 15
        convertedItems := tgeneric.MassConvert(headers, SerializeHeaderDBToModel)
        for headerChunk := range slices.Chunk(convertedItems, sizeOfChunks) </span><span class="cov0" title="0">{
                if len(headerChunk) &lt; sizeOfChunks </span><span class="cov0" title="0">{
                        for _, header := range headerChunk </span><span class="cov0" title="0">{
                                err := h.CreateHeaderModel(ctx, header)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">item1 := headerChunk[0]
                item2 := headerChunk[1]
                item3 := headerChunk[2]
                item4 := headerChunk[3]
                item5 := headerChunk[4]
                item6 := headerChunk[5]
                item7 := headerChunk[6]
                item8 := headerChunk[7]
                item9 := headerChunk[8]
                item10 := headerChunk[9]
                item11 := headerChunk[10]
                item12 := headerChunk[11]
                item13 := headerChunk[12]
                item14 := headerChunk[13]
                item15 := headerChunk[14]

                params := gen.CreateHeaderBulkParams{
                        // 1
                        ID:            item1.ID,
                        ExampleID:     item1.ExampleID,
                        DeltaParentID: item1.DeltaParentID,
                        HeaderKey:     item1.HeaderKey,
                        Enable:        item1.Enable,
                        Description:   item1.Description,
                        Value:         item1.Value,
                        Prev:          item1.Prev,
                        Next:          item1.Next,
                        // 2
                        ID_2:            item2.ID,
                        ExampleID_2:     item2.ExampleID,
                        DeltaParentID_2: item2.DeltaParentID,
                        HeaderKey_2:     item2.HeaderKey,
                        Enable_2:        item2.Enable,
                        Description_2:   item2.Description,
                        Value_2:         item2.Value,
                        Prev_2:          item2.Prev,
                        Next_2:          item2.Next,
                        // 3
                        ID_3:            item3.ID,
                        ExampleID_3:     item3.ExampleID,
                        DeltaParentID_3: item3.DeltaParentID,
                        HeaderKey_3:     item3.HeaderKey,
                        Enable_3:        item3.Enable,
                        Description_3:   item3.Description,
                        Value_3:         item3.Value,
                        Prev_3:          item3.Prev,
                        Next_3:          item3.Next,
                        // 4
                        ID_4:            item4.ID,
                        ExampleID_4:     item4.ExampleID,
                        DeltaParentID_4: item4.DeltaParentID,
                        HeaderKey_4:     item4.HeaderKey,
                        Enable_4:        item4.Enable,
                        Description_4:   item4.Description,
                        Value_4:         item4.Value,
                        Prev_4:          item4.Prev,
                        Next_4:          item4.Next,
                        // 5
                        ID_5:            item5.ID,
                        ExampleID_5:     item5.ExampleID,
                        DeltaParentID_5: item5.DeltaParentID,
                        HeaderKey_5:     item5.HeaderKey,
                        Enable_5:        item5.Enable,
                        Description_5:   item5.Description,
                        Value_5:         item5.Value,
                        Prev_5:          item5.Prev,
                        Next_5:          item5.Next,
                        // 6
                        ID_6:            item6.ID,
                        ExampleID_6:     item6.ExampleID,
                        DeltaParentID_6: item6.DeltaParentID,
                        HeaderKey_6:     item6.HeaderKey,
                        Enable_6:        item6.Enable,
                        Description_6:   item6.Description,
                        Value_6:         item6.Value,
                        Prev_6:          item6.Prev,
                        Next_6:          item6.Next,
                        // 7
                        ID_7:            item7.ID,
                        ExampleID_7:     item7.ExampleID,
                        DeltaParentID_7: item7.DeltaParentID,
                        HeaderKey_7:     item7.HeaderKey,
                        Enable_7:        item7.Enable,
                        Description_7:   item7.Description,
                        Value_7:         item7.Value,
                        Prev_7:          item7.Prev,
                        Next_7:          item7.Next,
                        // 8
                        ID_8:            item8.ID,
                        ExampleID_8:     item8.ExampleID,
                        DeltaParentID_8: item8.DeltaParentID,
                        HeaderKey_8:     item8.HeaderKey,
                        Enable_8:        item8.Enable,
                        Description_8:   item8.Description,
                        Value_8:         item8.Value,
                        Prev_8:          item8.Prev,
                        Next_8:          item8.Next,
                        // 9
                        ID_9:            item9.ID,
                        ExampleID_9:     item9.ExampleID,
                        DeltaParentID_9: item9.DeltaParentID,
                        HeaderKey_9:     item9.HeaderKey,
                        Enable_9:        item9.Enable,
                        Description_9:   item9.Description,
                        Value_9:         item9.Value,
                        Prev_9:          item9.Prev,
                        Next_9:          item9.Next,
                        // 10
                        ID_10:            item10.ID,
                        ExampleID_10:     item10.ExampleID,
                        DeltaParentID_10: item10.DeltaParentID,
                        HeaderKey_10:     item10.HeaderKey,
                        Enable_10:        item10.Enable,
                        Description_10:   item10.Description,
                        Value_10:         item10.Value,
                        Prev_10:          item10.Prev,
                        Next_10:          item10.Next,
                        // 11
                        ID_11:            item11.ID,
                        ExampleID_11:     item11.ExampleID,
                        DeltaParentID_11: item11.DeltaParentID,
                        HeaderKey_11:     item11.HeaderKey,
                        Enable_11:        item11.Enable,
                        Description_11:   item11.Description,
                        Value_11:         item11.Value,
                        Prev_11:          item11.Prev,
                        Next_11:          item11.Next,
                        // 12
                        ID_12:            item12.ID,
                        ExampleID_12:     item12.ExampleID,
                        DeltaParentID_12: item12.DeltaParentID,
                        HeaderKey_12:     item12.HeaderKey,
                        Enable_12:        item12.Enable,
                        Description_12:   item12.Description,
                        Value_12:         item12.Value,
                        Prev_12:          item12.Prev,
                        Next_12:          item12.Next,
                        // 13
                        ID_13:            item13.ID,
                        ExampleID_13:     item13.ExampleID,
                        DeltaParentID_13: item13.DeltaParentID,
                        HeaderKey_13:     item13.HeaderKey,
                        Enable_13:        item13.Enable,
                        Description_13:   item13.Description,
                        Value_13:         item13.Value,
                        Prev_13:          item13.Prev,
                        Next_13:          item13.Next,
                        // 14
                        ID_14:            item14.ID,
                        ExampleID_14:     item14.ExampleID,
                        DeltaParentID_14: item14.DeltaParentID,
                        HeaderKey_14:     item14.HeaderKey,
                        Enable_14:        item14.Enable,
                        Description_14:   item14.Description,
                        Value_14:         item14.Value,
                        Prev_14:          item14.Prev,
                        Next_14:          item14.Next,
                        // 15
                        ID_15:            item15.ID,
                        ExampleID_15:     item15.ExampleID,
                        DeltaParentID_15: item15.DeltaParentID,
                        HeaderKey_15:     item15.HeaderKey,
                        Enable_15:        item15.Enable,
                        Description_15:   item15.Description,
                        Value_15:         item15.Value,
                        Prev_15:          item15.Prev,
                        Next_15:          item15.Next,
                }
                if err := h.queries.CreateHeaderBulk(ctx, params); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (h HeaderService) UpdateHeader(ctx context.Context, header mexampleheader.Header) error <span class="cov0" title="0">{
        return h.queries.UpdateHeader(ctx, gen.UpdateHeaderParams{
                ID:          header.ID,
                HeaderKey:   header.HeaderKey,
                Enable:      header.Enable,
                Description: header.Description,
                Value:       header.Value,
        })
}</span>

func (h HeaderService) DeleteHeader(ctx context.Context, headerID idwrap.IDWrap) error <span class="cov0" title="0">{
        return h.queries.DeleteHeader(ctx, headerID)
}</span>

func (h HeaderService) ResetHeaderDelta(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        header, err := h.GetHeaderByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">header.DeltaParentID = nil
        header.HeaderKey = ""
        header.Enable = false
        header.Description = ""
        header.Value = ""

        return h.UpdateHeader(ctx, header)</span>
}

// GetHeadersOrdered walks the linked list from head to tail for an example
func (h HeaderService) GetHeadersOrdered(ctx context.Context, exampleID idwrap.IDWrap) ([]mexampleheader.Header, error) <span class="cov0" title="0">{
        dbHeaders, err := h.queries.GetHeadersByExampleIDOrdered(ctx, gen.GetHeadersByExampleIDOrderedParams{
                ExampleID:   exampleID,
                ExampleID_2: exampleID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var headers []mexampleheader.Header
        for _, dbHeader := range dbHeaders </span><span class="cov0" title="0">{
                // Convert the query row to model Header
                var deltaParentID *idwrap.IDWrap
                if dbHeader.DeltaParentID != nil </span><span class="cov0" title="0">{
                        id := idwrap.NewFromBytesMust(dbHeader.DeltaParentID)
                        deltaParentID = &amp;id
                }</span>

                <span class="cov0" title="0">var prev *idwrap.IDWrap
                if dbHeader.Prev != nil </span><span class="cov0" title="0">{
                        id := idwrap.NewFromBytesMust(dbHeader.Prev)
                        prev = &amp;id
                }</span>

                <span class="cov0" title="0">var next *idwrap.IDWrap
                if dbHeader.Next != nil </span><span class="cov0" title="0">{
                        id := idwrap.NewFromBytesMust(dbHeader.Next)
                        next = &amp;id
                }</span>

                <span class="cov0" title="0">header := mexampleheader.Header{
                        ID:            idwrap.NewFromBytesMust(dbHeader.ID),
                        ExampleID:     idwrap.NewFromBytesMust(dbHeader.ExampleID),
                        DeltaParentID: deltaParentID,
                        HeaderKey:     dbHeader.HeaderKey,
                        Enable:        dbHeader.Enable,
                        Description:   dbHeader.Description,
                        Value:         dbHeader.Value,
                        Prev:          prev,
                        Next:          next,
                }
                headers = append(headers, header)</span>
        }

        <span class="cov0" title="0">return headers, nil</span>
}

// UpdateHeaderLinks updates the prev/next pointers for a header
func (h HeaderService) UpdateHeaderLinks(ctx context.Context, headerID idwrap.IDWrap, prev, next *idwrap.IDWrap) error <span class="cov0" title="0">{
        // Get the header to extract its example ID for validation
        header, err := h.GetHeaderByID(ctx, headerID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">return h.queries.UpdateHeaderOrder(ctx, gen.UpdateHeaderOrderParams{
                Prev:      prev,
                Next:      next,
                ID:        headerID,
                ExampleID: header.ExampleID,
        })</span>
}

// AppendHeader adds a header to the end of the linked list for an example
func (h HeaderService) AppendHeader(ctx context.Context, header mexampleheader.Header) error <span class="cov0" title="0">{
        // First, try to get the tail of the current list
        tail, err := h.queries.GetHeaderTail(ctx, header.ExampleID)
        var hasTail bool
        if err != nil &amp;&amp; !errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">hasTail = !errors.Is(err, sql.ErrNoRows)

        if !hasTail </span><span class="cov0" title="0">{
                // No existing headers, this will be the first one
                header.Prev = nil
                header.Next = nil
        }</span> else<span class="cov0" title="0"> {
                // Link this header to the end of the existing list
                header.Prev = &amp;tail.ID
                header.Next = nil
        }</span>

        // Create the header first (must exist before we can reference it)
        <span class="cov0" title="0">if err := h.CreateHeader(ctx, header); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Now update the old tail to point to this new header (if there was a tail)
        <span class="cov0" title="0">if hasTail </span><span class="cov0" title="0">{
                if err := h.queries.UpdateHeaderNext(ctx, gen.UpdateHeaderNextParams{
                        Next:      &amp;header.ID,
                        ID:        tail.ID,
                        ExampleID: header.ExampleID,
                }); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// AppendBulkHeader adds multiple headers to the end of the linked list while maintaining proper linking
func (h HeaderService) AppendBulkHeader(ctx context.Context, headers []mexampleheader.Header) error <span class="cov0" title="0">{
        if len(headers) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Group headers by example ID to handle linked lists separately for each example
        <span class="cov0" title="0">headersByExample := make(map[idwrap.IDWrap][]mexampleheader.Header)
        for _, header := range headers </span><span class="cov0" title="0">{
                headersByExample[header.ExampleID] = append(headersByExample[header.ExampleID], header)
        }</span>

        // Process headers for each example separately
        <span class="cov0" title="0">for exampleID, exampleHeaders := range headersByExample </span><span class="cov0" title="0">{
                // Get the current tail for this example
                tail, err := h.queries.GetHeaderTail(ctx, exampleID)
                var currentTail *idwrap.IDWrap
                if err != nil &amp;&amp; !errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        currentTail = &amp;tail.ID
                }</span>

                // Create headers WITHOUT prev/next first to avoid foreign key violations
                <span class="cov0" title="0">headersToCreate := make([]mexampleheader.Header, len(exampleHeaders))
                for i, header := range exampleHeaders </span><span class="cov0" title="0">{
                        headersToCreate[i] = header
                        headersToCreate[i].Prev = nil
                        headersToCreate[i].Next = nil
                }</span>

                // Create all headers without links first
                <span class="cov0" title="0">if err := h.CreateBulkHeader(ctx, headersToCreate); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Now update the links between headers after they all exist
                <span class="cov0" title="0">for i := range exampleHeaders </span><span class="cov0" title="0">{
                        var prevID, nextID *idwrap.IDWrap
                        
                        if i == 0 </span><span class="cov0" title="0">{
                                // First header links to existing tail
                                prevID = currentTail
                        }</span> else<span class="cov0" title="0"> {
                                // Link to previous header in this batch
                                prevID = &amp;exampleHeaders[i-1].ID
                        }</span>
                        
                        <span class="cov0" title="0">if i &lt; len(exampleHeaders)-1 </span><span class="cov0" title="0">{
                                // Link to next header in this batch
                                nextID = &amp;exampleHeaders[i+1].ID
                        }</span>
                        
                        // Update the header's links using UpdateHeaderOrder
                        <span class="cov0" title="0">if prevID != nil || nextID != nil </span><span class="cov0" title="0">{
                                if err := h.queries.UpdateHeaderOrder(ctx, gen.UpdateHeaderOrderParams{
                                        Prev:      prevID,
                                        Next:      nextID,
                                        ID:        exampleHeaders[i].ID,
                                        ExampleID: exampleID,
                                }); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

                // Finally update the existing tail to point to the first new header (if there was a tail)
                <span class="cov0" title="0">if currentTail != nil </span><span class="cov0" title="0">{
                        if err := h.queries.UpdateHeaderNext(ctx, gen.UpdateHeaderNextParams{
                                Next:      &amp;exampleHeaders[0].ID,
                                ID:        *currentTail,
                                ExampleID: exampleID,
                        }); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// UnlinkHeader removes a header from the linked list by updating surrounding pointers
func (h HeaderService) UnlinkHeader(ctx context.Context, headerID idwrap.IDWrap) error <span class="cov0" title="0">{
        // First get the header to know its current prev/next
        header, err := h.GetHeaderByID(ctx, headerID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update the previous header to point to our next
        <span class="cov0" title="0">if header.Prev != nil </span><span class="cov0" title="0">{
                if err := h.queries.UpdateHeaderNext(ctx, gen.UpdateHeaderNextParams{
                        Next:      header.Next,
                        ID:        *header.Prev,
                        ExampleID: header.ExampleID,
                }); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Update the next header to point to our previous
        <span class="cov0" title="0">if header.Next != nil </span><span class="cov0" title="0">{
                if err := h.queries.UpdateHeaderPrev(ctx, gen.UpdateHeaderPrevParams{
                        Prev:      header.Prev,
                        ID:        *header.Next,
                        ExampleID: header.ExampleID,
                }); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Finally delete the header itself
        <span class="cov0" title="0">return h.DeleteHeader(ctx, headerID)</span>
}

// UpdateHeaderNext updates only the next pointer of a header
func (h HeaderService) UpdateHeaderNext(ctx context.Context, headerID idwrap.IDWrap, next *idwrap.IDWrap) error <span class="cov0" title="0">{
        // Get the header to extract its example ID for validation
        header, err := h.GetHeaderByID(ctx, headerID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">return h.queries.UpdateHeaderNext(ctx, gen.UpdateHeaderNextParams{
                Next:      next,
                ID:        headerID,
                ExampleID: header.ExampleID,
        })</span>
}

// UpdateHeaderPrev updates only the prev pointer of a header
func (h HeaderService) UpdateHeaderPrev(ctx context.Context, headerID idwrap.IDWrap, prev *idwrap.IDWrap) error <span class="cov0" title="0">{
        // Get the header to extract its example ID for validation
        header, err := h.GetHeaderByID(ctx, headerID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">return h.queries.UpdateHeaderPrev(ctx, gen.UpdateHeaderPrevParams{
                Prev:      prev,
                ID:        headerID,
                ExampleID: header.ExampleID,
        })</span>
}

// MoveHeader moves a header to a new position in the linked list relative to another header
// Either afterHeaderID or beforeHeaderID should be provided, not both
// If afterHeaderID is provided, the header will be moved to the position after the target
// If beforeHeaderID is provided, the header will be moved to the position before the target
func (h HeaderService) MoveHeader(ctx context.Context, headerID idwrap.IDWrap, afterHeaderID, beforeHeaderID *idwrap.IDWrap, exampleID idwrap.IDWrap) error <span class="cov0" title="0">{
        // Validate that exactly one position is specified
        if (afterHeaderID == nil &amp;&amp; beforeHeaderID == nil) || (afterHeaderID != nil &amp;&amp; beforeHeaderID != nil) </span><span class="cov0" title="0">{
                return errors.New("exactly one of afterHeaderID or beforeHeaderID must be specified")
        }</span>

        // Get the header to move
        <span class="cov0" title="0">headerToMove, err := h.GetHeaderByID(ctx, headerID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate that header belongs to the specified example
        <span class="cov0" title="0">if headerToMove.ExampleID.Compare(exampleID) != 0 </span><span class="cov0" title="0">{
                return errors.New("header does not belong to the specified example")
        }</span>

        // Determine the target header
        <span class="cov0" title="0">var targetHeaderID idwrap.IDWrap
        var moveAfter bool
        if afterHeaderID != nil </span><span class="cov0" title="0">{
                targetHeaderID = *afterHeaderID
                moveAfter = true
        }</span> else<span class="cov0" title="0"> {
                targetHeaderID = *beforeHeaderID
                moveAfter = false
        }</span>

        // Get the target header
        <span class="cov0" title="0">targetHeader, err := h.GetHeaderByID(ctx, targetHeaderID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate that target header belongs to the same example
        <span class="cov0" title="0">if targetHeader.ExampleID.Compare(exampleID) != 0 </span><span class="cov0" title="0">{
                return errors.New("target header does not belong to the specified example")
        }</span>

        // Check if the move would result in no change (same position)
        <span class="cov0" title="0">if moveAfter </span><span class="cov0" title="0">{
                // Moving after target - no change if header is already after target
                if targetHeader.Next != nil &amp;&amp; targetHeader.Next.Compare(headerID) == 0 </span><span class="cov0" title="0">{
                        return nil // No change needed
                }</span>
        } else<span class="cov0" title="0"> {
                // Moving before target - no change if header is already before target
                if targetHeader.Prev != nil &amp;&amp; targetHeader.Prev.Compare(headerID) == 0 </span><span class="cov0" title="0">{
                        return nil // No change needed
                }</span>
        }

        // Step 1: Remember the original neighbors of the header to move
        <span class="cov0" title="0">originalPrev := headerToMove.Prev
        originalNext := headerToMove.Next

        // Step 2: Unlink the header from its current position
        if originalPrev != nil </span><span class="cov0" title="0">{
                if err := h.UpdateHeaderNext(ctx, *originalPrev, originalNext); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if originalNext != nil </span><span class="cov0" title="0">{
                if err := h.UpdateHeaderPrev(ctx, *originalNext, originalPrev); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Step 3: Insert the header at the new position
        <span class="cov0" title="0">var newPrev, newNext *idwrap.IDWrap

        if moveAfter </span><span class="cov0" title="0">{
                // Moving after target: target &lt;- header -&gt; target.next
                newPrev = &amp;targetHeaderID
                newNext = targetHeader.Next

                // Update target's next to point to our header
                if err := h.UpdateHeaderNext(ctx, targetHeaderID, &amp;headerID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // If target had a next, update its prev to point to our header
                <span class="cov0" title="0">if targetHeader.Next != nil </span><span class="cov0" title="0">{
                        if err := h.UpdateHeaderPrev(ctx, *targetHeader.Next, &amp;headerID); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Moving before target: target.prev &lt;- header -&gt; target
                newPrev = targetHeader.Prev
                newNext = &amp;targetHeaderID

                // If target had a prev, update its next to point to our header
                if targetHeader.Prev != nil </span><span class="cov0" title="0">{
                        if err := h.UpdateHeaderNext(ctx, *targetHeader.Prev, &amp;headerID); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // Update target's prev to point to our header
                <span class="cov0" title="0">if err := h.UpdateHeaderPrev(ctx, targetHeaderID, &amp;headerID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Step 4: Update our header's prev/next pointers
        <span class="cov0" title="0">return h.UpdateHeaderLinks(ctx, headerID, newPrev, newNext)</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package sexamplequery

import (
        "context"
        "database/sql"
        "errors"
        "slices"
        "sort"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mexamplequery"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

var ErrNoQueryFound = errors.New("no error query found")

func SerializeQueryModelToDB(query mexamplequery.Query) gen.ExampleQuery <span class="cov0" title="0">{
        return gen.ExampleQuery{
                ID:            query.ID,
                ExampleID:     query.ExampleID,
                DeltaParentID: query.DeltaParentID,
                QueryKey:      query.QueryKey,
                Enable:        query.Enable,
                Description:   query.Description,
                Value:         query.Value,
        }
}</span>

func SerializeQueryDBToModel(query gen.ExampleQuery) mexamplequery.Query <span class="cov0" title="0">{
        return mexamplequery.Query{
                ID:            query.ID,
                ExampleID:     query.ExampleID,
                DeltaParentID: query.DeltaParentID,
                QueryKey:      query.QueryKey,
                Enable:        query.Enable,
                Description:   query.Description,
                Value:         query.Value,
        }
}</span>

type ExampleQueryService struct {
        queries *gen.Queries
}

func New(queries *gen.Queries) ExampleQueryService <span class="cov0" title="0">{
        return ExampleQueryService{queries: queries}
}</span>

func (h ExampleQueryService) TX(tx *sql.Tx) ExampleQueryService <span class="cov0" title="0">{
        return ExampleQueryService{queries: h.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*ExampleQueryService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">service := ExampleQueryService{queries: queries}
        return &amp;service, nil</span>
}

func (h ExampleQueryService) GetExampleQuery(ctx context.Context, id idwrap.IDWrap) (mexamplequery.Query, error) <span class="cov0" title="0">{
        query, err := h.queries.GetQuery(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return mexamplequery.Query{}, err
        }</span>
        <span class="cov0" title="0">return SerializeQueryDBToModel(query), nil</span>
}

func (h ExampleQueryService) GetExampleQueriesByExampleID(ctx context.Context, exampleID idwrap.IDWrap) ([]mexamplequery.Query, error) <span class="cov0" title="0">{
        queries, err := h.queries.GetQueriesByExampleID(ctx, exampleID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []mexamplequery.Query{}, ErrNoQueryFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">sort.Slice(queries, func(i, j int) bool </span><span class="cov0" title="0">{
                return queries[i].ID.Compare(queries[j].ID) &lt; 0
        }</span>)
        <span class="cov0" title="0">return tgeneric.MassConvert(queries, SerializeQueryDBToModel), nil</span>
}

func (h ExampleQueryService) GetExampleQueryByDeltaParentID(ctx context.Context, deltaParentID *idwrap.IDWrap) (mexamplequery.Query, error) <span class="cov0" title="0">{
        query, err := h.queries.GetQueryByDeltaParentID(ctx, deltaParentID)
        if err != nil </span><span class="cov0" title="0">{
                return mexamplequery.Query{}, err
        }</span>
        <span class="cov0" title="0">return SerializeQueryDBToModel(query), nil</span>
}

func (h ExampleQueryService) CreateExampleQuery(ctx context.Context, query mexamplequery.Query) error <span class="cov0" title="0">{
        return h.queries.CreateQuery(ctx, gen.CreateQueryParams{
                ID:            query.ID,
                ExampleID:     query.ExampleID,
                QueryKey:      query.QueryKey,
                Enable:        query.Enable,
                Description:   query.Description,
                Value:         query.Value,
                DeltaParentID: query.DeltaParentID,
        })
}</span>

func (h ExampleQueryService) CreateExampleQueryDB(ctx context.Context, query gen.ExampleQuery) error <span class="cov0" title="0">{
        return h.queries.CreateQuery(ctx, gen.CreateQueryParams{
                ID:            query.ID,
                ExampleID:     query.ExampleID,
                QueryKey:      query.QueryKey,
                Enable:        query.Enable,
                Description:   query.Description,
                Value:         query.Value,
                DeltaParentID: query.DeltaParentID,
        })
}</span>

func (h ExampleQueryService) CreateBulkQuery(ctx context.Context, queries []mexamplequery.Query) error <span class="cov0" title="0">{
        const sizeOfChunks = 10
        convertedItems := tgeneric.MassConvert(queries, SerializeQueryModelToDB)
        for headerChunk := range slices.Chunk(convertedItems, sizeOfChunks) </span><span class="cov0" title="0">{
                if len(headerChunk) &lt; sizeOfChunks </span><span class="cov0" title="0">{
                        for _, header := range headerChunk </span><span class="cov0" title="0">{
                                err := h.CreateExampleQueryDB(ctx, header)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">item1 := headerChunk[0]
                item2 := headerChunk[1]
                item3 := headerChunk[2]
                item4 := headerChunk[3]
                item5 := headerChunk[4]
                item6 := headerChunk[5]
                item7 := headerChunk[6]
                item8 := headerChunk[7]
                item9 := headerChunk[8]
                item10 := headerChunk[9]

                params := gen.CreateQueryBulkParams{
                        // 1
                        ID:            item1.ID,
                        ExampleID:     item1.ExampleID,
                        DeltaParentID: item1.DeltaParentID,
                        QueryKey:      item1.QueryKey,
                        Enable:        item1.Enable,
                        Description:   item1.Description,
                        Value:         item1.Value,
                        // 2
                        ID_2:            item2.ID,
                        ExampleID_2:     item2.ExampleID,
                        DeltaParentID_2: item2.DeltaParentID,
                        QueryKey_2:      item2.QueryKey,
                        Enable_2:        item2.Enable,
                        Description_2:   item2.Description,
                        Value_2:         item2.Value,
                        // 3
                        ID_3:            item3.ID,
                        ExampleID_3:     item3.ExampleID,
                        DeltaParentID_3: item3.DeltaParentID,
                        QueryKey_3:      item3.QueryKey,
                        Enable_3:        item3.Enable,
                        Description_3:   item3.Description,
                        Value_3:         item3.Value,
                        // 4
                        ID_4:            item4.ID,
                        ExampleID_4:     item4.ExampleID,
                        DeltaParentID_4: item4.DeltaParentID,
                        QueryKey_4:      item4.QueryKey,
                        Enable_4:        item4.Enable,
                        Description_4:   item4.Description,
                        Value_4:         item4.Value,
                        // 5
                        ID_5:            item5.ID,
                        ExampleID_5:     item5.ExampleID,
                        DeltaParentID_5: item5.DeltaParentID,
                        QueryKey_5:      item5.QueryKey,
                        Enable_5:        item5.Enable,
                        Description_5:   item5.Description,
                        Value_5:         item5.Value,
                        // 6
                        ID_6:            item6.ID,
                        ExampleID_6:     item6.ExampleID,
                        DeltaParentID_6: item6.DeltaParentID,
                        QueryKey_6:      item6.QueryKey,
                        Enable_6:        item6.Enable,
                        Description_6:   item6.Description,
                        Value_6:         item6.Value,
                        // 7
                        ID_7:            item7.ID,
                        ExampleID_7:     item7.ExampleID,
                        DeltaParentID_7: item7.DeltaParentID,
                        QueryKey_7:      item7.QueryKey,
                        Enable_7:        item7.Enable,
                        Description_7:   item7.Description,
                        Value_7:         item7.Value,
                        // 8
                        ID_8:            item8.ID,
                        ExampleID_8:     item8.ExampleID,
                        DeltaParentID_8: item8.DeltaParentID,
                        QueryKey_8:      item8.QueryKey,
                        Enable_8:        item8.Enable,
                        Description_8:   item8.Description,
                        Value_8:         item8.Value,
                        // 9
                        ID_9:            item9.ID,
                        ExampleID_9:     item9.ExampleID,
                        DeltaParentID_9: item9.DeltaParentID,
                        QueryKey_9:      item9.QueryKey,
                        Enable_9:        item9.Enable,
                        Description_9:   item9.Description,
                        Value_9:         item9.Value,
                        // 10
                        ID_10:            item10.ID,
                        ExampleID_10:     item10.ExampleID,
                        DeltaParentID_10: item10.DeltaParentID,
                        QueryKey_10:      item10.QueryKey,
                        Enable_10:        item10.Enable,
                        Description_10:   item10.Description,
                        Value_10:         item10.Value,
                }
                if err := h.queries.CreateQueryBulk(ctx, params); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (h ExampleQueryService) UpdateExampleQuery(ctx context.Context, query mexamplequery.Query) error <span class="cov0" title="0">{
        return h.queries.UpdateQuery(ctx, gen.UpdateQueryParams{
                ID:          query.ID,
                QueryKey:    query.QueryKey,
                Enable:      query.Enable,
                Description: query.Description,
                Value:       query.Value,
        })
}</span>

func (h ExampleQueryService) DeleteExampleQuery(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        return h.queries.DeleteQuery(ctx, id)
}</span>

func (h ExampleQueryService) ResetExampleQueryDelta(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        query, err := h.GetExampleQuery(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">query.DeltaParentID = nil
        query.QueryKey = ""
        query.Enable = false
        query.Description = ""
        query.Value = ""

        return h.UpdateExampleQuery(ctx, query)</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package sexampleresp

import (
        "context"
        "database/sql"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mexampleresp"
)

var ErrNoRespFound error = sql.ErrNoRows

type ExampleRespService struct {
        Queries *gen.Queries
}

func New(queries *gen.Queries) ExampleRespService <span class="cov0" title="0">{
        return ExampleRespService{Queries: queries}
}</span>

func (s ExampleRespService) TX(tx *sql.Tx) ExampleRespService <span class="cov0" title="0">{
        return ExampleRespService{Queries: s.Queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*ExampleRespService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;ExampleRespService{
                Queries: queries,
        }, nil</span>
}

func ConvertToDBExampleResp(item mexampleresp.ExampleResp) gen.ExampleResp <span class="cov0" title="0">{
        return gen.ExampleResp{
                ID:               item.ID,
                ExampleID:        item.ExampleID,
                Status:           item.Status,
                Body:             item.Body,
                Duration:         item.Duration,
                BodyCompressType: int8(item.BodyCompressType),
        }
}</span>

func ConvertToModelExampleResp(item gen.ExampleResp) mexampleresp.ExampleResp <span class="cov0" title="0">{
        return mexampleresp.ExampleResp{
                ID:               item.ID,
                ExampleID:        item.ExampleID,
                Status:           item.Status,
                Body:             item.Body,
                Duration:         item.Duration,
                BodyCompressType: mexampleresp.BodyCompressType(item.BodyCompressType),
        }
}</span>

func (s ExampleRespService) GetExampleResp(ctx context.Context, respID idwrap.IDWrap) (*mexampleresp.ExampleResp, error) <span class="cov0" title="0">{
        exampleResp, err := s.Queries.GetExampleResp(ctx, respID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">a := ConvertToModelExampleResp(exampleResp)
        return &amp;a, nil</span>
}

func (s ExampleRespService) GetExampleRespByExampleID(ctx context.Context, exampleID idwrap.IDWrap) (*mexampleresp.ExampleResp, error) <span class="cov0" title="0">{
        exampleResp, err := s.Queries.GetExampleRespByExampleIDLatest(ctx, exampleID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoRespFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">a := ConvertToModelExampleResp(exampleResp)
        return &amp;a, nil</span>
}

func (s ExampleRespService) GetExampleRespByExampleIDLatest(ctx context.Context, exampleID idwrap.IDWrap) (*mexampleresp.ExampleResp, error) <span class="cov0" title="0">{
        exampleResp, err := s.Queries.GetExampleRespByExampleIDLatest(ctx, exampleID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoRespFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">a := ConvertToModelExampleResp(exampleResp)
        return &amp;a, nil</span>
}

func (s ExampleRespService) CreateExampleResp(ctx context.Context, item mexampleresp.ExampleResp) error <span class="cov0" title="0">{
        e := ConvertToDBExampleResp(item)
        return s.Queries.CreateExampleResp(ctx, gen.CreateExampleRespParams{
                ID:               e.ID,
                ExampleID:        e.ExampleID,
                Status:           e.Status,
                Body:             e.Body,
                BodyCompressType: e.BodyCompressType,
                Duration:         e.Duration,
        })
}</span>

func (s ExampleRespService) CreateExampleRespBulk(ctx context.Context, items []mexampleresp.ExampleResp) error <span class="cov0" title="0">{
        var err error
        for _, item := range items </span><span class="cov0" title="0">{
                err = s.CreateExampleResp(ctx, item)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s ExampleRespService) UpdateExampleResp(ctx context.Context, item mexampleresp.ExampleResp) error <span class="cov0" title="0">{
        e := ConvertToDBExampleResp(item)
        return s.Queries.UpdateExampleResp(ctx, gen.UpdateExampleRespParams{
                ID:               e.ID,
                Status:           e.Status,
                Body:             e.Body,
                BodyCompressType: e.BodyCompressType,
                Duration:         e.Duration,
        })
}</span>

func (s ExampleRespService) DeleteExampleResp(ctx context.Context, respID idwrap.IDWrap) error <span class="cov0" title="0">{
        return s.Queries.DeleteExampleResp(ctx, respID)
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">package sexamplerespheader

import (
        "context"
        "database/sql"
        "slices"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mexamplerespheader"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

type ExampleRespHeaderService struct {
        queries *gen.Queries
}

var ErrNoRespHeaderFound error = sql.ErrNoRows

func New(queries *gen.Queries) ExampleRespHeaderService <span class="cov0" title="0">{
        return ExampleRespHeaderService{queries: queries}
}</span>

func (s ExampleRespHeaderService) TX(tx *sql.Tx) ExampleRespHeaderService <span class="cov0" title="0">{
        return ExampleRespHeaderService{queries: s.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*ExampleRespHeaderService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;ExampleRespHeaderService{
                queries: queries,
        }, nil</span>
}

func ConvertToDBExampleRespHeader(item mexamplerespheader.ExampleRespHeader) gen.ExampleRespHeader <span class="cov0" title="0">{
        return gen.ExampleRespHeader{
                ID:            item.ID,
                ExampleRespID: item.ExampleRespID,
                HeaderKey:     item.HeaderKey,
                Value:         item.Value,
        }
}</span>

func ConvertFromDBExampleRespHeader(item gen.ExampleRespHeader) mexamplerespheader.ExampleRespHeader <span class="cov0" title="0">{
        return mexamplerespheader.ExampleRespHeader{
                ID:            item.ID,
                ExampleRespID: item.ExampleRespID,
                HeaderKey:     item.HeaderKey,
                Value:         item.Value,
        }
}</span>

func (s *ExampleRespHeaderService) CreateExampleRespHeader(ctx context.Context, item mexamplerespheader.ExampleRespHeader) error <span class="cov0" title="0">{
        arg := ConvertToDBExampleRespHeader(item)
        return s.queries.CreateExampleRespHeader(ctx, gen.CreateExampleRespHeaderParams{
                ID:            arg.ID,
                ExampleRespID: arg.ExampleRespID,
                HeaderKey:     arg.HeaderKey,
                Value:         arg.Value,
        })
}</span>

func (s *ExampleRespHeaderService) CreateExampleRespHeaderRaw(ctx context.Context, arg gen.ExampleRespHeader) error <span class="cov0" title="0">{
        return s.queries.CreateExampleRespHeader(ctx, gen.CreateExampleRespHeaderParams{
                ID:            arg.ID,
                ExampleRespID: arg.ExampleRespID,
                HeaderKey:     arg.HeaderKey,
                Value:         arg.Value,
        })
}</span>

func (s *ExampleRespHeaderService) CreateExampleRespHeaderBulk(ctx context.Context, headers []mexamplerespheader.ExampleRespHeader) error <span class="cov0" title="0">{
        const sizeOfChunks = 5
        convertedItems := tgeneric.MassConvert(headers, ConvertToDBExampleRespHeader)
        for headerChunk := range slices.Chunk(convertedItems, sizeOfChunks) </span><span class="cov0" title="0">{
                if len(headerChunk) &lt; sizeOfChunks </span><span class="cov0" title="0">{
                        for _, header := range headerChunk </span><span class="cov0" title="0">{
                                err := s.CreateExampleRespHeaderRaw(ctx, header)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">item1 := headerChunk[0]
                item2 := headerChunk[1]
                item3 := headerChunk[2]
                item4 := headerChunk[3]
                item5 := headerChunk[4]

                params := gen.CreateExampleRespHeaderBulkParams{
                        // 1
                        ID:            item1.ID,
                        ExampleRespID: item1.ExampleRespID,
                        HeaderKey:     item1.HeaderKey,
                        Value:         item1.Value,
                        // 2
                        ID_2:            item2.ID,
                        ExampleRespID_2: item2.ExampleRespID,
                        HeaderKey_2:     item2.HeaderKey,
                        Value_2:         item2.Value,
                        // 3
                        ID_3:            item3.ID,
                        ExampleRespID_3: item3.ExampleRespID,
                        HeaderKey_3:     item3.HeaderKey,
                        Value_3:         item3.Value,
                        // 4
                        ID_4:            item4.ID,
                        ExampleRespID_4: item4.ExampleRespID,
                        HeaderKey_4:     item4.HeaderKey,
                        Value_4:         item4.Value,
                        // 5
                        ID_5:            item5.ID,
                        ExampleRespID_5: item5.ExampleRespID,
                        HeaderKey_5:     item5.HeaderKey,
                        Value_5:         item5.Value,
                }
                if err := s.queries.CreateExampleRespHeaderBulk(ctx, params); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *ExampleRespHeaderService) GetExampleRespHeader(ctx context.Context, id idwrap.IDWrap) (mexamplerespheader.ExampleRespHeader, error) <span class="cov0" title="0">{
        item, err := s.queries.GetExampleRespHeader(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return mexamplerespheader.ExampleRespHeader{}, err
        }</span>
        <span class="cov0" title="0">return ConvertFromDBExampleRespHeader(item), nil</span>
}

func (s *ExampleRespHeaderService) GetHeaderByRespID(ctx context.Context, id idwrap.IDWrap) ([]mexamplerespheader.ExampleRespHeader, error) <span class="cov0" title="0">{
        items, err := s.queries.GetExampleRespHeadersByRespID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []mexamplerespheader.ExampleRespHeader{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return tgeneric.MassConvert(items, ConvertFromDBExampleRespHeader), nil</span>
}

func (s *ExampleRespHeaderService) UpdateExampleRespHeader(ctx context.Context, item mexamplerespheader.ExampleRespHeader) error <span class="cov0" title="0">{
        arg := ConvertToDBExampleRespHeader(item)
        return s.queries.UpdateExampleRespHeader(ctx, gen.UpdateExampleRespHeaderParams{
                ID:        arg.ID,
                HeaderKey: arg.HeaderKey,
                Value:     arg.Value,
        })
}</span>

func (s *ExampleRespHeaderService) UpdateExampleRespHeaderBulk(ctx context.Context, items []mexamplerespheader.ExampleRespHeader) error <span class="cov0" title="0">{
        var err error
        for _, item := range items </span><span class="cov0" title="0">{
                err = s.UpdateExampleRespHeader(ctx, item)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *ExampleRespHeaderService) DeleteExampleRespHeader(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        return s.queries.DeleteExampleRespHeader(ctx, id)
}</span>

func (s *ExampleRespHeaderService) DeleteExampleRespHeaderBulk(ctx context.Context, id []idwrap.IDWrap) error <span class="cov0" title="0">{
        for _, item := range id </span><span class="cov0" title="0">{
                err := s.DeleteExampleRespHeader(ctx, item)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package sflow

import (
        "context"
        "database/sql"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mflow"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

type FlowService struct {
        queries *gen.Queries
}

var ErrNoFlowFound = sql.ErrNoRows

func New(queries *gen.Queries) FlowService <span class="cov0" title="0">{
        return FlowService{queries: queries}
}</span>

func (s FlowService) TX(tx *sql.Tx) FlowService <span class="cov0" title="0">{
        return FlowService{queries: s.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*FlowService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;FlowService{
                queries: queries,
        }, nil</span>
}

func ConvertModelToDB(item mflow.Flow) gen.Flow <span class="cov0" title="0">{
        return gen.Flow{
                ID:              item.ID,
                WorkspaceID:     item.WorkspaceID,
                VersionParentID: item.VersionParentID,
                Name:            item.Name,
        }
}</span>

func ConvertDBToModel(item gen.Flow) mflow.Flow <span class="cov0" title="0">{
        return mflow.Flow{
                ID:              item.ID,
                WorkspaceID:     item.WorkspaceID,
                VersionParentID: item.VersionParentID,
                Name:            item.Name,
        }
}</span>

func (s *FlowService) GetFlow(ctx context.Context, id idwrap.IDWrap) (mflow.Flow, error) <span class="cov0" title="0">{
        item, err := s.queries.GetFlow(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return mflow.Flow{}, tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoFlowFound, err)
        }</span>
        <span class="cov0" title="0">return ConvertDBToModel(item), nil</span>
}

func (s *FlowService) GetFlowsByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]mflow.Flow, error) <span class="cov0" title="0">{
        item, err := s.queries.GetFlowsByWorkspaceID(ctx, workspaceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoFlowFound, err)
        }</span>
        <span class="cov0" title="0">return tgeneric.MassConvert(item, ConvertDBToModel), nil</span>
}

func (s *FlowService) GetFlowsByVersionParentID(ctx context.Context, versionParentID idwrap.IDWrap) ([]mflow.Flow, error) <span class="cov0" title="0">{
        item, err := s.queries.GetFlowsByVersionParentID(ctx, &amp;versionParentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoFlowFound, err)
        }</span>
        <span class="cov0" title="0">return tgeneric.MassConvert(item, ConvertDBToModel), nil</span>
}

func (s *FlowService) CreateFlow(ctx context.Context, item mflow.Flow) error <span class="cov0" title="0">{
        arg := ConvertModelToDB(item)
        err := s.queries.CreateFlow(ctx, gen.CreateFlowParams{
                ID:              arg.ID,
                WorkspaceID:     arg.WorkspaceID,
                VersionParentID: arg.VersionParentID,
                Name:            arg.Name,
        })
        return tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoFlowFound, err)
}</span>

func (s *FlowService) CreateFlowBulk(ctx context.Context, flows []mflow.Flow) error <span class="cov0" title="0">{
        var err error
        for _, flow := range flows </span><span class="cov0" title="0">{
                err = s.CreateFlow(ctx, flow)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *FlowService) UpdateFlow(ctx context.Context, flow mflow.Flow) error <span class="cov0" title="0">{
        arg := ConvertModelToDB(flow)
        err := s.queries.UpdateFlow(ctx, gen.UpdateFlowParams{
                ID:   arg.ID,
                Name: arg.Name,
        })
        return tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoFlowFound, err)
}</span>

func (s *FlowService) DeleteFlow(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        err := s.queries.DeleteFlow(ctx, id)
        return tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoFlowFound, err)
}</span>
</pre>
		
		<pre class="file" id="file96" style="display: none">package sflowtag

import (
        "context"
        "database/sql"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mflowtag"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

type FlowTagService struct {
        queries *gen.Queries
}

var ErrNoFlowTag error = sql.ErrNoRows

func New(queries *gen.Queries) FlowTagService <span class="cov0" title="0">{
        return FlowTagService{queries: queries}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*FlowTagService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;FlowTagService{
                queries: queries,
        }, nil</span>
}

func ConvertDBToModel(item gen.FlowTag) mflowtag.FlowTag <span class="cov0" title="0">{
        return mflowtag.FlowTag{
                ID:     item.ID,
                FlowID: item.FlowID,
                TagID:  item.TagID,
        }
}</span>

func ConvertModelToDB(item mflowtag.FlowTag) gen.FlowTag <span class="cov0" title="0">{
        return gen.FlowTag{
                ID:     item.ID,
                FlowID: item.FlowID,
                TagID:  item.TagID,
        }
}</span>

func (s *FlowTagService) GetFlowTag(ctx context.Context, id idwrap.IDWrap) (mflowtag.FlowTag, error) <span class="cov0" title="0">{
        item, err := s.queries.GetFlowTag(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return mflowtag.FlowTag{}, tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoFlowTag, err)
        }</span>
        <span class="cov0" title="0">return ConvertDBToModel(item), nil</span>
}

func (s *FlowTagService) GetFlowTagsByTagID(ctx context.Context, tagID idwrap.IDWrap) ([]mflowtag.FlowTag, error) <span class="cov0" title="0">{
        items, err := s.queries.GetFlowTagsByTagID(ctx, tagID)
        if err != nil </span><span class="cov0" title="0">{
                return []mflowtag.FlowTag{}, tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoFlowTag, err)
        }</span>
        <span class="cov0" title="0">return tgeneric.MassConvert(items, ConvertDBToModel), nil</span>
}

func (s *FlowTagService) CreateFlowTag(ctx context.Context, ftag mflowtag.FlowTag) error <span class="cov0" title="0">{
        arg := ConvertModelToDB(ftag)
        err := s.queries.CreateFlowTag(ctx, gen.CreateFlowTagParams{
                ID:     arg.ID,
                FlowID: arg.FlowID,
                TagID:  arg.TagID,
        })
        return tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoFlowTag, err)
}</span>

func (s *FlowTagService) DeleteFlowTag(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        err := s.queries.DeleteFlowTag(ctx, id)
        return tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoFlowTag, err)
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">package sflowvariable

import (
        "context"
        "database/sql"
        "fmt"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/movable"
)

// FlowVariableMovableRepository implements movable.MovableRepository for FlowVariables
// It adapts position-based operations to linked list operations using prev/next pointers
type FlowVariableMovableRepository struct {
        queries *gen.Queries
}

// NewFlowVariableMovableRepository creates a new FlowVariableMovableRepository
func NewFlowVariableMovableRepository(queries *gen.Queries) *FlowVariableMovableRepository <span class="cov0" title="0">{
        return &amp;FlowVariableMovableRepository{
                queries: queries,
        }
}</span>

// TX returns a new repository instance with transaction support
func (r *FlowVariableMovableRepository) TX(tx *sql.Tx) *FlowVariableMovableRepository <span class="cov0" title="0">{
        return &amp;FlowVariableMovableRepository{
                queries: r.queries.WithTx(tx),
        }
}</span>

// UpdatePosition updates the position of a flow variable in the linked list
// For flow variables, parentID is the flow_id and listType is ignored
func (r *FlowVariableMovableRepository) UpdatePosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap, listType movable.ListType, position int) error <span class="cov0" title="0">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get flow variable to find flow_id
        <span class="cov0" title="0">flowVariable, err := repo.queries.GetFlowVariable(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get flow variable: %w", err)
        }</span>

        // Get ordered list of flow variables in flow
        <span class="cov0" title="0">orderedFlowVariables, err := repo.queries.GetFlowVariablesByFlowIDOrdered(ctx, gen.GetFlowVariablesByFlowIDOrderedParams{
                FlowID:   flowVariable.FlowID,
                FlowID_2: flowVariable.FlowID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get flow variables in order: %w", err)
        }</span>

        // Find current position and validate new position
        <span class="cov0" title="0">currentIdx := -1
        for i, fv := range orderedFlowVariables </span><span class="cov0" title="0">{
                if idwrap.NewFromBytesMust(fv.ID).Compare(itemID) == 0 </span><span class="cov0" title="0">{
                        currentIdx = i
                        break</span>
                }
        }

        <span class="cov0" title="0">if currentIdx == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("flow variable not found in flow")
        }</span>

        <span class="cov0" title="0">if position &lt; 0 || position &gt;= len(orderedFlowVariables) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid position: %d (valid range: 0-%d)", position, len(orderedFlowVariables)-1)
        }</span>

        <span class="cov0" title="0">if currentIdx == position </span><span class="cov0" title="0">{
                // No change needed
                return nil
        }</span>

        // FIXED: Use proper remove/insert pattern to maintain linked list integrity
        // Step 1: Remove the flow variable from its current position
        <span class="cov0" title="0">if err := repo.removeFromPosition(ctx, tx, itemID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove flow variable from current position: %w", err)
        }</span>

        // Step 2: Calculate the target position after removal
        // When we remove an item, positions of items after it shift down by 1
        <span class="cov0" title="0">targetPosition := position
        if currentIdx &lt; position </span><span class="cov0" title="0">{
                targetPosition = position - 1
        }</span>
        
        // Special case: if we're moving to the last position in the original list,
        // we want to append to the end of the reduced list
        <span class="cov0" title="0">if position == len(orderedFlowVariables)-1 </span><span class="cov0" title="0">{
                targetPosition = len(orderedFlowVariables) // This will trigger append to end in insertAtPosition
        }</span>

        // Step 3: Insert the flow variable at the new position
        <span class="cov0" title="0">if err := repo.insertAtPosition(ctx, tx, itemID, flowVariable.FlowID, targetPosition); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert flow variable at new position: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdatePositions updates positions for multiple flow variables in batch
func (r *FlowVariableMovableRepository) UpdatePositions(ctx context.Context, tx *sql.Tx, updates []movable.PositionUpdate) error <span class="cov0" title="0">{
        if len(updates) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Get repository with transaction support
        <span class="cov0" title="0">repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get the flow ID from the first flow variable to validate all are in same flow
        <span class="cov0" title="0">firstFlowVariable, err := repo.queries.GetFlowVariable(ctx, updates[0].ItemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get first flow variable: %w", err)
        }</span>
        <span class="cov0" title="0">flowID := firstFlowVariable.FlowID
        
        // Validate all flow variables are in the same flow and create ID position map
        positionMap := make(map[idwrap.IDWrap]int)
        for _, update := range updates </span><span class="cov0" title="0">{
                flowVariable, err := repo.queries.GetFlowVariable(ctx, update.ItemID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get flow variable %s: %w", update.ItemID.String(), err)
                }</span>
                <span class="cov0" title="0">if flowVariable.FlowID.Compare(flowID) != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("all flow variables must be in the same flow")
                }</span>
                <span class="cov0" title="0">positionMap[update.ItemID] = update.Position</span>
        }
        
        // Build the complete ordered list with all flow variables at their new positions
        <span class="cov0" title="0">orderedIDs := make([]idwrap.IDWrap, len(updates))
        for _, update := range updates </span><span class="cov0" title="0">{
                if update.Position &lt; 0 || update.Position &gt;= len(updates) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid position %d for flow variable %s (valid range: 0-%d)", 
                                update.Position, update.ItemID.String(), len(updates)-1)
                }</span>
                <span class="cov0" title="0">orderedIDs[update.Position] = update.ItemID</span>
        }
        
        // Calculate prev/next pointers for each flow variable in the new order
        <span class="cov0" title="0">type ptrUpdate struct {
                id   idwrap.IDWrap
                prev *idwrap.IDWrap
                next *idwrap.IDWrap
        }
        
        ptrUpdates := make([]ptrUpdate, len(orderedIDs))
        for i, id := range orderedIDs </span><span class="cov0" title="0">{
                var prev, next *idwrap.IDWrap
                
                if i &gt; 0 </span><span class="cov0" title="0">{
                        prev = &amp;orderedIDs[i-1]
                }</span>
                <span class="cov0" title="0">if i &lt; len(orderedIDs)-1 </span><span class="cov0" title="0">{
                        next = &amp;orderedIDs[i+1]
                }</span>
                
                <span class="cov0" title="0">ptrUpdates[i] = ptrUpdate{
                        id:   id,
                        prev: prev,
                        next: next,
                }</span>
        }
        
        // Apply all updates atomically
        <span class="cov0" title="0">for _, update := range ptrUpdates </span><span class="cov0" title="0">{
                if err := repo.queries.UpdateFlowVariableOrder(ctx, gen.UpdateFlowVariableOrderParams{
                        Prev:   update.prev,
                        Next:   update.next,
                        ID:     update.id,
                        FlowID: flowID,
                }); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update flow variable %s order: %w", update.id.String(), err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetMaxPosition returns the maximum position value for flow variables in a flow
// For linked lists, this is the count of flow variables minus 1
func (r *FlowVariableMovableRepository) GetMaxPosition(ctx context.Context, parentID idwrap.IDWrap, listType movable.ListType) (int, error) <span class="cov0" title="0">{
        // For flow variables, parentID is the flow_id
        orderedFlowVariables, err := r.queries.GetFlowVariablesByFlowIDOrdered(ctx, gen.GetFlowVariablesByFlowIDOrderedParams{
                FlowID:   parentID,
                FlowID_2: parentID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return -1, nil // No flow variables means no max position
                }</span>
                <span class="cov0" title="0">return 0, fmt.Errorf("failed to get flow variables in order: %w", err)</span>
        }

        <span class="cov0" title="0">if len(orderedFlowVariables) == 0 </span><span class="cov0" title="0">{
                return -1, nil
        }</span>

        <span class="cov0" title="0">return len(orderedFlowVariables) - 1, nil</span>
}

// GetItemsByParent returns all flow variables under a flow, ordered by position
func (r *FlowVariableMovableRepository) GetItemsByParent(ctx context.Context, parentID idwrap.IDWrap, listType movable.ListType) ([]movable.MovableItem, error) <span class="cov0" title="0">{
        // For flow variables, parentID is the flow_id
        orderedFlowVariables, err := r.queries.GetFlowVariablesByFlowIDOrdered(ctx, gen.GetFlowVariablesByFlowIDOrderedParams{
                FlowID:   parentID,
                FlowID_2: parentID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []movable.MovableItem{}, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get flow variables in order: %w", err)</span>
        }

        // Convert to MovableItem structs
        <span class="cov0" title="0">items := make([]movable.MovableItem, len(orderedFlowVariables))
        for i, fv := range orderedFlowVariables </span><span class="cov0" title="0">{
                items[i] = movable.MovableItem{
                        ID:       idwrap.NewFromBytesMust(fv.ID),
                        ParentID: &amp;parentID, // flow_id as parent
                        Position: int(fv.Position),
                        ListType: listType,
                }
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

// insertAtPosition inserts a flow variable at a specific position in the linked list
// This is a helper method for operations that need to insert new flow variables
func (r *FlowVariableMovableRepository) insertAtPosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap, flowID idwrap.IDWrap, position int) error <span class="cov0" title="0">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get ordered list of flow variables in flow
        <span class="cov0" title="0">orderedFlowVariables, err := repo.queries.GetFlowVariablesByFlowIDOrdered(ctx, gen.GetFlowVariablesByFlowIDOrderedParams{
                FlowID:   flowID,
                FlowID_2: flowID,
        })
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get flow variables in order: %w", err)
        }</span>

        <span class="cov0" title="0">var newPrev, newNext *idwrap.IDWrap

        if len(orderedFlowVariables) == 0 </span><span class="cov0" title="0">{
                // First flow variable in flow
                newPrev = nil
                newNext = nil
        }</span> else<span class="cov0" title="0"> if position == 0 </span><span class="cov0" title="0">{
                // Insert at head
                newPrev = nil
                if len(orderedFlowVariables) &gt; 0 </span><span class="cov0" title="0">{
                        currentHeadID := idwrap.NewFromBytesMust(orderedFlowVariables[0].ID)
                        newNext = &amp;currentHeadID
                        
                        // Get the current head's next pointer to preserve it
                        currentHead, err := repo.queries.GetFlowVariable(ctx, currentHeadID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get current head: %w", err)
                        }</span>
                        
                        // Update the current head to point back to new item
                        <span class="cov0" title="0">err = repo.queries.UpdateFlowVariableOrder(ctx, gen.UpdateFlowVariableOrderParams{
                                Prev:   &amp;itemID,        // Current head's prev now points to new item
                                Next:   currentHead.Next, // Preserve current head's next pointer
                                ID:     currentHeadID,
                                FlowID: flowID,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update current head: %w", err)
                        }</span>
                }
        } else<span class="cov0" title="0"> if position &gt;= len(orderedFlowVariables) </span><span class="cov0" title="0">{
                // Insert at tail
                if len(orderedFlowVariables) &gt; 0 </span><span class="cov0" title="0">{
                        currentTailID := idwrap.NewFromBytesMust(orderedFlowVariables[len(orderedFlowVariables)-1].ID)
                        newPrev = &amp;currentTailID
                        
                        // Get the current tail's prev pointer to preserve it
                        currentTail, err := repo.queries.GetFlowVariable(ctx, currentTailID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get current tail: %w", err)
                        }</span>
                        
                        // Update the current tail to point forward to new item
                        <span class="cov0" title="0">err = repo.queries.UpdateFlowVariableOrder(ctx, gen.UpdateFlowVariableOrderParams{
                                Prev:   currentTail.Prev, // Preserve current tail's prev pointer
                                Next:   &amp;itemID,         // Current tail's next now points to new item
                                ID:     currentTailID,
                                FlowID: flowID,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update current tail: %w", err)
                        }</span>
                }
                <span class="cov0" title="0">newNext = nil</span>
        } else<span class="cov0" title="0"> {
                // Insert in middle
                prevID := idwrap.NewFromBytesMust(orderedFlowVariables[position-1].ID)
                nextID := idwrap.NewFromBytesMust(orderedFlowVariables[position].ID)
                newPrev = &amp;prevID
                newNext = &amp;nextID
                
                // Get existing prev and next items to preserve their other pointers
                prevItem, err := repo.queries.GetFlowVariable(ctx, prevID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get prev item: %w", err)
                }</span>
                
                <span class="cov0" title="0">nextItem, err := repo.queries.GetFlowVariable(ctx, nextID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get next item: %w", err)
                }</span>
                
                // Update prev item to point to new item
                <span class="cov0" title="0">err = repo.queries.UpdateFlowVariableOrder(ctx, gen.UpdateFlowVariableOrderParams{
                        Prev:   prevItem.Prev, // Preserve prev item's own prev pointer
                        Next:   &amp;itemID,       // Point to new item
                        ID:     prevID,
                        FlowID: flowID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update prev item: %w", err)
                }</span>
                
                // Update next item to point back to new item
                <span class="cov0" title="0">err = repo.queries.UpdateFlowVariableOrder(ctx, gen.UpdateFlowVariableOrderParams{
                        Prev:   &amp;itemID,       // Point to new item
                        Next:   nextItem.Next, // Preserve next item's own next pointer
                        ID:     nextID,
                        FlowID: flowID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update next item: %w", err)
                }</span>
        }

        // Set the new item's position
        <span class="cov0" title="0">return repo.queries.UpdateFlowVariableOrder(ctx, gen.UpdateFlowVariableOrderParams{
                Prev:   newPrev,
                Next:   newNext,
                ID:     itemID,
                FlowID: flowID,
        })</span>
}

// removeFromPosition removes a flow variable from its current position in the linked list
// This is a helper method for operations that need to remove flow variables
func (r *FlowVariableMovableRepository) removeFromPosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap) error <span class="cov0" title="0">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get the flow variable to remove and its current prev/next pointers
        <span class="cov0" title="0">flowVariable, err := repo.queries.GetFlowVariable(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get flow variable: %w", err)
        }</span>

        // Update prev flow variable's next pointer to skip the removed flow variable
        <span class="cov0" title="0">if flowVariable.Prev != nil </span><span class="cov0" title="0">{
                err = repo.queries.UpdateFlowVariableNext(ctx, gen.UpdateFlowVariableNextParams{
                        Next:   flowVariable.Next, // Point to the removed flow variable's next
                        ID:     *flowVariable.Prev,
                        FlowID: flowVariable.FlowID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update previous flow variable's next pointer: %w", err)
                }</span>
        }

        // Update next flow variable's prev pointer to skip the removed flow variable
        <span class="cov0" title="0">if flowVariable.Next != nil </span><span class="cov0" title="0">{
                err = repo.queries.UpdateFlowVariablePrev(ctx, gen.UpdateFlowVariablePrevParams{
                        Prev:   flowVariable.Prev, // Point to the removed flow variable's prev
                        ID:     *flowVariable.Next,
                        FlowID: flowVariable.FlowID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update next flow variable's prev pointer: %w", err)
                }</span>
        }

        // Clear the removed flow variable's pointers
        <span class="cov0" title="0">err = repo.queries.UpdateFlowVariableOrder(ctx, gen.UpdateFlowVariableOrderParams{
                Prev:   nil,
                Next:   nil,
                ID:     itemID,
                FlowID: flowVariable.FlowID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear removed flow variable's pointers: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file98" style="display: none">package sflowvariable

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "slices"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mflowvariable"
        "the-dev-tools/server/pkg/movable"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

type FlowVariableService struct {
        queries           *gen.Queries
        movableRepository *FlowVariableMovableRepository
}

var ErrNoFlowVariableFound = errors.New("no flow variable find")

func New(queries *gen.Queries) FlowVariableService <span class="cov0" title="0">{
        // Create the movable repository for flow variables
        movableRepo := NewFlowVariableMovableRepository(queries)
        
        return FlowVariableService{
                queries:           queries,
                movableRepository: movableRepo,
        }
}</span>

func (s FlowVariableService) TX(tx *sql.Tx) FlowVariableService <span class="cov0" title="0">{
        // Create new instances with transaction support
        txQueries := s.queries.WithTx(tx)
        movableRepo := NewFlowVariableMovableRepository(txQueries)
        
        return FlowVariableService{
                queries:           txQueries,
                movableRepository: movableRepo,
        }
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*FlowVariableService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Create movable repository
        <span class="cov0" title="0">movableRepo := NewFlowVariableMovableRepository(queries)
        
        return &amp;FlowVariableService{
                queries:           queries,
                movableRepository: movableRepo,
        }, nil</span>
}

func ConvertModelToDB(item mflowvariable.FlowVariable) gen.FlowVariable <span class="cov0" title="0">{
        return gen.FlowVariable{
                ID:          item.ID,
                FlowID:      item.FlowID,
                Key:         item.Name,
                Value:       item.Value,
                Enabled:     item.Enabled,
                Description: item.Description,
        }
}</span>

func ConvertDBToModel(item gen.FlowVariable) mflowvariable.FlowVariable <span class="cov0" title="0">{
        return mflowvariable.FlowVariable{
                ID:          item.ID,
                FlowID:      item.FlowID,
                Name:        item.Key,
                Value:       item.Value,
                Enabled:     item.Enabled,
                Description: item.Description,
        }
}</span>

func (s *FlowVariableService) GetFlowVariable(ctx context.Context, id idwrap.IDWrap) (mflowvariable.FlowVariable, error) <span class="cov0" title="0">{
        item, err := s.queries.GetFlowVariable(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return mflowvariable.FlowVariable{}, tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoFlowVariableFound, err)
        }</span>
        <span class="cov0" title="0">return ConvertDBToModel(item), nil</span>
}

func (s *FlowVariableService) GetFlowVariablesByFlowID(ctx context.Context, flowID idwrap.IDWrap) ([]mflowvariable.FlowVariable, error) <span class="cov0" title="0">{
        items, err := s.queries.GetFlowVariablesByFlowID(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoFlowVariableFound, err)
        }</span>
        <span class="cov0" title="0">return tgeneric.MassConvert(items, ConvertDBToModel), nil</span>
}

func (s *FlowVariableService) CreateFlowVariable(ctx context.Context, item mflowvariable.FlowVariable) error <span class="cov0" title="0">{
        arg := ConvertModelToDB(item)
        err := s.queries.CreateFlowVariable(ctx, gen.CreateFlowVariableParams{
                ID:          arg.ID,
                FlowID:      arg.FlowID,
                Key:         arg.Key,
                Value:       arg.Value,
                Enabled:     arg.Enabled,
                Description: arg.Description,
        })
        return tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoFlowVariableFound, err)
}</span>

const sizeOfChunks = 10

func (s *FlowVariableService) CreateFlowVariableBulk(ctx context.Context, variables []mflowvariable.FlowVariable) error <span class="cov0" title="0">{

        for chunk := range slices.Chunk(variables, sizeOfChunks) </span><span class="cov0" title="0">{
                if len(chunk) &lt; 10 </span><span class="cov0" title="0">{
                        for _, variable := range chunk </span><span class="cov0" title="0">{
                                err := s.CreateFlowVariable(ctx, variable)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                // Convert all items to DB parameters
                <span class="cov0" title="0">dbItems := tgeneric.MassConvert(chunk, ConvertModelToDB)
                params := s.createBulkParams(dbItems)

                err := s.queries.CreateFlowVariableBulk(ctx, params)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *FlowVariableService) createBulkParams(items []gen.FlowVariable) gen.CreateFlowVariableBulkParams <span class="cov0" title="0">{
        params := gen.CreateFlowVariableBulkParams{}

        // Directly assign each position instead of using a loop
        // Position 1
        params.ID = items[0].ID
        params.FlowID = items[0].FlowID
        params.Key = items[0].Key
        params.Value = items[0].Value
        params.Enabled = items[0].Enabled
        params.Description = items[0].Description

        // Position 2
        params.ID_2 = items[1].ID
        params.FlowID_2 = items[1].FlowID
        params.Key_2 = items[1].Key
        params.Value_2 = items[1].Value
        params.Enabled_2 = items[1].Enabled
        params.Description_2 = items[1].Description

        // Position 3
        params.ID_3 = items[2].ID
        params.FlowID_3 = items[2].FlowID
        params.Key_3 = items[2].Key
        params.Value_3 = items[2].Value
        params.Enabled_3 = items[2].Enabled
        params.Description_3 = items[2].Description

        // Position 4
        params.ID_4 = items[3].ID
        params.FlowID_4 = items[3].FlowID
        params.Key_4 = items[3].Key
        params.Value_4 = items[3].Value
        params.Enabled_4 = items[3].Enabled
        params.Description_4 = items[3].Description

        // Position 5
        params.ID_5 = items[4].ID
        params.FlowID_5 = items[4].FlowID
        params.Key_5 = items[4].Key
        params.Value_5 = items[4].Value
        params.Enabled_5 = items[4].Enabled
        params.Description_5 = items[4].Description

        // Position 6
        params.ID_6 = items[5].ID
        params.FlowID_6 = items[5].FlowID
        params.Key_6 = items[5].Key
        params.Value_6 = items[5].Value
        params.Enabled_6 = items[5].Enabled
        params.Description_6 = items[5].Description

        // Position 7
        params.ID_7 = items[6].ID
        params.FlowID_7 = items[6].FlowID
        params.Key_7 = items[6].Key
        params.Value_7 = items[6].Value
        params.Enabled_7 = items[6].Enabled
        params.Description_7 = items[6].Description

        // Position 8
        params.ID_8 = items[7].ID
        params.FlowID_8 = items[7].FlowID
        params.Key_8 = items[7].Key
        params.Value_8 = items[7].Value
        params.Enabled_8 = items[7].Enabled
        params.Description_8 = items[7].Description

        // Position 9
        params.ID_9 = items[8].ID
        params.FlowID_9 = items[8].FlowID
        params.Key_9 = items[8].Key
        params.Value_9 = items[8].Value
        params.Enabled_9 = items[8].Enabled
        params.Description_9 = items[8].Description

        // Position 10
        params.ID_10 = items[9].ID
        params.FlowID_10 = items[9].FlowID
        params.Key_10 = items[9].Key
        params.Value_10 = items[9].Value
        params.Enabled_10 = items[9].Enabled
        params.Description_10 = items[9].Description

        return params
}</span>

func (s *FlowVariableService) UpdateFlowVariable(ctx context.Context, item mflowvariable.FlowVariable) error <span class="cov0" title="0">{
        err := s.queries.UpdateFlowVariable(ctx, gen.UpdateFlowVariableParams{
                ID:          item.ID,
                Key:         item.Name,
                Value:       item.Value,
                Enabled:     item.Enabled,
                Description: item.Description,
        })
        return tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoFlowVariableFound, err)
}</span>

func (s *FlowVariableService) DeleteFlowVariable(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        err := s.queries.DeleteFlowVariable(ctx, id)
        return tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoFlowVariableFound, err)
}</span>

// GetFlowVariablesByFlowIDOrdered returns flow variables in the flow in their proper order
func (s *FlowVariableService) GetFlowVariablesByFlowIDOrdered(ctx context.Context, flowID idwrap.IDWrap) ([]mflowvariable.FlowVariable, error) <span class="cov0" title="0">{
        // Use the underlying query that maintains the linked list order
        orderedFlowVariables, err := s.queries.GetFlowVariablesByFlowIDOrdered(ctx, gen.GetFlowVariablesByFlowIDOrderedParams{
                FlowID:   flowID,
                FlowID_2: flowID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []mflowvariable.FlowVariable{}, nil
                }</span>
                <span class="cov0" title="0">return nil, tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoFlowVariableFound, err)</span>
        }

        // Convert to model flow variables
        <span class="cov0" title="0">flowVariables := make([]mflowvariable.FlowVariable, len(orderedFlowVariables))
        for i, fv := range orderedFlowVariables </span><span class="cov0" title="0">{
                flowVariables[i] = mflowvariable.FlowVariable{
                        ID:          idwrap.NewFromBytesMust(fv.ID),
                        FlowID:      idwrap.NewFromBytesMust(fv.FlowID),
                        Name:        fv.Key,
                        Value:       fv.Value,
                        Enabled:     fv.Enabled,
                        Description: fv.Description,
                }
        }</span>

        <span class="cov0" title="0">return flowVariables, nil</span>
}

// MoveFlowVariable moves a flow variable to a specific position in the flow
func (s *FlowVariableService) MoveFlowVariable(ctx context.Context, itemID idwrap.IDWrap, position int) error <span class="cov0" title="0">{
        return s.MoveFlowVariableTX(ctx, nil, itemID, position)
}</span>

// MoveFlowVariableTX moves a flow variable to a specific position within a transaction
func (s *FlowVariableService) MoveFlowVariableTX(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap, position int) error <span class="cov0" title="0">{
        service := *s
        if tx != nil </span><span class="cov0" title="0">{
                service = s.TX(tx)
        }</span>

        // Use the movable repository to perform the position-based move
        <span class="cov0" title="0">err := service.movableRepository.UpdatePosition(ctx, tx, itemID, movable.FlowListTypeVariables, position)
        if err != nil </span><span class="cov0" title="0">{
                return tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoFlowVariableFound, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Repository returns the movable repository for advanced operations
func (s *FlowVariableService) Repository() *FlowVariableMovableRepository <span class="cov0" title="0">{
        return s.movableRepository
}</span>

// validateMoveOperation validates that a move operation is safe and valid
func (s *FlowVariableService) validateMoveOperation(ctx context.Context, variableID, targetVariableID idwrap.IDWrap) error <span class="cov0" title="0">{
        if variableID.Compare(targetVariableID) == 0 </span><span class="cov0" title="0">{
                return errors.New("cannot move flow variable relative to itself")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// checkFlowBoundaries ensures both flow variables are in the same flow
func (s *FlowVariableService) checkFlowBoundaries(ctx context.Context, variableID, targetVariableID idwrap.IDWrap) error <span class="cov0" title="0">{
        sourceVariable, err := s.GetFlowVariable(ctx, variableID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get source flow variable: %w", err)
        }</span>

        <span class="cov0" title="0">targetVariable, err := s.GetFlowVariable(ctx, targetVariableID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get target flow variable: %w", err)
        }</span>

        <span class="cov0" title="0">if sourceVariable.FlowID.Compare(targetVariable.FlowID) != 0 </span><span class="cov0" title="0">{
                return errors.New("flow variables must be in the same flow")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// MoveFlowVariableAfter moves a flow variable to be positioned after the target variable
func (s *FlowVariableService) MoveFlowVariableAfter(ctx context.Context, variableID, targetVariableID idwrap.IDWrap) error <span class="cov0" title="0">{
        return s.MoveFlowVariableAfterTX(ctx, nil, variableID, targetVariableID)
}</span>

// MoveFlowVariableAfterTX moves a flow variable to be positioned after the target variable within a transaction
func (s *FlowVariableService) MoveFlowVariableAfterTX(ctx context.Context, tx *sql.Tx, variableID, targetVariableID idwrap.IDWrap) error <span class="cov0" title="0">{
        service := *s
        if tx != nil </span><span class="cov0" title="0">{
                service = s.TX(tx)
        }</span>

        // Validate the move operation
        <span class="cov0" title="0">if err := service.validateMoveOperation(ctx, variableID, targetVariableID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check flow boundaries
        <span class="cov0" title="0">if err := service.checkFlowBoundaries(ctx, variableID, targetVariableID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get flow ID for both variables
        <span class="cov0" title="0">sourceVariable, err := service.GetFlowVariable(ctx, variableID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get source flow variable: %w", err)
        }</span>

        // Get all flow variables in the flow in order
        <span class="cov0" title="0">variables, err := service.GetFlowVariablesByFlowIDOrdered(ctx, sourceVariable.FlowID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get flow variables in order: %w", err)
        }</span>

        // Find positions of source and target variables
        <span class="cov0" title="0">var sourcePos, targetPos int = -1, -1
        for i, v := range variables </span><span class="cov0" title="0">{
                if v.ID.Compare(variableID) == 0 </span><span class="cov0" title="0">{
                        sourcePos = i
                }</span>
                <span class="cov0" title="0">if v.ID.Compare(targetVariableID) == 0 </span><span class="cov0" title="0">{
                        targetPos = i
                }</span>
        }

        <span class="cov0" title="0">if sourcePos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("source flow variable not found in flow")
        }</span>
        <span class="cov0" title="0">if targetPos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("target flow variable not found in flow")
        }</span>

        <span class="cov0" title="0">if sourcePos == targetPos </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot move flow variable relative to itself")
        }</span>

        // Calculate new order: move source to be after target
        <span class="cov0" title="0">newOrder := make([]idwrap.IDWrap, 0, len(variables))

        for i, v := range variables </span><span class="cov0" title="0">{
                if i == sourcePos </span><span class="cov0" title="0">{
                        continue</span> // Skip source variable
                }
                <span class="cov0" title="0">newOrder = append(newOrder, v.ID)
                if i == targetPos </span><span class="cov0" title="0">{
                        newOrder = append(newOrder, variableID) // Insert source after target
                }</span>
        }

        // Reorder flow variables
        <span class="cov0" title="0">return service.ReorderFlowVariablesTX(ctx, tx, sourceVariable.FlowID, newOrder)</span>
}

// MoveFlowVariableBefore moves a flow variable to be positioned before the target variable
func (s *FlowVariableService) MoveFlowVariableBefore(ctx context.Context, variableID, targetVariableID idwrap.IDWrap) error <span class="cov0" title="0">{
        return s.MoveFlowVariableBeforeTX(ctx, nil, variableID, targetVariableID)
}</span>

// MoveFlowVariableBeforeTX moves a flow variable to be positioned before the target variable within a transaction
func (s *FlowVariableService) MoveFlowVariableBeforeTX(ctx context.Context, tx *sql.Tx, variableID, targetVariableID idwrap.IDWrap) error <span class="cov0" title="0">{
        service := *s
        if tx != nil </span><span class="cov0" title="0">{
                service = s.TX(tx)
        }</span>

        // Validate the move operation
        <span class="cov0" title="0">if err := service.validateMoveOperation(ctx, variableID, targetVariableID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check flow boundaries
        <span class="cov0" title="0">if err := service.checkFlowBoundaries(ctx, variableID, targetVariableID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get flow ID for both variables
        <span class="cov0" title="0">sourceVariable, err := service.GetFlowVariable(ctx, variableID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get source flow variable: %w", err)
        }</span>

        // Get all flow variables in the flow in order
        <span class="cov0" title="0">variables, err := service.GetFlowVariablesByFlowIDOrdered(ctx, sourceVariable.FlowID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get flow variables in order: %w", err)
        }</span>

        // Find positions of source and target variables
        <span class="cov0" title="0">var sourcePos, targetPos int = -1, -1
        for i, v := range variables </span><span class="cov0" title="0">{
                if v.ID.Compare(variableID) == 0 </span><span class="cov0" title="0">{
                        sourcePos = i
                }</span>
                <span class="cov0" title="0">if v.ID.Compare(targetVariableID) == 0 </span><span class="cov0" title="0">{
                        targetPos = i
                }</span>
        }

        <span class="cov0" title="0">if sourcePos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("source flow variable not found in flow")
        }</span>
        <span class="cov0" title="0">if targetPos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("target flow variable not found in flow")
        }</span>

        <span class="cov0" title="0">if sourcePos == targetPos </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot move flow variable relative to itself")
        }</span>

        // Calculate new order: move source to be before target
        <span class="cov0" title="0">newOrder := make([]idwrap.IDWrap, 0, len(variables))

        for i, v := range variables </span><span class="cov0" title="0">{
                if i == sourcePos </span><span class="cov0" title="0">{
                        continue</span> // Skip source variable
                }
                <span class="cov0" title="0">if i == targetPos </span><span class="cov0" title="0">{
                        newOrder = append(newOrder, variableID) // Insert source before target
                }</span>
                <span class="cov0" title="0">newOrder = append(newOrder, v.ID)</span>
        }

        // Reorder flow variables
        <span class="cov0" title="0">return service.ReorderFlowVariablesTX(ctx, tx, sourceVariable.FlowID, newOrder)</span>
}

// ReorderFlowVariables performs a bulk reorder of flow variables using the movable system
func (s *FlowVariableService) ReorderFlowVariables(ctx context.Context, flowID idwrap.IDWrap, orderedIDs []idwrap.IDWrap) error <span class="cov0" title="0">{
        return s.ReorderFlowVariablesTX(ctx, nil, flowID, orderedIDs)
}</span>

// ReorderFlowVariablesTX performs a bulk reorder of flow variables using the movable system within a transaction
func (s *FlowVariableService) ReorderFlowVariablesTX(ctx context.Context, tx *sql.Tx, flowID idwrap.IDWrap, orderedIDs []idwrap.IDWrap) error <span class="cov0" title="0">{
        service := *s
        if tx != nil </span><span class="cov0" title="0">{
                service = s.TX(tx)
        }</span>

        // Build position updates using the flow variable list type
        <span class="cov0" title="0">updates := make([]movable.PositionUpdate, len(orderedIDs))
        for i, id := range orderedIDs </span><span class="cov0" title="0">{
                updates[i] = movable.PositionUpdate{
                        ItemID:   id,
                        ListType: movable.FlowListTypeVariables, // Flow variables within a flow
                        Position: i,
                }
        }</span>

        // Execute the batch update using the movable repository
        <span class="cov0" title="0">if err := service.movableRepository.UpdatePositions(ctx, tx, updates); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reorder flow variables: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package sitemapi

import (
        "context"
        "database/sql"
        "slices"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mitemapi"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

type ItemApiService struct {
        queries *gen.Queries
}

func ConvertToDBItemApi(item mitemapi.ItemApi) gen.ItemApi <span class="cov0" title="0">{
        return gen.ItemApi{
                ID:              item.ID,
                CollectionID:    item.CollectionID,
                FolderID:        item.FolderID,
                Name:            item.Name,
                Url:             item.Url,
                Method:          item.Method,
                VersionParentID: item.VersionParentID,
                DeltaParentID:   item.DeltaParentID,
                Hidden:          item.Hidden,
                Prev:            item.Prev,
                Next:            item.Next,
        }
}</span>

func ConvertToModelItemApi(item gen.ItemApi) mitemapi.ItemApi <span class="cov0" title="0">{
        return mitemapi.ItemApi{
                ID:              item.ID,
                CollectionID:    item.CollectionID,
                FolderID:        item.FolderID,
                Name:            item.Name,
                Url:             item.Url,
                Method:          item.Method,
                VersionParentID: item.VersionParentID,
                DeltaParentID:   item.DeltaParentID,
                Hidden:          item.Hidden,
                Prev:            item.Prev,
                Next:            item.Next,
        }
}</span>

var ErrNoItemApiFound = sql.ErrNoRows

func New(queries *gen.Queries) ItemApiService <span class="cov0" title="0">{
        return ItemApiService{queries: queries}
}</span>

func (ias ItemApiService) TX(tx *sql.Tx) ItemApiService <span class="cov0" title="0">{
        return ItemApiService{queries: ias.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*ItemApiService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;ItemApiService{
                queries: queries,
        }, nil</span>
}

func (ias ItemApiService) GetItemApi(ctx context.Context, id idwrap.IDWrap) (*mitemapi.ItemApi, error) <span class="cov0" title="0">{
        itemApi, err := ias.queries.GetItemApi(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoItemApiFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">item := ConvertToModelItemApi(itemApi)
        return &amp;item, nil</span>
}

func (ias ItemApiService) CreateItemApi(ctx context.Context, item *mitemapi.ItemApi) error <span class="cov0" title="0">{
        itemConverted := ConvertToDBItemApi(*item)
        return ias.queries.CreateItemApi(ctx, gen.CreateItemApiParams{
                ID:              itemConverted.ID,
                CollectionID:    itemConverted.CollectionID,
                FolderID:        itemConverted.FolderID,
                Name:            itemConverted.Name,
                Url:             itemConverted.Url,
                Method:          itemConverted.Method,
                Prev:            itemConverted.Prev,
                Next:            itemConverted.Next,
                VersionParentID: itemConverted.VersionParentID,
                DeltaParentID:   itemConverted.DeltaParentID,
                Hidden:          itemConverted.Hidden,
        })
}</span>

func (ias ItemApiService) CreateItemGenApi(ctx context.Context, item *gen.ItemApi) error <span class="cov0" title="0">{
        return ias.queries.CreateItemApi(ctx, gen.CreateItemApiParams{
                ID:              item.ID,
                CollectionID:    item.CollectionID,
                FolderID:        item.FolderID,
                Name:            item.Name,
                Url:             item.Url,
                Method:          item.Method,
                Prev:            item.Prev,
                Next:            item.Next,
                VersionParentID: item.VersionParentID,
                DeltaParentID:   item.DeltaParentID,
                Hidden:          item.Hidden,
        })
}</span>

func (ias ItemApiService) CreateItemApiBulk(ctx context.Context, items []mitemapi.ItemApi) error <span class="cov0" title="0">{
        sizeOfChunks := 10
        convertedItems := tgeneric.MassConvert(items, ConvertToDBItemApi)

        for chunk := range slices.Chunk(convertedItems, sizeOfChunks) </span><span class="cov0" title="0">{
                if len(chunk) &lt; sizeOfChunks </span><span class="cov0" title="0">{
                        for _, item := range chunk </span><span class="cov0" title="0">{
                                err := ias.CreateItemGenApi(ctx, &amp;item)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">item1 := chunk[0]
                item2 := chunk[1]
                item3 := chunk[2]
                item4 := chunk[3]
                item5 := chunk[4]
                item6 := chunk[5]
                item7 := chunk[6]
                item8 := chunk[7]
                item9 := chunk[8]
                item10 := chunk[9]
                params := gen.CreateItemApiBulkParams{
                        // 1
                        ID:              item1.ID,
                        CollectionID:    item1.CollectionID,
                        FolderID:        item1.FolderID,
                        Name:            item1.Name,
                        Url:             item1.Url,
                        Method:          item1.Method,
                        VersionParentID: item1.VersionParentID,
                        DeltaParentID:   item1.DeltaParentID,
                        Prev:            item1.Prev,
                        Next:            item1.Next,
                        Hidden:          item1.Hidden,
                        // 2
                        ID_2:              item2.ID,
                        CollectionID_2:    item2.CollectionID,
                        FolderID_2:        item2.FolderID,
                        Name_2:            item2.Name,
                        Url_2:             item2.Url,
                        Method_2:          item2.Method,
                        VersionParentID_2: item2.VersionParentID,
                        DeltaParentID_2:   item2.DeltaParentID,
                        Prev_2:            item2.Prev,
                        Next_2:            item2.Next,
                        Hidden_2:          item2.Hidden,
                        // 3
                        ID_3:              item3.ID,
                        CollectionID_3:    item3.CollectionID,
                        FolderID_3:        item3.FolderID,
                        Name_3:            item3.Name,
                        Url_3:             item3.Url,
                        Method_3:          item3.Method,
                        VersionParentID_3: item3.VersionParentID,
                        DeltaParentID_3:   item3.DeltaParentID,
                        Prev_3:            item3.Prev,
                        Next_3:            item3.Next,
                        Hidden_3:          item3.Hidden,
                        // 4
                        ID_4:              item4.ID,
                        CollectionID_4:    item4.CollectionID,
                        FolderID_4:        item4.FolderID,
                        Name_4:            item4.Name,
                        Url_4:             item4.Url,
                        Method_4:          item4.Method,
                        VersionParentID_4: item4.VersionParentID,
                        DeltaParentID_4:   item4.DeltaParentID,
                        Prev_4:            item4.Prev,
                        Next_4:            item4.Next,
                        Hidden_4:          item4.Hidden,
                        // 5
                        ID_5:              item5.ID,
                        CollectionID_5:    item5.CollectionID,
                        FolderID_5:        item5.FolderID,
                        Name_5:            item5.Name,
                        Url_5:             item5.Url,
                        Method_5:          item5.Method,
                        VersionParentID_5: item5.VersionParentID,
                        DeltaParentID_5:   item5.DeltaParentID,
                        Prev_5:            item5.Prev,
                        Next_5:            item5.Next,
                        Hidden_5:          item5.Hidden,
                        // 6
                        ID_6:              item6.ID,
                        CollectionID_6:    item6.CollectionID,
                        FolderID_6:        item6.FolderID,
                        Name_6:            item6.Name,
                        Url_6:             item6.Url,
                        Method_6:          item6.Method,
                        VersionParentID_6: item6.VersionParentID,
                        DeltaParentID_6:   item6.DeltaParentID,
                        Prev_6:            item6.Prev,
                        Next_6:            item6.Next,
                        Hidden_6:          item6.Hidden,
                        // 7
                        ID_7:              item7.ID,
                        CollectionID_7:    item7.CollectionID,
                        FolderID_7:        item7.FolderID,
                        Name_7:            item7.Name,
                        Url_7:             item7.Url,
                        Method_7:          item7.Method,
                        VersionParentID_7: item7.VersionParentID,
                        DeltaParentID_7:   item7.DeltaParentID,
                        Prev_7:            item7.Prev,
                        Next_7:            item7.Next,
                        Hidden_7:          item7.Hidden,
                        // 8
                        ID_8:              item8.ID,
                        CollectionID_8:    item8.CollectionID,
                        FolderID_8:        item8.FolderID,
                        Name_8:            item8.Name,
                        Url_8:             item8.Url,
                        Method_8:          item8.Method,
                        VersionParentID_8: item8.VersionParentID,
                        DeltaParentID_8:   item8.DeltaParentID,
                        Prev_8:            item8.Prev,
                        Next_8:            item8.Next,
                        Hidden_8:          item8.Hidden,
                        // 9
                        ID_9:              item9.ID,
                        CollectionID_9:    item9.CollectionID,
                        FolderID_9:        item9.FolderID,
                        Name_9:            item9.Name,
                        Url_9:             item9.Url,
                        Method_9:          item9.Method,
                        VersionParentID_9: item9.VersionParentID,
                        DeltaParentID_9:   item9.DeltaParentID,
                        Prev_9:            item9.Prev,
                        Next_9:            item9.Next,
                        Hidden_9:          item9.Hidden,
                        // 10
                        ID_10:              item10.ID,
                        CollectionID_10:    item10.CollectionID,
                        FolderID_10:        item10.FolderID,
                        Name_10:            item10.Name,
                        Url_10:             item10.Url,
                        Method_10:          item10.Method,
                        VersionParentID_10: item10.VersionParentID,
                        DeltaParentID_10:   item10.DeltaParentID,
                        Prev_10:            item10.Prev,
                        Next_10:            item10.Next,
                        Hidden_10:          item10.Hidden,
                }

                if err := ias.queries.CreateItemApiBulk(ctx, params); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (ias ItemApiService) UpdateItemApi(ctx context.Context, item *mitemapi.ItemApi) error <span class="cov0" title="0">{
        err := ias.queries.UpdateItemApi(ctx, gen.UpdateItemApiParams{
                ID:       item.ID,
                FolderID: item.FolderID,
                Name:     item.Name,
                Url:      item.Url,
                Method:   item.Method,
                Hidden:   item.Hidden,
        })
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return ErrNoItemApiFound
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (ias ItemApiService) UpdateItemApiOrder(ctx context.Context, item *mitemapi.ItemApi) error <span class="cov0" title="0">{
        err := ias.queries.UpdateItemApiOrder(ctx, gen.UpdateItemApiOrderParams{
                Next: item.Next,
                Prev: item.Prev,
                ID:   item.ID,
        })
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return ErrNoItemApiFound
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (ias ItemApiService) DeleteItemApi(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        return ias.queries.DeleteItemApi(ctx, id)
}</span>

func (ias ItemApiService) GetApisWithCollectionID(ctx context.Context, collectionID idwrap.IDWrap) ([]mitemapi.ItemApi, error) <span class="cov0" title="0">{
        itemApis, err := ias.queries.GetItemsApiByCollectionID(ctx, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []mitemapi.ItemApi{}, ErrNoItemApiFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return tgeneric.MassConvert(itemApis, ConvertToModelItemApi), nil</span>
}

func (ias ItemApiService) GetAllApisWithCollectionID(ctx context.Context, collectionID idwrap.IDWrap) ([]mitemapi.ItemApi, error) <span class="cov0" title="0">{
        itemApis, err := ias.queries.GetAllItemsApiByCollectionID(ctx, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []mitemapi.ItemApi{}, ErrNoItemApiFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return tgeneric.MassConvert(itemApis, ConvertToModelItemApi), nil</span>
}

func (ias ItemApiService) GetItemApiByCollectionIDAndNextIDAndParentID(ctx context.Context, collectionID idwrap.IDWrap, nextID, parentID *idwrap.IDWrap) (mitemapi.ItemApi, error) <span class="cov0" title="0">{
        itemApi, err := ias.queries.GetItemApiByCollectionIDAndNextIDAndParentID(ctx, gen.GetItemApiByCollectionIDAndNextIDAndParentIDParams{
                Next:         nextID,
                FolderID:     parentID,
                CollectionID: collectionID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return mitemapi.ItemApi{}, ErrNoItemApiFound
                }</span>
                <span class="cov0" title="0">return mitemapi.ItemApi{}, err</span>
        }
        <span class="cov0" title="0">return ConvertToModelItemApi(itemApi), nil</span>
}

func (ias ItemApiService) GetItemApiByCollectionIDAndURLAndMethod(ctx context.Context, collectionID idwrap.IDWrap, url, method string) (*mitemapi.ItemApi, error) <span class="cov0" title="0">{
        itemApi, err := ias.queries.GetItemApiByCollectionIDAndURLAndMethod(ctx, gen.GetItemApiByCollectionIDAndURLAndMethodParams{
                CollectionID: collectionID,
                Url:          url,
                Method:       method,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoItemApiFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">item := ConvertToModelItemApi(itemApi)
        return &amp;item, nil</span>
}

func (ias ItemApiService) GetWorkspaceID(ctx context.Context, id idwrap.IDWrap) (idwrap.IDWrap, error) <span class="cov0" title="0">{
        ownerUlid, err := ias.queries.GetItemApiWorkspaceID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return idwrap.IDWrap{}, ErrNoItemApiFound
                }</span>
                <span class="cov0" title="0">return idwrap.IDWrap{}, err</span>
        }
        <span class="cov0" title="0">return ownerUlid, err</span>
}

func (ias ItemApiService) CheckWorkspaceID(ctx context.Context, id, ownerID idwrap.IDWrap) (bool, error) <span class="cov0" title="0">{
        collectionWorkspaceID, err := ias.GetWorkspaceID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return false, ErrNoItemApiFound
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov0" title="0">return ownerID.Compare(collectionWorkspaceID) == 0, nil</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package sitemapiexample

import (
        "context"
        "database/sql"
        "fmt"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mitemapiexample"
        "the-dev-tools/server/pkg/movable"
)

// ExampleMovableRepository implements movable.MovableRepository for Examples
// It adapts position-based operations to linked list operations using prev/next pointers
// Examples are scoped by endpoint_id (item_api_id)
type ExampleMovableRepository struct {
        queries *gen.Queries
}

// NewExampleMovableRepository creates a new ExampleMovableRepository
func NewExampleMovableRepository(queries *gen.Queries) *ExampleMovableRepository <span class="cov8" title="1">{
        return &amp;ExampleMovableRepository{
                queries: queries,
        }
}</span>

// TX returns a new repository instance with transaction support
func (r *ExampleMovableRepository) TX(tx *sql.Tx) *ExampleMovableRepository <span class="cov0" title="0">{
        return &amp;ExampleMovableRepository{
                queries: r.queries.WithTx(tx),
        }
}</span>

// UpdatePosition updates the position of an example in the linked list
// For examples, parentID is the endpoint_id (item_api_id) and listType should be CollectionListTypeExamples
// This method performs an atomic move operation that prevents examples from becoming isolated
func (r *ExampleMovableRepository) UpdatePosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap, listType movable.ListType, position int) error <span class="cov8" title="1">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get example to find endpoint_id
        <span class="cov8" title="1">example, err := repo.queries.GetItemApiExample(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get example: %w", err)
        }</span>

        // Get ordered list of examples for the endpoint
        <span class="cov8" title="1">orderedExamples, err := repo.queries.GetExamplesByEndpointIDOrdered(ctx, gen.GetExamplesByEndpointIDOrderedParams{
                ItemApiID:   example.ItemApiID,
                ItemApiID_2: example.ItemApiID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get examples in order: %w", err)
        }</span>

        // Find current position and validate new position
        <span class="cov8" title="1">currentIdx := -1
        for i, ex := range orderedExamples </span><span class="cov8" title="1">{
                if idwrap.NewFromBytesMust(ex.ID).Compare(itemID) == 0 </span><span class="cov8" title="1">{
                        currentIdx = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if currentIdx == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("example not found in endpoint")
        }</span>

        <span class="cov8" title="1">if position &lt; 0 || position &gt;= len(orderedExamples) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid position: %d (valid range: 0-%d)", position, len(orderedExamples)-1)
        }</span>

        <span class="cov8" title="1">if currentIdx == position </span><span class="cov0" title="0">{
                // No change needed
                return nil
        }</span>

        // Perform atomic move operation to prevent isolation
        <span class="cov8" title="1">if err := repo.atomicMove(ctx, tx, itemID, example.ItemApiID, currentIdx, position, orderedExamples); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to perform atomic move: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UpdatePositions updates positions for multiple examples in batch
func (r *ExampleMovableRepository) UpdatePositions(ctx context.Context, tx *sql.Tx, updates []movable.PositionUpdate) error <span class="cov0" title="0">{
        if len(updates) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Get repository with transaction support
        <span class="cov0" title="0">repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get the endpoint ID from the first example to validate all are in same endpoint
        <span class="cov0" title="0">firstExample, err := repo.queries.GetItemApiExample(ctx, updates[0].ItemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get first example: %w", err)
        }</span>
        <span class="cov0" title="0">endpointID := firstExample.ItemApiID
        
        // Validate all examples are in the same endpoint and create ID position map
        positionMap := make(map[idwrap.IDWrap]int)
        for _, update := range updates </span><span class="cov0" title="0">{
                example, err := repo.queries.GetItemApiExample(ctx, update.ItemID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get example %s: %w", update.ItemID.String(), err)
                }</span>
                <span class="cov0" title="0">if example.ItemApiID.Compare(endpointID) != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("all examples must be in the same endpoint")
                }</span>
                <span class="cov0" title="0">positionMap[update.ItemID] = update.Position</span>
        }
        
        // Build the complete ordered list with all examples at their new positions
        <span class="cov0" title="0">orderedIDs := make([]idwrap.IDWrap, len(updates))
        for _, update := range updates </span><span class="cov0" title="0">{
                if update.Position &lt; 0 || update.Position &gt;= len(updates) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid position %d for example %s (valid range: 0-%d)", 
                                update.Position, update.ItemID.String(), len(updates)-1)
                }</span>
                <span class="cov0" title="0">orderedIDs[update.Position] = update.ItemID</span>
        }
        
        // Calculate prev/next pointers for each example in the new order
        <span class="cov0" title="0">type ptrUpdate struct {
                id   idwrap.IDWrap
                prev *idwrap.IDWrap
                next *idwrap.IDWrap
        }
        
        ptrUpdates := make([]ptrUpdate, len(orderedIDs))
        for i, id := range orderedIDs </span><span class="cov0" title="0">{
                var prev, next *idwrap.IDWrap
                
                if i &gt; 0 </span><span class="cov0" title="0">{
                        prev = &amp;orderedIDs[i-1]
                }</span>
                <span class="cov0" title="0">if i &lt; len(orderedIDs)-1 </span><span class="cov0" title="0">{
                        next = &amp;orderedIDs[i+1]
                }</span>
                
                <span class="cov0" title="0">ptrUpdates[i] = ptrUpdate{
                        id:   id,
                        prev: prev,
                        next: next,
                }</span>
        }
        
        // Apply all updates atomically
        <span class="cov0" title="0">for _, update := range ptrUpdates </span><span class="cov0" title="0">{
                if err := repo.queries.UpdateExampleOrder(ctx, gen.UpdateExampleOrderParams{
                        Prev:      update.prev,
                        Next:      update.next,
                        ID:        update.id,
                        ItemApiID: endpointID,
                }); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update example %s order: %w", update.id.String(), err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetMaxPosition returns the maximum position value for examples in an endpoint
// For linked lists, this is the count of examples minus 1
func (r *ExampleMovableRepository) GetMaxPosition(ctx context.Context, parentID idwrap.IDWrap, listType movable.ListType) (int, error) <span class="cov8" title="1">{
        // For examples, parentID is the endpoint_id (item_api_id)
        orderedExamples, err := r.queries.GetExamplesByEndpointIDOrdered(ctx, gen.GetExamplesByEndpointIDOrderedParams{
                ItemApiID:   parentID,
                ItemApiID_2: parentID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return -1, nil // No examples means no max position
                }</span>
                <span class="cov0" title="0">return 0, fmt.Errorf("failed to get examples in order: %w", err)</span>
        }

        <span class="cov8" title="1">if len(orderedExamples) == 0 </span><span class="cov8" title="1">{
                return -1, nil
        }</span>

        <span class="cov8" title="1">return len(orderedExamples) - 1, nil</span>
}

// GetItemsByParent returns all examples under an endpoint, ordered by position
func (r *ExampleMovableRepository) GetItemsByParent(ctx context.Context, parentID idwrap.IDWrap, listType movable.ListType) ([]movable.MovableItem, error) <span class="cov8" title="1">{
        // For examples, parentID is the endpoint_id (item_api_id)
        orderedExamples, err := r.queries.GetExamplesByEndpointIDOrdered(ctx, gen.GetExamplesByEndpointIDOrderedParams{
                ItemApiID:   parentID,
                ItemApiID_2: parentID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []movable.MovableItem{}, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get examples in order: %w", err)</span>
        }

        // Convert to MovableItem structs
        <span class="cov8" title="1">items := make([]movable.MovableItem, len(orderedExamples))
        for i, ex := range orderedExamples </span><span class="cov8" title="1">{
                items[i] = movable.MovableItem{
                        ID:       idwrap.NewFromBytesMust(ex.ID),
                        ParentID: &amp;parentID, // endpoint_id as parent
                        Position: i, // Use index as position (0, 1, 2, etc.)
                        ListType: listType,
                }
        }</span>

        <span class="cov8" title="1">return items, nil</span>
}

// ExampleListType creates a ListType for examples scoped to an endpoint
func ExampleListType(endpointID idwrap.IDWrap) movable.ListType <span class="cov0" title="0">{
        // Return the examples list type from the movable package
        return movable.CollectionListTypeExamples
}</span>

// Create creates a new example with proper linked list management
func (r *ExampleMovableRepository) Create(ctx context.Context, tx *sql.Tx, example mitemapiexample.ItemApiExample) error <span class="cov8" title="1">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Special handling for default examples - they exist outside the user chain
        <span class="cov8" title="1">if example.IsDefault </span><span class="cov8" title="1">{
                // Default examples don't participate in the linked list
                // They have prev=NULL and next=NULL and stay isolated
                arg := ConvertToDBItem(example)
                err := repo.queries.CreateItemApiExample(ctx, gen.CreateItemApiExampleParams{
                        ID:              arg.ID,
                        ItemApiID:       arg.ItemApiID,
                        CollectionID:    arg.CollectionID,
                        IsDefault:       arg.IsDefault,
                        BodyType:        arg.BodyType,
                        Name:            arg.Name,
                        VersionParentID: arg.VersionParentID,
                        Prev:            nil, // Default examples are isolated
                        Next:            nil, // Default examples are isolated
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create default example: %w", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
        
        // For user examples, find the current tail of the user example chain
        // Note: GetExamplesByEndpointIDOrdered already filters out default examples with is_default = FALSE
        <span class="cov8" title="1">orderedExamples, err := repo.queries.GetExamplesByEndpointIDOrdered(ctx, gen.GetExamplesByEndpointIDOrderedParams{
                ItemApiID:   example.ItemApiID,
                ItemApiID_2: example.ItemApiID,
        })
        
        var prevID *idwrap.IDWrap
        if err == nil &amp;&amp; len(orderedExamples) &gt; 0 </span><span class="cov8" title="1">{
                // Get the last example in the ordered list (current tail)
                lastExample := orderedExamples[len(orderedExamples)-1]
                lastID := idwrap.NewFromBytesMust(lastExample.ID)
                prevID = &amp;lastID
        }</span>
        // If no user examples exist yet, this will be the head with prev=NULL
        // This is correct - user examples form their own chain separate from default
        
        // Create the example with proper linking
        <span class="cov8" title="1">arg := ConvertToDBItem(example)
        err = repo.queries.CreateItemApiExample(ctx, gen.CreateItemApiExampleParams{
                ID:              arg.ID,
                ItemApiID:       arg.ItemApiID,
                CollectionID:    arg.CollectionID,
                IsDefault:       arg.IsDefault,
                BodyType:        arg.BodyType,
                Name:            arg.Name,
                VersionParentID: arg.VersionParentID,
                Prev:            prevID, // Link to current tail or NULL if first user example
                Next:            nil,    // New tail has no next
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create example: %w", err)
        }</span>
        
        // If there was a previous tail, update it to point to the new example
        <span class="cov8" title="1">if prevID != nil </span><span class="cov8" title="1">{
                err = repo.queries.UpdateExampleNext(ctx, gen.UpdateExampleNextParams{
                        Next:      &amp;example.ID,
                        ID:        *prevID,
                        ItemApiID: example.ItemApiID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update previous tail: %w", err)
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

// insertAtPosition inserts an example at a specific position in the linked list
// This is a helper method for operations that need to insert examples
func (r *ExampleMovableRepository) insertAtPosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap, endpointID idwrap.IDWrap, position int) error <span class="cov0" title="0">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get ordered list of examples for the endpoint
        <span class="cov0" title="0">orderedExamples, err := repo.queries.GetExamplesByEndpointIDOrdered(ctx, gen.GetExamplesByEndpointIDOrderedParams{
                ItemApiID:   endpointID,
                ItemApiID_2: endpointID,
        })
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get examples in order: %w", err)
        }</span>

        <span class="cov0" title="0">var newPrev, newNext *idwrap.IDWrap

        if len(orderedExamples) == 0 </span><span class="cov0" title="0">{
                // First example for endpoint
                newPrev = nil
                newNext = nil
        }</span> else<span class="cov0" title="0"> if position == 0 </span><span class="cov0" title="0">{
                // Insert at head
                newPrev = nil
                if len(orderedExamples) &gt; 0 </span><span class="cov0" title="0">{
                        currentHeadID := idwrap.NewFromBytesMust(orderedExamples[0].ID)
                        newNext = &amp;currentHeadID
                        
                        // Update the current head to point back to new item
                        err = repo.queries.UpdateExamplePrev(ctx, gen.UpdateExamplePrevParams{
                                Prev:      &amp;itemID,        // Current head's prev now points to new item
                                ID:        currentHeadID,
                                ItemApiID: endpointID,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update current head: %w", err)
                        }</span>
                }
        } else<span class="cov0" title="0"> if position &gt;= len(orderedExamples) </span><span class="cov0" title="0">{
                // Insert at tail
                if len(orderedExamples) &gt; 0 </span><span class="cov0" title="0">{
                        currentTailID := idwrap.NewFromBytesMust(orderedExamples[len(orderedExamples)-1].ID)
                        newPrev = &amp;currentTailID
                        
                        // Update the current tail to point forward to new item
                        err = repo.queries.UpdateExampleNext(ctx, gen.UpdateExampleNextParams{
                                Next:      &amp;itemID,         // Current tail's next now points to new item
                                ID:        currentTailID,
                                ItemApiID: endpointID,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update current tail: %w", err)
                        }</span>
                }
                <span class="cov0" title="0">newNext = nil</span>
        } else<span class="cov0" title="0"> {
                // Insert in middle
                prevID := idwrap.NewFromBytesMust(orderedExamples[position-1].ID)
                nextID := idwrap.NewFromBytesMust(orderedExamples[position].ID)
                newPrev = &amp;prevID
                newNext = &amp;nextID
                
                // Update prev item to point to new item
                err = repo.queries.UpdateExampleNext(ctx, gen.UpdateExampleNextParams{
                        Next:      &amp;itemID,       // Point to new item
                        ID:        prevID,
                        ItemApiID: endpointID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update prev item: %w", err)
                }</span>
                
                // Update next item to point back to new item
                <span class="cov0" title="0">err = repo.queries.UpdateExamplePrev(ctx, gen.UpdateExamplePrevParams{
                        Prev:      &amp;itemID,       // Point to new item
                        ID:        nextID,
                        ItemApiID: endpointID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update next item: %w", err)
                }</span>
        }

        // Set the new item's position
        <span class="cov0" title="0">return repo.queries.UpdateExampleOrder(ctx, gen.UpdateExampleOrderParams{
                Prev:      newPrev,
                Next:      newNext,
                ID:        itemID,
                ItemApiID: endpointID,
        })</span>
}

// atomicMove performs an atomic move operation that prevents examples from becoming isolated
// This replaces the problematic remove/insert pattern with a single atomic operation
func (r *ExampleMovableRepository) atomicMove(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap, endpointID idwrap.IDWrap, currentIdx, targetIdx int, orderedExamples []gen.GetExamplesByEndpointIDOrderedRow) error <span class="cov8" title="1">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Calculate all required pointer updates for the atomic move
        <span class="cov8" title="1">updates, err := repo.calculateAtomicMoveUpdates(itemID, currentIdx, targetIdx, orderedExamples)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to calculate move updates: %w", err)
        }</span>

        // Apply all updates atomically - if any fails, the transaction will rollback
        <span class="cov8" title="1">for _, update := range updates </span><span class="cov8" title="1">{
                if err := repo.queries.UpdateExampleOrder(ctx, gen.UpdateExampleOrderParams{
                        Prev:      update.prev,
                        Next:      update.next,
                        ID:        update.id,
                        ItemApiID: endpointID,
                }); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update example %s pointers: %w", update.id.String(), err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// atomicMoveUpdate represents a single pointer update in an atomic move
type atomicMoveUpdate struct {
        id   idwrap.IDWrap
        prev *idwrap.IDWrap
        next *idwrap.IDWrap
}

// calculateAtomicMoveUpdates calculates all pointer updates needed for atomic move
// This ensures no example ever becomes isolated during the move process
func (r *ExampleMovableRepository) calculateAtomicMoveUpdates(itemID idwrap.IDWrap, currentIdx, targetIdx int, orderedExamples []gen.GetExamplesByEndpointIDOrderedRow) ([]atomicMoveUpdate, error) <span class="cov8" title="1">{
        var updates []atomicMoveUpdate
        
        // Handle empty list case
        if len(orderedExamples) == 0 </span><span class="cov8" title="1">{
                return updates, nil
        }</span>
        
        // Validate indices
        <span class="cov8" title="1">if currentIdx &lt; 0 || currentIdx &gt;= len(orderedExamples) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid currentIdx: %d (valid range: 0-%d)", currentIdx, len(orderedExamples)-1)
        }</span>
        <span class="cov8" title="1">if targetIdx &lt; 0 || targetIdx &gt;= len(orderedExamples) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid targetIdx: %d (valid range: 0-%d)", targetIdx, len(orderedExamples)-1)
        }</span>
        
        // Create a working copy of the example order with the item moved to its new position
        <span class="cov8" title="1">workingOrder := make([]idwrap.IDWrap, len(orderedExamples))
        for i, ex := range orderedExamples </span><span class="cov8" title="1">{
                workingOrder[i] = idwrap.NewFromBytesMust(ex.ID)
        }</span>
        
        // Move item from currentIdx to targetIdx
        <span class="cov8" title="1">movedItem := workingOrder[currentIdx]
        
        // Remove the item from its current position
        workingOrder = append(workingOrder[:currentIdx], workingOrder[currentIdx+1:]...)
        
        // Calculate where to insert in the shortened array
        insertIndex := targetIdx
        if currentIdx &lt; targetIdx </span><span class="cov8" title="1">{
                // When moving forward, we need to account for the removal
                // If targetIdx was the last position in the original array, append to end
                if targetIdx == len(orderedExamples)-1 </span><span class="cov8" title="1">{
                        insertIndex = len(workingOrder) // Append to end
                }</span> else<span class="cov0" title="0"> {
                        insertIndex = targetIdx - 1
                }</span>
        }
        
        // Insert the item at the calculated position
        <span class="cov8" title="1">workingOrder = append(workingOrder[:insertIndex], append([]idwrap.IDWrap{movedItem}, workingOrder[insertIndex:]...)...)
        
        // Calculate new prev/next pointers for all affected examples
        for i, id := range workingOrder </span><span class="cov8" title="1">{
                var prev, next *idwrap.IDWrap
                
                if i &gt; 0 </span><span class="cov8" title="1">{
                        prev = &amp;workingOrder[i-1]
                }</span>
                <span class="cov8" title="1">if i &lt; len(workingOrder)-1 </span><span class="cov8" title="1">{
                        next = &amp;workingOrder[i+1]
                }</span>
                
                // Only include updates for examples that need pointer changes
                <span class="cov8" title="1">needsUpdate := false
                
                // Find current pointers for this example
                for _, ex := range orderedExamples </span><span class="cov8" title="1">{
                        if idwrap.NewFromBytesMust(ex.ID).Compare(id) == 0 </span><span class="cov8" title="1">{
                                // Get current prev/next as idwrap pointers
                                var currentPrev, currentNext *idwrap.IDWrap
                                if ex.Prev != nil </span><span class="cov8" title="1">{
                                        currentPrevID := idwrap.NewFromBytesMust(ex.Prev)
                                        currentPrev = &amp;currentPrevID
                                }</span>
                                <span class="cov8" title="1">if ex.Next != nil </span><span class="cov8" title="1">{
                                        currentNextID := idwrap.NewFromBytesMust(ex.Next)
                                        currentNext = &amp;currentNextID
                                }</span>
                                
                                // Check if prev pointer changed
                                <span class="cov8" title="1">if (prev == nil &amp;&amp; currentPrev != nil) || (prev != nil &amp;&amp; currentPrev == nil) </span><span class="cov8" title="1">{
                                        needsUpdate = true
                                }</span> else<span class="cov0" title="0"> if prev != nil &amp;&amp; currentPrev != nil &amp;&amp; prev.Compare(*currentPrev) != 0 </span><span class="cov0" title="0">{
                                        needsUpdate = true
                                }</span>
                                
                                // Check if next pointer changed
                                <span class="cov8" title="1">if (next == nil &amp;&amp; currentNext != nil) || (next != nil &amp;&amp; currentNext == nil) </span><span class="cov8" title="1">{
                                        needsUpdate = true
                                }</span> else<span class="cov0" title="0"> if next != nil &amp;&amp; currentNext != nil &amp;&amp; next.Compare(*currentNext) != 0 </span><span class="cov0" title="0">{
                                        needsUpdate = true
                                }</span>
                                <span class="cov8" title="1">break</span>
                        }
                }
                
                <span class="cov8" title="1">if needsUpdate </span><span class="cov8" title="1">{
                        updates = append(updates, atomicMoveUpdate{
                                id:   id,
                                prev: prev,
                                next: next,
                        })
                }</span>
        }
        
        <span class="cov8" title="1">return updates, nil</span>
}

// removeFromPosition removes an example from its current position in the linked list
// DEPRECATED: This method creates isolated nodes and should not be used for moves
// Use atomicMove instead for move operations
func (r *ExampleMovableRepository) removeFromPosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap, endpointID idwrap.IDWrap) error <span class="cov0" title="0">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get the example to remove and its current prev/next pointers
        <span class="cov0" title="0">example, err := repo.queries.GetItemApiExample(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get example: %w", err)
        }</span>

        // Update prev example's next pointer to skip the removed example
        <span class="cov0" title="0">if example.Prev != nil </span><span class="cov0" title="0">{
                err = repo.queries.UpdateExampleNext(ctx, gen.UpdateExampleNextParams{
                        Next:      example.Next, // Point to the removed example's next
                        ID:        *example.Prev,
                        ItemApiID: endpointID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update previous example's next pointer: %w", err)
                }</span>
        }

        // Update next example's prev pointer to skip the removed example
        <span class="cov0" title="0">if example.Next != nil </span><span class="cov0" title="0">{
                err = repo.queries.UpdateExamplePrev(ctx, gen.UpdateExamplePrevParams{
                        Prev:      example.Prev, // Point to the removed example's prev
                        ID:        *example.Next,
                        ItemApiID: endpointID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update next example's prev pointer: %w", err)
                }</span>
        }

        // Clear the removed example's pointers
        <span class="cov0" title="0">err = repo.queries.UpdateExampleOrder(ctx, gen.UpdateExampleOrderParams{
                Prev:      nil,
                Next:      nil,
                ID:        itemID,
                ItemApiID: endpointID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear removed example's pointers: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DetectIsolatedExamples finds examples that are isolated (prev=NULL, next=NULL) but are not the only example
// These examples would be invisible to the recursive CTE query but still exist in the database
func (r *ExampleMovableRepository) DetectIsolatedExamples(ctx context.Context, endpointID idwrap.IDWrap) ([]idwrap.IDWrap, error) <span class="cov8" title="1">{
        // Get all examples for this endpoint directly from database
        allExamples, err := r.queries.GetItemApiExamples(ctx, endpointID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get all examples: %w", err)
        }</span>

        // If there's only one example, it's allowed to have prev=NULL and next=NULL
        <span class="cov8" title="1">if len(allExamples) &lt;= 1 </span><span class="cov8" title="1">{
                return []idwrap.IDWrap{}, nil
        }</span>

        <span class="cov8" title="1">var isolated []idwrap.IDWrap
        for _, ex := range allExamples </span><span class="cov8" title="1">{
                // Skip default examples
                if ex.IsDefault </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Skip examples with version parent (not base examples)
                <span class="cov8" title="1">if ex.VersionParentID != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // If example has both prev=NULL and next=NULL, and there are other examples, it's isolated
                <span class="cov8" title="1">if ex.Prev == nil &amp;&amp; ex.Next == nil </span><span class="cov0" title="0">{
                        isolated = append(isolated, ex.ID)
                }</span>
        }

        <span class="cov8" title="1">return isolated, nil</span>
}

// RepairIsolatedExamples automatically links isolated examples back into the chain
// This method should be used for recovery from corrupted linked lists
func (r *ExampleMovableRepository) RepairIsolatedExamples(ctx context.Context, tx *sql.Tx, endpointID idwrap.IDWrap) error <span class="cov8" title="1">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Find isolated examples
        <span class="cov8" title="1">isolatedIDs, err := repo.DetectIsolatedExamples(ctx, endpointID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to detect isolated examples: %w", err)
        }</span>

        <span class="cov8" title="1">if len(isolatedIDs) == 0 </span><span class="cov8" title="1">{
                return nil // No isolated examples to repair
        }</span>

        // Get the current valid chain using the ordered query
        <span class="cov0" title="0">orderedExamples, err := repo.queries.GetExamplesByEndpointIDOrdered(ctx, gen.GetExamplesByEndpointIDOrderedParams{
                ItemApiID:   endpointID,
                ItemApiID_2: endpointID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get ordered examples: %w", err)
        }</span>

        // For each isolated example, append it to the end of the valid chain
        <span class="cov0" title="0">for _, isolatedID := range isolatedIDs </span><span class="cov0" title="0">{
                var newPrev *idwrap.IDWrap
                
                // If there are examples in the valid chain, link to the last one
                if len(orderedExamples) &gt; 0 </span><span class="cov0" title="0">{
                        lastExampleID := idwrap.NewFromBytesMust(orderedExamples[len(orderedExamples)-1].ID)
                        newPrev = &amp;lastExampleID
                        
                        // Update the current tail to point to the isolated example
                        err = repo.queries.UpdateExampleNext(ctx, gen.UpdateExampleNextParams{
                                Next:      &amp;isolatedID,
                                ID:        lastExampleID,
                                ItemApiID: endpointID,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update current tail's next pointer: %w", err)
                        }</span>
                }

                // Update the isolated example to link into the chain
                <span class="cov0" title="0">err = repo.queries.UpdateExampleOrder(ctx, gen.UpdateExampleOrderParams{
                        Prev:      newPrev,
                        Next:      nil, // It becomes the new tail
                        ID:        isolatedID,
                        ItemApiID: endpointID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to link isolated example %s: %w", isolatedID.String(), err)
                }</span>

                // Add this repaired example to our ordered list for next iteration
                <span class="cov0" title="0">orderedExamples = append(orderedExamples, gen.GetExamplesByEndpointIDOrderedRow{
                        ID: isolatedID.Bytes(),
                })</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidateLinkedListIntegrity checks if the linked list structure is valid
// Returns an error if corruption is detected
func (r *ExampleMovableRepository) ValidateLinkedListIntegrity(ctx context.Context, endpointID idwrap.IDWrap) error <span class="cov8" title="1">{
        // Get all examples directly from database
        allExamples, err := r.queries.GetItemApiExamples(ctx, endpointID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get all examples: %w", err)
        }</span>

        // Filter to non-default, base examples
        <span class="cov8" title="1">var baseExamples []gen.ItemApiExample
        for _, ex := range allExamples </span><span class="cov8" title="1">{
                if !ex.IsDefault &amp;&amp; ex.VersionParentID == nil </span><span class="cov8" title="1">{
                        baseExamples = append(baseExamples, ex)
                }</span>
        }

        <span class="cov8" title="1">if len(baseExamples) == 0 </span><span class="cov8" title="1">{
                return nil // No examples to validate
        }</span>

        // Get examples via ordered query (what the API sees)
        <span class="cov8" title="1">orderedExamples, err := r.queries.GetExamplesByEndpointIDOrdered(ctx, gen.GetExamplesByEndpointIDOrderedParams{
                ItemApiID:   endpointID,
                ItemApiID_2: endpointID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get ordered examples: %w", err)
        }</span>

        // Check 1: All base examples should be visible via ordered query
        <span class="cov8" title="1">if len(baseExamples) != len(orderedExamples) </span><span class="cov0" title="0">{
                isolatedIDs, _ := r.DetectIsolatedExamples(ctx, endpointID)
                return fmt.Errorf("linked list corruption detected: %d examples in database, %d visible via API (%d isolated)", 
                        len(baseExamples), len(orderedExamples), len(isolatedIDs))
        }</span>

        // Check 2: Verify pointer consistency
        <span class="cov8" title="1">exampleMap := make(map[string]gen.ItemApiExample)
        for _, ex := range baseExamples </span><span class="cov8" title="1">{
                exampleMap[ex.ID.String()] = ex
        }</span>

        <span class="cov8" title="1">for _, ex := range baseExamples </span><span class="cov8" title="1">{
                exID := ex.ID
                
                // If has prev, prev should point back to this example
                if ex.Prev != nil </span><span class="cov8" title="1">{
                        prevID := *ex.Prev
                        prevEx, exists := exampleMap[prevID.String()]
                        if !exists </span><span class="cov0" title="0">{
                                return fmt.Errorf("example %s points to non-existent prev %s", exID.String(), prevID.String())
                        }</span>
                        <span class="cov8" title="1">if prevEx.Next == nil || prevEx.Next.Compare(exID) != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("bidirectional link broken: %s-&gt;prev-&gt;%s but %s-&gt;next does not point back", 
                                        exID.String(), prevID.String(), prevID.String())
                        }</span>
                }

                // If has next, next should point back to this example
                <span class="cov8" title="1">if ex.Next != nil </span><span class="cov8" title="1">{
                        nextID := *ex.Next
                        nextEx, exists := exampleMap[nextID.String()]
                        if !exists </span><span class="cov0" title="0">{
                                return fmt.Errorf("example %s points to non-existent next %s", exID.String(), nextID.String())
                        }</span>
                        <span class="cov8" title="1">if nextEx.Prev == nil || nextEx.Prev.Compare(exID) != 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("bidirectional link broken: %s-&gt;next-&gt;%s but %s-&gt;prev does not point back", 
                                        exID.String(), nextID.String(), nextID.String())
                        }</span>
                }
        }

        // Check 3: Should have exactly one head (prev=NULL) and one tail (next=NULL)
        <span class="cov8" title="1">heads := 0
        tails := 0
        for _, ex := range baseExamples </span><span class="cov8" title="1">{
                if ex.Prev == nil </span><span class="cov8" title="1">{
                        heads++
                }</span>
                <span class="cov8" title="1">if ex.Next == nil </span><span class="cov8" title="1">{
                        tails++
                }</span>
        }

        <span class="cov8" title="1">if heads != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("linked list has %d head nodes (should be 1)", heads)
        }</span>
        <span class="cov8" title="1">if tails != 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("linked list has %d tail nodes (should be 1)", tails)
        }</span>

        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file101" style="display: none">package sitemapiexample

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "time"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mexamplebreadcrumb"
        "the-dev-tools/server/pkg/model/mitemapiexample"
        "the-dev-tools/server/pkg/model/mitemfolder"
        "the-dev-tools/server/pkg/movable"
        "the-dev-tools/server/pkg/service/scollection"
        "the-dev-tools/server/pkg/service/sitemapi"
        "the-dev-tools/server/pkg/service/sitemfolder"
)

type ItemApiExampleService struct {
        Queries           *gen.Queries
        movableRepository *ExampleMovableRepository
}

var ErrNoItemApiExampleFound = errors.New("no example found")

func New(queries *gen.Queries) ItemApiExampleService <span class="cov8" title="1">{
        return ItemApiExampleService{
                Queries:           queries,
                movableRepository: NewExampleMovableRepository(queries),
        }
}</span>

func (ias ItemApiExampleService) TX(tx *sql.Tx) ItemApiExampleService <span class="cov0" title="0">{
        return ItemApiExampleService{
                Queries:           ias.Queries.WithTx(tx),
                movableRepository: ias.movableRepository.TX(tx),
        }
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*ItemApiExampleService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;ItemApiExampleService{
                Queries:           queries,
                movableRepository: NewExampleMovableRepository(queries),
        }, nil</span>
}

func MassConvert[T any, O any](item []T, convFunc func(T) *O) []O <span class="cov8" title="1">{
        arr := make([]O, len(item))
        for i, v := range item </span><span class="cov8" title="1">{
                arr[i] = *convFunc(v)
        }</span>
        <span class="cov8" title="1">return arr</span>
}

func ConvertToDBItem(item mitemapiexample.ItemApiExample) gen.ItemApiExample <span class="cov8" title="1">{
        // TODO: add headers and query
        return gen.ItemApiExample{
                ID:           item.ID,
                ItemApiID:    item.ItemApiID,
                CollectionID: item.CollectionID,
                IsDefault:    item.IsDefault,
                BodyType:     int8(item.BodyType),
                Name:         item.Name,

                VersionParentID: item.VersionParentID,
                Prev:            item.Prev,
                Next:            item.Next,
        }
}</span>

func ConvertToModelItem(item gen.ItemApiExample) *mitemapiexample.ItemApiExample <span class="cov8" title="1">{
        return &amp;mitemapiexample.ItemApiExample{
                ID:           item.ID,
                ItemApiID:    item.ItemApiID,
                CollectionID: item.CollectionID,
                IsDefault:    item.IsDefault,
                BodyType:     mitemapiexample.BodyType(item.BodyType),
                Name:         item.Name,

                VersionParentID: item.VersionParentID,
                Prev:            item.Prev,
                Next:            item.Next,
        }
}</span>

func ConvertOrderedRowToModelItem(row gen.GetExamplesByEndpointIDOrderedRow) *mitemapiexample.ItemApiExample <span class="cov8" title="1">{
        var versionParentID *idwrap.IDWrap
        if row.VersionParentID != nil </span><span class="cov0" title="0">{
                id := idwrap.NewFromBytesMust(row.VersionParentID)
                versionParentID = &amp;id
        }</span>
        
        <span class="cov8" title="1">var prev *idwrap.IDWrap
        if row.Prev != nil </span><span class="cov8" title="1">{
                id := idwrap.NewFromBytesMust(row.Prev)
                prev = &amp;id
        }</span>
        
        <span class="cov8" title="1">var next *idwrap.IDWrap
        if row.Next != nil </span><span class="cov8" title="1">{
                id := idwrap.NewFromBytesMust(row.Next)
                next = &amp;id
        }</span>

        <span class="cov8" title="1">return &amp;mitemapiexample.ItemApiExample{
                ID:           idwrap.NewFromBytesMust(row.ID),
                ItemApiID:    idwrap.NewFromBytesMust(row.ItemApiID),
                CollectionID: idwrap.NewFromBytesMust(row.CollectionID),
                IsDefault:    row.IsDefault,
                BodyType:     mitemapiexample.BodyType(row.BodyType),
                Name:         row.Name,
                Updated:      time.Now(), // Note: GetExamplesByEndpointIDOrderedRow doesn't include Updated field

                VersionParentID: versionParentID,
                Prev:            prev,
                Next:            next,
        }</span>
}

func (iaes ItemApiExampleService) GetApiExamples(ctx context.Context, apiUlid idwrap.IDWrap) ([]mitemapiexample.ItemApiExample, error) <span class="cov0" title="0">{
        itemApiExamples, err := iaes.Queries.GetItemApiExamples(ctx, apiUlid)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []mitemapiexample.ItemApiExample{}, ErrNoItemApiExampleFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return MassConvert(itemApiExamples, ConvertToModelItem), nil</span>
}

func (iaes ItemApiExampleService) GetApiExamplesOrdered(ctx context.Context, apiUlid idwrap.IDWrap) ([]mitemapiexample.ItemApiExample, error) <span class="cov8" title="1">{
        itemApiExamples, err := iaes.Queries.GetExamplesByEndpointIDOrdered(ctx, gen.GetExamplesByEndpointIDOrderedParams{
                ItemApiID:   apiUlid,
                ItemApiID_2: apiUlid,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []mitemapiexample.ItemApiExample{}, ErrNoItemApiExampleFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return MassConvert(itemApiExamples, ConvertOrderedRowToModelItem), nil</span>
}

// GetAllApiExamples returns ALL examples including isolated ones using the fallback query
func (iaes ItemApiExampleService) GetAllApiExamples(ctx context.Context, endpointID idwrap.IDWrap) ([]mitemapiexample.ItemApiExample, error) <span class="cov8" title="1">{
        examples, err := iaes.Queries.GetAllExamplesByEndpointID(ctx, endpointID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []mitemapiexample.ItemApiExample{}, ErrNoItemApiExampleFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return MassConvert(examples, ConvertToModelItem), nil</span>
}

// AutoLinkIsolatedExamples detects and repairs isolated examples in an endpoint
// This method is defensive - it logs warnings but doesn't fail user operations
func (iaes ItemApiExampleService) AutoLinkIsolatedExamples(ctx context.Context, endpointID idwrap.IDWrap) error <span class="cov8" title="1">{
        // Get all examples (including isolated ones)
        allExamples, err := iaes.GetAllApiExamples(ctx, endpointID)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrNoItemApiExampleFound </span><span class="cov0" title="0">{
                        return nil // No examples to repair
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get all examples: %w", err)</span>
        }

        // Get connected examples via ordered query
        <span class="cov8" title="1">orderedExamples, err := iaes.GetApiExamplesOrdered(ctx, endpointID)
        if err != nil </span><span class="cov0" title="0">{
                if err == ErrNoItemApiExampleFound </span><span class="cov0" title="0">{
                        // If no ordered examples but we have all examples, all are isolated
                        if len(allExamples) &gt; 0 </span><span class="cov0" title="0">{
                                return iaes.movableRepository.RepairIsolatedExamples(ctx, nil, endpointID)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("failed to get ordered examples: %w", err)</span>
        }

        // Compare counts to detect isolated examples
        <span class="cov8" title="1">if len(allExamples) != len(orderedExamples) </span><span class="cov0" title="0">{
                // Found isolated examples - attempt repair
                fmt.Printf("Auto-linking detected %d isolated examples for endpoint %s (total: %d, connected: %d)\n", 
                        len(allExamples)-len(orderedExamples), endpointID.String(), len(allExamples), len(orderedExamples))
                
                err = iaes.movableRepository.RepairIsolatedExamples(ctx, nil, endpointID)
                if err != nil </span><span class="cov0" title="0">{
                        // Log warning but don't fail the operation - this is defensive repair
                        fmt.Printf("Warning: failed to auto-link isolated examples for endpoint %s: %v\n", endpointID.String(), err)
                        return err
                }</span>
                
                <span class="cov0" title="0">fmt.Printf("Successfully auto-linked isolated examples for endpoint %s\n", endpointID.String())</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (iaes ItemApiExampleService) GetApiExamplesWithDefaults(ctx context.Context, endpointID idwrap.IDWrap) ([]mitemapiexample.ItemApiExample, error) <span class="cov0" title="0">{
        itemApiExamples, err := iaes.Queries.GetItemApiExamplesWithDefaults(ctx, endpointID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []mitemapiexample.ItemApiExample{}, ErrNoItemApiExampleFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return MassConvert(itemApiExamples, ConvertToModelItem), nil</span>
}

func (iaes ItemApiExampleService) GetDefaultApiExample(ctx context.Context, apiUlid idwrap.IDWrap) (*mitemapiexample.ItemApiExample, error) <span class="cov8" title="1">{
        itemApiExample, err := iaes.Queries.GetItemApiExampleDefault(ctx, apiUlid)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoItemApiExampleFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">return ConvertToModelItem(itemApiExample), nil</span>
}

func (iaes ItemApiExampleService) GetApiExample(ctx context.Context, id idwrap.IDWrap) (*mitemapiexample.ItemApiExample, error) <span class="cov8" title="1">{
        itemApiExample, err := iaes.Queries.GetItemApiExample(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoItemApiExampleFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return ConvertToModelItem(itemApiExample), nil</span>
}

func (iaes ItemApiExampleService) GetExampleAllParents(ctx context.Context, id idwrap.IDWrap, collectionService scollection.CollectionService, folderService sitemfolder.ItemFolderService, endpointService sitemapi.ItemApiService) ([]mexamplebreadcrumb.ExampleBreadcrumb, error) <span class="cov0" title="0">{

        example, err := iaes.GetApiExample(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">endpoint, err := endpointService.GetItemApi(ctx, example.ItemApiID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">collection, err := collectionService.GetCollection(ctx, example.CollectionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">folderID := endpoint.FolderID
        var folders []mitemfolder.ItemFolder
        for folderID != nil </span><span class="cov0" title="0">{
                folder, err := folderService.GetFolder(ctx, *folderID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">folders = append(folders, *folder)
                folderID = folder.ParentID</span>
        }

        <span class="cov0" title="0">var crumbs []mexamplebreadcrumb.ExampleBreadcrumb

        crumbs = append(crumbs, mexamplebreadcrumb.ExampleBreadcrumb{
                Kind:       mexamplebreadcrumb.EXAMPLE_BREADCRUMB_KIND_COLLECTION,
                Collection: collection,
        })
        for _, folder := range folders </span><span class="cov0" title="0">{
                crumbs = append(crumbs, mexamplebreadcrumb.ExampleBreadcrumb{
                        Kind:   mexamplebreadcrumb.EXAMPLE_BREADCRUMB_KIND_FOLDER,
                        Folder: &amp;folder,
                })
        }</span>
        <span class="cov0" title="0">crumbs = append(crumbs, mexamplebreadcrumb.ExampleBreadcrumb{
                Kind:     mexamplebreadcrumb.EXAMPLE_BREADCRUMB_KIND_ENDPOINT,
                Endpoint: endpoint,
        })

        return crumbs, nil</span>
}

func (iaes ItemApiExampleService) GetApiExampleByCollection(ctx context.Context, collectionID idwrap.IDWrap) ([]mitemapiexample.ItemApiExample, error) <span class="cov0" title="0">{
        itemApiExamples, err := iaes.Queries.GetItemApiExampleByCollectionID(ctx, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []mitemapiexample.ItemApiExample{}, ErrNoItemApiExampleFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return MassConvert(itemApiExamples, ConvertToModelItem), nil</span>
}

func (iaes ItemApiExampleService) GetApiExampleByVersionParentID(ctx context.Context, versionID idwrap.IDWrap) ([]mitemapiexample.ItemApiExample, error) <span class="cov0" title="0">{
        itemApiExamples, err := iaes.Queries.GetItemApiExampleByVersionParentID(ctx, &amp;versionID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []mitemapiexample.ItemApiExample{}, ErrNoItemApiExampleFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return MassConvert(itemApiExamples, ConvertToModelItem), nil</span>
}

func (iaes ItemApiExampleService) CreateApiExample(ctx context.Context, item *mitemapiexample.ItemApiExample) error <span class="cov8" title="1">{
        // Use the movable repository for proper linked list management
        // This ensures examples are correctly linked when created
        return iaes.movableRepository.Create(ctx, nil, *item)
}</span>


func (iaes ItemApiExampleService) CreateApiExampleBulk(ctx context.Context, items []mitemapiexample.ItemApiExample) error <span class="cov8" title="1">{
        // For bulk creation, use the individual CreateApiExample method to ensure proper linking
        // This is simpler and more reliable than trying to handle bulk linking logic
        for _, item := range items </span><span class="cov8" title="1">{
                err := iaes.CreateApiExample(ctx, &amp;item)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create example %s: %w", item.ID.String(), err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (iaes ItemApiExampleService) UpdateItemApiExample(ctx context.Context, item *mitemapiexample.ItemApiExample) error <span class="cov0" title="0">{
        return iaes.Queries.UpdateItemApiExample(ctx, gen.UpdateItemApiExampleParams{
                ID:       item.ID,
                Name:     item.Name,
                BodyType: int8(item.BodyType),
        })
}</span>

func (iaes ItemApiExampleService) UpdateItemApiExampleOrder(ctx context.Context, example *mitemapiexample.ItemApiExample) error <span class="cov0" title="0">{
        return iaes.Queries.UpdateItemApiExampleOrder(ctx, gen.UpdateItemApiExampleOrderParams{
                ID:   example.ID,
                Next: example.Next,
                Prev: example.Prev,
        })
}</span>

func (iaes ItemApiExampleService) DeleteApiExample(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        return iaes.Queries.DeleteItemApiExample(ctx, id)
}</span>

// GetMovableRepository returns the movable repository for example operations
func (iaes ItemApiExampleService) GetMovableRepository() *ExampleMovableRepository <span class="cov0" title="0">{
        return iaes.movableRepository
}</span>

// MoveExample moves an example to a specific position within an endpoint
func (iaes ItemApiExampleService) MoveExample(ctx context.Context, endpointID, exampleID idwrap.IDWrap, position int) error <span class="cov0" title="0">{
        err := iaes.MoveExampleTX(ctx, nil, endpointID, exampleID, position)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Auto-repair any isolated examples after move (defensive programming)
        <span class="cov0" title="0">repairErr := iaes.AutoLinkIsolatedExamples(ctx, endpointID)
        if repairErr != nil </span><span class="cov0" title="0">{
                // Log warning but don't fail the move operation - user's move succeeded
                fmt.Printf("Warning: auto-linking after move failed for endpoint %s: %v\n", endpointID.String(), repairErr)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// MoveExampleTX moves an example to a specific position within a transaction
func (iaes ItemApiExampleService) MoveExampleTX(ctx context.Context, tx *sql.Tx, endpointID, exampleID idwrap.IDWrap, position int) error <span class="cov0" title="0">{
        service := iaes
        if tx != nil </span><span class="cov0" title="0">{
                service = iaes.TX(tx)
        }</span>

        // Validate example belongs to endpoint
        <span class="cov0" title="0">example, err := service.GetApiExample(ctx, exampleID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("example not found: %w", err)
        }</span>
        
        <span class="cov0" title="0">if example.ItemApiID.Compare(endpointID) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("example does not belong to the specified endpoint")
        }</span>

        // Use repository to perform the move
        <span class="cov0" title="0">repo := service.GetMovableRepository()
        return repo.UpdatePosition(ctx, tx, exampleID, movable.CollectionListTypeExamples, position)</span>
}

// MoveExampleAfter moves an example to be positioned after the target example
func (iaes ItemApiExampleService) MoveExampleAfter(ctx context.Context, endpointID, exampleID, targetExampleID idwrap.IDWrap) error <span class="cov0" title="0">{
        err := iaes.MoveExampleAfterTX(ctx, nil, endpointID, exampleID, targetExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Auto-repair any isolated examples after move (defensive programming)
        <span class="cov0" title="0">repairErr := iaes.AutoLinkIsolatedExamples(ctx, endpointID)
        if repairErr != nil </span><span class="cov0" title="0">{
                // Log warning but don't fail the move operation - user's move succeeded
                fmt.Printf("Warning: auto-linking after move failed for endpoint %s: %v\n", endpointID.String(), repairErr)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// MoveExampleAfterTX moves an example to be positioned after the target example within a transaction
func (iaes ItemApiExampleService) MoveExampleAfterTX(ctx context.Context, tx *sql.Tx, endpointID, exampleID, targetExampleID idwrap.IDWrap) error <span class="cov0" title="0">{
        service := iaes
        if tx != nil </span><span class="cov0" title="0">{
                service = iaes.TX(tx)
        }</span>

        // Validate examples belong to endpoint and prevent self-move
        <span class="cov0" title="0">if err := service.validateExampleMove(ctx, endpointID, exampleID, targetExampleID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get current position of target example
        <span class="cov0" title="0">targetPosition, err := service.getExamplePosition(ctx, endpointID, targetExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get target example position: %w", err)
        }</span>

        // Get total number of examples to ensure position is valid
        <span class="cov0" title="0">orderedExamples, err := service.Queries.GetExamplesByEndpointIDOrdered(ctx, gen.GetExamplesByEndpointIDOrderedParams{
                ItemApiID:   endpointID,
                ItemApiID_2: endpointID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get ordered examples: %w", err)
        }</span>

        // Move to position after target (target position + 1)
        // But ensure it doesn't exceed the valid range
        <span class="cov0" title="0">newPosition := targetPosition + 1
        maxPosition := len(orderedExamples) - 1
        if newPosition &gt; maxPosition </span><span class="cov0" title="0">{
                newPosition = maxPosition
        }</span>

        <span class="cov0" title="0">repo := service.GetMovableRepository()
        return repo.UpdatePosition(ctx, tx, exampleID, movable.CollectionListTypeExamples, newPosition)</span>
}

// MoveExampleBefore moves an example to be positioned before the target example
func (iaes ItemApiExampleService) MoveExampleBefore(ctx context.Context, endpointID, exampleID, targetExampleID idwrap.IDWrap) error <span class="cov0" title="0">{
        err := iaes.MoveExampleBeforeTX(ctx, nil, endpointID, exampleID, targetExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Auto-repair any isolated examples after move (defensive programming)
        <span class="cov0" title="0">repairErr := iaes.AutoLinkIsolatedExamples(ctx, endpointID)
        if repairErr != nil </span><span class="cov0" title="0">{
                // Log warning but don't fail the move operation - user's move succeeded
                fmt.Printf("Warning: auto-linking after move failed for endpoint %s: %v\n", endpointID.String(), repairErr)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// MoveExampleBeforeTX moves an example to be positioned before the target example within a transaction
func (iaes ItemApiExampleService) MoveExampleBeforeTX(ctx context.Context, tx *sql.Tx, endpointID, exampleID, targetExampleID idwrap.IDWrap) error <span class="cov0" title="0">{
        service := iaes
        if tx != nil </span><span class="cov0" title="0">{
                service = iaes.TX(tx)
        }</span>

        // Validate examples belong to endpoint and prevent self-move
        <span class="cov0" title="0">if err := service.validateExampleMove(ctx, endpointID, exampleID, targetExampleID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get current position of target example
        <span class="cov0" title="0">targetPosition, err := service.getExamplePosition(ctx, endpointID, targetExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get target example position: %w", err)
        }</span>

        // Move to position before target (target position)
        <span class="cov0" title="0">repo := service.GetMovableRepository()
        return repo.UpdatePosition(ctx, tx, exampleID, movable.CollectionListTypeExamples, targetPosition)</span>
}

// validateExampleMove validates that examples belong to the endpoint and prevents self-moves
func (iaes ItemApiExampleService) validateExampleMove(ctx context.Context, endpointID, exampleID, targetExampleID idwrap.IDWrap) error <span class="cov0" title="0">{
        // Prevent self-move
        if exampleID.Compare(targetExampleID) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot move example relative to itself")
        }</span>

        // Validate source example belongs to endpoint
        <span class="cov0" title="0">example, err := iaes.GetApiExample(ctx, exampleID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("source example not found: %w", err)
        }</span>
        
        <span class="cov0" title="0">if example.ItemApiID.Compare(endpointID) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("source example does not belong to the specified endpoint")
        }</span>

        // Validate target example belongs to endpoint
        <span class="cov0" title="0">targetExample, err := iaes.GetApiExample(ctx, targetExampleID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("target example not found: %w", err)
        }</span>
        
        <span class="cov0" title="0">if targetExample.ItemApiID.Compare(endpointID) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("target example does not belong to the specified endpoint")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getExamplePosition gets the position of an example within an endpoint
func (iaes ItemApiExampleService) getExamplePosition(ctx context.Context, endpointID, exampleID idwrap.IDWrap) (int, error) <span class="cov0" title="0">{
        // Get ordered examples for the endpoint
        orderedExamples, err := iaes.Queries.GetExamplesByEndpointIDOrdered(ctx, gen.GetExamplesByEndpointIDOrderedParams{
                ItemApiID:   endpointID,
                ItemApiID_2: endpointID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get ordered examples: %w", err)
        }</span>

        // Find position of the example
        <span class="cov0" title="0">for i, ex := range orderedExamples </span><span class="cov0" title="0">{
                if idwrap.NewFromBytesMust(ex.ID).Compare(exampleID) == 0 </span><span class="cov0" title="0">{
                        return i, nil
                }</span>
        }

        <span class="cov0" title="0">return 0, fmt.Errorf("example not found in endpoint")</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package sitemfolder

import (
        "context"
        "database/sql"
        "errors"
        "slices"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mitemfolder"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

type ItemFolderService struct {
        queries *gen.Queries
}

var ErrNoItemFolderFound = sql.ErrNoRows

func ConvertToDBItemFolder(folder mitemfolder.ItemFolder) gen.ItemFolder <span class="cov0" title="0">{
        return gen.ItemFolder{
                ID:           folder.ID,
                CollectionID: folder.CollectionID,
                ParentID:     folder.ParentID,
                Name:         folder.Name,
        }
}</span>

func ConvertToModelItemFolder(folder gen.ItemFolder) mitemfolder.ItemFolder <span class="cov0" title="0">{
        return mitemfolder.ItemFolder{
                ID:           folder.ID,
                CollectionID: folder.CollectionID,
                ParentID:     folder.ParentID,
                Name:         folder.Name,
        }
}</span>

func New(queries *gen.Queries) ItemFolderService <span class="cov0" title="0">{
        return ItemFolderService{queries: queries}
}</span>

func (ifs ItemFolderService) TX(tx *sql.Tx) ItemFolderService <span class="cov0" title="0">{
        return ItemFolderService{queries: ifs.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*ItemFolderService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;ItemFolderService{
                queries: queries,
        }, nil</span>
}

func (ifs ItemFolderService) GetFolder(ctx context.Context, id idwrap.IDWrap) (*mitemfolder.ItemFolder, error) <span class="cov0" title="0">{
        rawFolder, err := ifs.queries.GetItemFolder(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoItemFolderFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">folder := ConvertToModelItemFolder(rawFolder)
        return &amp;folder, nil</span>
}

func (ifs ItemFolderService) GetFoldersWithCollectionID(ctx context.Context, collectionID idwrap.IDWrap) ([]mitemfolder.ItemFolder, error) <span class="cov0" title="0">{
        rawFolders, err := ifs.queries.GetItemFoldersByCollectionID(ctx, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []mitemfolder.ItemFolder{}, ErrNoItemFolderFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return tgeneric.MassConvert(rawFolders, ConvertToModelItemFolder), nil</span>
}

func (ifs ItemFolderService) GetFolderByCollectionIDAndNextID(ctx context.Context, collectionID idwrap.IDWrap, nextID, parentID *idwrap.IDWrap) (*mitemfolder.ItemFolder, error) <span class="cov0" title="0">{
        rawFolder, err := ifs.queries.GetItemFolderByCollectionIDAndNextIDAndParentID(ctx, gen.GetItemFolderByCollectionIDAndNextIDAndParentIDParams{
                CollectionID: collectionID,
                ParentID:     parentID,
                Next:         nextID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoItemFolderFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">a := ConvertToModelItemFolder(rawFolder)
        return &amp;a, nil</span>
}

func (ifs ItemFolderService) UpdateOrder(ctx context.Context, folder *mitemfolder.ItemFolder) error <span class="cov0" title="0">{
        folders, err := ifs.GetFoldersWithCollectionID(ctx, folder.CollectionID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">parentIDPtr := folder.ParentID
        if parentIDPtr == nil </span><span class="cov0" title="0">{
                tempID, err := idwrap.NewFromBytes(make([]byte, 0))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">parentIDPtr = &amp;tempID</span>
        }
        <span class="cov0" title="0">parentFolders := make([]mitemfolder.ItemFolder, 0)
        parentID := *parentIDPtr
        for _, folder := range folders </span><span class="cov0" title="0">{
                if folder.ParentID.Compare(parentID) == 0 </span><span class="cov0" title="0">{
                        parentFolders = append(parentFolders, folder)
                }</span>
        }

        <span class="cov0" title="0">sameLevelFolderMap := make(map[idwrap.IDWrap]mitemfolder.ItemFolder)
        for _, folder := range parentFolders </span><span class="cov0" title="0">{
                sameLevelFolderMap[folder.ID] = folder
        }</span>

        <span class="cov0" title="0">var folderPrev *mitemfolder.ItemFolder
        if folder.Prev != nil </span><span class="cov0" title="0">{
                parentFolder, ok := sameLevelFolderMap[*folder.Prev]
                if !ok </span><span class="cov0" title="0">{
                        return ErrNoItemFolderFound
                }</span>
                <span class="cov0" title="0">folderPrev = &amp;parentFolder</span>
        }
        <span class="cov0" title="0">var folderNext *mitemfolder.ItemFolder
        if folder.Next != nil </span><span class="cov0" title="0">{
                childFolder, ok := sameLevelFolderMap[*folder.Next]
                if !ok </span><span class="cov0" title="0">{
                        return ErrNoItemFolderFound
                }</span>
                <span class="cov0" title="0">folderNext = &amp;childFolder</span>
        }

        <span class="cov0" title="0">if folderPrev != nil </span><span class="cov0" title="0">{
                if folderPrev.Next != nil </span><span class="cov0" title="0">{
                        if folder.Prev != nil </span><span class="cov0" title="0">{
                                if folderPrev.Next.Compare(*folder.Prev) != 0 </span><span class="cov0" title="0">{
                                        return errors.New("ordering is not right next and prev not match")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return errors.New("ordering is not right next and prev not match")
                        }</span>
                }
                <span class="cov0" title="0">if folderPrev.Next != folder.Next </span><span class="cov0" title="0">{
                        return errors.New("ordering is not right next and prev not match")
                }</span>
                <span class="cov0" title="0">folder.Prev = &amp;folderPrev.ID
                folderPrev.Next = &amp;folder.ID</span>
        }
        <span class="cov0" title="0">if folderNext != nil </span><span class="cov0" title="0">{
                if folderNext.Prev != nil </span><span class="cov0" title="0">{
                        if folder.Next != nil </span><span class="cov0" title="0">{
                                if folderNext.Prev.Compare(*folder.Next) != 0 </span><span class="cov0" title="0">{
                                        return errors.New("ordering is not right next and prev not match")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return errors.New("ordering is not right next and prev not match")
                        }</span>
                }
                <span class="cov0" title="0">folder.Next = &amp;folderNext.ID
                folderNext.Prev = &amp;folder.ID</span>
        }

        <span class="cov0" title="0">err = ifs.UpdateItemFolder(ctx, folder)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = ifs.UpdateItemFolder(ctx, folderPrev)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return ifs.UpdateItemFolder(ctx, folderNext)</span>
}

func (ifs ItemFolderService) GetLastFolder(ctx context.Context, collectionID idwrap.IDWrap, parentIDPtr, targetIDPtr *idwrap.IDWrap) (*mitemfolder.ItemFolder, error) <span class="cov0" title="0">{
        folders, err := ifs.GetFoldersWithCollectionID(ctx, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var folderParentSelected []mitemfolder.ItemFolder
        if parentIDPtr == nil </span><span class="cov0" title="0">{
                for _, folder := range folders </span><span class="cov0" title="0">{
                        if folder.ParentID == nil </span><span class="cov0" title="0">{
                                folderParentSelected = append(folderParentSelected, folder)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                for _, folder := range folders </span><span class="cov0" title="0">{
                        if folder.ParentID.Compare(*parentIDPtr) == 0 </span><span class="cov0" title="0">{
                                folderParentSelected = append(folderParentSelected, folder)
                        }</span>
                }
        }
        <span class="cov0" title="0">if targetIDPtr == nil </span><span class="cov0" title="0">{
                for _, folder := range folderParentSelected </span><span class="cov0" title="0">{
                        if folder.Next == nil </span><span class="cov0" title="0">{
                                return &amp;folder, nil
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                for _, folder := range folderParentSelected </span><span class="cov0" title="0">{
                        if folder.ID.Compare(*targetIDPtr) == 0 </span><span class="cov0" title="0">{
                                return &amp;folder, nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil, errors.New("no folder found")</span>
}

func (ifs ItemFolderService) CreateItemFolder(ctx context.Context, folder *mitemfolder.ItemFolder) error <span class="cov0" title="0">{
        createParams := gen.CreateItemFolderParams{
                ID:           folder.ID,
                Name:         folder.Name,
                CollectionID: folder.CollectionID,
                ParentID:     folder.ParentID,
                Next:         folder.Next,
                Prev:         folder.Prev,
        }
        return ifs.queries.CreateItemFolder(ctx, createParams)
}</span>

func (ifs ItemFolderService) CreateItemFolderBulk(ctx context.Context, items []mitemfolder.ItemFolder) error <span class="cov0" title="0">{
        const sizeOfChunks = 10

        for chunk := range slices.Chunk(items, sizeOfChunks) </span><span class="cov0" title="0">{
                if len(chunk) &lt; sizeOfChunks </span><span class="cov0" title="0">{
                        for _, item := range chunk </span><span class="cov0" title="0">{
                                err := ifs.CreateItemFolder(ctx, &amp;item)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">item1 := chunk[0]
                item2 := chunk[1]
                item3 := chunk[2]
                item4 := chunk[3]
                item5 := chunk[4]
                item6 := chunk[5]
                item7 := chunk[6]
                item8 := chunk[7]
                item9 := chunk[8]
                item10 := chunk[9]
                params := gen.CreateItemFolderBulkParams{
                        // Item 1
                        ID:           item1.ID,
                        CollectionID: item1.CollectionID,
                        ParentID:     item1.ParentID,
                        Name:         item1.Name,
                        Prev:         item1.Prev,
                        Next:         item1.Next,
                        // Item 2
                        ID_2:           item2.ID,
                        CollectionID_2: item2.CollectionID,
                        ParentID_2:     item2.ParentID,
                        Name_2:         item2.Name,
                        Prev_2:         item2.Prev,
                        Next_2:         item2.Next,
                        // Item 3
                        ID_3:           item3.ID,
                        CollectionID_3: item3.CollectionID,
                        ParentID_3:     item3.ParentID,
                        Name_3:         item3.Name,
                        Prev_3:         item3.Prev,
                        Next_3:         item3.Next,
                        // Item 4
                        ID_4:           item4.ID,
                        CollectionID_4: item4.CollectionID,
                        ParentID_4:     item4.ParentID,
                        Name_4:         item4.Name,
                        Prev_4:         item4.Prev,
                        Next_4:         item4.Next,
                        // Item 5
                        ID_5:           item5.ID,
                        CollectionID_5: item5.CollectionID,
                        ParentID_5:     item5.ParentID,
                        Name_5:         item5.Name,
                        Prev_5:         item5.Prev,
                        Next_5:         item5.Next,
                        // Item 6
                        ID_6:           item6.ID,
                        CollectionID_6: item6.CollectionID,
                        ParentID_6:     item6.ParentID,
                        Name_6:         item6.Name,
                        Prev_6:         item6.Prev,
                        Next_6:         item6.Next,
                        // Item 7
                        ID_7:           item7.ID,
                        CollectionID_7: item7.CollectionID,
                        ParentID_7:     item7.ParentID,
                        Name_7:         item7.Name,
                        Prev_7:         item7.Prev,
                        Next_7:         item7.Next,
                        // Item 8
                        ID_8:           item8.ID,
                        CollectionID_8: item8.CollectionID,
                        ParentID_8:     item8.ParentID,
                        Name_8:         item8.Name,
                        Prev_8:         item8.Prev,
                        Next_8:         item8.Next,
                        // Item 9
                        ID_9:           item9.ID,
                        CollectionID_9: item9.CollectionID,
                        ParentID_9:     item9.ParentID,
                        Name_9:         item9.Name,
                        Prev_9:         item9.Prev,
                        Next_9:         item9.Next,
                        // Item 10
                        ID_10:           item10.ID,
                        CollectionID_10: item10.CollectionID,
                        ParentID_10:     item10.ParentID,
                        Name_10:         item10.Name,
                        Prev_10:         item10.Prev,
                        Next_10:         item10.Next,
                }

                if err := ifs.queries.CreateItemFolderBulk(ctx, params); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        }
        <span class="cov0" title="0">return nil</span>
}

func (ifs ItemFolderService) UpdateItemFolder(ctx context.Context, folder *mitemfolder.ItemFolder) error <span class="cov0" title="0">{
        err := ifs.queries.UpdateItemFolder(ctx, gen.UpdateItemFolderParams{
                ID:       folder.ID,
                Name:     folder.Name,
                ParentID: folder.ParentID,
        })
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return ErrNoItemFolderFound
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (ifs ItemFolderService) DeleteItemFolder(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        err := ifs.queries.DeleteItemFolder(ctx, id)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return ErrNoItemFolderFound
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (ifs ItemFolderService) GetWorkspaceID(ctx context.Context, folderID idwrap.IDWrap) (idwrap.IDWrap, error) <span class="cov0" title="0">{
        ownerID, err := ifs.queries.GetItemFolderWorkspaceID(ctx, folderID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return idwrap.IDWrap{}, ErrNoItemFolderFound
                }</span>
                <span class="cov0" title="0">return idwrap.IDWrap{}, err</span>
        }
        <span class="cov0" title="0">return ownerID, err</span>
}

func (ifs ItemFolderService) CheckWorkspaceID(ctx context.Context, folderID idwrap.IDWrap, ownerID idwrap.IDWrap) (bool, error) <span class="cov0" title="0">{
        CollectionWorkspaceID, err := ifs.GetWorkspaceID(ctx, folderID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return false, ErrNoItemFolderFound
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov0" title="0">return folderID.Compare(CollectionWorkspaceID) == 0, nil</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package snode

import (
        "context"
        "database/sql"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mnnode"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

var ErrNoNodeFound error = sql.ErrNoRows

type NodeService struct {
        queries *gen.Queries
}

func New(queries *gen.Queries) NodeService <span class="cov0" title="0">{
        return NodeService{queries: queries}
}</span>

func (s NodeService) TX(tx *sql.Tx) NodeService <span class="cov0" title="0">{
        return NodeService{queries: s.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*NodeService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;NodeService{
                queries: queries,
        }, nil</span>
}

func ConvertNodeToDB(n mnnode.MNode) *gen.FlowNode <span class="cov0" title="0">{
        return &amp;gen.FlowNode{
                ID:        n.ID,
                FlowID:    n.FlowID,
                Name:      n.Name,
                NodeKind:  int32(n.NodeKind),
                PositionX: n.PositionX,
                PositionY: n.PositionY,
        }
}</span>

func ConvertNodeToModel(n gen.FlowNode) *mnnode.MNode <span class="cov0" title="0">{
        return &amp;mnnode.MNode{
                ID:        n.ID,
                FlowID:    n.FlowID,
                Name:      n.Name,
                NodeKind:  mnnode.NodeKind(n.NodeKind),
                PositionX: n.PositionX,
                PositionY: n.PositionY,
        }
}</span>

func (ns NodeService) GetNode(ctx context.Context, id idwrap.IDWrap) (*mnnode.MNode, error) <span class="cov0" title="0">{
        node, err := ns.queries.GetFlowNode(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ConvertNodeToModel(node), nil</span>
}

func (ns NodeService) GetNodesByFlowID(ctx context.Context, flowID idwrap.IDWrap) ([]mnnode.MNode, error) <span class="cov0" title="0">{
        nodes, err := ns.queries.GetFlowNodesByFlowID(ctx, flowID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []mnnode.MNode{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return tgeneric.MassConvertPtr(nodes, ConvertNodeToModel), nil</span>
}

func (ns NodeService) CreateNode(ctx context.Context, n mnnode.MNode) error <span class="cov0" title="0">{
        node := ConvertNodeToDB(n)
        return ns.queries.CreateFlowNode(ctx, gen.CreateFlowNodeParams{
                ID:        node.ID,
                FlowID:    node.FlowID,
                Name:      node.Name,
                NodeKind:  node.NodeKind,
                PositionX: node.PositionX,
                PositionY: node.PositionY,
        })
}</span>

func (ns NodeService) CreateNodeBulk(ctx context.Context, nodes []mnnode.MNode) error <span class="cov0" title="0">{
        for _, n := range nodes </span><span class="cov0" title="0">{
                node := ConvertNodeToDB(n)
                err := ns.queries.CreateFlowNode(ctx, gen.CreateFlowNodeParams{
                        ID:        node.ID,
                        FlowID:    node.FlowID,
                        Name:      node.Name,
                        NodeKind:  node.NodeKind,
                        PositionX: node.PositionX,
                        PositionY: node.PositionY,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (ns NodeService) UpdateNode(ctx context.Context, n mnnode.MNode) error <span class="cov0" title="0">{
        node := ConvertNodeToDB(n)
        return ns.queries.UpdateFlowNode(ctx, gen.UpdateFlowNodeParams{
                ID:        node.ID,
                Name:      node.Name,
                PositionX: node.PositionX,
                PositionY: node.PositionY,
        })
}</span>

func (ns NodeService) DeleteNode(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        return ns.queries.DeleteFlowNode(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">package snodeexecution

import (
        "context"
        "database/sql"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mnodeexecution"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

type NodeExecutionService struct {
        queries *gen.Queries
}

func New(queries *gen.Queries) NodeExecutionService <span class="cov8" title="1">{
        return NodeExecutionService{queries: queries}
}</span>

func (s NodeExecutionService) TX(tx *sql.Tx) NodeExecutionService <span class="cov0" title="0">{
        return NodeExecutionService{queries: s.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*NodeExecutionService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;NodeExecutionService{
                queries: queries,
        }, nil</span>
}

func ConvertNodeExecutionToDB(ne mnodeexecution.NodeExecution) *gen.NodeExecution <span class="cov8" title="1">{
        var errorSQL sql.NullString
        if ne.Error != nil </span><span class="cov8" title="1">{
                errorSQL = sql.NullString{
                        String: *ne.Error,
                        Valid:  true,
                }
        }</span>

        <span class="cov8" title="1">var responseID []byte
        if ne.ResponseID != nil </span><span class="cov0" title="0">{
                responseID = ne.ResponseID.Bytes()
        }</span>

        <span class="cov8" title="1">var completedAtSQL sql.NullInt64
        if ne.CompletedAt != nil </span><span class="cov0" title="0">{
                completedAtSQL = sql.NullInt64{
                        Int64: *ne.CompletedAt,
                        Valid: true,
                }
        }</span>

        <span class="cov8" title="1">return &amp;gen.NodeExecution{
                ID:                     ne.ID,
                NodeID:                 ne.NodeID,
                Name:                   ne.Name,
                State:                  ne.State,
                InputData:              ne.InputData,
                InputDataCompressType:  ne.InputDataCompressType,
                OutputData:             ne.OutputData,
                OutputDataCompressType: ne.OutputDataCompressType,
                Error:                  errorSQL,
                ResponseID:             responseID,
                CompletedAt:            completedAtSQL,
        }</span>
}

func ConvertNodeExecutionToModel(ne gen.NodeExecution) *mnodeexecution.NodeExecution <span class="cov8" title="1">{
        var errorPtr *string
        if ne.Error.Valid </span><span class="cov8" title="1">{
                errorPtr = &amp;ne.Error.String
        }</span>

        <span class="cov8" title="1">var responseIDPtr *idwrap.IDWrap
        if len(ne.ResponseID) &gt; 0 </span><span class="cov0" title="0">{
                respID, err := idwrap.NewFromBytes(ne.ResponseID)
                if err == nil </span><span class="cov0" title="0">{
                        responseIDPtr = &amp;respID
                }</span>
        }

        <span class="cov8" title="1">var completedAtPtr *int64
        if ne.CompletedAt.Valid </span><span class="cov8" title="1">{
                completedAtPtr = &amp;ne.CompletedAt.Int64
        }</span>

        <span class="cov8" title="1">return &amp;mnodeexecution.NodeExecution{
                ID:                     ne.ID,
                NodeID:                 ne.NodeID,
                Name:                   ne.Name,
                State:                  ne.State,
                InputData:              ne.InputData,
                InputDataCompressType:  ne.InputDataCompressType,
                OutputData:             ne.OutputData,
                OutputDataCompressType: ne.OutputDataCompressType,
                Error:                  errorPtr,
                ResponseID:             responseIDPtr,
                CompletedAt:            completedAtPtr,
        }</span>
}

func (s NodeExecutionService) CreateNodeExecution(ctx context.Context, ne mnodeexecution.NodeExecution) error <span class="cov8" title="1">{
        var errorSQL sql.NullString
        if ne.Error != nil </span><span class="cov0" title="0">{
                errorSQL = sql.NullString{
                        String: *ne.Error,
                        Valid:  true,
                }
        }</span>

        <span class="cov8" title="1">var responseID []byte
        if ne.ResponseID != nil </span><span class="cov0" title="0">{
                responseID = ne.ResponseID.Bytes()
        }</span>

        <span class="cov8" title="1">var completedAtSQL sql.NullInt64
        if ne.CompletedAt != nil </span><span class="cov8" title="1">{
                completedAtSQL = sql.NullInt64{
                        Int64: *ne.CompletedAt,
                        Valid: true,
                }
        }</span>

        <span class="cov8" title="1">_, err := s.queries.CreateNodeExecution(ctx, gen.CreateNodeExecutionParams{
                ID:                     ne.ID,
                NodeID:                 ne.NodeID,
                Name:                   ne.Name,
                State:                  ne.State,
                Error:                  errorSQL,
                InputData:              ne.InputData,
                InputDataCompressType:  ne.InputDataCompressType,
                OutputData:             ne.OutputData,
                OutputDataCompressType: ne.OutputDataCompressType,
                ResponseID:             responseID,
                CompletedAt:            completedAtSQL,
        })

        return err</span>
}

func (s NodeExecutionService) GetNodeExecution(ctx context.Context, executionID idwrap.IDWrap) (*mnodeexecution.NodeExecution, error) <span class="cov0" title="0">{
        execution, err := s.queries.GetNodeExecution(ctx, executionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ConvertNodeExecutionToModel(execution), nil</span>
}

func (s NodeExecutionService) GetNodeExecutionsByNodeID(ctx context.Context, nodeID idwrap.IDWrap) ([]mnodeexecution.NodeExecution, error) <span class="cov8" title="1">{
        executions, err := s.queries.GetNodeExecutionsByNodeID(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []mnodeexecution.NodeExecution{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return tgeneric.MassConvertPtr(executions, ConvertNodeExecutionToModel), nil</span>
}

func (s NodeExecutionService) ListNodeExecutionsByNodeID(ctx context.Context, nodeID idwrap.IDWrap) ([]mnodeexecution.NodeExecution, error) <span class="cov0" title="0">{
        // For now, use the existing method - could add pagination later
        return s.GetNodeExecutionsByNodeID(ctx, nodeID)
}</span>

func (s NodeExecutionService) GetLatestNodeExecutionByNodeID(ctx context.Context, nodeID idwrap.IDWrap) (*mnodeexecution.NodeExecution, error) <span class="cov0" title="0">{
        execution, err := s.queries.GetLatestNodeExecutionByNodeID(ctx, nodeID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return ConvertNodeExecutionToModel(execution), nil</span>
}

func (s NodeExecutionService) UpdateNodeExecution(ctx context.Context, ne mnodeexecution.NodeExecution) error <span class="cov0" title="0">{
        var errorSQL sql.NullString
        if ne.Error != nil </span><span class="cov0" title="0">{
                errorSQL = sql.NullString{
                        String: *ne.Error,
                        Valid:  true,
                }
        }</span>

        <span class="cov0" title="0">var responseID []byte
        if ne.ResponseID != nil </span><span class="cov0" title="0">{
                responseID = ne.ResponseID.Bytes()
        }</span>

        <span class="cov0" title="0">var completedAtSQL sql.NullInt64
        if ne.CompletedAt != nil </span><span class="cov0" title="0">{
                completedAtSQL = sql.NullInt64{
                        Int64: *ne.CompletedAt,
                        Valid: true,
                }
        }</span>

        <span class="cov0" title="0">_, err := s.queries.UpdateNodeExecution(ctx, gen.UpdateNodeExecutionParams{
                ID:                     ne.ID,
                State:                  ne.State,
                Error:                  errorSQL,
                OutputData:             ne.OutputData,
                OutputDataCompressType: ne.OutputDataCompressType,
                ResponseID:             responseID,
                CompletedAt:            completedAtSQL,
        })

        return err</span>
}

func (s NodeExecutionService) UpsertNodeExecution(ctx context.Context, ne mnodeexecution.NodeExecution) error <span class="cov0" title="0">{
        var errorSQL sql.NullString
        if ne.Error != nil </span><span class="cov0" title="0">{
                errorSQL = sql.NullString{
                        String: *ne.Error,
                        Valid:  true,
                }
        }</span>

        <span class="cov0" title="0">var responseID []byte
        if ne.ResponseID != nil </span><span class="cov0" title="0">{
                responseID = ne.ResponseID.Bytes()
        }</span>

        <span class="cov0" title="0">var completedAtSQL sql.NullInt64
        if ne.CompletedAt != nil </span><span class="cov0" title="0">{
                completedAtSQL = sql.NullInt64{
                        Int64: *ne.CompletedAt,
                        Valid: true,
                }
        }</span>

        <span class="cov0" title="0">_, err := s.queries.UpsertNodeExecution(ctx, gen.UpsertNodeExecutionParams{
                ID:                     ne.ID,
                NodeID:                 ne.NodeID,
                Name:                   ne.Name,
                State:                  ne.State,
                Error:                  errorSQL,
                InputData:              ne.InputData,
                InputDataCompressType:  ne.InputDataCompressType,
                OutputData:             ne.OutputData,
                OutputDataCompressType: ne.OutputDataCompressType,
                ResponseID:             responseID,
                CompletedAt:            completedAtSQL,
        })

        return err</span>
}

func (s NodeExecutionService) DeleteNodeExecutionsByNodeID(ctx context.Context, nodeID idwrap.IDWrap) error <span class="cov0" title="0">{
        return s.queries.DeleteNodeExecutionsByNodeID(ctx, nodeID)
}</span>

func (s NodeExecutionService) DeleteNodeExecutionsByNodeIDs(ctx context.Context, nodeIDs []idwrap.IDWrap) error <span class="cov0" title="0">{
        return s.queries.DeleteNodeExecutionsByNodeIDs(ctx, nodeIDs)
}</span>
</pre>
		
		<pre class="file" id="file105" style="display: none">package snodefor

import (
        "context"
        "database/sql"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mcondition"
        "the-dev-tools/server/pkg/model/mnnode/mnfor"
)

var ErrNoNodeForFound = sql.ErrNoRows

type NodeForService struct {
        queries *gen.Queries
}

func New(queries *gen.Queries) NodeForService <span class="cov0" title="0">{
        return NodeForService{queries: queries}
}</span>

func (nfs NodeForService) TX(tx *sql.Tx) NodeForService <span class="cov0" title="0">{
        return NodeForService{queries: nfs.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*NodeForService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;NodeForService{
                queries: queries,
        }, nil</span>
}

func ConvertToDBNodeFor(nf mnfor.MNFor) gen.FlowNodeFor <span class="cov0" title="0">{
        return gen.FlowNodeFor{
                FlowNodeID:    nf.FlowNodeID,
                IterCount:     nf.IterCount,
                ErrorHandling: int8(nf.ErrorHandling),
                Expression:    nf.Condition.Comparisons.Expression,
        }
}</span>

func ConvertToModelNodeFor(nf gen.FlowNodeFor) *mnfor.MNFor <span class="cov0" title="0">{
        return &amp;mnfor.MNFor{
                FlowNodeID:    nf.FlowNodeID,
                IterCount:     nf.IterCount,
                ErrorHandling: mnfor.ErrorHandling(nf.ErrorHandling),
                Condition: mcondition.Condition{
                        Comparisons: mcondition.Comparison{
                                Expression: nf.Expression,
                        },
                },
        }
}</span>

func (nfs NodeForService) GetNodeFor(ctx context.Context, id idwrap.IDWrap) (*mnfor.MNFor, error) <span class="cov0" title="0">{
        nodeFor, err := nfs.queries.GetFlowNodeFor(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ConvertToModelNodeFor(nodeFor), nil</span>
}

func (nfs NodeForService) CreateNodeFor(ctx context.Context, nf mnfor.MNFor) error <span class="cov0" title="0">{
        nodeFor := ConvertToDBNodeFor(nf)
        return nfs.queries.CreateFlowNodeFor(ctx, gen.CreateFlowNodeForParams{
                FlowNodeID:    nodeFor.FlowNodeID,
                IterCount:     nodeFor.IterCount,
                ErrorHandling: nodeFor.ErrorHandling,
                Expression:    nodeFor.Expression,
        })
}</span>

func (nfs NodeForService) CreateNodeForBulk(ctx context.Context, nf []mnfor.MNFor) error <span class="cov0" title="0">{
        var err error
        for _, n := range nf </span><span class="cov0" title="0">{
                err = nfs.CreateNodeFor(ctx, n)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return err</span>
}

func (nfs NodeForService) UpdateNodeFor(ctx context.Context, nf mnfor.MNFor) error <span class="cov0" title="0">{
        nodeFor := ConvertToDBNodeFor(nf)
        return nfs.queries.UpdateFlowNodeFor(ctx, gen.UpdateFlowNodeForParams{
                FlowNodeID:    nodeFor.FlowNodeID,
                IterCount:     nodeFor.IterCount,
                ErrorHandling: nodeFor.ErrorHandling,
                Expression:    nodeFor.Expression,
        })
}</span>

func (nfs NodeForService) DeleteNodeFor(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        err := nfs.queries.DeleteFlowNodeFor(ctx, id)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return ErrNoNodeForFound
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package snodeforeach

import (
        "context"
        "database/sql"
        "errors"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mcondition"
        "the-dev-tools/server/pkg/model/mnnode/mnfor"
        "the-dev-tools/server/pkg/model/mnnode/mnforeach"
)

var ErrNoNodeForEachFound = errors.New("node foreach not found")

type NodeForEachService struct {
        queries *gen.Queries
}

func New(queries *gen.Queries) NodeForEachService <span class="cov0" title="0">{
        return NodeForEachService{queries: queries}
}</span>

func (nfs NodeForEachService) TX(tx *sql.Tx) NodeForEachService <span class="cov0" title="0">{
        return NodeForEachService{queries: nfs.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*NodeForEachService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;NodeForEachService{
                queries: queries,
        }, nil</span>
}

func ConvertToDBNodeFor(nf mnforeach.MNForEach) gen.FlowNodeForEach <span class="cov0" title="0">{
        return gen.FlowNodeForEach{
                FlowNodeID:     nf.FlowNodeID,
                IterExpression: nf.IterExpression,
                ErrorHandling:  int8(nf.ErrorHandling),
                Expression:     nf.Condition.Comparisons.Expression,
        }
}</span>

func ConvertToModelNodeFor(nf gen.FlowNodeForEach) *mnforeach.MNForEach <span class="cov0" title="0">{
        return &amp;mnforeach.MNForEach{
                FlowNodeID:     nf.FlowNodeID,
                IterExpression: nf.IterExpression,
                ErrorHandling:  mnfor.ErrorHandling(nf.ErrorHandling),
                Condition: mcondition.Condition{
                        Comparisons: mcondition.Comparison{
                                Expression: nf.Expression,
                        },
                },
        }
}</span>

func (nfs NodeForEachService) GetNodeForEach(ctx context.Context, id idwrap.IDWrap) (*mnforeach.MNForEach, error) <span class="cov0" title="0">{
        nodeForEach, err := nfs.queries.GetFlowNodeForEach(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ConvertToModelNodeFor(nodeForEach), nil</span>
}

func (nfs NodeForEachService) CreateNodeForEach(ctx context.Context, nf mnforeach.MNForEach) error <span class="cov0" title="0">{
        nodeForEach := ConvertToDBNodeFor(nf)
        return nfs.queries.CreateFlowNodeForEach(ctx, gen.CreateFlowNodeForEachParams{
                FlowNodeID:     nodeForEach.FlowNodeID,
                IterExpression: nodeForEach.IterExpression,
                ErrorHandling:  nodeForEach.ErrorHandling,
                Expression:     nodeForEach.Expression,
        })
}</span>

func (nfs NodeForEachService) CreateNodeForEachBulk(ctx context.Context, forEachNodes []mnforeach.MNForEach) error <span class="cov0" title="0">{
        var err error
        for _, forEachNode := range forEachNodes </span><span class="cov0" title="0">{
                err = nfs.CreateNodeForEach(ctx, forEachNode)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return err</span>
}

func (nfs NodeForEachService) UpdateNodeForEach(ctx context.Context, nf mnforeach.MNForEach) error <span class="cov0" title="0">{
        nodeForEach := ConvertToDBNodeFor(nf)
        return nfs.queries.UpdateFlowNodeForEach(ctx, gen.UpdateFlowNodeForEachParams{
                FlowNodeID:     nodeForEach.FlowNodeID,
                IterExpression: nodeForEach.IterExpression,
                ErrorHandling:  nodeForEach.ErrorHandling,
                Expression:     nodeForEach.Expression,
        })
}</span>

func (nfs NodeForEachService) DeleteNodeForEach(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        err := nfs.queries.DeleteFlowNodeForEach(ctx, id)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return ErrNoNodeForEachFound
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package snodeif

import (
        "context"
        "database/sql"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mcondition"
        "the-dev-tools/server/pkg/model/mnnode/mnif"
)

type NodeIfService struct {
        queries *gen.Queries
}

func New(queries *gen.Queries) *NodeIfService <span class="cov0" title="0">{
        return &amp;NodeIfService{
                queries: queries,
        }
}</span>

func (nifs NodeIfService) TX(tx *sql.Tx) *NodeIfService <span class="cov0" title="0">{
        return &amp;NodeIfService{queries: nifs.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*NodeIfService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;NodeIfService{
                queries: queries,
        }, nil</span>
}

func ConvertToDBNodeIf(ni mnif.MNIF) gen.FlowNodeCondition <span class="cov0" title="0">{
        return gen.FlowNodeCondition{
                FlowNodeID: ni.FlowNodeID,
                Expression: ni.Condition.Comparisons.Expression,
        }
}</span>

func ConvertToModelNodeIf(ni gen.FlowNodeCondition) *mnif.MNIF <span class="cov0" title="0">{
        return &amp;mnif.MNIF{
                FlowNodeID: ni.FlowNodeID,
                Condition: mcondition.Condition{
                        Comparisons: mcondition.Comparison{
                                Expression: ni.Expression,
                        },
                },
        }
}</span>

func (nifs NodeIfService) GetNodeIf(ctx context.Context, id idwrap.IDWrap) (*mnif.MNIF, error) <span class="cov0" title="0">{
        nodeIf, err := nifs.queries.GetFlowNodeCondition(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ConvertToModelNodeIf(nodeIf), nil</span>
}

func (nifs NodeIfService) CreateNodeIf(ctx context.Context, ni mnif.MNIF) error <span class="cov0" title="0">{
        nodeIf := ConvertToDBNodeIf(ni)
        return nifs.queries.CreateFlowNodeCondition(ctx, gen.CreateFlowNodeConditionParams{
                FlowNodeID: nodeIf.FlowNodeID,
                Expression: ni.Condition.Comparisons.Expression,
        })
}</span>

func (nifs NodeIfService) CreateNodeIfBulk(ctx context.Context, conditionNodes []mnif.MNIF) error <span class="cov0" title="0">{
        var err error
        for _, n := range conditionNodes </span><span class="cov0" title="0">{
                err = nifs.CreateNodeIf(ctx, n)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (nifs NodeIfService) UpdateNodeIf(ctx context.Context, ni mnif.MNIF) error <span class="cov0" title="0">{
        nodeIf := ConvertToDBNodeIf(ni)
        return nifs.queries.UpdateFlowNodeCondition(ctx, gen.UpdateFlowNodeConditionParams{
                FlowNodeID: nodeIf.FlowNodeID,
                Expression: nodeIf.Expression,
        })
}</span>

func (nifs NodeIfService) DeleteNodeIf(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        return nifs.queries.DeleteFlowNodeCondition(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file108" style="display: none">package snodejs

import (
        "context"
        "database/sql"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/compress"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mnnode/mnjs"
)

var ErrNoNodeForFound = sql.ErrNoRows

type NodeJSService struct {
        queries *gen.Queries
}

func New(queries *gen.Queries) NodeJSService <span class="cov0" title="0">{
        return NodeJSService{queries: queries}
}</span>

func (nfs NodeJSService) TX(tx *sql.Tx) NodeJSService <span class="cov0" title="0">{
        return NodeJSService{queries: nfs.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*NodeJSService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;NodeJSService{
                queries: queries,
        }, nil</span>
}

// INFO: for some reason sqlc generate `Js` as `J`, will check later why it is not working
func ConvertDBToModel(nf gen.FlowNodeJ) mnjs.MNJS <span class="cov0" title="0">{
        return mnjs.MNJS{
                FlowNodeID:       nf.FlowNodeID,
                Code:             nf.Code,
                CodeCompressType: compress.CompressType(nf.CodeCompressType),
        }
}</span>

func ConvertModelToDB(mn mnjs.MNJS) gen.FlowNodeJ <span class="cov0" title="0">{
        return gen.FlowNodeJ{
                FlowNodeID:       mn.FlowNodeID,
                Code:             mn.Code,
                CodeCompressType: int8(mn.CodeCompressType),
        }
}</span>

func (nfs NodeJSService) GetNodeJS(ctx context.Context, id idwrap.IDWrap) (mnjs.MNJS, error) <span class="cov0" title="0">{
        nodeJS, err := nfs.queries.GetFlowNodeJs(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return mnjs.MNJS{}, err
        }</span>
        <span class="cov0" title="0">return ConvertDBToModel(nodeJS), nil</span>
}

func (nfs NodeJSService) CreateNodeJS(ctx context.Context, mn mnjs.MNJS) error <span class="cov0" title="0">{
        nodeJS := ConvertModelToDB(mn)
        return nfs.queries.CreateFlowNodeJs(ctx, gen.CreateFlowNodeJsParams{
                FlowNodeID:       nodeJS.FlowNodeID,
                Code:             nodeJS.Code,
                CodeCompressType: nodeJS.CodeCompressType,
        })
}</span>

func (nfs NodeJSService) CreateNodeJSBulk(ctx context.Context, jsNodes []mnjs.MNJS) error <span class="cov0" title="0">{
        var err error
        for _, jsNode := range jsNodes </span><span class="cov0" title="0">{
                err = nfs.CreateNodeJS(ctx, jsNode)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return err</span>
}

func (nfs NodeJSService) UpdateNodeJS(ctx context.Context, mn mnjs.MNJS) error <span class="cov0" title="0">{
        nodeJS := ConvertModelToDB(mn)
        return nfs.queries.UpdateFlowNodeJs(ctx, gen.UpdateFlowNodeJsParams{
                FlowNodeID:       nodeJS.FlowNodeID,
                Code:             nodeJS.Code,
                CodeCompressType: nodeJS.CodeCompressType,
        })
}</span>

func (nfs NodeJSService) DeleteNodeJS(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        return nfs.queries.DeleteFlowNodeJs(ctx, id)
}</span>
</pre>
		
		<pre class="file" id="file109" style="display: none">package snodenoop

import (
        "context"
        "database/sql"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mnnode/mnnoop"
)

var ErrNoNodeForFound = sql.ErrNoRows

type NodeNoopService struct {
        queries *gen.Queries
}

func New(queries *gen.Queries) NodeNoopService <span class="cov0" title="0">{
        return NodeNoopService{queries: queries}
}</span>

func (nns NodeNoopService) TX(tx *sql.Tx) NodeNoopService <span class="cov0" title="0">{
        return NodeNoopService{queries: nns.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*NodeNoopService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;NodeNoopService{
                queries: queries,
        }, nil</span>
}

func ConvertToDBNodeStart(ns mnnoop.NoopNode) gen.FlowNodeNoop <span class="cov0" title="0">{
        return gen.FlowNodeNoop{
                FlowNodeID: ns.FlowNodeID,
                NodeType:   int16(ns.Type),
        }
}</span>

func ConvertToModelNodeStart(ns gen.FlowNodeNoop) *mnnoop.NoopNode <span class="cov0" title="0">{
        return &amp;mnnoop.NoopNode{
                FlowNodeID: ns.FlowNodeID,
                Type:       mnnoop.NoopTypes(ns.NodeType),
        }
}</span>

func (nfs NodeNoopService) GetNodeNoop(ctx context.Context, id idwrap.IDWrap) (*mnnoop.NoopNode, error) <span class="cov0" title="0">{
        nodeFor, err := nfs.queries.GetFlowNodeNoop(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ConvertToModelNodeStart(nodeFor), nil</span>
}

func (nfs NodeNoopService) GetNodesByFlowID(ctx context.Context, flowID idwrap.IDWrap) ([]mnnoop.NoopNode, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (nfs NodeNoopService) CreateNodeNoop(ctx context.Context, nf mnnoop.NoopNode) error <span class="cov0" title="0">{
        convertedNode := ConvertToDBNodeStart(nf)
        return nfs.queries.CreateFlowNodeNoop(ctx, gen.CreateFlowNodeNoopParams{
                FlowNodeID: convertedNode.FlowNodeID,
                NodeType:   convertedNode.NodeType,
        })
}</span>

func (nfs NodeNoopService) CreateNodeNoopBulk(ctx context.Context, nf []mnnoop.NoopNode) error <span class="cov0" title="0">{
        for _, n := range nf </span><span class="cov0" title="0">{
                convertedNode := ConvertToDBNodeStart(n)
                err := nfs.queries.CreateFlowNodeNoop(ctx, gen.CreateFlowNodeNoopParams{
                        FlowNodeID: convertedNode.FlowNodeID,
                        NodeType:   convertedNode.NodeType,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (nfs NodeNoopService) DeleteNodeNoop(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        err := nfs.queries.DeleteFlowNodeFor(ctx, id)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return ErrNoNodeForFound
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package snoderequest

import (
        "context"
        "database/sql"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mnnode/mnrequest"
)

type NodeRequestService struct {
        queries *gen.Queries
}

func New(queries *gen.Queries) NodeRequestService <span class="cov0" title="0">{
        return NodeRequestService{queries: queries}
}</span>

func (nrs NodeRequestService) TX(tx *sql.Tx) NodeRequestService <span class="cov0" title="0">{
        return NodeRequestService{queries: nrs.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*NodeRequestService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;NodeRequestService{
                queries: queries,
        }, nil</span>
}

func ConvertToDBNodeRequest(nr mnrequest.MNRequest) gen.FlowNodeRequest <span class="cov0" title="0">{
        return gen.FlowNodeRequest{
                FlowNodeID:      nr.FlowNodeID,
                EndpointID:      nr.EndpointID,
                ExampleID:       nr.ExampleID,
                DeltaExampleID:  nr.DeltaExampleID,
                DeltaEndpointID: nr.DeltaEndpointID,
        }
}</span>

func ConvertToModelNodeRequest(nr gen.FlowNodeRequest) *mnrequest.MNRequest <span class="cov0" title="0">{
        return &amp;mnrequest.MNRequest{
                FlowNodeID:      nr.FlowNodeID,
                EndpointID:      nr.EndpointID,
                ExampleID:       nr.ExampleID,
                DeltaExampleID:  nr.DeltaExampleID,
                DeltaEndpointID: nr.DeltaEndpointID,
        }
}</span>

func (nrs NodeRequestService) GetNodeRequest(ctx context.Context, id idwrap.IDWrap) (*mnrequest.MNRequest, error) <span class="cov0" title="0">{
        nodeRequest, err := nrs.queries.GetFlowNodeRequest(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return ConvertToModelNodeRequest(nodeRequest), nil</span>
}

func (nrs NodeRequestService) CreateNodeRequest(ctx context.Context, nr mnrequest.MNRequest) error <span class="cov0" title="0">{
        nodeRequest := ConvertToDBNodeRequest(nr)
        return nrs.queries.CreateFlowNodeRequest(ctx, gen.CreateFlowNodeRequestParams{
                FlowNodeID:      nodeRequest.FlowNodeID,
                EndpointID:      nodeRequest.EndpointID,
                ExampleID:       nodeRequest.ExampleID,
                DeltaExampleID:  nodeRequest.DeltaExampleID,
                DeltaEndpointID: nodeRequest.DeltaEndpointID,
        })
}</span>

func (nrs NodeRequestService) CreateNodeRequestBulk(ctx context.Context, nr []mnrequest.MNRequest) error <span class="cov0" title="0">{
        for _, nodeRequest := range nr </span><span class="cov0" title="0">{
                err := nrs.queries.CreateFlowNodeRequest(ctx, gen.CreateFlowNodeRequestParams{
                        FlowNodeID:      nodeRequest.FlowNodeID,
                        EndpointID:      nodeRequest.EndpointID,
                        ExampleID:       nodeRequest.ExampleID,
                        DeltaExampleID:  nodeRequest.DeltaExampleID,
                        DeltaEndpointID: nodeRequest.DeltaEndpointID, // TODO: Uncomment after regenerating sqlc files
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (nrs NodeRequestService) UpdateNodeRequest(ctx context.Context, nr mnrequest.MNRequest) error <span class="cov0" title="0">{
        nodeRequest := ConvertToDBNodeRequest(nr)
        return nrs.queries.UpdateFlowNodeRequest(ctx, gen.UpdateFlowNodeRequestParams{
                FlowNodeID:      nodeRequest.FlowNodeID,
                EndpointID:      nodeRequest.EndpointID,
                ExampleID:       nodeRequest.ExampleID,
                DeltaExampleID:  nodeRequest.DeltaExampleID,
                DeltaEndpointID: nodeRequest.DeltaEndpointID, // TODO: Uncomment after regenerating sqlc files
        })
}</span>

func (nrs NodeRequestService) DeleteNodeRequest(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        err := nrs.queries.DeleteFlowNodeRequest(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">package stag

import (
        "context"
        "database/sql"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mtag"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

type TagService struct {
        queries *gen.Queries
}

var ErrNoTag error = sql.ErrNoRows

func New(queries *gen.Queries) TagService <span class="cov0" title="0">{
        return TagService{queries: queries}
}</span>

func (s *TagService) TX(tx *sql.Tx) TagService <span class="cov0" title="0">{
        return TagService{queries: s.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*TagService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;TagService{
                queries: queries,
        }, nil</span>
}

func ConvertDBToModel(item gen.Tag) mtag.Tag <span class="cov0" title="0">{
        return mtag.Tag{
                ID:          item.ID,
                WorkspaceID: item.WorkspaceID,
                Name:        item.Name,
                Color:       uint8(item.Color),
        }
}</span>

func ConvertModelToDB(item mtag.Tag) gen.Tag <span class="cov0" title="0">{
        return gen.Tag{
                ID:          item.ID,
                WorkspaceID: item.WorkspaceID,
                Name:        item.Name,
                Color:       int8(item.Color),
        }
}</span>

func (s *TagService) GetTag(ctx context.Context, id idwrap.IDWrap) (mtag.Tag, error) <span class="cov0" title="0">{
        item, err := s.queries.GetTag(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return mtag.Tag{}, err
        }</span>
        <span class="cov0" title="0">return ConvertDBToModel(item), nil</span>
}

func (s *TagService) GetTagByWorkspace(ctx context.Context, id idwrap.IDWrap) ([]mtag.Tag, error) <span class="cov0" title="0">{
        item, err := s.queries.GetTagsByWorkspaceID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return []mtag.Tag{}, err
        }</span>

        <span class="cov0" title="0">return tgeneric.MassConvert(item, ConvertDBToModel), nil</span>
}

func (s *TagService) CreateTag(ctx context.Context, ftag mtag.Tag) error <span class="cov0" title="0">{
        arg := ConvertModelToDB(ftag)
        err := s.queries.CreateTag(ctx, gen.CreateTagParams{
                ID:          arg.ID,
                WorkspaceID: arg.WorkspaceID,
                Name:        arg.Name,
                Color:       arg.Color,
        })
        return tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoTag, err)
}</span>

func (s *TagService) UpdateTag(ctx context.Context, ftag mtag.Tag) error <span class="cov0" title="0">{
        arg := ConvertModelToDB(ftag)
        err := s.queries.UpdateTag(ctx, gen.UpdateTagParams{
                ID:    arg.ID,
                Name:  arg.Name,
                Color: arg.Color,
        })
        return tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoTag, err)
}</span>

func (s *TagService) DeleteTag(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        err := s.queries.DeleteTag(ctx, id)
        return tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoTag, err)
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">package suser

import (
        "context"
        "database/sql"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/muser"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

type UserService struct {
        queries *gen.Queries
}

func New(queries *gen.Queries) UserService <span class="cov0" title="0">{
        return UserService{queries: queries}
}</span>

func (us UserService) TX(tx *sql.Tx) UserService <span class="cov0" title="0">{
        return UserService{queries: us.queries.WithTx(tx)}
}</span>

var ErrUserNotFound = sql.ErrNoRows

// WARNING: this is also get user password hash do not use for public api
func (us UserService) GetUser(ctx context.Context, id idwrap.IDWrap) (*muser.User, error) <span class="cov0" title="0">{
        user, err := us.queries.GetUser(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var provider *string = nil
        if user.ProviderID.Valid </span><span class="cov0" title="0">{
                provider = &amp;user.ProviderID.String
        }</span>

        <span class="cov0" title="0">return &amp;muser.User{
                ID:           user.ID,
                Email:        user.Email,
                Password:     user.PasswordHash,
                ProviderType: muser.ProviderType(user.ProviderType),
                ProviderID:   provider,
        }, nil</span>
}

func (us UserService) GetUserByEmail(ctx context.Context, email string) (*muser.User, error) <span class="cov0" title="0">{
        user, err := us.queries.GetUserByEmail(ctx, email)
        err = tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrUserNotFound, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var provider *string = nil
        if user.ProviderID.Valid </span><span class="cov0" title="0">{
                provider = &amp;user.ProviderID.String
        }</span>
        <span class="cov0" title="0">return &amp;muser.User{
                ID:           user.ID,
                Email:        user.Email,
                Password:     user.PasswordHash,
                ProviderType: muser.ProviderType(user.ProviderType),
                ProviderID:   provider,
        }, nil</span>
}

func (us UserService) CreateUser(ctx context.Context, user *muser.User) error <span class="cov0" title="0">{
        var ProviderID sql.NullString
        if user.ProviderID != nil </span><span class="cov0" title="0">{
                ProviderID = sql.NullString{
                        String: *user.ProviderID,
                        Valid:  true,
                }
        }</span> else<span class="cov0" title="0"> {
                ProviderID = sql.NullString{
                        Valid: false,
                }
        }</span>

        <span class="cov0" title="0">return us.queries.CreateUser(ctx, gen.CreateUserParams{
                ID:           user.ID,
                Email:        user.Email,
                PasswordHash: user.Password,
                ProviderType: int8(user.ProviderType),
                ProviderID:   ProviderID,
        })</span>
}

func (us UserService) UpdateUser(ctx context.Context, user *muser.User) error <span class="cov0" title="0">{
        err := us.queries.UpdateUser(ctx, gen.UpdateUserParams{
                ID:           user.ID,
                Email:        user.Email,
                PasswordHash: user.Password,
        })
        err = tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrUserNotFound, err)
        return err
}</span>

func (us UserService) DeleteUser(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        return us.queries.DeleteUser(ctx, id)
}</span>

// WARNING: this is also get user password hash do not use for public api
func (us UserService) GetUserWithOAuthIDAndType(ctx context.Context, oauthID string, oauthType muser.ProviderType) (*muser.User, error) <span class="cov0" title="0">{
        user, err := us.queries.GetUserByProviderIDandType(ctx, gen.GetUserByProviderIDandTypeParams{
                ProviderID: sql.NullString{
                        String: oauthID,
                        Valid:  true,
                },
                ProviderType: int8(oauthType),
        })
        err = tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrUserNotFound, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;muser.User{
                ID:           user.ID,
                Email:        user.Email,
                Password:     user.PasswordHash,
                ProviderType: oauthType,
                ProviderID:   &amp;oauthID,
        }, nil</span>
}

func (us UserService) CheckUserBelongsToWorkspace(ctx context.Context, userID idwrap.IDWrap, workspaceID idwrap.IDWrap) (bool, error) <span class="cov0" title="0">{
        b, err := us.queries.CheckIFWorkspaceUserExists(ctx, gen.CheckIFWorkspaceUserExistsParams{
                UserID:      userID,
                WorkspaceID: workspaceID,
        })
        err = tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrUserNotFound, err)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return b, nil</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">package svar

import (
        "context"
        "database/sql"
        "fmt"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/movable"
)

// VariableMovableRepository implements movable.MovableRepository for Variables
// It adapts position-based operations to linked list operations using prev/next pointers
type VariableMovableRepository struct {
        queries *gen.Queries
}

// NewVariableMovableRepository creates a new VariableMovableRepository
func NewVariableMovableRepository(queries *gen.Queries) *VariableMovableRepository <span class="cov8" title="1">{
        return &amp;VariableMovableRepository{
                queries: queries,
        }
}</span>

// TX returns a new repository instance with transaction support
func (r *VariableMovableRepository) TX(tx *sql.Tx) *VariableMovableRepository <span class="cov0" title="0">{
        return &amp;VariableMovableRepository{
                queries: r.queries.WithTx(tx),
        }
}</span>

// UpdatePosition updates the position of a variable in the linked list
// For variables, parentID is the env_id and listType is ignored
func (r *VariableMovableRepository) UpdatePosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap, listType movable.ListType, position int) error <span class="cov0" title="0">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get variable to find env_id
        <span class="cov0" title="0">variable, err := repo.queries.GetVariable(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get variable: %w", err)
        }</span>

        // Get ordered list of variables in environment
        <span class="cov0" title="0">orderedVariables, err := repo.queries.GetVariablesByEnvironmentIDOrdered(ctx, gen.GetVariablesByEnvironmentIDOrderedParams{
                EnvID:   variable.EnvID,
                EnvID_2: variable.EnvID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get variables in order: %w", err)
        }</span>

        // Find current position and validate new position
        <span class="cov0" title="0">currentIdx := -1
        for i, v := range orderedVariables </span><span class="cov0" title="0">{
                if idwrap.NewFromBytesMust(v.ID).Compare(itemID) == 0 </span><span class="cov0" title="0">{
                        currentIdx = i
                        break</span>
                }
        }

        <span class="cov0" title="0">if currentIdx == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("variable not found in environment")
        }</span>

        <span class="cov0" title="0">if position &lt; 0 || position &gt;= len(orderedVariables) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid position: %d (valid range: 0-%d)", position, len(orderedVariables)-1)
        }</span>

        <span class="cov0" title="0">if currentIdx == position </span><span class="cov0" title="0">{
                // No change needed
                return nil
        }</span>

        // FIXED: Use proper remove/insert pattern to maintain linked list integrity
        // Step 1: Remove the variable from its current position
        <span class="cov0" title="0">if err := repo.removeFromPosition(ctx, tx, itemID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove variable from current position: %w", err)
        }</span>

        // Step 2: Calculate the target position after removal
        // When we remove an item, positions of items after it shift down by 1
        <span class="cov0" title="0">targetPosition := position
        if currentIdx &lt; position </span><span class="cov0" title="0">{
                targetPosition = position - 1
        }</span>
        
        // Special case: if we're moving to the last position in the original list,
        // we want to append to the end of the reduced list
        <span class="cov0" title="0">if position == len(orderedVariables)-1 </span><span class="cov0" title="0">{
                targetPosition = len(orderedVariables) // This will trigger append to end in insertAtPosition
        }</span>

        // Step 3: Insert the variable at the new position
        <span class="cov0" title="0">if err := repo.insertAtPosition(ctx, tx, itemID, variable.EnvID, targetPosition); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert variable at new position: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdatePositions updates positions for multiple variables in batch
func (r *VariableMovableRepository) UpdatePositions(ctx context.Context, tx *sql.Tx, updates []movable.PositionUpdate) error <span class="cov0" title="0">{
        if len(updates) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Get repository with transaction support
        <span class="cov0" title="0">repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get the environment ID from the first variable to validate all are in same environment
        <span class="cov0" title="0">firstVariable, err := repo.queries.GetVariable(ctx, updates[0].ItemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get first variable: %w", err)
        }</span>
        <span class="cov0" title="0">envID := firstVariable.EnvID
        
        // Validate all variables are in the same environment and create ID position map
        positionMap := make(map[idwrap.IDWrap]int)
        for _, update := range updates </span><span class="cov0" title="0">{
                variable, err := repo.queries.GetVariable(ctx, update.ItemID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get variable %s: %w", update.ItemID.String(), err)
                }</span>
                <span class="cov0" title="0">if variable.EnvID.Compare(envID) != 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("all variables must be in the same environment")
                }</span>
                <span class="cov0" title="0">positionMap[update.ItemID] = update.Position</span>
        }
        
        // Build the complete ordered list with all variables at their new positions
        <span class="cov0" title="0">orderedIDs := make([]idwrap.IDWrap, len(updates))
        for _, update := range updates </span><span class="cov0" title="0">{
                if update.Position &lt; 0 || update.Position &gt;= len(updates) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid position %d for variable %s (valid range: 0-%d)", 
                                update.Position, update.ItemID.String(), len(updates)-1)
                }</span>
                <span class="cov0" title="0">orderedIDs[update.Position] = update.ItemID</span>
        }
        
        // Calculate prev/next pointers for each variable in the new order
        <span class="cov0" title="0">type ptrUpdate struct {
                id   idwrap.IDWrap
                prev *idwrap.IDWrap
                next *idwrap.IDWrap
        }
        
        ptrUpdates := make([]ptrUpdate, len(orderedIDs))
        for i, id := range orderedIDs </span><span class="cov0" title="0">{
                var prev, next *idwrap.IDWrap
                
                if i &gt; 0 </span><span class="cov0" title="0">{
                        prev = &amp;orderedIDs[i-1]
                }</span>
                <span class="cov0" title="0">if i &lt; len(orderedIDs)-1 </span><span class="cov0" title="0">{
                        next = &amp;orderedIDs[i+1]
                }</span>
                
                <span class="cov0" title="0">ptrUpdates[i] = ptrUpdate{
                        id:   id,
                        prev: prev,
                        next: next,
                }</span>
        }
        
        // Apply all updates atomically
        <span class="cov0" title="0">for _, update := range ptrUpdates </span><span class="cov0" title="0">{
                if err := repo.queries.UpdateVariableOrder(ctx, gen.UpdateVariableOrderParams{
                        Prev:  update.prev,
                        Next:  update.next,
                        ID:    update.id,
                        EnvID: envID,
                }); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update variable %s order: %w", update.id.String(), err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetMaxPosition returns the maximum position value for variables in an environment
// For linked lists, this is the count of variables minus 1
func (r *VariableMovableRepository) GetMaxPosition(ctx context.Context, parentID idwrap.IDWrap, listType movable.ListType) (int, error) <span class="cov0" title="0">{
        // For variables, parentID is the env_id
        orderedVariables, err := r.queries.GetVariablesByEnvironmentIDOrdered(ctx, gen.GetVariablesByEnvironmentIDOrderedParams{
                EnvID:   parentID,
                EnvID_2: parentID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return -1, nil // No variables means no max position
                }</span>
                <span class="cov0" title="0">return 0, fmt.Errorf("failed to get variables in order: %w", err)</span>
        }

        <span class="cov0" title="0">if len(orderedVariables) == 0 </span><span class="cov0" title="0">{
                return -1, nil
        }</span>

        <span class="cov0" title="0">return len(orderedVariables) - 1, nil</span>
}

// GetItemsByParent returns all variables under an environment, ordered by position
func (r *VariableMovableRepository) GetItemsByParent(ctx context.Context, parentID idwrap.IDWrap, listType movable.ListType) ([]movable.MovableItem, error) <span class="cov0" title="0">{
        // For variables, parentID is the env_id
        orderedVariables, err := r.queries.GetVariablesByEnvironmentIDOrdered(ctx, gen.GetVariablesByEnvironmentIDOrderedParams{
                EnvID:   parentID,
                EnvID_2: parentID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []movable.MovableItem{}, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get variables in order: %w", err)</span>
        }

        // Convert to MovableItem structs
        <span class="cov0" title="0">items := make([]movable.MovableItem, len(orderedVariables))
        for i, v := range orderedVariables </span><span class="cov0" title="0">{
                items[i] = movable.MovableItem{
                        ID:       idwrap.NewFromBytesMust(v.ID),
                        ParentID: &amp;parentID, // env_id as parent
                        Position: int(v.Position),
                        ListType: listType,
                }
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

// insertAtPosition inserts a variable at a specific position in the linked list
// This is a helper method for operations that need to insert new variables
func (r *VariableMovableRepository) insertAtPosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap, envID idwrap.IDWrap, position int) error <span class="cov0" title="0">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get ordered list of variables in environment
        <span class="cov0" title="0">orderedVariables, err := repo.queries.GetVariablesByEnvironmentIDOrdered(ctx, gen.GetVariablesByEnvironmentIDOrderedParams{
                EnvID:   envID,
                EnvID_2: envID,
        })
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get variables in order: %w", err)
        }</span>

        <span class="cov0" title="0">var newPrev, newNext *idwrap.IDWrap

        if len(orderedVariables) == 0 </span><span class="cov0" title="0">{
                // First variable in environment
                newPrev = nil
                newNext = nil
        }</span> else<span class="cov0" title="0"> if position == 0 </span><span class="cov0" title="0">{
                // Insert at head
                newPrev = nil
                if len(orderedVariables) &gt; 0 </span><span class="cov0" title="0">{
                        currentHeadID := idwrap.NewFromBytesMust(orderedVariables[0].ID)
                        newNext = &amp;currentHeadID
                        
                        // Get the current head's next pointer to preserve it
                        currentHead, err := repo.queries.GetVariable(ctx, currentHeadID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get current head: %w", err)
                        }</span>
                        
                        // Update the current head to point back to new item
                        <span class="cov0" title="0">err = repo.queries.UpdateVariableOrder(ctx, gen.UpdateVariableOrderParams{
                                Prev:  &amp;itemID,        // Current head's prev now points to new item
                                Next:  currentHead.Next, // Preserve current head's next pointer
                                ID:    currentHeadID,
                                EnvID: envID,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update current head: %w", err)
                        }</span>
                }
        } else<span class="cov0" title="0"> if position &gt;= len(orderedVariables) </span><span class="cov0" title="0">{
                // Insert at tail
                if len(orderedVariables) &gt; 0 </span><span class="cov0" title="0">{
                        currentTailID := idwrap.NewFromBytesMust(orderedVariables[len(orderedVariables)-1].ID)
                        newPrev = &amp;currentTailID
                        
                        // Get the current tail's prev pointer to preserve it
                        currentTail, err := repo.queries.GetVariable(ctx, currentTailID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to get current tail: %w", err)
                        }</span>
                        
                        // Update the current tail to point forward to new item
                        <span class="cov0" title="0">err = repo.queries.UpdateVariableOrder(ctx, gen.UpdateVariableOrderParams{
                                Prev:  currentTail.Prev, // Preserve current tail's prev pointer
                                Next:  &amp;itemID,         // Current tail's next now points to new item
                                ID:    currentTailID,
                                EnvID: envID,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update current tail: %w", err)
                        }</span>
                }
                <span class="cov0" title="0">newNext = nil</span>
        } else<span class="cov0" title="0"> {
                // Insert in middle
                prevID := idwrap.NewFromBytesMust(orderedVariables[position-1].ID)
                nextID := idwrap.NewFromBytesMust(orderedVariables[position].ID)
                newPrev = &amp;prevID
                newNext = &amp;nextID
                
                // Get existing prev and next items to preserve their other pointers
                prevItem, err := repo.queries.GetVariable(ctx, prevID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get prev item: %w", err)
                }</span>
                
                <span class="cov0" title="0">nextItem, err := repo.queries.GetVariable(ctx, nextID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get next item: %w", err)
                }</span>
                
                // Update prev item to point to new item
                <span class="cov0" title="0">err = repo.queries.UpdateVariableOrder(ctx, gen.UpdateVariableOrderParams{
                        Prev:  prevItem.Prev, // Preserve prev item's own prev pointer
                        Next:  &amp;itemID,       // Point to new item
                        ID:    prevID,
                        EnvID: envID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update prev item: %w", err)
                }</span>
                
                // Update next item to point back to new item
                <span class="cov0" title="0">err = repo.queries.UpdateVariableOrder(ctx, gen.UpdateVariableOrderParams{
                        Prev:  &amp;itemID,       // Point to new item
                        Next:  nextItem.Next, // Preserve next item's own next pointer
                        ID:    nextID,
                        EnvID: envID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update next item: %w", err)
                }</span>
        }

        // Set the new item's position
        <span class="cov0" title="0">return repo.queries.UpdateVariableOrder(ctx, gen.UpdateVariableOrderParams{
                Prev:  newPrev,
                Next:  newNext,
                ID:    itemID,
                EnvID: envID,
        })</span>
}

// removeFromPosition removes a variable from its current position in the linked list
// This is a helper method for operations that need to remove variables
func (r *VariableMovableRepository) removeFromPosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap) error <span class="cov0" title="0">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get the variable to remove and its current prev/next pointers
        <span class="cov0" title="0">variable, err := repo.queries.GetVariable(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get variable: %w", err)
        }</span>

        // Update prev variable's next pointer to skip the removed variable
        <span class="cov0" title="0">if variable.Prev != nil </span><span class="cov0" title="0">{
                err = repo.queries.UpdateVariableNext(ctx, gen.UpdateVariableNextParams{
                        Next:  variable.Next, // Point to the removed variable's next
                        ID:    *variable.Prev,
                        EnvID: variable.EnvID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update previous variable's next pointer: %w", err)
                }</span>
        }

        // Update next variable's prev pointer to skip the removed variable
        <span class="cov0" title="0">if variable.Next != nil </span><span class="cov0" title="0">{
                err = repo.queries.UpdateVariablePrev(ctx, gen.UpdateVariablePrevParams{
                        Prev:  variable.Prev, // Point to the removed variable's prev
                        ID:    *variable.Next,
                        EnvID: variable.EnvID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update next variable's prev pointer: %w", err)
                }</span>
        }

        // Clear the removed variable's pointers
        <span class="cov0" title="0">err = repo.queries.UpdateVariableOrder(ctx, gen.UpdateVariableOrderParams{
                Prev:  nil,
                Next:  nil,
                ID:    itemID,
                EnvID: variable.EnvID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear removed variable's pointers: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file114" style="display: none">package svar

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mvar"
        "the-dev-tools/server/pkg/movable"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

type VarService struct {
        queries              *gen.Queries
        logger               *slog.Logger
        linkedListManager    movable.LinkedListManager
        movableRepository    movable.MovableRepository
}

var (
        ErrNoVarFound                 = sql.ErrNoRows
        ErrInvalidMoveOperation       = fmt.Errorf("invalid move operation")
        ErrEnvironmentBoundaryViolation = fmt.Errorf("variables must be in same environment")
        ErrSelfReferentialMove        = fmt.Errorf("cannot move variable relative to itself")
)

func New(queries *gen.Queries, logger *slog.Logger) VarService <span class="cov8" title="1">{
        // Create the movable repository for variables
        movableRepo := NewVariableMovableRepository(queries)
        
        // Create the linked list manager with the movable repository
        linkedListManager := movable.NewDefaultLinkedListManager(movableRepo)
        
        return VarService{
                queries:              queries,
                logger:               logger,
                linkedListManager:    linkedListManager,
                movableRepository:    movableRepo,
        }
}</span>

func (e VarService) TX(tx *sql.Tx) VarService <span class="cov0" title="0">{
        // Create new instances with transaction support
        txQueries := e.queries.WithTx(tx)
        movableRepo := NewVariableMovableRepository(txQueries)
        linkedListManager := movable.NewDefaultLinkedListManager(movableRepo)
        
        return VarService{
                queries:              txQueries,
                logger:               e.logger,
                linkedListManager:    linkedListManager,
                movableRepository:    movableRepo,
        }
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*VarService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Create movable repository and linked list manager
        <span class="cov0" title="0">movableRepo := NewVariableMovableRepository(queries)
        linkedListManager := movable.NewDefaultLinkedListManager(movableRepo)
        
        // Use a default logger for transaction services
        logger := slog.Default()
        
        service := VarService{
                queries:              queries,
                logger:               logger,
                linkedListManager:    linkedListManager,
                movableRepository:    movableRepo,
        }
        return &amp;service, nil</span>
}

func ConvertToDBVar(varParm mvar.Var) gen.Variable <span class="cov8" title="1">{
        return gen.Variable{
                ID:          varParm.ID,
                EnvID:       varParm.EnvID,
                VarKey:      varParm.VarKey,
                Value:       varParm.Value,
                Enabled:     varParm.Enabled,
                Description: varParm.Description,
        }
}</span>

func ConvertToModelVar(varParm gen.Variable) *mvar.Var <span class="cov8" title="1">{
        return &amp;mvar.Var{
                ID:          varParm.ID,
                EnvID:       varParm.EnvID,
                VarKey:      varParm.VarKey,
                Value:       varParm.Value,
                Enabled:     varParm.Enabled,
                Description: varParm.Description,
        }
}</span>

func (e VarService) Get(ctx context.Context, id idwrap.IDWrap) (*mvar.Var, error) <span class="cov0" title="0">{
        variable, err := e.queries.GetVariable(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoVarFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return ConvertToModelVar(variable), nil</span>
}

func (e VarService) GetVariableByEnvID(ctx context.Context, envID idwrap.IDWrap) ([]mvar.Var, error) <span class="cov0" title="0">{
        rows, err := e.queries.GetVariablesByEnvironmentID(ctx, envID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []mvar.Var{}, ErrNoVarFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return tgeneric.MassConvertPtr(rows, ConvertToModelVar), nil</span>
}

func (e VarService) Create(ctx context.Context, varParm mvar.Var) error <span class="cov0" title="0">{
        // Find the current tail of the linked list (last variable in environment)
        existingVariables, err := e.GetVariablesByEnvIDOrdered(ctx, varParm.EnvID)
        if err != nil &amp;&amp; err != ErrNoVarFound </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get existing variables: %w", err)
        }</span>

        <span class="cov0" title="0">var prev *idwrap.IDWrap

        // If there are existing variables, set prev to point to the last one
        // and update that variable's next pointer to point to the new one
        if len(existingVariables) &gt; 0 </span><span class="cov0" title="0">{
                lastVariable := existingVariables[len(existingVariables)-1]
                prev = &amp;lastVariable.ID

                // Get the database version to access prev/next fields
                dbLastVariable, err := e.queries.GetVariable(ctx, lastVariable.ID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get last variable from database: %w", err)
                }</span>

                // Update the current tail's next pointer to point to new variable
                <span class="cov0" title="0">err = e.queries.UpdateVariableOrder(ctx, gen.UpdateVariableOrderParams{
                        Prev:  dbLastVariable.Prev, // Keep existing prev pointer
                        Next:  &amp;varParm.ID,         // Set next to new variable
                        ID:    lastVariable.ID,     // Update the last variable
                        EnvID: varParm.EnvID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update previous tail variable: %w", err)
                }</span>
        }

        // Create the variable with proper linked list pointers
        <span class="cov0" title="0">return e.queries.CreateVariable(ctx, gen.CreateVariableParams{
                ID:          varParm.ID,
                EnvID:       varParm.EnvID,
                VarKey:      varParm.VarKey,
                Value:       varParm.Value,
                Enabled:     varParm.Enabled,
                Description: varParm.Description,
                Prev:        prev, // Points to current tail (or nil if first)
                Next:        nil,  // Always nil for new variables (they become the new tail)
        })</span>
}

func (e VarService) Update(ctx context.Context, varParm *mvar.Var) error <span class="cov0" title="0">{
        variable := ConvertToDBVar(*varParm)
        return e.queries.UpdateVariable(ctx, gen.UpdateVariableParams{
                ID:          variable.ID,
                VarKey:      variable.VarKey,
                Value:       variable.Value,
                Enabled:     variable.Enabled,
                Description: variable.Description,
        })
}</span>

func (e VarService) Delete(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        return e.DeleteVariableTX(ctx, nil, id)
}</span>

// GetEnvID returns the environment ID for a variable
func (e VarService) GetEnvID(ctx context.Context, varID idwrap.IDWrap) (idwrap.IDWrap, error) <span class="cov0" title="0">{
        variable, err := e.queries.GetVariable(ctx, varID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return idwrap.IDWrap{}, ErrNoVarFound
                }</span>
                <span class="cov0" title="0">return idwrap.IDWrap{}, err</span>
        }
        <span class="cov0" title="0">return variable.EnvID, nil</span>
}

// CheckEnvironmentBoundaries ensures both variables are in the same environment
func (e VarService) CheckEnvironmentBoundaries(ctx context.Context, varID, ownerID idwrap.IDWrap) (bool, error) <span class="cov0" title="0">{
        variableEnvID, err := e.GetEnvID(ctx, varID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return false, ErrNoVarFound
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov0" title="0">return ownerID.Compare(variableEnvID) == 0, nil</span>
}

// GetVariablesByEnvIDOrdered returns variables in the environment in their proper order
func (e VarService) GetVariablesByEnvIDOrdered(ctx context.Context, envID idwrap.IDWrap) ([]mvar.Var, error) <span class="cov0" title="0">{
        // Use the underlying query that maintains the linked list order
        orderedVariables, err := e.queries.GetVariablesByEnvironmentIDOrdered(ctx, gen.GetVariablesByEnvironmentIDOrderedParams{
                EnvID:   envID,
                EnvID_2: envID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        e.logger.InfoContext(ctx, fmt.Sprintf("envID: %s has no variables", envID.String()))
                        return []mvar.Var{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Convert to model variables
        <span class="cov0" title="0">variables := make([]mvar.Var, len(orderedVariables))
        for i, v := range orderedVariables </span><span class="cov0" title="0">{
                variables[i] = mvar.Var{
                        ID:          idwrap.NewFromBytesMust(v.ID),
                        EnvID:       idwrap.NewFromBytesMust(v.EnvID),
                        VarKey:      v.VarKey,
                        Value:       v.Value,
                        Enabled:     v.Enabled,
                        Description: v.Description,
                }
        }</span>

        <span class="cov0" title="0">return variables, nil</span>
}

// DeleteVariableTX deletes a variable while maintaining linked-list integrity within a transaction
func (e VarService) DeleteVariableTX(ctx context.Context, tx *sql.Tx, id idwrap.IDWrap) error <span class="cov0" title="0">{
        service := e
        if tx != nil </span><span class="cov0" title="0">{
                service = e.TX(tx)
        }</span>

        // 1. Get the variable being deleted to find its prev/next pointers
        <span class="cov0" title="0">variable, err := service.queries.GetVariable(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        e.logger.DebugContext(ctx, fmt.Sprintf("Variable %s not found for deletion", id.String()))
                        return ErrNoVarFound
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get variable for deletion: %w", err)</span>
        }

        // 2. Fix linked-list pointers before deletion
        // Update prev variable's next pointer to skip the deleted variable
        <span class="cov0" title="0">if variable.Prev != nil </span><span class="cov0" title="0">{
                err = service.queries.UpdateVariableNext(ctx, gen.UpdateVariableNextParams{
                        Next:  variable.Next,      // Point to the deleted variable's next
                        ID:    *variable.Prev,
                        EnvID: variable.EnvID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update previous variable's next pointer: %w", err)
                }</span>
        }

        // Update next variable's prev pointer to skip the deleted variable
        <span class="cov0" title="0">if variable.Next != nil </span><span class="cov0" title="0">{
                err = service.queries.UpdateVariablePrev(ctx, gen.UpdateVariablePrevParams{
                        Prev:  variable.Prev,      // Point to the deleted variable's prev
                        ID:    *variable.Next,
                        EnvID: variable.EnvID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update next variable's prev pointer: %w", err)
                }</span>
        }

        // 3. Now safely delete the variable
        <span class="cov0" title="0">err = service.queries.DeleteVariable(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete variable after fixing linked-list: %w", err)
        }</span>

        <span class="cov0" title="0">e.logger.DebugContext(ctx, "Variable deleted with linked-list integrity maintained", 
                "variableID", id.String())

        return nil</span>
}

// validateMoveOperation validates that a move operation is safe and valid
func (e VarService) validateMoveOperation(ctx context.Context, varID, targetVarID idwrap.IDWrap) error <span class="cov8" title="1">{
        if varID.Compare(targetVarID) == 0 </span><span class="cov8" title="1">{
                return ErrSelfReferentialMove
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// checkEnvironmentBoundaries ensures both variables are in the same environment
func (e VarService) checkEnvironmentBoundaries(ctx context.Context, varID, targetVarID idwrap.IDWrap) error <span class="cov0" title="0">{
        sourceEnvID, err := e.GetEnvID(ctx, varID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get source variable environment: %w", err)
        }</span>

        <span class="cov0" title="0">targetEnvID, err := e.GetEnvID(ctx, targetVarID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get target variable environment: %w", err)
        }</span>

        <span class="cov0" title="0">if sourceEnvID.Compare(targetEnvID) != 0 </span><span class="cov0" title="0">{
                return ErrEnvironmentBoundaryViolation
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Movable operations for variables

// MoveVariableAfter moves a variable to be positioned after the target variable
func (e VarService) MoveVariableAfter(ctx context.Context, varID, targetVarID idwrap.IDWrap) error <span class="cov0" title="0">{
        return e.MoveVariableAfterTX(ctx, nil, varID, targetVarID)
}</span>

// MoveVariableAfterTX moves a variable to be positioned after the target variable within a transaction
func (e VarService) MoveVariableAfterTX(ctx context.Context, tx *sql.Tx, varID, targetVarID idwrap.IDWrap) error <span class="cov0" title="0">{
        service := e
        if tx != nil </span><span class="cov0" title="0">{
                service = e.TX(tx)
        }</span>

        // Validate the move operation
        <span class="cov0" title="0">if err := service.validateMoveOperation(ctx, varID, targetVarID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check environment boundaries
        <span class="cov0" title="0">if err := service.checkEnvironmentBoundaries(ctx, varID, targetVarID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get environment ID for both variables
        <span class="cov0" title="0">sourceEnvID, err := service.GetEnvID(ctx, varID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get source variable environment: %w", err)
        }</span>

        // Get all variables in the environment in order
        <span class="cov0" title="0">variables, err := service.GetVariablesByEnvIDOrdered(ctx, sourceEnvID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get variables in order: %w", err)
        }</span>

        // Find positions of source and target variables
        <span class="cov0" title="0">var sourcePos, targetPos int = -1, -1
        for i, v := range variables </span><span class="cov0" title="0">{
                if v.ID.Compare(varID) == 0 </span><span class="cov0" title="0">{
                        sourcePos = i
                }</span>
                <span class="cov0" title="0">if v.ID.Compare(targetVarID) == 0 </span><span class="cov0" title="0">{
                        targetPos = i
                }</span>
        }

        <span class="cov0" title="0">if sourcePos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("source variable not found in environment")
        }</span>
        <span class="cov0" title="0">if targetPos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("target variable not found in environment")
        }</span>

        <span class="cov0" title="0">if sourcePos == targetPos </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot move variable relative to itself")
        }</span>

        // Calculate new order: move source to be after target
        <span class="cov0" title="0">newOrder := make([]idwrap.IDWrap, 0, len(variables))

        for i, v := range variables </span><span class="cov0" title="0">{
                if i == sourcePos </span><span class="cov0" title="0">{
                        continue</span> // Skip source variable
                }
                <span class="cov0" title="0">newOrder = append(newOrder, v.ID)
                if i == targetPos </span><span class="cov0" title="0">{
                        newOrder = append(newOrder, varID) // Insert source after target
                }</span>
        }

        // Reorder variables
        <span class="cov0" title="0">return service.ReorderVariablesTX(ctx, tx, sourceEnvID, newOrder)</span>
}

// MoveVariableBefore moves a variable to be positioned before the target variable
func (e VarService) MoveVariableBefore(ctx context.Context, varID, targetVarID idwrap.IDWrap) error <span class="cov0" title="0">{
        return e.MoveVariableBeforeTX(ctx, nil, varID, targetVarID)
}</span>

// MoveVariableBeforeTX moves a variable to be positioned before the target variable within a transaction
func (e VarService) MoveVariableBeforeTX(ctx context.Context, tx *sql.Tx, varID, targetVarID idwrap.IDWrap) error <span class="cov0" title="0">{
        service := e
        if tx != nil </span><span class="cov0" title="0">{
                service = e.TX(tx)
        }</span>

        // Validate the move operation
        <span class="cov0" title="0">if err := service.validateMoveOperation(ctx, varID, targetVarID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check environment boundaries
        <span class="cov0" title="0">if err := service.checkEnvironmentBoundaries(ctx, varID, targetVarID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get environment ID for both variables
        <span class="cov0" title="0">sourceEnvID, err := service.GetEnvID(ctx, varID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get source variable environment: %w", err)
        }</span>

        // Get all variables in the environment in order
        <span class="cov0" title="0">variables, err := service.GetVariablesByEnvIDOrdered(ctx, sourceEnvID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get variables in order: %w", err)
        }</span>

        // Find positions of source and target variables
        <span class="cov0" title="0">var sourcePos, targetPos int = -1, -1
        for i, v := range variables </span><span class="cov0" title="0">{
                if v.ID.Compare(varID) == 0 </span><span class="cov0" title="0">{
                        sourcePos = i
                }</span>
                <span class="cov0" title="0">if v.ID.Compare(targetVarID) == 0 </span><span class="cov0" title="0">{
                        targetPos = i
                }</span>
        }

        <span class="cov0" title="0">if sourcePos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("source variable not found in environment")
        }</span>
        <span class="cov0" title="0">if targetPos == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("target variable not found in environment")
        }</span>

        <span class="cov0" title="0">if sourcePos == targetPos </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot move variable relative to itself")
        }</span>

        // Calculate new order: move source to be before target
        <span class="cov0" title="0">newOrder := make([]idwrap.IDWrap, 0, len(variables))

        for i, v := range variables </span><span class="cov0" title="0">{
                if i == sourcePos </span><span class="cov0" title="0">{
                        continue</span> // Skip source variable
                }
                <span class="cov0" title="0">if i == targetPos </span><span class="cov0" title="0">{
                        newOrder = append(newOrder, varID) // Insert source before target
                }</span>
                <span class="cov0" title="0">newOrder = append(newOrder, v.ID)</span>
        }

        // Reorder variables
        <span class="cov0" title="0">return service.ReorderVariablesTX(ctx, tx, sourceEnvID, newOrder)</span>
}

// ReorderVariables performs a bulk reorder of variables using the movable system
func (e VarService) ReorderVariables(ctx context.Context, envID idwrap.IDWrap, orderedIDs []idwrap.IDWrap) error <span class="cov0" title="0">{
        return e.ReorderVariablesTX(ctx, nil, envID, orderedIDs)
}</span>

// ReorderVariablesTX performs a bulk reorder of variables using the movable system within a transaction
func (e VarService) ReorderVariablesTX(ctx context.Context, tx *sql.Tx, envID idwrap.IDWrap, orderedIDs []idwrap.IDWrap) error <span class="cov0" title="0">{
        service := e
        if tx != nil </span><span class="cov0" title="0">{
                service = e.TX(tx)
        }</span>

        // Build position updates using the environment list type
        <span class="cov0" title="0">updates := make([]movable.PositionUpdate, len(orderedIDs))
        for i, id := range orderedIDs </span><span class="cov0" title="0">{
                updates[i] = movable.PositionUpdate{
                        ItemID:   id,
                        ListType: movable.WorkspaceListTypeVariables, // Variables within an environment
                        Position: i,
                }
        }</span>

        // Execute the batch update using the movable repository
        <span class="cov0" title="0">if err := service.movableRepository.UpdatePositions(ctx, tx, updates); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reorder variables: %w", err)
        }</span>

        <span class="cov0" title="0">e.logger.DebugContext(ctx, "Variables reordered", 
                "envID", envID.String(),
                "variableCount", len(orderedIDs))

        return nil</span>
}

// CompactVariablePositions recalculates and compacts position values to eliminate gaps
func (e VarService) CompactVariablePositions(ctx context.Context, envID idwrap.IDWrap) error <span class="cov0" title="0">{
        return e.CompactVariablePositionsTX(ctx, nil, envID)
}</span>

// CompactVariablePositionsTX recalculates and compacts position values within a transaction
func (e VarService) CompactVariablePositionsTX(ctx context.Context, tx *sql.Tx, envID idwrap.IDWrap) error <span class="cov0" title="0">{
        service := e
        if tx != nil </span><span class="cov0" title="0">{
                service = e.TX(tx)
        }</span>

        <span class="cov0" title="0">if err := service.linkedListManager.CompactPositions(ctx, tx, envID, movable.WorkspaceListTypeVariables); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to compact variable positions: %w", err)
        }</span>

        <span class="cov0" title="0">e.logger.DebugContext(ctx, "Variable positions compacted", "envID", envID.String())
        return nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package sworkspace

import (
        "context"
        "database/sql"
        "fmt"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/movable"
)

// WorkspaceMovableRepository implements movable.MovableRepository for Workspaces
// It adapts position-based operations to linked list operations using prev/next pointers
// For workspaces, the key difference is that UserID acts as the parent scope instead of a direct FK
type WorkspaceMovableRepository struct {
        queries *gen.Queries
}

// NewWorkspaceMovableRepository creates a new WorkspaceMovableRepository
func NewWorkspaceMovableRepository(queries *gen.Queries) *WorkspaceMovableRepository <span class="cov8" title="1">{
        return &amp;WorkspaceMovableRepository{
                queries: queries,
        }
}</span>

// TX returns a new repository instance with transaction support
func (r *WorkspaceMovableRepository) TX(tx *sql.Tx) *WorkspaceMovableRepository <span class="cov0" title="0">{
        return &amp;WorkspaceMovableRepository{
                queries: r.queries.WithTx(tx),
        }
}</span>

// UpdatePosition updates the position of a workspace in the linked list
// For workspaces, parentID is the user_id and listType should be WorkspaceListTypeWorkspaces
func (r *WorkspaceMovableRepository) UpdatePosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap, listType movable.ListType, position int) error <span class="cov0" title="0">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // For workspaces, we need to get the user that owns this workspace
        // Since workspaces don't directly store userID, we need to find it via workspace_users table
        <span class="cov0" title="0">workspaceUsers, err := repo.queries.GetWorkspaceUserByWorkspaceID(ctx, itemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get workspace users: %w", err)
        }</span>
        <span class="cov0" title="0">if len(workspaceUsers) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("workspace has no users")
        }</span>

        // For simplicity, use the first user (workspace owner/admin)
        // In a real system, you'd want to pass the userID as a parameter
        <span class="cov0" title="0">userID := workspaceUsers[0].UserID

        // Get ordered list of workspaces for user
        orderedWorkspaces, err := repo.queries.GetWorkspacesByUserIDOrdered(ctx, gen.GetWorkspacesByUserIDOrderedParams{
                UserID:   userID,
                UserID_2: userID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get workspaces in order: %w", err)
        }</span>

        // Find current position and validate new position
        <span class="cov0" title="0">currentIdx := -1
        for i, ws := range orderedWorkspaces </span><span class="cov0" title="0">{
                if idwrap.NewFromBytesMust(ws.ID).Compare(itemID) == 0 </span><span class="cov0" title="0">{
                        currentIdx = i
                        break</span>
                }
        }

        <span class="cov0" title="0">if currentIdx == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("workspace not found in user's workspace list")
        }</span>

        <span class="cov0" title="0">if position &lt; 0 || position &gt;= len(orderedWorkspaces) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid position: %d (valid range: 0-%d)", position, len(orderedWorkspaces)-1)
        }</span>

        <span class="cov0" title="0">if currentIdx == position </span><span class="cov0" title="0">{
                // No change needed
                return nil
        }</span>

        // Use proper remove/insert pattern to maintain linked list integrity
        // Step 1: Remove the workspace from its current position
        <span class="cov0" title="0">if err := repo.removeFromPosition(ctx, tx, itemID, userID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove workspace from current position: %w", err)
        }</span>

        // Step 2: Calculate the target position after removal
        // When we remove an item, positions of items after it shift down by 1
        <span class="cov0" title="0">targetPosition := position
        if currentIdx &lt; position </span><span class="cov0" title="0">{
                targetPosition = position - 1
        }</span>
        
        // Special case: if we're moving to the last position in the original list,
        // we want to append to the end of the reduced list
        <span class="cov0" title="0">if position == len(orderedWorkspaces)-1 </span><span class="cov0" title="0">{
                targetPosition = len(orderedWorkspaces) // This will trigger append to end in insertAtPosition
        }</span>

        // Step 3: Insert the workspace at the new position
        <span class="cov0" title="0">if err := repo.insertAtPosition(ctx, tx, itemID, userID, targetPosition); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to insert workspace at new position: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdatePositions updates positions for multiple workspaces in batch
func (r *WorkspaceMovableRepository) UpdatePositions(ctx context.Context, tx *sql.Tx, updates []movable.PositionUpdate) error <span class="cov0" title="0">{
        if len(updates) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        // Get repository with transaction support
        <span class="cov0" title="0">repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get user ID from the first workspace to validate all are in same user's list
        <span class="cov0" title="0">firstWorkspaceUsers, err := repo.queries.GetWorkspaceUserByWorkspaceID(ctx, updates[0].ItemID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get first workspace users: %w", err)
        }</span>
        <span class="cov0" title="0">if len(firstWorkspaceUsers) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("first workspace has no users")
        }</span>
        <span class="cov0" title="0">userID := firstWorkspaceUsers[0].UserID
        
        // Validate all workspaces are accessible by the same user and create ID position map
        positionMap := make(map[idwrap.IDWrap]int)
        for _, update := range updates </span><span class="cov0" title="0">{
                workspaceUsers, err := repo.queries.GetWorkspaceUserByWorkspaceID(ctx, update.ItemID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get workspace users for %s: %w", update.ItemID.String(), err)
                }</span>
                
                // Check if user has access to this workspace
                <span class="cov0" title="0">hasAccess := false
                for _, wu := range workspaceUsers </span><span class="cov0" title="0">{
                        if wu.UserID.Compare(userID) == 0 </span><span class="cov0" title="0">{
                                hasAccess = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !hasAccess </span><span class="cov0" title="0">{
                        return fmt.Errorf("user does not have access to workspace %s", update.ItemID.String())
                }</span>
                
                <span class="cov0" title="0">positionMap[update.ItemID] = update.Position</span>
        }
        
        // Build the complete ordered list with all workspaces at their new positions
        <span class="cov0" title="0">orderedIDs := make([]idwrap.IDWrap, len(updates))
        for _, update := range updates </span><span class="cov0" title="0">{
                if update.Position &lt; 0 || update.Position &gt;= len(updates) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid position %d for workspace %s (valid range: 0-%d)", 
                                update.Position, update.ItemID.String(), len(updates)-1)
                }</span>
                <span class="cov0" title="0">orderedIDs[update.Position] = update.ItemID</span>
        }
        
        // Calculate prev/next pointers for each workspace in the new order
        <span class="cov0" title="0">type ptrUpdate struct {
                id   idwrap.IDWrap
                prev *idwrap.IDWrap
                next *idwrap.IDWrap
        }
        
        ptrUpdates := make([]ptrUpdate, len(orderedIDs))
        for i, id := range orderedIDs </span><span class="cov0" title="0">{
                var prev, next *idwrap.IDWrap
                
                if i &gt; 0 </span><span class="cov0" title="0">{
                        prevID := orderedIDs[i-1]
                        prev = &amp;prevID
                }</span>
                <span class="cov0" title="0">if i &lt; len(orderedIDs)-1 </span><span class="cov0" title="0">{
                        nextID := orderedIDs[i+1]
                        next = &amp;nextID
                }</span>
                
                <span class="cov0" title="0">ptrUpdates[i] = ptrUpdate{
                        id:   id,
                        prev: prev,
                        next: next,
                }</span>
        }
        
        // Apply all updates atomically
        <span class="cov0" title="0">for _, update := range ptrUpdates </span><span class="cov0" title="0">{
                if err := repo.queries.UpdateWorkspaceOrder(ctx, gen.UpdateWorkspaceOrderParams{
                        Prev:   update.prev,
                        Next:   update.next,
                        ID:     update.id,
                        UserID: userID,
                }); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update workspace %s order: %w", update.id.String(), err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetMaxPosition returns the maximum position value for workspaces for a user
// For linked lists, this is the count of workspaces minus 1
func (r *WorkspaceMovableRepository) GetMaxPosition(ctx context.Context, parentID idwrap.IDWrap, listType movable.ListType) (int, error) <span class="cov0" title="0">{
        // For workspaces, parentID is the user_id
        orderedWorkspaces, err := r.queries.GetWorkspacesByUserIDOrdered(ctx, gen.GetWorkspacesByUserIDOrderedParams{
                UserID:   parentID,
                UserID_2: parentID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return -1, nil // No workspaces means no max position
                }</span>
                <span class="cov0" title="0">return 0, fmt.Errorf("failed to get workspaces in order: %w", err)</span>
        }

        <span class="cov0" title="0">if len(orderedWorkspaces) == 0 </span><span class="cov0" title="0">{
                return -1, nil
        }</span>

        <span class="cov0" title="0">return len(orderedWorkspaces) - 1, nil</span>
}

// GetItemsByParent returns all workspaces under a user, ordered by position
func (r *WorkspaceMovableRepository) GetItemsByParent(ctx context.Context, parentID idwrap.IDWrap, listType movable.ListType) ([]movable.MovableItem, error) <span class="cov0" title="0">{
        // For workspaces, parentID is the user_id
        orderedWorkspaces, err := r.queries.GetWorkspacesByUserIDOrdered(ctx, gen.GetWorkspacesByUserIDOrderedParams{
                UserID:   parentID,
                UserID_2: parentID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return []movable.MovableItem{}, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get workspaces in order: %w", err)</span>
        }

        // Convert to MovableItem structs
        <span class="cov0" title="0">items := make([]movable.MovableItem, len(orderedWorkspaces))
        for i, ws := range orderedWorkspaces </span><span class="cov0" title="0">{
                items[i] = movable.MovableItem{
                        ID:       idwrap.NewFromBytesMust(ws.ID),
                        ParentID: &amp;parentID, // user_id as parent
                        Position: int(ws.Position),
                        ListType: listType,
                }
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

// insertAtPosition inserts a workspace at a specific position in the linked list
// This is a helper method for operations that need to insert workspaces
func (r *WorkspaceMovableRepository) insertAtPosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap, userID idwrap.IDWrap, position int) error <span class="cov0" title="0">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get ordered list of workspaces for user
        <span class="cov0" title="0">orderedWorkspaces, err := repo.queries.GetWorkspacesByUserIDOrdered(ctx, gen.GetWorkspacesByUserIDOrderedParams{
                UserID:   userID,
                UserID_2: userID,
        })
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get workspaces in order: %w", err)
        }</span>

        <span class="cov0" title="0">var newPrev, newNext *idwrap.IDWrap

        if len(orderedWorkspaces) == 0 </span><span class="cov0" title="0">{
                // First workspace for user
                newPrev = nil
                newNext = nil
        }</span> else<span class="cov0" title="0"> if position == 0 </span><span class="cov0" title="0">{
                // Insert at head
                newPrev = nil
                if len(orderedWorkspaces) &gt; 0 </span><span class="cov0" title="0">{
                        currentHeadID := idwrap.NewFromBytesMust(orderedWorkspaces[0].ID)
                        newNext = &amp;currentHeadID
                        
                        // Update the current head to point back to new item
                        err = repo.queries.UpdateWorkspacePrev(ctx, gen.UpdateWorkspacePrevParams{
                                Prev:   &amp;itemID,        // Current head's prev now points to new item
                                ID:     currentHeadID,
                                UserID: userID,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update current head: %w", err)
                        }</span>
                }
        } else<span class="cov0" title="0"> if position &gt;= len(orderedWorkspaces) </span><span class="cov0" title="0">{
                // Insert at tail
                if len(orderedWorkspaces) &gt; 0 </span><span class="cov0" title="0">{
                        currentTailID := idwrap.NewFromBytesMust(orderedWorkspaces[len(orderedWorkspaces)-1].ID)
                        newPrev = &amp;currentTailID
                        
                        // Update the current tail to point forward to new item
                        err = repo.queries.UpdateWorkspaceNext(ctx, gen.UpdateWorkspaceNextParams{
                                Next:   &amp;itemID,         // Current tail's next now points to new item
                                ID:     currentTailID,
                                UserID: userID,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update current tail: %w", err)
                        }</span>
                }
                <span class="cov0" title="0">newNext = nil</span>
        } else<span class="cov0" title="0"> {
                // Insert in middle
                prevID := idwrap.NewFromBytesMust(orderedWorkspaces[position-1].ID)
                nextID := idwrap.NewFromBytesMust(orderedWorkspaces[position].ID)
                newPrev = &amp;prevID
                newNext = &amp;nextID
                
                // Update prev item to point to new item
                err = repo.queries.UpdateWorkspaceNext(ctx, gen.UpdateWorkspaceNextParams{
                        Next:   &amp;itemID,       // Point to new item
                        ID:     prevID,
                        UserID: userID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update prev item: %w", err)
                }</span>
                
                // Update next item to point back to new item
                <span class="cov0" title="0">err = repo.queries.UpdateWorkspacePrev(ctx, gen.UpdateWorkspacePrevParams{
                        Prev:   &amp;itemID,       // Point to new item
                        ID:     nextID,
                        UserID: userID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update next item: %w", err)
                }</span>
        }

        // Set the new item's position
        <span class="cov0" title="0">return repo.queries.UpdateWorkspaceOrder(ctx, gen.UpdateWorkspaceOrderParams{
                Prev:   newPrev,
                Next:   newNext,
                ID:     itemID,
                UserID: userID,
        })</span>
}

// removeFromPosition removes a workspace from its current position in the linked list
// This is a helper method for operations that need to remove workspaces
func (r *WorkspaceMovableRepository) removeFromPosition(ctx context.Context, tx *sql.Tx, itemID idwrap.IDWrap, userID idwrap.IDWrap) error <span class="cov0" title="0">{
        // Get repository with transaction support
        repo := r
        if tx != nil </span><span class="cov0" title="0">{
                repo = r.TX(tx)
        }</span>

        // Get the workspace to remove and its current prev/next pointers
        <span class="cov0" title="0">workspace, err := repo.queries.GetWorkspaceByUserIDandWorkspaceID(ctx, gen.GetWorkspaceByUserIDandWorkspaceIDParams{
                WorkspaceID: itemID,
                UserID:      userID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get workspace: %w", err)
        }</span>

        // Update prev workspace's next pointer to skip the removed workspace
        <span class="cov0" title="0">if workspace.Prev != nil </span><span class="cov0" title="0">{
                err = repo.queries.UpdateWorkspaceNext(ctx, gen.UpdateWorkspaceNextParams{
                        Next:   workspace.Next, // Point to the removed workspace's next
                        ID:     *workspace.Prev,
                        UserID: userID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update previous workspace's next pointer: %w", err)
                }</span>
        }

        // Update next workspace's prev pointer to skip the removed workspace
        <span class="cov0" title="0">if workspace.Next != nil </span><span class="cov0" title="0">{
                err = repo.queries.UpdateWorkspacePrev(ctx, gen.UpdateWorkspacePrevParams{
                        Prev:   workspace.Prev, // Point to the removed workspace's prev
                        ID:     *workspace.Next,
                        UserID: userID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update next workspace's prev pointer: %w", err)
                }</span>
        }

        // Clear the removed workspace's pointers
        <span class="cov0" title="0">err = repo.queries.UpdateWorkspaceOrder(ctx, gen.UpdateWorkspaceOrderParams{
                Prev:   nil,
                Next:   nil,
                ID:     itemID,
                UserID: userID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear removed workspace's pointers: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file116" style="display: none">package sworkspace

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/dbtime"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mworkspace"
        "the-dev-tools/server/pkg/movable"
        "the-dev-tools/server/pkg/translate/tgeneric"
        "time"
)

var ErrNoWorkspaceFound = sql.ErrNoRows

type WorkspaceService struct {
        queries           *gen.Queries
        movableRepository *WorkspaceMovableRepository
}

func ConvertToDBWorkspace(workspace mworkspace.Workspace) gen.Workspace <span class="cov8" title="1">{
        return gen.Workspace{
                ID:              workspace.ID,
                Name:            workspace.Name,
                Updated:         workspace.Updated.Unix(),
                CollectionCount: workspace.CollectionCount,
                FlowCount:       workspace.FlowCount,
                ActiveEnv:       workspace.ActiveEnv,
                GlobalEnv:       workspace.GlobalEnv,
        }
}</span>

func ConvertToModelWorkspace(workspace gen.Workspace) mworkspace.Workspace <span class="cov0" title="0">{
        return mworkspace.Workspace{
                ID:              workspace.ID,
                Name:            workspace.Name,
                Updated:         dbtime.DBTime(time.Unix(workspace.Updated, 0)),
                CollectionCount: workspace.CollectionCount,
                FlowCount:       workspace.FlowCount,
                ActiveEnv:       workspace.ActiveEnv,
                GlobalEnv:       workspace.GlobalEnv,
        }
}</span>

func ConvertGetWorkspaceRowToModel(workspace gen.GetWorkspaceRow) mworkspace.Workspace <span class="cov0" title="0">{
        return mworkspace.Workspace{
                ID:              workspace.ID,
                Name:            workspace.Name,
                Updated:         dbtime.DBTime(time.Unix(workspace.Updated, 0)),
                CollectionCount: workspace.CollectionCount,
                FlowCount:       workspace.FlowCount,
                ActiveEnv:       workspace.ActiveEnv,
                GlobalEnv:       workspace.GlobalEnv,
        }
}</span>


func ConvertGetWorkspacesByUserIDOrderedRowToModel(workspace gen.GetWorkspacesByUserIDOrderedRow) mworkspace.Workspace <span class="cov8" title="1">{
        return mworkspace.Workspace{
                ID:              idwrap.NewFromBytesMust(workspace.ID),
                Name:            workspace.Name,
                Updated:         dbtime.DBTime(time.Unix(workspace.Updated, 0)),
                CollectionCount: workspace.CollectionCount,
                FlowCount:       workspace.FlowCount,
                ActiveEnv:       idwrap.NewFromBytesMust(workspace.ActiveEnv),
                GlobalEnv:       idwrap.NewFromBytesMust(workspace.GlobalEnv),
        }
}</span>

func New(queries *gen.Queries) WorkspaceService <span class="cov8" title="1">{
        movableRepo := NewWorkspaceMovableRepository(queries)
        
        return WorkspaceService{
                queries: queries,
                movableRepository: movableRepo,
        }
}</span>

func (ws WorkspaceService) TX(tx *sql.Tx) WorkspaceService <span class="cov0" title="0">{
        // Create new instances with transaction support
        txQueries := ws.queries.WithTx(tx)
        movableRepo := NewWorkspaceMovableRepository(txQueries)
        
        return WorkspaceService{
                queries: txQueries,
                movableRepository: movableRepo,
        }
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*WorkspaceService, error) <span class="cov8" title="1">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoWorkspaceFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        
        <span class="cov8" title="1">movableRepo := NewWorkspaceMovableRepository(queries)
        
        return &amp;WorkspaceService{
                queries: queries,
                movableRepository: movableRepo,
        }, nil</span>
}

func (ws WorkspaceService) Create(ctx context.Context, w *mworkspace.Workspace) error <span class="cov8" title="1">{
        dbWorkspace := ConvertToDBWorkspace(*w)
        
        // Create the workspace with initial NULL prev/next
        err := ws.queries.CreateWorkspace(ctx, gen.CreateWorkspaceParams{
                ID:              dbWorkspace.ID,
                Name:            dbWorkspace.Name,
                Updated:         dbWorkspace.Updated,
                CollectionCount: dbWorkspace.CollectionCount,
                FlowCount:       dbWorkspace.FlowCount,
                ActiveEnv:       dbWorkspace.ActiveEnv,
                GlobalEnv:       dbWorkspace.GlobalEnv,
                Prev:            nil, // Initially isolated
                Next:            nil, // Initially isolated
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // NOTE: Auto-linking will be handled by the RPC layer after workspace_user is created
        <span class="cov8" title="1">return nil</span>
}

// AutoLinkWorkspaceToUserList links a newly created workspace into the user's existing workspace chain
// This prevents the workspace from being an isolated node that doesn't appear in the ordered query
// This method should be called after both workspace and workspace_user records are created
func (ws WorkspaceService) AutoLinkWorkspaceToUserList(ctx context.Context, workspaceID idwrap.IDWrap, userID idwrap.IDWrap) error <span class="cov8" title="1">{
        // Get ALL workspaces for the user (including isolated ones)
        // This is critical - we need to see workspaces that aren't linked yet
        allWorkspaces, err := ws.queries.GetAllWorkspacesByUserID(ctx, userID)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get all user workspaces for auto-linking: %w", err)
        }</span>

        // Convert to map for quick lookup and count workspaces excluding the new one
        <span class="cov8" title="1">workspaceMap := make(map[string]bool)
        var existingWorkspaces []gen.Workspace
        
        for _, workspace := range allWorkspaces </span><span class="cov8" title="1">{
                // Skip the newly created workspace itself
                if workspace.ID.Compare(workspaceID) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">workspaceMap[workspace.ID.String()] = true
                existingWorkspaces = append(existingWorkspaces, workspace)</span>
        }

        // If this is the first workspace for the user, leave it as isolated head
        <span class="cov8" title="1">if len(existingWorkspaces) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Find the structure of existing workspaces
        <span class="cov8" title="1">var tailWorkspaceID idwrap.IDWrap
        var foundHead, foundTail bool
        
        // Look for head (prev=NULL) and tail (next=NULL) in existing workspaces
        for _, workspace := range existingWorkspaces </span><span class="cov8" title="1">{
                if workspace.Prev == nil </span><span class="cov8" title="1">{
                        foundHead = true
                }</span>
                <span class="cov8" title="1">if workspace.Next == nil </span><span class="cov8" title="1">{
                        tailWorkspaceID = workspace.ID
                        foundTail = true
                }</span>
        }

        // Handle different scenarios based on existing chain structure
        
        // Scenario 1: No existing chain structure (all workspaces are isolated)
        // Link the new workspace to any existing workspace to start a chain
        <span class="cov8" title="1">if !foundHead &amp;&amp; !foundTail </span><span class="cov0" title="0">{
                // Pick the first existing workspace to form a chain with
                firstExisting := existingWorkspaces[0]
                firstExistingID := firstExisting.ID
                
                // Make firstExisting the head and new workspace its next
                err = ws.queries.UpdateWorkspaceOrder(ctx, gen.UpdateWorkspaceOrderParams{
                        Prev:   nil,
                        Next:   &amp;workspaceID,
                        ID:     firstExistingID,
                        UserID: userID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set first existing workspace as head: %w", err)
                }</span>
                
                // Set new workspace as tail
                <span class="cov0" title="0">err = ws.queries.UpdateWorkspaceOrder(ctx, gen.UpdateWorkspaceOrderParams{
                        Prev:   &amp;firstExistingID,
                        Next:   nil,
                        ID:     workspaceID,
                        UserID: userID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set new workspace as tail: %w", err)
                }</span>
                
                <span class="cov0" title="0">return nil</span>
        }
        
        // Scenario 2: This is the second workspace (one existing, forming first chain)
        <span class="cov8" title="1">if len(existingWorkspaces) == 1 </span><span class="cov8" title="1">{
                firstExistingID := existingWorkspaces[0].ID
                
                // Link first → new (first becomes head if not already)
                err = ws.queries.UpdateWorkspaceOrder(ctx, gen.UpdateWorkspaceOrderParams{
                        Prev:   nil, // First workspace becomes head
                        Next:   &amp;workspaceID,
                        ID:     firstExistingID,
                        UserID: userID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set first workspace as head: %w", err)
                }</span>
                
                // New workspace becomes tail
                <span class="cov8" title="1">err = ws.queries.UpdateWorkspaceOrder(ctx, gen.UpdateWorkspaceOrderParams{
                        Prev:   &amp;firstExistingID,
                        Next:   nil, // New workspace becomes tail
                        ID:     workspaceID,
                        UserID: userID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set new workspace as tail: %w", err)
                }</span>
                
                <span class="cov8" title="1">return nil</span>
        }
        
        // Scenario 3: Multiple workspaces exist with proper chain - append to tail
        <span class="cov8" title="1">if foundTail </span><span class="cov8" title="1">{
                // Update current tail to point to new workspace
                err = ws.queries.UpdateWorkspaceNext(ctx, gen.UpdateWorkspaceNextParams{
                        Next:   &amp;workspaceID,
                        ID:     tailWorkspaceID,
                        UserID: userID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update current tail's next pointer: %w", err)
                }</span>
                
                // Set new workspace as new tail
                <span class="cov8" title="1">err = ws.queries.UpdateWorkspaceOrder(ctx, gen.UpdateWorkspaceOrderParams{
                        Prev:   &amp;tailWorkspaceID,
                        Next:   nil, // New tail
                        ID:     workspaceID,
                        UserID: userID,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set new workspace as tail: %w", err)
                }</span>
                
                <span class="cov8" title="1">return nil</span>
        }
        
        // Scenario 4: Chain is corrupted or unclear - leave workspace isolated
        // This prevents corrupting an already damaged linked list
        <span class="cov0" title="0">return nil</span>
}

func (ws WorkspaceService) Get(ctx context.Context, id idwrap.IDWrap) (*mworkspace.Workspace, error) <span class="cov0" title="0">{
        workspaceRaw, err := ws.queries.GetWorkspace(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoWorkspaceFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">workspace := ConvertGetWorkspaceRowToModel(workspaceRaw)
        return &amp;workspace, nil</span>
}

func (ws WorkspaceService) Update(ctx context.Context, org *mworkspace.Workspace) error <span class="cov0" title="0">{
        err := ws.queries.UpdateWorkspace(ctx, gen.UpdateWorkspaceParams{
                ID:              org.ID,
                Name:            org.Name,
                FlowCount:       org.FlowCount,
                CollectionCount: org.CollectionCount,
                Updated:         org.Updated.Unix(),
                ActiveEnv:       org.ActiveEnv,
        })
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return ErrNoWorkspaceFound
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (ws WorkspaceService) UpdateUpdatedTime(ctx context.Context, org *mworkspace.Workspace) error <span class="cov0" title="0">{
        err := ws.queries.UpdateWorkspaceUpdatedTime(ctx, gen.UpdateWorkspaceUpdatedTimeParams{
                ID:      org.ID,
                Updated: org.Updated.Unix(),
        })
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return ErrNoWorkspaceFound
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (ws WorkspaceService) Delete(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        err := ws.queries.DeleteWorkspace(ctx, id)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return ErrNoWorkspaceFound
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (ws WorkspaceService) GetMultiByUserID(ctx context.Context, userID idwrap.IDWrap) ([]mworkspace.Workspace, error) <span class="cov0" title="0">{
        rawWorkspaces, err := ws.queries.GetWorkspacesByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoWorkspaceFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return tgeneric.MassConvert(rawWorkspaces, ConvertToModelWorkspace), nil</span>
}

func (ws WorkspaceService) GetByIDandUserID(ctx context.Context, orgID, userID idwrap.IDWrap) (*mworkspace.Workspace, error) <span class="cov0" title="0">{
        workspaceRaw, err := ws.queries.GetWorkspaceByUserIDandWorkspaceID(ctx, gen.GetWorkspaceByUserIDandWorkspaceIDParams{
                UserID:      userID,
                WorkspaceID: orgID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoWorkspaceFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">workspace := ConvertToModelWorkspace(workspaceRaw)
        return &amp;workspace, nil</span>
}

// GetWorkspacesByUserIDOrdered returns workspaces for a user in their proper order
func (ws WorkspaceService) GetWorkspacesByUserIDOrdered(ctx context.Context, userID idwrap.IDWrap) ([]mworkspace.Workspace, error) <span class="cov8" title="1">{
        rawWorkspaces, err := ws.queries.GetWorkspacesByUserIDOrdered(ctx, gen.GetWorkspacesByUserIDOrderedParams{
                UserID:   userID,
                UserID_2: userID,
        })
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNoWorkspaceFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return tgeneric.MassConvert(rawWorkspaces, ConvertGetWorkspacesByUserIDOrderedRowToModel), nil</span>
}

// MoveWorkspace moves a workspace to a specific position for a user
func (ws WorkspaceService) MoveWorkspace(ctx context.Context, userID idwrap.IDWrap, workspaceID idwrap.IDWrap, position int) error <span class="cov0" title="0">{
        return ws.MoveWorkspaceTX(ctx, nil, userID, workspaceID, position)
}</span>

// MoveWorkspaceTX moves a workspace to a specific position within a transaction
func (ws WorkspaceService) MoveWorkspaceTX(ctx context.Context, tx *sql.Tx, userID idwrap.IDWrap, workspaceID idwrap.IDWrap, position int) error <span class="cov0" title="0">{
        service := ws
        if tx != nil </span><span class="cov0" title="0">{
                service = ws.TX(tx)
        }</span>

        // Validate user has access to the workspace
        <span class="cov0" title="0">_, err := service.GetByIDandUserID(ctx, workspaceID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("user does not have access to workspace or workspace not found: %w", err)
        }</span>

        // Use the movable repository to perform the position-based move
        <span class="cov0" title="0">err = service.movableRepository.UpdatePosition(ctx, tx, workspaceID, movable.WorkspaceListTypeWorkspaces, position)
        if err != nil </span><span class="cov0" title="0">{
                return tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoWorkspaceFound, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateMoveOperation validates that a move operation is safe and valid
func (ws WorkspaceService) validateMoveOperation(ctx context.Context, userID, workspaceID, targetWorkspaceID idwrap.IDWrap) error <span class="cov0" title="0">{
        if workspaceID.Compare(targetWorkspaceID) == 0 </span><span class="cov0" title="0">{
                return errors.New("cannot move workspace relative to itself")
        }</span>

        // Validate user has access to both workspaces
        <span class="cov0" title="0">_, err := ws.GetByIDandUserID(ctx, workspaceID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("user does not have access to source workspace: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = ws.GetByIDandUserID(ctx, targetWorkspaceID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("user does not have access to target workspace: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// MoveWorkspaceAfter moves a workspace to be positioned after the target workspace
func (ws WorkspaceService) MoveWorkspaceAfter(ctx context.Context, userID, workspaceID, targetWorkspaceID idwrap.IDWrap) error <span class="cov0" title="0">{
        return ws.MoveWorkspaceAfterTX(ctx, nil, userID, workspaceID, targetWorkspaceID)
}</span>

// MoveWorkspaceAfterTX moves a workspace to be positioned after the target workspace within a transaction
func (ws WorkspaceService) MoveWorkspaceAfterTX(ctx context.Context, tx *sql.Tx, userID, workspaceID, targetWorkspaceID idwrap.IDWrap) error <span class="cov0" title="0">{
        service := ws
        if tx != nil </span><span class="cov0" title="0">{
                service = ws.TX(tx)
        }</span>

        // Validate the move operation
        <span class="cov0" title="0">if err := service.validateMoveOperation(ctx, userID, workspaceID, targetWorkspaceID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get all workspaces for the user in order
        <span class="cov0" title="0">orderedWorkspaces, err := service.GetWorkspacesByUserIDOrdered(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get workspaces in order: %w", err)
        }</span>

        // Find positions of source and target workspaces
        <span class="cov0" title="0">targetPosition := -1
        for i, workspace := range orderedWorkspaces </span><span class="cov0" title="0">{
                if workspace.ID.Compare(targetWorkspaceID) == 0 </span><span class="cov0" title="0">{
                        targetPosition = i
                        break</span>
                }
        }

        <span class="cov0" title="0">if targetPosition == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("target workspace not found")
        }</span>

        // Calculate new position: after target (position + 1, but clamped to end)
        <span class="cov0" title="0">newPosition := targetPosition + 1
        if newPosition &gt;= len(orderedWorkspaces) </span><span class="cov0" title="0">{
                newPosition = len(orderedWorkspaces) - 1
        }</span>

        // Execute move using movable repository
        <span class="cov0" title="0">err = service.movableRepository.UpdatePosition(ctx, tx, workspaceID, movable.WorkspaceListTypeWorkspaces, newPosition)
        if err != nil </span><span class="cov0" title="0">{
                return tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoWorkspaceFound, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// MoveWorkspaceBefore moves a workspace to be positioned before the target workspace
func (ws WorkspaceService) MoveWorkspaceBefore(ctx context.Context, userID, workspaceID, targetWorkspaceID idwrap.IDWrap) error <span class="cov0" title="0">{
        return ws.MoveWorkspaceBeforeTX(ctx, nil, userID, workspaceID, targetWorkspaceID)
}</span>

// MoveWorkspaceBeforeTX moves a workspace to be positioned before the target workspace within a transaction
func (ws WorkspaceService) MoveWorkspaceBeforeTX(ctx context.Context, tx *sql.Tx, userID, workspaceID, targetWorkspaceID idwrap.IDWrap) error <span class="cov0" title="0">{
        service := ws
        if tx != nil </span><span class="cov0" title="0">{
                service = ws.TX(tx)
        }</span>

        // Validate the move operation
        <span class="cov0" title="0">if err := service.validateMoveOperation(ctx, userID, workspaceID, targetWorkspaceID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get all workspaces for the user in order
        <span class="cov0" title="0">orderedWorkspaces, err := service.GetWorkspacesByUserIDOrdered(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get workspaces in order: %w", err)
        }</span>

        // Find positions of source and target workspaces
        <span class="cov0" title="0">targetPosition := -1
        for i, workspace := range orderedWorkspaces </span><span class="cov0" title="0">{
                if workspace.ID.Compare(targetWorkspaceID) == 0 </span><span class="cov0" title="0">{
                        targetPosition = i
                        break</span>
                }
        }

        <span class="cov0" title="0">if targetPosition == -1 </span><span class="cov0" title="0">{
                return fmt.Errorf("target workspace not found")
        }</span>

        // Calculate new position: before target (same position, target will shift)
        <span class="cov0" title="0">newPosition := targetPosition

        // Execute move using movable repository
        err = service.movableRepository.UpdatePosition(ctx, tx, workspaceID, movable.WorkspaceListTypeWorkspaces, newPosition)
        if err != nil </span><span class="cov0" title="0">{
                return tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoWorkspaceFound, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ReorderWorkspaces performs a bulk reorder of workspaces using the movable system
func (ws WorkspaceService) ReorderWorkspaces(ctx context.Context, userID idwrap.IDWrap, orderedIDs []idwrap.IDWrap) error <span class="cov0" title="0">{
        return ws.ReorderWorkspacesTX(ctx, nil, userID, orderedIDs)
}</span>

// ReorderWorkspacesTX performs a bulk reorder of workspaces using the movable system within a transaction
func (ws WorkspaceService) ReorderWorkspacesTX(ctx context.Context, tx *sql.Tx, userID idwrap.IDWrap, orderedIDs []idwrap.IDWrap) error <span class="cov0" title="0">{
        service := ws
        if tx != nil </span><span class="cov0" title="0">{
                service = ws.TX(tx)
        }</span>

        // Validate user has access to all workspaces
        <span class="cov0" title="0">for _, workspaceID := range orderedIDs </span><span class="cov0" title="0">{
                _, err := service.GetByIDandUserID(ctx, workspaceID, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("user does not have access to workspace %s: %w", workspaceID.String(), err)
                }</span>
        }

        // Build position updates using the workspace list type
        <span class="cov0" title="0">updates := make([]movable.PositionUpdate, len(orderedIDs))
        for i, workspaceID := range orderedIDs </span><span class="cov0" title="0">{
                updates[i] = movable.PositionUpdate{
                        ItemID:   workspaceID,
                        ListType: movable.WorkspaceListTypeWorkspaces,
                        Position: i,
                }
        }</span>

        // Execute the batch update using the movable repository
        <span class="cov0" title="0">err := service.movableRepository.UpdatePositions(ctx, tx, updates)
        if err != nil </span><span class="cov0" title="0">{
                return tgeneric.ReplaceRootWithSub(sql.ErrNoRows, ErrNoWorkspaceFound, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Repository returns the movable repository for advanced operations
func (ws WorkspaceService) Repository() *WorkspaceMovableRepository <span class="cov0" title="0">{
        return ws.movableRepository
}</span>
</pre>
		
		<pre class="file" id="file117" style="display: none">package sworkspacesusers

import (
        "context"
        "database/sql"
        "errors"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mworkspaceuser"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

var ErrWorkspaceUserNotFound = errors.New("workspace user not found")

func ConvertToDBWorkspaceUser(wsuser mworkspaceuser.WorkspaceUser) gen.WorkspacesUser <span class="cov0" title="0">{
        return gen.WorkspacesUser{
                ID:          wsuser.ID,
                WorkspaceID: wsuser.WorkspaceID,
                UserID:      wsuser.UserID,
                Role:        int8(wsuser.Role),
        }
}</span>

func ConvertToModelWorkspaceUser(wsuser gen.WorkspacesUser) mworkspaceuser.WorkspaceUser <span class="cov0" title="0">{
        return mworkspaceuser.WorkspaceUser{
                ID:          wsuser.ID,
                WorkspaceID: wsuser.WorkspaceID,
                UserID:      wsuser.UserID,
                Role:        mworkspaceuser.Role(wsuser.Role),
        }
}</span>

type WorkspaceUserService struct {
        queries *gen.Queries
}

func New(queries *gen.Queries) WorkspaceUserService <span class="cov0" title="0">{
        return WorkspaceUserService{queries: queries}
}</span>

func (wsu WorkspaceUserService) TX(tx *sql.Tx) WorkspaceUserService <span class="cov0" title="0">{
        return WorkspaceUserService{queries: wsu.queries.WithTx(tx)}
}</span>

func NewTX(ctx context.Context, tx *sql.Tx) (*WorkspaceUserService, error) <span class="cov0" title="0">{
        queries, err := gen.Prepare(ctx, tx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;WorkspaceUserService{
                queries: queries,
        }, nil</span>
}

func (wsu WorkspaceUserService) CreateWorkspaceUser(ctx context.Context, user *mworkspaceuser.WorkspaceUser) error <span class="cov0" title="0">{
        return wsu.queries.CreateWorkspaceUser(ctx, gen.CreateWorkspaceUserParams{
                ID:          user.ID,
                WorkspaceID: user.WorkspaceID,
                UserID:      user.UserID,
                Role:        int8(user.Role),
        })
}</span>

func (wsu WorkspaceUserService) GetWorkspaceUser(ctx context.Context, id idwrap.IDWrap) (*mworkspaceuser.WorkspaceUser, error) <span class="cov0" title="0">{
        wsuser, err := wsu.queries.GetWorkspaceUser(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;mworkspaceuser.WorkspaceUser{
                ID:          wsuser.ID,
                WorkspaceID: wsuser.WorkspaceID,
                UserID:      wsuser.UserID,
                Role:        mworkspaceuser.Role(wsuser.Role),
        }, nil</span>
}

func (wsu WorkspaceUserService) UpdateWorkspaceUser(ctx context.Context, wsuser *mworkspaceuser.WorkspaceUser) error <span class="cov0" title="0">{
        return wsu.queries.UpdateWorkspaceUser(ctx, gen.UpdateWorkspaceUserParams{
                ID:          wsuser.ID,
                WorkspaceID: wsuser.WorkspaceID,
                UserID:      wsuser.UserID,
        })
}</span>

func (wsu WorkspaceUserService) DeleteWorkspaceUser(ctx context.Context, id idwrap.IDWrap) error <span class="cov0" title="0">{
        return wsu.queries.DeleteWorkspaceUser(ctx, id)
}</span>

func (wsus WorkspaceUserService) GetWorkspaceUserByUserID(ctx context.Context, userID idwrap.IDWrap) ([]mworkspaceuser.WorkspaceUser, error) <span class="cov0" title="0">{
        rawWsUsers, err := wsus.queries.GetWorkspaceUserByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return tgeneric.MassConvert(rawWsUsers, ConvertToModelWorkspaceUser), nil</span>
}

func (wsus WorkspaceUserService) GetWorkspaceUserByWorkspaceID(ctx context.Context, wsID idwrap.IDWrap) ([]mworkspaceuser.WorkspaceUser, error) <span class="cov0" title="0">{
        rawWsUsers, err := wsus.queries.GetWorkspaceUserByWorkspaceID(ctx, wsID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return tgeneric.MassConvert(rawWsUsers, ConvertToModelWorkspaceUser), nil</span>
}

func (wsus WorkspaceUserService) GetWorkspaceUsersByWorkspaceIDAndUserID(ctx context.Context, wsID, userID idwrap.IDWrap) (*mworkspaceuser.WorkspaceUser, error) <span class="cov0" title="0">{
        wsu, err := wsus.queries.GetWorkspaceUserByWorkspaceIDAndUserID(ctx, gen.GetWorkspaceUserByWorkspaceIDAndUserIDParams{
                WorkspaceID: wsID,
                UserID:      userID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">workspace := ConvertToModelWorkspaceUser(wsu)
        return &amp;workspace, nil</span>
}

// is a greater than b
func IsPermGreater(a, b *mworkspaceuser.WorkspaceUser) (bool, error) <span class="cov0" title="0">{
        if a.Role &gt; mworkspaceuser.RoleOwner || b.Role &gt; mworkspaceuser.RoleOwner </span><span class="cov0" title="0">{
                return false, errors.New("invalid role")
        }</span>
        <span class="cov0" title="0">return a.Role &gt; b.Role, nil</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package sortenabled

type Enabled interface {
        IsEnabled() bool
}

// just get enabled etc...
func GetAllWithState[E Enabled](enables *[]E, state bool) <span class="cov8" title="1">{
        enablesTemp := *enables
        tempEnables := make([]E, 0, len(enablesTemp))
        for _, enablable := range enablesTemp </span><span class="cov8" title="1">{
                if enablable.IsEnabled() == state </span><span class="cov8" title="1">{
                        tempEnables = append(tempEnables, enablable)
                }</span>
        }
        <span class="cov8" title="1">*enables = tempEnables</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">package stoken

import (
        "fmt"
        "the-dev-tools/server/pkg/idwrap"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/oklog/ulid/v2"
)

type TokenType string

const (
        AccessToken  TokenType = "access_token"
        RefreshToken TokenType = "refresh_token"

        TokenHeaderKey string = "Authorization"
)

type DefaultClaims struct {
        jwt.RegisteredClaims
        TokenType TokenType `json:"token_type"`
        Email     string    `json:"email"`
}

func NewJWT(id idwrap.IDWrap, email string, tokenType TokenType, duration time.Duration, secret []byte) (string, error) <span class="cov8" title="1">{
        t := jwt.NewWithClaims(jwt.SigningMethodHS256, DefaultClaims{
                TokenType: tokenType,
                Email:     email,
                RegisteredClaims: jwt.RegisteredClaims{
                        Issuer:    "devtools-server",
                        Subject:   id.String(),
                        Audience:  jwt.ClaimStrings{"devtools-server"},
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(duration)),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        ID:        ulid.Make().String(),
                },
        })

        tokenString, err := t.SignedString(secret)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return tokenString, nil</span>
}

func keyFunc(secret []byte) jwt.Keyfunc <span class="cov8" title="1">{
        return func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov8" title="1">return secret, nil</span>
        }
}

func parseClaims(tokenString string, secret []byte) (*DefaultClaims, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;DefaultClaims{}, keyFunc(secret))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token")
        }</span>
        <span class="cov8" title="1">return GetClaims(token)</span>
}

func ValidateJWT(tokenString string, tokenType TokenType, secret []byte) (*DefaultClaims, error) <span class="cov8" title="1">{
        claims, err := parseClaims(tokenString, secret)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if claims.TokenType != tokenType </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid token type")
        }</span>

        <span class="cov8" title="1">return claims, nil</span>
}

func GetClaims(token *jwt.Token) (*DefaultClaims, error) <span class="cov8" title="1">{
        claims, ok := token.Claims.(*DefaultClaims)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot cast claims")
        }</span>
        <span class="cov8" title="1">return claims, nil</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">package testutil

import (
        "context"
        "database/sql"
        "log/slog"
        "testing"
        "the-dev-tools/db/pkg/dbtest"
        "the-dev-tools/db/pkg/sqlc/gen"
        "the-dev-tools/server/internal/api/rcollection"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/logger/mocklogger"
        "the-dev-tools/server/pkg/model/mcollection"
        "the-dev-tools/server/pkg/model/muser"
        "the-dev-tools/server/pkg/model/mworkspace"
        "the-dev-tools/server/pkg/model/mworkspaceuser"
        "the-dev-tools/server/pkg/service/scollection"
        "the-dev-tools/server/pkg/service/suser"
        "the-dev-tools/server/pkg/service/sworkspace"
        "the-dev-tools/server/pkg/service/sworkspacesusers"
        "time"
)

type BaseDBQueries struct {
        Queries *gen.Queries
        DB      *sql.DB
        t       *testing.T
        ctx     context.Context
}

type BaseTestServices struct {
        DB  *sql.DB
        Cs  scollection.CollectionService
        Us  suser.UserService
        Ws  sworkspace.WorkspaceService
        Wus sworkspacesusers.WorkspaceUserService
}

func CreateBaseDB(ctx context.Context, t *testing.T) *BaseDBQueries <span class="cov0" title="0">{
        db, err := dbtest.GetTestDB(ctx)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>
        <span class="cov0" title="0">queries, err := gen.Prepare(ctx, db)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>

        <span class="cov0" title="0">return &amp;BaseDBQueries{Queries: queries, t: t, ctx: ctx, DB: db}</span>
}

func (c BaseDBQueries) GetBaseServices() BaseTestServices <span class="cov0" title="0">{
        queries := c.Queries

        mockLogger := mocklogger.NewMockLogger()
        cs := scollection.New(queries, mockLogger)
        ws := sworkspace.New(queries)
        wus := sworkspacesusers.New(queries)
        us := suser.New(queries)
        return BaseTestServices{
                DB:  c.DB,
                Cs:  cs,
                Us:  us,
                Ws:  ws,
                Wus: wus,
        }
}</span>

func (c BaseTestServices) CreateTempCollection(t *testing.T, ctx context.Context, wsID, wuID, userID, collectionID idwrap.IDWrap) <span class="cov0" title="0">{
        cs := c.Cs
        ws := c.Ws
        wus := c.Wus
        us := c.Us

        workspaceData := mworkspace.Workspace{
                ID:      wsID,
                Updated: time.Now(),
                Name:    "test",
        }

        err := ws.Create(ctx, &amp;workspaceData)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>

        <span class="cov0" title="0">providerID := "test"
        userData := muser.User{
                ID:           userID,
                Email:        "test@dev.tools",
                Password:     []byte("test"),
                ProviderID:   &amp;providerID,
                ProviderType: muser.MagicLink,
                Status:       muser.Active,
        }

        err = us.CreateUser(ctx, &amp;userData)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>

        <span class="cov0" title="0">workspaceUserData := mworkspaceuser.WorkspaceUser{
                ID:          wuID,
                WorkspaceID: wsID,
                UserID:      userID,
                Role:        mworkspaceuser.RoleAdmin,
        }

        err = wus.CreateWorkspaceUser(ctx, &amp;workspaceUserData)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>

        <span class="cov0" title="0">collectionData := mcollection.Collection{
                ID:          collectionID,
                WorkspaceID: wsID,
                Name:        "test",
                Updated:     time.Now(),
        }

        err = cs.CreateCollection(ctx, &amp;collectionData)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>

        <span class="cov0" title="0">collectionGet, err := cs.GetCollection(ctx, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>

        <span class="cov0" title="0">if collectionGet == nil </span><span class="cov0" title="0">{
                t.Fatal("Collection not found")
        }</span>
}

func (c BaseTestServices) CreateCollectionRPC() rcollection.CollectionServiceRPC <span class="cov0" title="0">{
        return rcollection.New(c.DB, c.Cs, c.Ws, c.Us)
}</span>

func (b BaseDBQueries) Close() <span class="cov0" title="0">{
        err := b.DB.Close()
        if err != nil </span><span class="cov0" title="0">{
                b.t.Error(err)
        }</span>
        <span class="cov0" title="0">err = b.Queries.Close()
        if err != nil </span><span class="cov0" title="0">{
                b.t.Error(err)
        }</span>
}

func AssertFatal[c comparable](t *testing.T, expected, got c) <span class="cov0" title="0">{
        t.Helper()
        if got != expected </span><span class="cov0" title="0">{
                t.Fatalf("got %v, expected %v", got, expected)
        }</span>
}

func Assert[c comparable](t *testing.T, expected, got c) <span class="cov0" title="0">{
        t.Helper()
        if got != expected </span><span class="cov0" title="0">{
                t.Errorf("got %v, expected %v", got, expected)
        }</span>
}

func AssertNot[c comparable](t *testing.T, not, got c) <span class="cov0" title="0">{
        t.Helper()
        if got == not </span><span class="cov0" title="0">{
                t.Errorf("got %v, expected not %v", got, not)
        }</span>
}

func AssertNotFatal[c comparable](t *testing.T, not, got c) <span class="cov0" title="0">{
        t.Helper()
        if got == not </span><span class="cov0" title="0">{
                t.Fatalf("got %v, expected not %v", got, not)
        }</span>
}

func (b BaseDBQueries) Logger() *slog.Logger <span class="cov0" title="0">{
        return mocklogger.NewMockLogger()
}</span>
</pre>
		
		<pre class="file" id="file121" style="display: none">package tassert

import (
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/massert"
        "the-dev-tools/server/pkg/translate/tcondition"
        requestv1 "the-dev-tools/spec/dist/buf/go/collection/item/request/v1"
)

func SerializeAssertModelToRPC(a massert.Assert) (*requestv1.Assert, error) <span class="cov0" title="0">{

        return &amp;requestv1.Assert{
                AssertId:  a.ID.Bytes(),
                Condition: tcondition.SeralizeConditionModelToRPC(a.Condition),
        }, nil
}</span>

func SerializeAssertModelToRPCItem(a massert.Assert) (*requestv1.AssertListItem, error) <span class="cov0" title="0">{
        assertRpc, err := SerializeAssertModelToRPC(a)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;requestv1.AssertListItem{
                AssertId:  assertRpc.AssertId,
                Condition: assertRpc.Condition,
        }, nil</span>
}

func SerializeAssertRPCToModel(rpcAssert *requestv1.Assert, exampleID idwrap.IDWrap) (massert.Assert, error) <span class="cov0" title="0">{
        id, err := idwrap.NewFromBytes(rpcAssert.GetAssertId())
        if err != nil </span><span class="cov0" title="0">{
                return massert.Assert{}, err
        }</span>

        <span class="cov0" title="0">var deltaParentIDPtr *idwrap.IDWrap

        modelAssert := SerializeAssertRPCToModelWithoutID(rpcAssert, exampleID, deltaParentIDPtr)
        modelAssert.ID = id
        return modelAssert, nil</span>
}

func SerializeAssertRPCToModelWithoutID(a *requestv1.Assert, exampleID idwrap.IDWrap, deltaParentIDPtr *idwrap.IDWrap) massert.Assert <span class="cov0" title="0">{

        return massert.Assert{
                ExampleID:     exampleID,
                DeltaParentID: deltaParentIDPtr,
                Condition:     tcondition.DeserializeConditionRPCToModel(a.Condition),
        }
}</span>

func SerializeAssertModelToRPCDeltaItem(a massert.Assert) (*requestv1.AssertDeltaListItem, error) <span class="cov0" title="0">{
        assertRpc, err := SerializeAssertModelToRPC(a)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;requestv1.AssertDeltaListItem{
                AssertId:  assertRpc.AssertId,
                Condition: assertRpc.Condition,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package tbodyform

import (
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mbodyform"
        bodyv1 "the-dev-tools/spec/dist/buf/go/collection/item/body/v1"
)

func SerializeFormModelToRPC(form mbodyform.BodyForm) *bodyv1.BodyForm <span class="cov0" title="0">{

        return &amp;bodyv1.BodyForm{
                BodyId:      form.ID.Bytes(),
                Key:         form.BodyKey,
                Enabled:     form.Enable,
                Value:       form.Value,
                Description: form.Description,
        }
}</span>

func SerializeFormModelToRPCItem(form mbodyform.BodyForm) *bodyv1.BodyFormListItem <span class="cov0" title="0">{

        return &amp;bodyv1.BodyFormListItem{
                BodyId:      form.ID.Bytes(),
                Key:         form.BodyKey,
                Enabled:     form.Enable,
                Value:       form.Value,
                Description: form.Description,
        }
}</span>

func SerializeFormRPCtoModel(form *bodyv1.BodyForm, ExampleID idwrap.IDWrap) (*mbodyform.BodyForm, error) <span class="cov0" title="0">{
        var deltaParentIDPtr *idwrap.IDWrap

        b, err := SeralizeFormRPCToModelWithoutID(form, ExampleID, deltaParentIDPtr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">ID, err := idwrap.NewFromBytes(form.GetBodyId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">b.ID = ID
        return b, nil</span>
}

func SeralizeFormRPCToModelWithoutID(form *bodyv1.BodyForm, exampleID idwrap.IDWrap, deltaParentIDPtr *idwrap.IDWrap) (*mbodyform.BodyForm, error) <span class="cov0" title="0">{
        return &amp;mbodyform.BodyForm{
                ExampleID:     exampleID,
                DeltaParentID: deltaParentIDPtr,
                BodyKey:       form.Key,
                Description:   form.Description,
                Enable:        form.Enabled,
                Value:         form.Value,
        }, nil
}</span>

func SerializeFormModelToRPCDeltaItem(form mbodyform.BodyForm) *bodyv1.BodyFormDeltaListItem <span class="cov0" title="0">{
        return &amp;bodyv1.BodyFormDeltaListItem{
                BodyId:      form.ID.Bytes(),
                Key:         form.BodyKey,
                Enabled:     form.Enable,
                Value:       form.Value,
                Description: form.Description,
        }
}</span>
</pre>
		
		<pre class="file" id="file123" style="display: none">package tbodyurl

import (
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mbodyurl"
        bodyv1 "the-dev-tools/spec/dist/buf/go/collection/item/body/v1"
)

func SerializeURLModelToRPC(urlEncoded mbodyurl.BodyURLEncoded) *bodyv1.BodyUrlEncoded <span class="cov0" title="0">{

        return &amp;bodyv1.BodyUrlEncoded{
                BodyId:      urlEncoded.ID.Bytes(),
                Key:         urlEncoded.BodyKey,
                Enabled:     urlEncoded.Enable,
                Value:       urlEncoded.Value,
                Description: urlEncoded.Description,
        }
}</span>

func SerializeURLModelToRPCItem(urlEncoded mbodyurl.BodyURLEncoded) *bodyv1.BodyUrlEncodedListItem <span class="cov0" title="0">{

        return &amp;bodyv1.BodyUrlEncodedListItem{
                BodyId:      urlEncoded.ID.Bytes(),
                Key:         urlEncoded.BodyKey,
                Enabled:     urlEncoded.Enable,
                Value:       urlEncoded.Value,
                Description: urlEncoded.Description,
        }
}</span>

func SerializeURLRPCtoModel(urlEncoded *bodyv1.BodyUrlEncoded, exampleID idwrap.IDWrap) (*mbodyurl.BodyURLEncoded, error) <span class="cov0" title="0">{
        var deltaParentIDPtr *idwrap.IDWrap
        b, err := SeralizeURLRPCToModelWithoutID(urlEncoded, exampleID, deltaParentIDPtr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">ID, err := idwrap.NewFromBytes(urlEncoded.GetBodyId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">b.ID = ID
        return b, nil</span>
}

func SeralizeURLRPCToModelWithoutID(urlEncoded *bodyv1.BodyUrlEncoded, exampleID idwrap.IDWrap, deltaParentIDPtr *idwrap.IDWrap) (*mbodyurl.BodyURLEncoded, error) <span class="cov0" title="0">{
        return &amp;mbodyurl.BodyURLEncoded{
                ExampleID:     exampleID,
                BodyKey:       urlEncoded.Key,
                DeltaParentID: deltaParentIDPtr,
                Description:   urlEncoded.Description,
                Enable:        urlEncoded.Enabled,
                Value:         urlEncoded.Value,
        }, nil
}</span>

func SeralizeURLRPCToModelWithoutIDForDelta(urlEncoded *bodyv1.BodyUrlEncoded, exampleID idwrap.IDWrap, deltaParentIDPtr *idwrap.IDWrap) (*mbodyurl.BodyURLEncoded, error) <span class="cov0" title="0">{
        return &amp;mbodyurl.BodyURLEncoded{
                ExampleID:     exampleID,
                BodyKey:       urlEncoded.Key,
                DeltaParentID: deltaParentIDPtr,
                Description:   urlEncoded.Description,
                Enable:        urlEncoded.Enabled,
                Value:         urlEncoded.Value,
        }, nil
}</span>

func SerializeURLModelToRPCDeltaItem(urlEncoded mbodyurl.BodyURLEncoded) *bodyv1.BodyUrlEncodedDeltaListItem <span class="cov0" title="0">{
        // Note: sourceKind should be determined dynamically in the caller using DetermineDeltaType
        return &amp;bodyv1.BodyUrlEncodedDeltaListItem{
                BodyId:      urlEncoded.ID.Bytes(),
                Key:         urlEncoded.BodyKey,
                Enabled:     urlEncoded.Enable,
                Value:       urlEncoded.Value,
                Description: urlEncoded.Description,
                // Source field should be set by the caller
        }
}</span>
</pre>
		
		<pre class="file" id="file124" style="display: none">package tbreadcrumbs

import (
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mexamplebreadcrumb"
        "the-dev-tools/server/pkg/model/mitemapiexample"
        "the-dev-tools/server/pkg/translate/tcollection"
        "the-dev-tools/server/pkg/translate/tfolder"
        "the-dev-tools/server/pkg/translate/titemapi"
        examplev1 "the-dev-tools/spec/dist/buf/go/collection/item/example/v1"
)

func SerializeModelToRPC(breadCrumb mexamplebreadcrumb.ExampleBreadcrumb) *examplev1.ExampleBreadcrumb <span class="cov0" title="0">{
        // Split folder path into an array of folder names

        rpcBreadcrumb := &amp;examplev1.ExampleBreadcrumb{
                Kind: examplev1.ExampleBreadcrumbKind(breadCrumb.Kind),
        }
        switch breadCrumb.Kind </span>{
        case mexamplebreadcrumb.EXAMPLE_BREADCRUMB_KIND_COLLECTION:<span class="cov0" title="0">
                rpcBreadcrumb.Collection = tcollection.SerializeCollectionModelToRPC(*breadCrumb.Collection)</span>
        case mexamplebreadcrumb.EXAMPLE_BREADCRUMB_KIND_FOLDER:<span class="cov0" title="0">
                rpcBreadcrumb.Folder = tfolder.SeralizeModelToRPCItem(*breadCrumb.Folder)</span>
        case mexamplebreadcrumb.EXAMPLE_BREADCRUMB_KIND_ENDPOINT:<span class="cov0" title="0">
                rpcBreadcrumb.Endpoint = titemapi.SeralizeModelToRPCItem(breadCrumb.Endpoint)</span>
        }

        <span class="cov0" title="0">return rpcBreadcrumb</span>

}

func SerializeModelToRPCItem(ex mitemapiexample.ItemApiExample, lastRespID *idwrap.IDWrap) *examplev1.ExampleListItem <span class="cov0" title="0">{
        var lastResp []byte = nil
        if lastRespID != nil </span><span class="cov0" title="0">{
                lastResp = lastRespID.Bytes()
        }</span>

        <span class="cov0" title="0">return &amp;examplev1.ExampleListItem{
                ExampleId:      ex.ID.Bytes(),
                Name:           ex.Name,
                LastResponseId: lastResp,
        }</span>
}

func DeserializeRPCToModel(ex *examplev1.Example) (mitemapiexample.ItemApiExample, error) <span class="cov0" title="0">{
        if ex == nil </span><span class="cov0" title="0">{
                return mitemapiexample.ItemApiExample{}, nil
        }</span>
        <span class="cov0" title="0">id, err := idwrap.NewFromBytes(ex.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return mitemapiexample.ItemApiExample{}, err
        }</span>

        <span class="cov0" title="0">return mitemapiexample.ItemApiExample{
                ID:       id,
                BodyType: mitemapiexample.BodyType(ex.BodyKind),
                Name:     ex.Name,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package tcollection

import (
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mcollection"
        collectionv1 "the-dev-tools/spec/dist/buf/go/collection/v1"
)

func SerializeCollectionModelToRPC(collection mcollection.Collection) *collectionv1.CollectionListItem <span class="cov0" title="0">{
        return &amp;collectionv1.CollectionListItem{
                CollectionId: collection.ID.Bytes(),
                Name:         collection.Name,
        }
}</span>

func SerializeCollectionRPCtoModel(collection *collectionv1.CollectionListItem) (*mcollection.Collection, error) <span class="cov0" title="0">{
        ID, err := idwrap.NewFromBytes(collection.GetCollectionId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;mcollection.Collection{
                ID:   ID,
                Name: collection.Name,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package tcondition

import (
        "the-dev-tools/server/pkg/model/mcondition"
        conditionv1 "the-dev-tools/spec/dist/buf/go/condition/v1"
)

func SeralizeConditionModelToRPC(c mcondition.Condition) *conditionv1.Condition <span class="cov0" title="0">{
        return &amp;conditionv1.Condition{
                Comparison: SerializeComparisonModelToRPC(c.Comparisons),
        }
}</span>

func DeserializeConditionRPCToModel(c *conditionv1.Condition) mcondition.Condition <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return mcondition.Condition{}
        }</span>
        <span class="cov0" title="0">return mcondition.Condition{
                Comparisons: DeserializeComparisonRPCToModel(c.Comparison),
        }</span>
}

func SerializeComparisonModelToRPC(c mcondition.Comparison) *conditionv1.Comparison <span class="cov0" title="0">{

        return &amp;conditionv1.Comparison{
                Expression: c.Expression,
        }
}</span>

func DeserializeComparisonRPCToModel(c *conditionv1.Comparison) mcondition.Comparison <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return mcondition.Comparison{}
        }</span>
        <span class="cov0" title="0">return mcondition.Comparison{
                Expression: c.Expression,
        }</span>
}
</pre>
		
		<pre class="file" id="file127" style="display: none">package tcurl

import (
        "fmt"
        "regexp"
        "strings"
        "the-dev-tools/server/pkg/compress"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mbodyform"
        "the-dev-tools/server/pkg/model/mbodyraw"
        "the-dev-tools/server/pkg/model/mbodyurl"
        "the-dev-tools/server/pkg/model/mexampleheader"
        "the-dev-tools/server/pkg/model/mexamplequery"
        "the-dev-tools/server/pkg/model/mitemapi"
        "the-dev-tools/server/pkg/model/mitemapiexample"
)

type CurlResolved struct {
        Apis             []mitemapi.ItemApi
        Examples         []mitemapiexample.ItemApiExample
        Queries          []mexamplequery.Query
        Headers          []mexampleheader.Header
        RawBodies        []mbodyraw.ExampleBodyRaw
        FormBodies       []mbodyform.BodyForm
        UrlEncodedBodies []mbodyurl.BodyURLEncoded
}

// Regular expressions for parsing curl commands
// Regular expressions for parsing curl commands
var (
        // URL pattern matches URLs in curl commands
        urlPattern = regexp.MustCompile(`(?:https?://|www\.)[^\s'"]+`)

        // Method pattern matches the -X or --request flag followed by the HTTP method
        methodPattern = regexp.MustCompile(`(?:-X|--request)\s+(?:'([A-Z]+)'|"([A-Z]+)"|([A-Z]+))`)

        // Header pattern matches -H or --header flags with their values
        headerPattern = regexp.MustCompile(`(?:-H|--header)\s+(?:'([^:]+):([^']+)'|"([^:]+):([^"]+)"|([^:]+):([^'"\s]+))`)

        // Cookie pattern matches -b or --cookie flags with their values
        cookiePattern = regexp.MustCompile(`(?:-b|--cookie)\s+(?:'([^']*)'|"([^"]*)"|([^\s'"][^\s]*))`)

        // Data patterns for different types of data
        dataPattern          = regexp.MustCompile(`(?:-d|--data|--data-raw|--data-binary)\s+(?:'([^']*)'|"([^"]*)"|([^\s'"][^\s]*))`)
        dataUrlEncodePattern = regexp.MustCompile(`--data-urlencode\s+(?:'([^=]+)=([^']*)'|"([^=]+)=([^"]*)"|([^=\s]+)=([^\s'"][^\s]*))`)
        formDataPattern      = regexp.MustCompile(`(?:-F|--form)\s+(?:'([^=]+)=([^']*)'|"([^=]+)=([^"]*)"|([^=\s]+)=([^\s'"][^\s]*))`)

        // Query parameter pattern to extract from URL
        queryParamPattern = regexp.MustCompile(`([^&amp;=]+)=([^&amp;]*)`)
)

func ConvertCurl(curlStr string, collectionID idwrap.IDWrap) (CurlResolved, error) <span class="cov8" title="1">{
        result := CurlResolved{
                Apis:             []mitemapi.ItemApi{},
                Examples:         []mitemapiexample.ItemApiExample{},
                Queries:          []mexamplequery.Query{},
                Headers:          []mexampleheader.Header{},
                RawBodies:        []mbodyraw.ExampleBodyRaw{},
                FormBodies:       []mbodyform.BodyForm{},
                UrlEncodedBodies: []mbodyurl.BodyURLEncoded{},
        }

        // Normalize the curl command to handle multi-line input
        normalizedCurl := normalizeCurlCommand(curlStr)

        // Validate that it's a curl command
        if !strings.HasPrefix(strings.TrimSpace(normalizedCurl), "curl") </span><span class="cov8" title="1">{
                return CurlResolved{}, fmt.Errorf("invalid curl command")
        }</span>

        // Generate IDs for the new API and example
        <span class="cov8" title="1">exampleID := idwrap.NewNow()
        apiID := idwrap.NewNow()

        // Extract URL
        url := extractURL(normalizedCurl)
        if url == "" </span><span class="cov0" title="0">{
                return CurlResolved{}, fmt.Errorf("URL not found in curl command")
        }</span>

        // Parse query parameters from URL
        <span class="cov8" title="1">baseURL, queries := parseURLAndQueries(url, exampleID)
        result.Queries = queries

        // Extract method
        method := extractMethod(normalizedCurl)

        // Extract headers
        headers := extractHeaders(normalizedCurl, exampleID)

        // Extract cookies and add them as headers
        cookieHeaders := extractCookies(normalizedCurl, exampleID)
        headers = append(headers, cookieHeaders...)

        result.Headers = headers

        // Extract data bodies
        hasDataFlag := false
        rawBodies := extractRawBodies(normalizedCurl, exampleID, &amp;hasDataFlag)
        result.RawBodies = rawBodies

        // Extract URL-encoded bodies
        urlEncodedBodies := extractURLEncodedBodies(normalizedCurl, exampleID, &amp;hasDataFlag)
        result.UrlEncodedBodies = urlEncodedBodies

        // Extract form bodies
        formBodies := extractFormBodies(normalizedCurl, exampleID, &amp;hasDataFlag)
        result.FormBodies = formBodies

        // Create API item
        api := mitemapi.ItemApi{
                ID:           apiID,
                CollectionID: collectionID,
                Method:       method,
                Url:          baseURL,
                Name:         baseURL,
        }

        // If no explicit method was provided but we have data flags, assume POST
        if method == "GET" &amp;&amp; hasDataFlag </span><span class="cov8" title="1">{
                api.Method = "POST"
        }</span>

        <span class="cov8" title="1">result.Apis = append(result.Apis, api)

        // Create example and determine the BodyType based on what data is present
        bodyType := mitemapiexample.BodyTypeNone
        if len(result.RawBodies) &gt; 0 </span><span class="cov8" title="1">{
                bodyType = mitemapiexample.BodyTypeRaw
        }</span> else<span class="cov8" title="1"> if len(result.FormBodies) &gt; 0 </span><span class="cov8" title="1">{
                bodyType = mitemapiexample.BodyTypeForm
        }</span> else<span class="cov8" title="1"> if len(result.UrlEncodedBodies) &gt; 0 </span><span class="cov8" title="1">{
                bodyType = mitemapiexample.BodyTypeUrlencoded
        }</span>

        <span class="cov8" title="1">example := mitemapiexample.ItemApiExample{
                ID:           exampleID,
                ItemApiID:    apiID,
                Name:         baseURL,
                CollectionID: collectionID,
                IsDefault:    true,
                BodyType:     bodyType,
        }
        result.Examples = append(result.Examples, example)

        // Create empty raw body if there's no raw body but other body types exist
        // SQL depends on having raw body entries
        if len(result.RawBodies) == 0 &amp;&amp; (len(result.FormBodies) &gt; 0 || len(result.UrlEncodedBodies) &gt; 0) </span><span class="cov8" title="1">{
                emptyRawBody := mbodyraw.ExampleBodyRaw{
                        ID:            idwrap.NewNow(),
                        ExampleID:     exampleID,
                        Data:          []byte{}, // Empty data
                        CompressType:  compress.CompressTypeNone,
                        VisualizeMode: mbodyraw.VisualizeModeText,
                }
                result.RawBodies = append(result.RawBodies, emptyRawBody)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// Normalize a curl command to handle both single-line and multi-line formats
func normalizeCurlCommand(curlStr string) string <span class="cov8" title="1">{
        // Handle line continuations (\ at end of line)
        curlStr = strings.ReplaceAll(curlStr, " \\\n", " ")
        curlStr = strings.ReplaceAll(curlStr, "\\\n", " ")

        // Remove newlines inside quoted strings
        var normalized strings.Builder
        inQuote := false
        quoteChar := rune(0)

        lines := strings.Split(curlStr, "\n")
        for i, line := range lines </span><span class="cov8" title="1">{
                trimmedLine := strings.TrimSpace(line)

                // Skip empty lines
                if trimmedLine == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // If this is a new curl command and we already have content, stop here
                <span class="cov8" title="1">if i &gt; 0 &amp;&amp; !inQuote &amp;&amp; strings.HasPrefix(trimmedLine, "curl") &amp;&amp; normalized.Len() &gt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                // Add space between lines if needed
                <span class="cov8" title="1">if normalized.Len() &gt; 0 &amp;&amp; !inQuote </span><span class="cov0" title="0">{
                        normalized.WriteRune(' ')
                }</span>

                // Process each character
                <span class="cov8" title="1">for _, char := range trimmedLine </span><span class="cov8" title="1">{
                        if char == '\'' || char == '"' </span><span class="cov8" title="1">{
                                if !inQuote </span><span class="cov8" title="1">{
                                        inQuote = true
                                        quoteChar = char
                                }</span> else<span class="cov8" title="1"> if char == quoteChar </span><span class="cov8" title="1">{
                                        inQuote = false
                                }</span>
                        }
                        <span class="cov8" title="1">normalized.WriteRune(char)</span>
                }
        }

        <span class="cov8" title="1">return normalized.String()</span>
}

func extractURL(curlStr string) string <span class="cov8" title="1">{
        // Check for URLs in the curl command
        urls := urlPattern.FindAllString(curlStr, -1)
        if len(urls) &gt; 0 </span><span class="cov8" title="1">{
                // Return the first URL found
                url := urls[0]
                // Remove any trailing quotes or spaces
                url = strings.TrimRight(url, "'\" ")
                return url
        }</span>

        // If no URL was found using the regex, try to extract it after the curl command
        <span class="cov0" title="0">fields := strings.Fields(curlStr)
        for i, field := range fields </span><span class="cov0" title="0">{
                if i &gt; 0 &amp;&amp; field != "curl" &amp;&amp; !strings.HasPrefix(field, "-") &amp;&amp;
                        fields[i-1] == "curl" || fields[i-1] == "-L" </span><span class="cov0" title="0">{
                        // Remove quotes if present
                        return removeQuotes(field)
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

func extractMethod(curlStr string) string <span class="cov8" title="1">{
        matches := methodPattern.FindStringSubmatch(curlStr)
        if len(matches) &gt;= 2 </span><span class="cov8" title="1">{
                // Check each capture group (single quotes, double quotes, or no quotes)
                for i := 1; i &lt; len(matches); i++ </span><span class="cov8" title="1">{
                        if matches[i] != "" </span><span class="cov8" title="1">{
                                return matches[i]
                        }</span>
                }
        }
        <span class="cov8" title="1">return "GET"</span> // Default to GET if no method specified
}

func extractHeaders(curlStr string, exampleID idwrap.IDWrap) []mexampleheader.Header <span class="cov8" title="1">{
        var headers []mexampleheader.Header

        matches := headerPattern.FindAllStringSubmatch(curlStr, -1)
        for _, match := range matches </span><span class="cov8" title="1">{
                // Check single quotes pattern (groups 1,2), double quotes pattern (groups 3,4), or no quotes pattern (groups 5,6)
                var key, value string
                if match[1] != "" </span><span class="cov8" title="1">{
                        key, value = match[1], match[2] // Single quotes
                }</span> else<span class="cov8" title="1"> if match[3] != "" </span><span class="cov8" title="1">{
                        key, value = match[3], match[4] // Double quotes
                }</span> else<span class="cov0" title="0"> {
                        key, value = match[5], match[6] // No quotes
                }</span>

                <span class="cov8" title="1">header := mexampleheader.Header{
                        ID:        idwrap.NewNow(),
                        ExampleID: exampleID,
                        HeaderKey: strings.TrimSpace(key),
                        Value:     strings.TrimSpace(value),
                        Enable:    true,
                }
                headers = append(headers, header)</span>
        }

        <span class="cov8" title="1">return headers</span>
}

func extractRawBodies(curlStr string, exampleID idwrap.IDWrap, hasDataFlag *bool) []mbodyraw.ExampleBodyRaw <span class="cov8" title="1">{
        var bodies []mbodyraw.ExampleBodyRaw

        matches := dataPattern.FindAllStringSubmatch(curlStr, -1)
        for _, match := range matches </span><span class="cov8" title="1">{
                *hasDataFlag = true

                // Check each capture group (single quotes, double quotes, or no quotes)
                var content string
                if match[1] != "" </span><span class="cov8" title="1">{
                        content = match[1] // Single quotes
                }</span> else<span class="cov0" title="0"> if match[2] != "" </span><span class="cov0" title="0">{
                        content = match[2] // Double quotes
                }</span> else<span class="cov0" title="0"> {
                        content = match[3] // No quotes
                }</span>

                <span class="cov8" title="1">body := mbodyraw.ExampleBodyRaw{
                        ID:            idwrap.NewNow(),
                        ExampleID:     exampleID,
                        Data:          []byte(content),
                        CompressType:  compress.CompressTypeNone,
                        VisualizeMode: mbodyraw.VisualizeModeText,
                }
                bodies = append(bodies, body)</span>
        }

        <span class="cov8" title="1">return bodies</span>
}

func extractURLEncodedBodies(curlStr string, exampleID idwrap.IDWrap, hasDataFlag *bool) []mbodyurl.BodyURLEncoded <span class="cov8" title="1">{
        var bodies []mbodyurl.BodyURLEncoded

        matches := dataUrlEncodePattern.FindAllStringSubmatch(curlStr, -1)
        for _, match := range matches </span><span class="cov8" title="1">{
                *hasDataFlag = true

                // Check each capture group (single quotes, double quotes, or no quotes)
                var key, value string
                if match[1] != "" </span><span class="cov8" title="1">{
                        key, value = match[1], match[2] // Single quotes
                }</span> else<span class="cov0" title="0"> if match[3] != "" </span><span class="cov0" title="0">{
                        key, value = match[3], match[4] // Double quotes
                }</span> else<span class="cov0" title="0"> {
                        key, value = match[5], match[6] // No quotes
                }</span>

                <span class="cov8" title="1">body := mbodyurl.BodyURLEncoded{
                        ID:        idwrap.NewNow(),
                        ExampleID: exampleID,
                        BodyKey:   key,
                        Value:     value,
                        Enable:    true,
                }
                bodies = append(bodies, body)</span>
        }

        <span class="cov8" title="1">return bodies</span>
}

func extractFormBodies(curlStr string, exampleID idwrap.IDWrap, hasDataFlag *bool) []mbodyform.BodyForm <span class="cov8" title="1">{
        var forms []mbodyform.BodyForm

        matches := formDataPattern.FindAllStringSubmatch(curlStr, -1)
        for _, match := range matches </span><span class="cov8" title="1">{
                *hasDataFlag = true

                // Check each capture group (single quotes, double quotes, or no quotes)
                var key, value string
                if match[1] != "" </span><span class="cov8" title="1">{
                        key, value = match[1], match[2] // Single quotes
                }</span> else<span class="cov0" title="0"> if match[3] != "" </span><span class="cov0" title="0">{
                        key, value = match[3], match[4] // Double quotes
                }</span> else<span class="cov0" title="0"> {
                        key, value = match[5], match[6] // No quotes
                }</span>

                <span class="cov8" title="1">form := mbodyform.BodyForm{
                        ID:        idwrap.NewNow(),
                        ExampleID: exampleID,
                        BodyKey:   key,
                        Value:     value,
                        Enable:    true,
                }
                forms = append(forms, form)</span>
        }

        <span class="cov8" title="1">return forms</span>
}

func parseURLAndQueries(urlStr string, exampleID idwrap.IDWrap) (string, []mexamplequery.Query) <span class="cov8" title="1">{
        parts := strings.SplitN(urlStr, "?", 2)
        if len(parts) == 1 </span><span class="cov8" title="1">{
                return urlStr, nil
        }</span>

        <span class="cov8" title="1">baseURL := parts[0]
        queryStr := parts[1]
        var queries []mexamplequery.Query

        matches := queryParamPattern.FindAllStringSubmatch(queryStr, -1)
        for _, match := range matches </span><span class="cov8" title="1">{
                if len(match) &gt;= 3 </span><span class="cov8" title="1">{
                        query := mexamplequery.Query{
                                ID:        idwrap.NewNow(),
                                ExampleID: exampleID,
                                QueryKey:  match[1],
                                Value:     match[2],
                                Enable:    true,
                        }
                        queries = append(queries, query)
                }</span>
        }

        <span class="cov8" title="1">return baseURL, queries</span>
}

func removeQuotes(s string) string <span class="cov0" title="0">{
        s = strings.TrimSpace(s)
        if (strings.HasPrefix(s, "'") &amp;&amp; strings.HasSuffix(s, "'")) ||
                (strings.HasPrefix(s, "\"") &amp;&amp; strings.HasSuffix(s, "\"")) </span><span class="cov0" title="0">{
                return s[1 : len(s)-1]
        }</span>
        <span class="cov0" title="0">return s</span>
}

// extractCookies extracts cookies from a curl command and converts them to Cookie headers
func extractCookies(curlStr string, exampleID idwrap.IDWrap) []mexampleheader.Header <span class="cov8" title="1">{
        var cookieHeaders []mexampleheader.Header

        matches := cookiePattern.FindAllStringSubmatch(curlStr, -1)
        for _, match := range matches </span><span class="cov0" title="0">{
                // Check each capture group (single quotes, double quotes, or no quotes)
                var cookieContent string
                if match[1] != "" </span><span class="cov0" title="0">{
                        cookieContent = match[1] // Single quotes
                }</span> else<span class="cov0" title="0"> if match[2] != "" </span><span class="cov0" title="0">{
                        cookieContent = match[2] // Double quotes
                }</span> else<span class="cov0" title="0"> {
                        cookieContent = match[3] // No quotes
                }</span>

                <span class="cov0" title="0">cookieHeader := mexampleheader.Header{
                        ID:        idwrap.NewNow(),
                        ExampleID: exampleID,
                        HeaderKey: "Cookie",
                        Value:     strings.TrimSpace(cookieContent),
                        Enable:    true,
                }
                cookieHeaders = append(cookieHeaders, cookieHeader)</span>
        }

        <span class="cov8" title="1">return cookieHeaders</span>
}
</pre>
		
		<pre class="file" id="file128" style="display: none">package tenv

import (
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/menv"
        environmentv1 "the-dev-tools/spec/dist/buf/go/environment/v1"

        "google.golang.org/protobuf/types/known/timestamppb"
)

func SeralizeModelToRPC(e menv.Env) *environmentv1.Environment <span class="cov0" title="0">{
        return &amp;environmentv1.Environment{
                EnvironmentId: e.ID.Bytes(),
                Name:          e.Name,
                IsGlobal:      e.Type == menv.EnvGlobal,
                Description:   e.Description,
                Updated:       timestamppb.New(e.Updated),
        }
}</span>

func DeserializeRPCToModel(e *environmentv1.Environment) (menv.Env, error) <span class="cov0" title="0">{
        id, err := idwrap.NewFromBytes(e.EnvironmentId)
        if err != nil </span><span class="cov0" title="0">{
                return menv.Env{}, err
        }</span>

        <span class="cov0" title="0">return DeseralizeRPCToModelWithID(id, e), nil</span>
}

func SeralizeModelToRPCItem(e menv.Env) *environmentv1.EnvironmentListItem <span class="cov0" title="0">{
        return &amp;environmentv1.EnvironmentListItem{
                EnvironmentId: e.ID.Bytes(),
                Name:          e.Name,
                IsGlobal:      e.Type == menv.EnvGlobal,
                Description:   e.Description,
                Updated:       timestamppb.New(e.Updated),
        }
}</span>

func DeseralizeRPCToModelWithID(id idwrap.IDWrap, e *environmentv1.Environment) menv.Env <span class="cov0" title="0">{
        var typ menv.EnvType
        if e.IsGlobal </span><span class="cov0" title="0">{
                typ = menv.EnvGlobal
        }</span> else<span class="cov0" title="0"> {
                typ = menv.EnvNormal
        }</span>

        <span class="cov0" title="0">return menv.Env{
                ID:          id,
                Name:        e.Name,
                Type:        typ,
                Description: e.Description,
                Updated:     e.Updated.AsTime(),
        }</span>
}

/*
func SeralizeModelToGroupRPC(key string, envs []menv.Env) *variablev1.Variable {
        return &amp;environmentv1.EnvironmentListItem{
                VariableKey: key,
                Environment: tgeneric.MassConvert(envs, SeralizeModelToRPC),
        }
}
*/
</pre>
		
		<pre class="file" id="file129" style="display: none">package texample

import (
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mitemapiexample"
        bodyv1 "the-dev-tools/spec/dist/buf/go/collection/item/body/v1"
        examplev1 "the-dev-tools/spec/dist/buf/go/collection/item/example/v1"
)

func SerializeModelToRPC(ex mitemapiexample.ItemApiExample, lastResp *idwrap.IDWrap, exampleBreadcrumbs []*examplev1.ExampleBreadcrumb) *examplev1.Example <span class="cov0" title="0">{
        // Split folder path into an array of folder names

        var lastResponseBytes []byte
        if lastResp != nil </span><span class="cov0" title="0">{
                lastResponseBytes = lastResp.Bytes()
        }</span>

        <span class="cov0" title="0">return &amp;examplev1.Example{
                ExampleId:      ex.ID.Bytes(),
                Name:           ex.Name,
                BodyKind:       bodyv1.BodyKind(ex.BodyType),
                LastResponseId: lastResponseBytes,
                Breadcrumbs:    exampleBreadcrumbs,
        }</span>
}

func SerializeModelToRPCItem(ex mitemapiexample.ItemApiExample, lastRespID *idwrap.IDWrap) *examplev1.ExampleListItem <span class="cov0" title="0">{
        var lastResp []byte = nil
        if lastRespID != nil </span><span class="cov0" title="0">{
                lastResp = lastRespID.Bytes()
        }</span>

        <span class="cov0" title="0">return &amp;examplev1.ExampleListItem{
                ExampleId:      ex.ID.Bytes(),
                Name:           ex.Name,
                LastResponseId: lastResp,
        }</span>
}

func DeserializeRPCToModel(ex *examplev1.Example) (mitemapiexample.ItemApiExample, error) <span class="cov0" title="0">{
        if ex == nil </span><span class="cov0" title="0">{
                return mitemapiexample.ItemApiExample{}, nil
        }</span>
        <span class="cov0" title="0">id, err := idwrap.NewFromBytes(ex.GetExampleId())
        if err != nil </span><span class="cov0" title="0">{
                return mitemapiexample.ItemApiExample{}, err
        }</span>

        <span class="cov0" title="0">return mitemapiexample.ItemApiExample{
                ID:       id,
                BodyType: mitemapiexample.BodyType(ex.BodyKind),
                Name:     ex.Name,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">package texampleresp

import (
        "errors"
        "the-dev-tools/server/pkg/model/mexampleresp"
        "the-dev-tools/server/pkg/zstdcompress"
        responsev1 "the-dev-tools/spec/dist/buf/go/collection/item/response/v1"

        "google.golang.org/protobuf/types/known/timestamppb"
)

/*
func SeralizeHeaderModelToRPC(h mexamplerespheader.ExampleRespHeader) *itemapiexamplev1.ResponseHeader {
        return &amp;itemapiexamplev1.ResponseHeader{
                Id:    h.ID.String(),
                Key:   h.HeaderKey,
                Value: h.Value,
        }
}
*/

var ErrDecompress error = errors.New("failed to decompress body")

func SeralizeModelToRPC(e mexampleresp.ExampleResp) (*responsev1.Response, error) <span class="cov0" title="0">{
        body := e.Body
        if e.BodyCompressType == mexampleresp.BodyCompressTypeZstd </span><span class="cov0" title="0">{
                var err error
                body, err = zstdcompress.Decompress(body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Join(ErrDecompress, err)
                }</span>
        }

        <span class="cov0" title="0">return &amp;responsev1.Response{
                ResponseId: e.ID.Bytes(),
                Status:     int32(e.Status),
                Body:       body,
                Time:       timestamppb.New(e.ID.Time()),
                Duration:   e.Duration,
        }, nil</span>
}

func SeralizeModelToRPCGetResponse(e mexampleresp.ExampleResp) (*responsev1.ResponseGetResponse, error) <span class="cov0" title="0">{
        body := e.Body
        if e.BodyCompressType == mexampleresp.BodyCompressTypeZstd </span><span class="cov0" title="0">{
                var err error
                body, err = zstdcompress.Decompress(body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Join(ErrDecompress, err)
                }</span>
        }

        <span class="cov0" title="0">return &amp;responsev1.ResponseGetResponse{
                ResponseId: e.ID.Bytes(),
                Status:     int32(e.Status),
                Body:       body,
                Time:       timestamppb.New(e.ID.Time()),
                Duration:   e.Duration,
                Size:       int32(len(body)),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">package texampleversion

import (
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mitemapiexample"
        examplev1 "the-dev-tools/spec/dist/buf/go/collection/item/example/v1"
)

func ModelToRPC(example mitemapiexample.ItemApiExample, responseID *idwrap.IDWrap) *examplev1.ExampleVersionsItem <span class="cov0" title="0">{
        var responseIDBytes []byte
        if responseID != nil </span><span class="cov0" title="0">{
                responseIDBytes = responseID.Bytes()
        }</span>
        <span class="cov0" title="0">return &amp;examplev1.ExampleVersionsItem{
                ExampleId:      example.ID.Bytes(),
                LastResponseId: responseIDBytes,
        }</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">package tflow

import (
        "the-dev-tools/server/pkg/model/mflow"
        flowv1 "the-dev-tools/spec/dist/buf/go/flow/v1"
)

func SeralizeModelToRPCItem(flow mflow.Flow) *flowv1.FlowListItem <span class="cov0" title="0">{
        return &amp;flowv1.FlowListItem{
                FlowId: flow.ID.Bytes(),
                Name:   flow.Name,
        }
}</span>

func SeralizeModelToRPC(flow mflow.Flow) *flowv1.Flow <span class="cov0" title="0">{
        return &amp;flowv1.Flow{
                FlowId: flow.ID.Bytes(),
                Name:   flow.Name,
        }
}</span>
</pre>
		
		<pre class="file" id="file133" style="display: none">package tflowvariable

import (
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mflowvariable"
        flowvariablev1 "the-dev-tools/spec/dist/buf/go/flowvariable/v1"
)

// ModelToRPC converts a FlowVariable model to its RPC representation
func ModelToRPC(v mflowvariable.FlowVariable) *flowvariablev1.FlowVariable <span class="cov0" title="0">{
        return &amp;flowvariablev1.FlowVariable{
                VariableId:  v.ID.Bytes(),
                Name:        v.Name,
                Value:       v.Value,
                Enabled:     v.Enabled,
                Description: v.Description,
        }
}</span>

// ModelToRPCListItem converts a FlowVariable model to a list item representation for RPC
func ModelToRPCListItem(v mflowvariable.FlowVariable) *flowvariablev1.FlowVariableListItem <span class="cov0" title="0">{
        return &amp;flowvariablev1.FlowVariableListItem{
                VariableId:  v.ID.Bytes(),
                Name:        v.Name,
                Value:       v.Value,
                Enabled:     v.Enabled,
                Description: v.Description,
        }
}</span>

// RPCToModel converts an RPC FlowVariable to its model representation
func RPCToModel(v *flowvariablev1.FlowVariable) (mflowvariable.FlowVariable, error) <span class="cov0" title="0">{
        id, err := idwrap.NewFromBytes(v.VariableId)
        if err != nil </span><span class="cov0" title="0">{
                return mflowvariable.FlowVariable{}, err
        }</span>

        <span class="cov0" title="0">return mflowvariable.FlowVariable{
                ID:          id,
                Name:        v.Name,
                Value:       v.Value,
                Enabled:     v.Enabled,
                Description: v.Description,
        }, nil</span>
}

// RPCToModelWithID creates a model with provided IDs from RPC representation
func RPCToModelWithID(variableID, flowID idwrap.IDWrap, v *flowvariablev1.FlowVariable) mflowvariable.FlowVariable <span class="cov0" title="0">{
        return mflowvariable.FlowVariable{
                ID:          variableID,
                FlowID:      flowID,
                Name:        v.Name,
                Value:       v.Value,
                Enabled:     v.Enabled,
                Description: v.Description,
        }
}</span>

// CreateUpdateFromRPC creates a FlowVariableUpdate from RPC update request fields
func CreateUpdateFromRPC(id idwrap.IDWrap, name, value *string, enabled *bool, description *string) mflowvariable.FlowVariableUpdate <span class="cov0" title="0">{
        update := mflowvariable.FlowVariableUpdate{
                ID: id,
        }

        if name != nil </span><span class="cov0" title="0">{
                update.Name = name
        }</span>

        <span class="cov0" title="0">if value != nil </span><span class="cov0" title="0">{
                update.Value = value
        }</span>

        <span class="cov0" title="0">if enabled != nil </span><span class="cov0" title="0">{
                update.Enabled = enabled
        }</span>

        <span class="cov0" title="0">if description != nil </span><span class="cov0" title="0">{
                update.Description = description
        }</span>

        <span class="cov0" title="0">return update</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">package tflowversion

import (
        "the-dev-tools/server/pkg/model/mflow"
        flowv1 "the-dev-tools/spec/dist/buf/go/flow/v1"
)

func ModelToRPC(flow mflow.Flow) *flowv1.FlowVersionsItem <span class="cov0" title="0">{
        return &amp;flowv1.FlowVersionsItem{
                FlowId: flow.ID.Bytes(),
                Name:   flow.Name,
        }
}</span>

func RPCToModel(flow mflow.Flow) *flowv1.FlowVersionsItem <span class="cov0" title="0">{
        return &amp;flowv1.FlowVersionsItem{
                FlowId: flow.ID.Bytes(),
                Name:   flow.Name,
        }
}</span>
</pre>
		
		<pre class="file" id="file135" style="display: none">package tfolder

import (
        "errors"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mitemfolder"
        folderv1 "the-dev-tools/spec/dist/buf/go/collection/item/folder/v1"
)

func SeralizeRPCToModel(item *folderv1.Folder, collectionID idwrap.IDWrap) (*mitemfolder.ItemFolder, error) <span class="cov0" title="0">{
        modelItem, err := SeralizeRPCToModelWithoutID(item, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">id, err := idwrap.NewFromBytes(item.GetFolderId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">modelItem.ID = id
        return modelItem, nil</span>
}

func SeralizeRPCToModelWithoutID(item *folderv1.Folder, collectionID idwrap.IDWrap) (*mitemfolder.ItemFolder, error) <span class="cov0" title="0">{
        var parentID *idwrap.IDWrap
        if item == nil </span><span class="cov0" title="0">{
                return nil, errors.New("folder is nil")
        }</span>

        <span class="cov0" title="0">parentIDBytes := item.GetParentFolderId()
        if parentIDBytes != nil </span><span class="cov0" title="0">{
                tempParentID, err := idwrap.NewFromBytes(parentIDBytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">parentID = &amp;tempParentID</span>
        }

        <span class="cov0" title="0">return &amp;mitemfolder.ItemFolder{
                CollectionID: collectionID,
                ParentID:     parentID,
                Name:         item.Name,
                Prev:         nil,
                Next:         nil,
        }, nil</span>
}

func DeseralizeModelToRPC(item mitemfolder.ItemFolder) *folderv1.Folder <span class="cov0" title="0">{
        var parentIDBytes []byte = nil
        if item.ParentID != nil </span><span class="cov0" title="0">{
                parentIDBytes = item.ParentID.Bytes()
        }</span>
        <span class="cov0" title="0">return &amp;folderv1.Folder{
                FolderId:       item.ID.Bytes(),
                ParentFolderId: parentIDBytes,
                Name:           item.Name,
        }</span>
}

func SeralizeModelToRPCItem(item mitemfolder.ItemFolder) *folderv1.FolderListItem <span class="cov0" title="0">{
        var parentIDBytes []byte = nil
        if item.ParentID != nil </span><span class="cov0" title="0">{
                parentIDBytes = item.ParentID.Bytes()
        }</span>
        <span class="cov0" title="0">return &amp;folderv1.FolderListItem{
                FolderId:       item.ID.Bytes(),
                ParentFolderId: parentIDBytes,
                Name:           item.Name,
        }</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">package tgeneric

func MassConvert[T any, O any](item []T, convFunc func(T) O) []O <span class="cov0" title="0">{
        arr := make([]O, len(item))
        for i, v := range item </span><span class="cov0" title="0">{
                arr[i] = convFunc(v)
        }</span>
        <span class="cov0" title="0">return arr</span>
}

func MassConvertPtr[T any, O any](item []T, convFunc func(T) *O) []O <span class="cov0" title="0">{
        arr := make([]O, len(item))
        for i, v := range item </span><span class="cov0" title="0">{
                arr[i] = *convFunc(v)
        }</span>
        <span class="cov0" title="0">return arr</span>
}

func MassConvertWithErr[T any, O any](item []T, convFunc func(T) (O, error)) ([]O, error) <span class="cov0" title="0">{
        arr := make([]O, len(item))
        var err error
        for i, v := range item </span><span class="cov0" title="0">{
                arr[i], err = convFunc(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return arr, nil</span>
}

func MapToSlice[T any, K comparable](item map[K]T) []T <span class="cov0" title="0">{
        arr := make([]T, 0, len(item))
        for _, v := range item </span><span class="cov0" title="0">{
                arr = append(arr, v)
        }</span>
        <span class="cov0" title="0">return arr</span>
}

func ReplaceRootWithSub[T comparable](rootError, subError, got T) T <span class="cov0" title="0">{
        if got == rootError </span><span class="cov0" title="0">{
                return subError
        }</span>
        <span class="cov0" title="0">return got</span>
}

const thresholdSwitchRemove = 100

func RemoveElement[T comparable](arr []T, v T) []T <span class="cov0" title="0">{
        if len(arr) &lt; thresholdSwitchRemove </span><span class="cov0" title="0">{
                return RemoveElementSmall(arr, v)
        }</span> else<span class="cov0" title="0"> {
                return RemoveElementBig(arr, v)
        }</span>
}

func RemoveElementSmall[T comparable](arr []T, v T) []T <span class="cov0" title="0">{
        var result []T
        for _, e := range arr </span><span class="cov0" title="0">{
                if e != v </span><span class="cov0" title="0">{
                        result = append(result, e)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func RemoveElementBig[T comparable](arr []T, v T) []T <span class="cov0" title="0">{
        a := make(map[T]struct{})
        for _, v := range arr </span><span class="cov0" title="0">{
                a[v] = struct{}{}
        }</span>

        <span class="cov0" title="0">delete(a, v)

        result := make([]T, 0, len(a))
        for k := range a </span><span class="cov0" title="0">{
                result = append(result, k)
        }</span>

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">package thar

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/url"
        "sort"
        "strings"
        "the-dev-tools/server/pkg/compress"
        "the-dev-tools/server/pkg/depfinder"
        "the-dev-tools/server/pkg/flow/edge"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/massert"
        "the-dev-tools/server/pkg/model/mbodyform"
        "the-dev-tools/server/pkg/model/mbodyraw"
        "the-dev-tools/server/pkg/model/mbodyurl"
        "the-dev-tools/server/pkg/model/mcondition"
        "the-dev-tools/server/pkg/model/mexampleheader"
        "the-dev-tools/server/pkg/model/mexamplequery"
        "the-dev-tools/server/pkg/model/mflow"
        "the-dev-tools/server/pkg/model/mitemapi"
        "the-dev-tools/server/pkg/model/mitemapiexample"
        "the-dev-tools/server/pkg/model/mitemfolder"
        "the-dev-tools/server/pkg/model/mnnode"
        "the-dev-tools/server/pkg/model/mnnode/mnnoop"
        "the-dev-tools/server/pkg/model/mnnode/mnrequest"
        "time"
)

type HarResvoled struct {
        // Collection Items
        Apis             []mitemapi.ItemApi
        Examples         []mitemapiexample.ItemApiExample
        Queries          []mexamplequery.Query
        Headers          []mexampleheader.Header
        RawBodies        []mbodyraw.ExampleBodyRaw
        FormBodies       []mbodyform.BodyForm
        UrlEncodedBodies []mbodyurl.BodyURLEncoded
        Folders          []mitemfolder.ItemFolder
        Asserts          []massert.Assert

        // Flow Items
        Flow         mflow.Flow
        Nodes        []mnnode.MNode
        RequestNodes []mnrequest.MNRequest
        Edges        []edge.Edge
        NoopNodes    []mnnoop.NoopNode
}

type HAR struct {
        Log Log `json:"log"`
}

type Log struct {
        Entries []Entry `json:"entries"`
}

type Entry struct {
        StartedDateTime time.Time `json:"startedDateTime"`
        ResourceType    string    `json:"_resourceType"`
        Request         Request   `json:"request"`
        Response        Response  `json:"response"`
}

type Request struct {
        Method      string    `json:"method"`
        URL         string    `json:"url"`
        HTTPVersion string    `json:"httpVersion"`
        Headers     []Header  `json:"headers"`
        PostData    *PostData `json:"postData,omitempty"`
        QueryString []Query   `json:"queryString"`
}

type Response struct {
        Status      int      `json:"status"`
        StatusText  string   `json:"statusText"`
        HTTPVersion string   `json:"httpVersion"`
        Headers     []Header `json:"headers"`
        Content     Content  `json:"content"`
}

type Header struct {
        Name  string `json:"name"`
        Value string `json:"value"`
}

type Query struct {
        Name  string `json:"name"`
        Value string `json:"value"`
}

type PostData struct {
        MimeType string  `json:"mimeType"`
        Text     string  `json:"text"`
        Params   []Param `json:"params,omitempty"`
}

type Param struct {
        Name  string `json:"name"`
        Value string `json:"value"`
}

type Content struct {
        Size     int    `json:"size"`
        MimeType string `json:"mimeType"`
        Text     string `json:"text"`
}

const (
        RawBodyCheck                 = "application/json"
        FormBodyCheck                = "multipart/form-data"
        UrlEncodedBodyCheck          = "application/x-www-form-urlencoded"
        TimestampSequencingThreshold = 50 * time.Millisecond // Connect requests within 50ms for better sequencing
)

func ConvertRaw(data []byte) (*HAR, error) <span class="cov8" title="1">{
        var harFile HAR
        err := json.Unmarshal(data, &amp;harFile)
        if err != nil </span><span class="cov0" title="0">{
                // check if json field not found
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;harFile, nil</span>
}

func ConvertParamToFormBodies(params []Param, exampleId idwrap.IDWrap) []mbodyform.BodyForm <span class="cov8" title="1">{
        result := make([]mbodyform.BodyForm, len(params))
        for i, param := range params </span><span class="cov8" title="1">{
                result[i] = mbodyform.BodyForm{
                        ID:        idwrap.NewNow(),
                        BodyKey:   param.Name,
                        Value:     param.Value,
                        Enable:    true,
                        ExampleID: exampleId,
                }
        }</span>
        <span class="cov8" title="1">return result</span>
}

func ConvertParamToFormBodiesWithTemplating(params []Param, exampleId idwrap.IDWrap, depFinder *depfinder.DepFinder) []mbodyform.BodyForm <span class="cov0" title="0">{
        result := make([]mbodyform.BodyForm, len(params))
        for i, param := range params </span><span class="cov0" title="0">{
                val := param.Value
                // Try to replace tokens in form values
                if newVal, found, _ := (*depFinder).ReplaceWithPaths(val); found </span><span class="cov0" title="0">{
                        val = newVal.(string)
                }</span>
                <span class="cov0" title="0">result[i] = mbodyform.BodyForm{
                        ID:        idwrap.NewNow(),
                        BodyKey:   param.Name,
                        Value:     val,
                        Enable:    true,
                        ExampleID: exampleId,
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func ConvertParamToFormBodiesWithDeltaParent(params []Param, deltaExampleID idwrap.IDWrap, baseBodies []mbodyform.BodyForm, depFinder *depfinder.DepFinder) []mbodyform.BodyForm <span class="cov8" title="1">{
        var result []mbodyform.BodyForm

        // Create a map of base bodies by their key for quick lookup
        baseBodyMap := make(map[string]mbodyform.BodyForm)
        for _, baseBody := range baseBodies </span><span class="cov8" title="1">{
                baseBodyMap[baseBody.BodyKey] = baseBody
        }</span>

        <span class="cov8" title="1">for _, param := range params </span><span class="cov8" title="1">{
                val := param.Value
                // Try to replace tokens in form values
                if newVal, found, _ := (*depFinder).ReplaceWithPaths(val); found </span><span class="cov0" title="0">{
                        val = newVal.(string)
                }</span>

                // Find the corresponding base body
                <span class="cov8" title="1">var deltaParentID *idwrap.IDWrap
                if baseBody, exists := baseBodyMap[param.Name]; exists </span><span class="cov8" title="1">{
                        deltaParentID = &amp;baseBody.ID
                }</span>

                <span class="cov8" title="1">result = append(result, mbodyform.BodyForm{
                        ID:            idwrap.NewNow(),
                        BodyKey:       param.Name,
                        Value:         val,
                        Enable:        true,
                        ExampleID:     deltaExampleID,
                        DeltaParentID: deltaParentID,
                })</span>
        }
        <span class="cov8" title="1">return result</span>
}

func ConvertParamToUrlBodies(params []Param, exampleId idwrap.IDWrap) []mbodyurl.BodyURLEncoded <span class="cov8" title="1">{
        result := make([]mbodyurl.BodyURLEncoded, len(params))
        for i, param := range params </span><span class="cov8" title="1">{
                result[i] = mbodyurl.BodyURLEncoded{
                        ID:        idwrap.NewNow(),
                        BodyKey:   param.Name,
                        Value:     param.Value,
                        Enable:    true,
                        ExampleID: exampleId,
                }
        }</span>
        <span class="cov8" title="1">return result</span>
}

func ConvertParamToUrlBodiesWithTemplating(params []Param, exampleId idwrap.IDWrap, depFinder *depfinder.DepFinder) []mbodyurl.BodyURLEncoded <span class="cov0" title="0">{
        result := make([]mbodyurl.BodyURLEncoded, len(params))
        for i, param := range params </span><span class="cov0" title="0">{
                val := param.Value
                // Try to replace tokens in URL-encoded values
                if newVal, found, _ := (*depFinder).ReplaceWithPaths(val); found </span><span class="cov0" title="0">{
                        val = newVal.(string)
                }</span>
                <span class="cov0" title="0">result[i] = mbodyurl.BodyURLEncoded{
                        ID:        idwrap.NewNow(),
                        BodyKey:   param.Name,
                        Value:     val,
                        Enable:    true,
                        ExampleID: exampleId,
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func ConvertParamToUrlBodiesWithDeltaParent(params []Param, deltaExampleID idwrap.IDWrap, baseBodies []mbodyurl.BodyURLEncoded, depFinder *depfinder.DepFinder) []mbodyurl.BodyURLEncoded <span class="cov8" title="1">{
        var result []mbodyurl.BodyURLEncoded

        // Create a map of base bodies by their key for quick lookup
        baseBodyMap := make(map[string]mbodyurl.BodyURLEncoded)
        for _, baseBody := range baseBodies </span><span class="cov8" title="1">{
                baseBodyMap[baseBody.BodyKey] = baseBody
        }</span>

        <span class="cov8" title="1">for _, param := range params </span><span class="cov8" title="1">{
                val := param.Value
                // Try to replace tokens in URL-encoded values
                if newVal, found, _ := (*depFinder).ReplaceWithPaths(val); found </span><span class="cov8" title="1">{
                        val = newVal.(string)
                }</span>

                // Find the corresponding base body
                <span class="cov8" title="1">var deltaParentID *idwrap.IDWrap
                if baseBody, exists := baseBodyMap[param.Name]; exists </span><span class="cov8" title="1">{
                        deltaParentID = &amp;baseBody.ID
                }</span>

                <span class="cov8" title="1">result = append(result, mbodyurl.BodyURLEncoded{
                        ID:            idwrap.NewNow(),
                        BodyKey:       param.Name,
                        Value:         val,
                        Enable:        true,
                        ExampleID:     deltaExampleID,
                        DeltaParentID: deltaParentID,
                })</span>
        }
        <span class="cov8" title="1">return result</span>
}

// createFolderHierarchy creates a folder hierarchy based on URL structure
// Returns the leaf folder ID and all folders to be created
func createFolderHierarchy(requestURL string, collectionID idwrap.IDWrap, existingFolders map[string]idwrap.IDWrap) (idwrap.IDWrap, []mitemfolder.ItemFolder, error) <span class="cov8" title="1">{
        parsedURL, err := url.Parse(requestURL)
        if err != nil </span><span class="cov0" title="0">{
                return idwrap.IDWrap{}, nil, err
        }</span>

        // Extract domain and path segments
        <span class="cov8" title="1">domain := parsedURL.Host
        if domain == "" </span><span class="cov0" title="0">{
                domain = "unknown"
        }</span>

        <span class="cov8" title="1">pathSegments := strings.Split(strings.Trim(parsedURL.Path, "/"), "/")
        if len(pathSegments) == 1 &amp;&amp; pathSegments[0] == "" </span><span class="cov8" title="1">{
                pathSegments = []string{} // Empty path
        }</span>

        // Create folder hierarchy: domain -&gt; path segments (excluding the last one which becomes the API name)
        <span class="cov8" title="1">var folders []mitemfolder.ItemFolder
        var lastFolderID idwrap.IDWrap

        // Create domain folder
        domainKey := domain
        if folderID, exists := existingFolders[domainKey]; exists </span><span class="cov8" title="1">{
                lastFolderID = folderID
        }</span> else<span class="cov8" title="1"> {
                lastFolderID = idwrap.NewNow()
                domainFolder := mitemfolder.ItemFolder{
                        ID:           lastFolderID,
                        Name:         domain,
                        CollectionID: collectionID,
                        ParentID:     nil,
                }
                folders = append(folders, domainFolder)
                existingFolders[domainKey] = lastFolderID
        }</span>

        // Create path segment folders based on URL structure
        // For URLs like /api/categories/16, we want:
        // - api folder (created)
        // - categories folder (parent: api)
        // - API name: 16 (placed in categories folder)
        // For URLs like /api/categories, we want:
        // - api folder (created)
        // - categories folder (parent: api)
        // - API name: categories (placed in categories folder)

        <span class="cov8" title="1">if len(pathSegments) &gt; 1 </span><span class="cov8" title="1">{
                // Create folders for all path segments except the last one
                for i := 0; i &lt; len(pathSegments)-1; i++ </span><span class="cov8" title="1">{
                        segment := pathSegments[i]
                        if segment == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Create key for this folder path - use full path to ensure uniqueness
                        <span class="cov8" title="1">folderPath := domain + "/" + strings.Join(pathSegments[:i+1], "/")
                        if folderID, exists := existingFolders[folderPath]; exists </span><span class="cov8" title="1">{
                                lastFolderID = folderID
                        }</span> else<span class="cov8" title="1"> {
                                parentFolderID := lastFolderID // Current parent
                                newFolderID := idwrap.NewNow()

                                folder := mitemfolder.ItemFolder{
                                        ID:           newFolderID,
                                        Name:         segment,
                                        CollectionID: collectionID,
                                        ParentID:     &amp;parentFolderID,
                                }
                                folders = append(folders, folder)
                                existingFolders[folderPath] = newFolderID
                                lastFolderID = newFolderID
                        }</span>
                }

                // For the last path segment, decide if it should be a folder or API name
                <span class="cov8" title="1">lastSegment := pathSegments[len(pathSegments)-1]
                if !isLikelyID(lastSegment) &amp;&amp; !isAPIEndpoint(lastSegment) </span><span class="cov8" title="1">{
                        // If it's not an ID or API endpoint, create a folder for it too
                        folderPath := domain + "/" + strings.Join(pathSegments, "/")
                        if folderID, exists := existingFolders[folderPath]; exists </span><span class="cov0" title="0">{
                                lastFolderID = folderID
                        }</span> else<span class="cov8" title="1"> {
                                parentFolderID := lastFolderID // Current parent
                                newFolderID := idwrap.NewNow()

                                folder := mitemfolder.ItemFolder{
                                        ID:           newFolderID,
                                        Name:         lastSegment,
                                        CollectionID: collectionID,
                                        ParentID:     &amp;parentFolderID,
                                }
                                folders = append(folders, folder)
                                existingFolders[folderPath] = newFolderID
                                lastFolderID = newFolderID
                        }</span>
                }
        }

        <span class="cov8" title="1">return lastFolderID, folders, nil</span>
}

// isLikelyID checks if a string looks like an ID (numeric or UUID-like)
func isLikelyID(segment string) bool <span class="cov8" title="1">{
        if segment == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if it's all numeric
        <span class="cov8" title="1">allNumeric := true
        for _, r := range segment </span><span class="cov8" title="1">{
                if r &lt; '0' || r &gt; '9' </span><span class="cov8" title="1">{
                        allNumeric = false
                        break</span>
                }
        }
        <span class="cov8" title="1">if allNumeric &amp;&amp; len(segment) &gt; 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check if it looks like a UUID (contains hyphens and alphanumeric)
        <span class="cov8" title="1">if strings.Contains(segment, "-") &amp;&amp; len(segment) &gt;= 8 </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if it's a very long alphanumeric string (likely an ID)
        <span class="cov8" title="1">if len(segment) &gt; 15 </span><span class="cov0" title="0">{
                alphaNumeric := true
                for _, r := range segment </span><span class="cov0" title="0">{
                        if (r &lt; '0' || r &gt; '9') &amp;&amp; (r &lt; 'a' || r &gt; 'z') &amp;&amp; (r &lt; 'A' || r &gt; 'Z') </span><span class="cov0" title="0">{
                                alphaNumeric = false
                                break</span>
                        }
                }
                <span class="cov0" title="0">if alphaNumeric </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// isAPIEndpoint checks if a segment is likely an API endpoint (action) rather than a resource
func isAPIEndpoint(segment string) bool <span class="cov8" title="1">{
        // Common API action words that shouldn't be folders
        apiActions := []string{
                "login", "logout", "register", "signin", "signout", "signup",
                "create", "update", "delete", "list", "get", "post", "put", "patch",
                "search", "filter", "sort", "export", "import", "download", "upload",
                "activate", "deactivate", "enable", "disable", "approve", "reject",
                "send", "receive", "process", "validate", "verify", "confirm",
                "reset", "refresh", "sync", "backup", "restore", "health", "status",
                "profile", "settings", "preferences", "account", "dashboard",
                "overview", "summary", "details", "info", "metadata",
        }

        segmentLower := strings.ToLower(segment)
        for _, action := range apiActions </span><span class="cov8" title="1">{
                if segmentLower == action </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// getAPINameFromURL extracts the API name from the URL with method awareness
func getAPINameFromURL(requestURL string, method string) string <span class="cov8" title="1">{
        parsedURL, err := url.Parse(requestURL)
        if err != nil </span><span class="cov0" title="0">{
                return requestURL // Fallback to full URL
        }</span>

        <span class="cov8" title="1">pathSegments := strings.Split(strings.Trim(parsedURL.Path, "/"), "/")
        if len(pathSegments) &gt; 0 &amp;&amp; pathSegments[len(pathSegments)-1] != "" </span><span class="cov8" title="1">{
                lastSegment := pathSegments[len(pathSegments)-1]

                // For DELETE operations with an ID as the last segment (e.g., /tags/uuid),
                // use the resource name (second-to-last segment) as the base name
                if method == "DELETE" &amp;&amp; len(pathSegments) &gt; 1 &amp;&amp; isLikelyID(lastSegment) </span><span class="cov8" title="1">{
                        resourceName := pathSegments[len(pathSegments)-2]
                        return resourceName
                }</span>

                // If the last segment is an ID and we have a meaningful second-to-last segment,
                // use the ID as the name
                <span class="cov8" title="1">if len(pathSegments) &gt; 1 &amp;&amp; isLikelyID(lastSegment) </span><span class="cov8" title="1">{
                        return lastSegment
                }</span>

                // For collection endpoints like /api/categories, use the last segment
                <span class="cov8" title="1">return lastSegment</span>
        }

        // If no path segments or empty last segment, use domain or full URL
        <span class="cov8" title="1">if parsedURL.Host != "" </span><span class="cov8" title="1">{
                return parsedURL.Host
        }</span>
        <span class="cov0" title="0">return requestURL</span>
}

// convertHARInternal is the internal implementation that accepts existing folders map
func convertHARInternal(har *HAR, collectionID, workspaceID idwrap.IDWrap, depFinder *depfinder.DepFinder, existingFoldersMap map[string]idwrap.IDWrap) (HarResvoled, error) <span class="cov8" title="1">{
        result := HarResvoled{}

        if len(har.Log.Entries) == 0 </span><span class="cov8" title="1">{
                return result, errors.New("HAR file is empty")
        }</span>

        // sort by started time
        <span class="cov8" title="1">sort.Slice(har.Log.Entries, func(i, j int) bool </span><span class="cov8" title="1">{
                return har.Log.Entries[i].StartedDateTime.Before(har.Log.Entries[j].StartedDateTime)
        }</span>)

        <span class="cov8" title="1">flowID := idwrap.NewNow()
        result.Flow = mflow.Flow{
                ID:          flowID,
                WorkspaceID: workspaceID,
                Name:        har.Log.Entries[0].Request.URL,
        }

        var posX, posY float64

        startNodeID := idwrap.NewNow()
        startNode := mnnode.MNode{
                ID:        startNodeID,
                FlowID:    flowID,
                Name:      "Start",
                NodeKind:  mnnode.NODE_KIND_NO_OP,
                PositionX: posX,
                PositionY: posY,
        }
        result.Nodes = append(result.Nodes, startNode)

        startNodeNoop := mnnoop.NoopNode{
                FlowNodeID: startNodeID,
                Type:       mnnoop.NODE_NO_OP_KIND_START,
        }
        result.NoopNodes = append(result.NoopNodes, startNodeNoop)

        type mpos struct {
                x float64
                y float64
        }

        if depFinder == nil </span><span class="cov8" title="1">{
                newFinder := depfinder.NewDepFinder()
                depFinder = &amp;newFinder
        }</span>
        <span class="cov8" title="1">nodePosMap := make(map[idwrap.IDWrap]mpos)

        slotIndex := 0
        const slotSize = 400

        // Map to track existing folders by their path to avoid duplicates
        existingFolders := existingFoldersMap
        if existingFolders == nil </span><span class="cov8" title="1">{
                existingFolders = make(map[string]idwrap.IDWrap)
        }</span>

        // Track previous node for timestamp-based sequencing
        <span class="cov8" title="1">var previousNodeID *idwrap.IDWrap
        var previousTimestamp *time.Time

        // Process each entry in the HAR file
        for i, entry := range har.Log.Entries </span><span class="cov8" title="1">{
                // Only process XHR requests.
                if !IsXHRRequest(entry) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">requestName := fmt.Sprintf("request_%d", i)

                // Check for UUIDs in the URL path and replace them with templated variables
                originalURL := entry.Request.URL
                templatedURL, urlHasTemplates, urlCouples := (*depFinder).ReplaceURLPathParams(originalURL)

                // Update the entry URL if templates were found
                if urlHasTemplates </span><span class="cov0" title="0">{
                        entry.Request.URL = templatedURL
                }</span>

                // Create folder hierarchy for this URL
                <span class="cov8" title="1">leafFolderID, newFolders, err := createFolderHierarchy(originalURL, collectionID, existingFolders)
                if err != nil </span><span class="cov0" title="0">{
                        return result, fmt.Errorf("failed to create folder hierarchy for URL %s: %w", originalURL, err)
                }</span>

                // Add new folders to result
                <span class="cov8" title="1">result.Folders = append(result.Folders, newFolders...)

                // Extract API name from URL with method awareness
                apiName := getAPINameFromURL(originalURL, entry.Request.Method)

                // Create Endpoint/api for each entry
                apiID := idwrap.NewNow()
                api := &amp;mitemapi.ItemApi{
                        ID:           apiID,
                        Name:         apiName,      // Use extracted API name
                        Url:          templatedURL, // Use templated URL for the actual endpoint
                        Method:       entry.Request.Method,
                        CollectionID: collectionID,
                        FolderID:     &amp;leafFolderID, // Place API in the appropriate folder
                }
                result.Apis = append(result.Apis, *api)

                // Create Delta Endpoint/api for delta functionality
                deltaApiID := idwrap.NewNow()
                deltaApi := &amp;mitemapi.ItemApi{
                        ID:            deltaApiID,
                        Name:          fmt.Sprintf("%s (Delta)", apiName),
                        Url:           templatedURL, // Use templated URL for the delta endpoint
                        Method:        entry.Request.Method,
                        CollectionID:  collectionID,
                        FolderID:      &amp;leafFolderID, // Place API in the appropriate folder
                        DeltaParentID: &amp;apiID,        // Reference the parent API
                }
                result.Apis = append(result.Apis, *deltaApi)

                // Create an example for this entry.
                exampleID := idwrap.NewNow()
                example := mitemapiexample.ItemApiExample{
                        ID:           exampleID,
                        CollectionID: collectionID,
                        Name:         apiName,
                        BodyType:     mitemapiexample.BodyTypeRaw,
                        ItemApiID:    apiID,
                }

                // If first occurrence, create a default example as well.
                defaultExampleID := idwrap.NewNow()
                exampleDefault := mitemapiexample.ItemApiExample{
                        ID:           defaultExampleID,
                        CollectionID: collectionID,
                        Name:         apiName,
                        BodyType:     mitemapiexample.BodyTypeRaw,
                        IsDefault:    true,
                        ItemApiID:    apiID,
                }
                deltaExampleID := idwrap.NewNow()
                deltaExample := mitemapiexample.ItemApiExample{
                        ID:              deltaExampleID,
                        Name:            fmt.Sprintf("%s (Delta)", apiName),
                        CollectionID:    collectionID,
                        ItemApiID:       apiID,
                        VersionParentID: &amp;defaultExampleID,
                }

                // Only add a flow node once per unique API.
                flowNodeID := idwrap.NewNow()
                request := mnrequest.MNRequest{
                        FlowNodeID:      flowNodeID,
                        EndpointID:      &amp;api.ID,
                        ExampleID:       &amp;exampleID,
                        DeltaExampleID:  &amp;deltaExampleID,
                        DeltaEndpointID: &amp;deltaApiID,
                }
                result.RequestNodes = append(result.RequestNodes, request)

                var connected bool

                // Check for timestamp-based sequencing to preserve some HAR ordering
                // This creates edges between consecutive requests that are close in time,
                // maintaining parallelism for requests further apart while ensuring
                // sequential execution for rapid consecutive requests
                currentTimestamp := entry.StartedDateTime
                if previousNodeID != nil &amp;&amp; previousTimestamp != nil </span><span class="cov8" title="1">{
                        timeDiff := currentTimestamp.Sub(*previousTimestamp)
                        if timeDiff &gt;= 0 &amp;&amp; timeDiff &lt;= TimestampSequencingThreshold </span><span class="cov8" title="1">{
                                // Connect to previous node if within threshold
                                result.Edges = append(result.Edges, edge.Edge{
                                        ID:            idwrap.NewNow(),
                                        FlowID:        flowID,
                                        SourceID:      *previousNodeID,
                                        TargetID:      flowNodeID,
                                        SourceHandler: edge.HandleUnspecified,
                                })
                                connected = true
                        }</span>
                }

                // Update previous node tracking
                <span class="cov8" title="1">previousNodeID = &amp;flowNodeID
                previousTimestamp = &amp;currentTimestamp

                // Add edges for URL path parameter dependencies
                for _, couple := range urlCouples </span><span class="cov0" title="0">{
                        result.Edges = append(result.Edges, edge.Edge{
                                ID:            idwrap.NewNow(),
                                FlowID:        flowID,
                                SourceID:      couple.NodeID,
                                TargetID:      flowNodeID,
                                SourceHandler: edge.HandleUnspecified,
                        })
                        connected = true
                }</span>

                // Process headers for dependency tracking but don't modify original values yet
                <span class="cov8" title="1">originalHeaders := make([]Header, len(entry.Request.Headers))
                copy(originalHeaders, entry.Request.Headers)

                deltaHeaders := make([]Header, len(entry.Request.Headers))
                copy(deltaHeaders, entry.Request.Headers)

                // Track which headers have dependencies so we only create delta versions for those
                headersWithDependencies := make(map[int]bool)

                for i, header := range deltaHeaders </span><span class="cov8" title="1">{
                        // Special handling for Authorization headers with Bearer tokens
                        if strings.EqualFold(header.Name, "Authorization") &amp;&amp; strings.HasPrefix(header.Value, "Bearer ") </span><span class="cov8" title="1">{
                                token := strings.TrimPrefix(header.Value, "Bearer ")
                                couple, err := (*depFinder).FindVar(token)
                                if err == nil </span><span class="cov8" title="1">{
                                        deltaHeaders[i].Value = fmt.Sprintf("Bearer {{ %s }}", couple.Path)
                                        headersWithDependencies[i] = true
                                        result.Edges = append(result.Edges, edge.Edge{
                                                ID:            idwrap.NewNow(),
                                                FlowID:        flowID,
                                                SourceID:      couple.NodeID,
                                                TargetID:      flowNodeID,
                                                SourceHandler: edge.HandleUnspecified,
                                        })
                                        connected = true
                                        continue</span>
                                }
                        }

                        // Regular header processing
                        <span class="cov8" title="1">couple, err := (*depFinder).FindVar(header.Value)
                        if err != nil </span><span class="cov8" title="1">{
                                if err == depfinder.ErrNotFound </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">return result, err</span>
                        }
                        <span class="cov8" title="1">deltaHeaders[i].Value = couple.Path
                        headersWithDependencies[i] = true

                        result.Edges = append(result.Edges, edge.Edge{
                                ID:            idwrap.NewNow(),
                                FlowID:        flowID,
                                SourceID:      couple.NodeID,
                                TargetID:      flowNodeID,
                                SourceHandler: edge.HandleUnspecified,
                        })
                        connected = true</span>
                }

                /*
                        for _, header := range entry.Response.Headers {
                                path := fmt.Sprintf("{{ %s.%s.%s.%s }}", requestName, "response", "headers", http.CanonicalHeaderKey(header.Name))
                                depFinder.AddVar(header.Value, depfinder.VarCouple{Path: path, NodeID: flowNodeID})
                        }
                */

                <span class="cov8" title="1">node := mnnode.MNode{
                        ID:        flowNodeID,
                        FlowID:    flowID,
                        Name:      requestName,
                        NodeKind:  mnnode.NODE_KIND_REQUEST,
                        PositionX: posX,
                        PositionY: posY,
                }
                result.Nodes = append(result.Nodes, node)

                // Use original headers for both default and normal examples
                headers := extractHeaders(originalHeaders, exampleID)
                headersDefault := extractHeaders(originalHeaders, defaultExampleID)
                result.Headers = append(result.Headers, headers...)
                result.Headers = append(result.Headers, headersDefault...)

                // Process queries - original for default, templated for delta
                originalQueries := make([]Query, len(entry.Request.QueryString))
                deltaQueries := make([]Query, len(entry.Request.QueryString))

                // Track which queries have dependencies so we only create delta versions for those
                queriesWithDependencies := make(map[int]bool)

                for i, query := range entry.Request.QueryString </span><span class="cov8" title="1">{
                        // Keep original values for default
                        originalQueries[i] = Query{Name: query.Name, Value: query.Value}

                        // Replace tokens in query values for delta
                        val := query.Value
                        var replaced bool
                        // If the value is valid JSON, parse and template it
                        var jsonObj interface{}
                        if err := json.Unmarshal([]byte(val), &amp;jsonObj); err == nil </span><span class="cov8" title="1">{
                                // Recursively process JSON structure
                                processedObj := processJSONForTokens(jsonObj, *depFinder)
                                if marshaled, err := json.Marshal(processedObj); err == nil </span><span class="cov8" title="1">{
                                        val = string(marshaled)
                                        replaced = true
                                        // Check if the processed JSON actually changed
                                        if val != query.Value </span><span class="cov0" title="0">{
                                                queriesWithDependencies[i] = true
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">if !replaced </span><span class="cov8" title="1">{
                                if newVal, found, _ := (*depFinder).ReplaceWithPaths(val); found </span><span class="cov8" title="1">{
                                        val = newVal.(string)
                                        queriesWithDependencies[i] = true
                                }</span>
                        }
                        <span class="cov8" title="1">deltaQueries[i] = Query{Name: query.Name, Value: val}</span>
                }

                <span class="cov8" title="1">queriesApi := extractQueryParams(originalQueries, exampleID)
                queriesDefaultApi := extractQueryParams(originalQueries, defaultExampleID)
                result.Queries = append(result.Queries, queriesApi...)
                result.Queries = append(result.Queries, queriesDefaultApi...)

                // Handle the request body.
                rawBody := mbodyraw.ExampleBodyRaw{
                        ID:            idwrap.NewNow(),
                        ExampleID:     exampleID,
                        Data:          []byte(""),
                        CompressType:  compress.CompressTypeNone,
                        VisualizeMode: mbodyraw.VisualizeModeText,
                }

                // Declare variables for form bodies and URL-encoded bodies at higher scope
                var formBodies []mbodyform.BodyForm
                var urlEncodedBodies []mbodyurl.BodyURLEncoded
                var templatedBodyBytes []byte // Store templated JSON for delta examples

                if entry.Request.PostData != nil </span><span class="cov8" title="1">{
                        postData := entry.Request.PostData
                        if strings.Contains(postData.MimeType, FormBodyCheck) </span><span class="cov8" title="1">{
                                // Use original values for both normal and default examples
                                formBodies = ConvertParamToFormBodies(postData.Params, exampleID)
                                result.FormBodies = append(result.FormBodies, formBodies...)
                                formBodiesDefault := ConvertParamToFormBodies(postData.Params, defaultExampleID)
                                result.FormBodies = append(result.FormBodies, formBodiesDefault...)

                                example.BodyType = mitemapiexample.BodyTypeForm
                        }</span> else<span class="cov8" title="1"> if strings.Contains(postData.MimeType, UrlEncodedBodyCheck) </span><span class="cov8" title="1">{
                                // Use original values for both normal and default examples
                                urlEncodedBodies = ConvertParamToUrlBodies(postData.Params, exampleID)
                                result.UrlEncodedBodies = append(result.UrlEncodedBodies, urlEncodedBodies...)
                                urlEncodedBodiesDefault := ConvertParamToUrlBodies(postData.Params, defaultExampleID)
                                result.UrlEncodedBodies = append(result.UrlEncodedBodies, urlEncodedBodiesDefault...)

                                example.BodyType = mitemapiexample.BodyTypeUrlencoded

                        }</span> else<span class="cov8" title="1"> {
                                // For JSON and other raw bodies, use original data without templating
                                // JSON bodies should never be templated according to requirements
                                bodyBytes := []byte(postData.Text)

                                // Still check for dependencies to create edges, but don't modify the body
                                if json.Valid(bodyBytes) </span><span class="cov8" title="1">{
                                        resultDep := depFinder.TemplateJSON(bodyBytes)
                                        if resultDep.Err != nil </span>{<span class="cov0" title="0">
                                                // Error templating JSON
                                        }</span> else<span class="cov8" title="1"> {
                                                if resultDep.FindAny </span><span class="cov8" title="1">{
                                                        connected = true
                                                        for _, couple := range resultDep.Couples </span><span class="cov8" title="1">{
                                                                result.Edges = append(result.Edges, edge.Edge{
                                                                        ID:            idwrap.NewNow(),
                                                                        FlowID:        flowID,
                                                                        SourceID:      couple.NodeID,
                                                                        TargetID:      flowNodeID,
                                                                        SourceHandler: edge.HandleUnspecified,
                                                                })
                                                        }</span>
                                                        // DO NOT store templated JSON - JSON bodies should never be templated
                                                        // templatedBodyBytes = resultDep.NewJson
                                                }
                                        }
                                }

                                <span class="cov8" title="1">rawBody.Data = bodyBytes
                                example.BodyType = mitemapiexample.BodyTypeRaw
                                if len(rawBody.Data) &gt; 1024 </span><span class="cov0" title="0">{
                                        compressedData, err := compress.Compress(rawBody.Data, compress.CompressTypeZstd)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return result, err
                                        }</span>
                                        <span class="cov0" title="0">if len(compressedData) &lt; len(rawBody.Data) </span><span class="cov0" title="0">{
                                                rawBody.Data = compressedData
                                                rawBody.CompressType = compress.CompressTypeZstd
                                        }</span>
                                }
                        }
                }

                // Don't immediately connect to start node - we'll handle this after all nodes are processed
                // to ensure proper dependency ordering
                <span class="cov8" title="1">if !connected </span><span class="cov8" title="1">{
                        posX = float64(slotIndex * slotSize)
                        posY = 100
                        nodePosMap[flowID] = mpos{x: posX, y: posY}
                        slotIndex++
                }</span>

                <span class="cov8" title="1">if len(entry.Response.Content.Text) != 0 </span><span class="cov8" title="1">{
                        repsonseBodyBytes := []byte(entry.Response.Content.Text)
                        if json.Valid(repsonseBodyBytes) </span><span class="cov8" title="1">{
                                path := fmt.Sprintf("%s.%s.%s", requestName, "response", "body")
                                nodeID := flowNodeID
                                couple := depfinder.VarCouple{Path: path, NodeID: nodeID}
                                // Ignore error from AddJsonBytes as it's not critical for the conversion
                                _ = depFinder.AddJsonBytes(repsonseBodyBytes, couple)
                        }</span>
                }

                <span class="cov8" title="1">result.RawBodies = append(result.RawBodies, rawBody)
                rawBodyDefault := rawBody
                rawBodyDefault.ID = idwrap.NewNow()
                rawBodyDefault.ExampleID = defaultExampleID
                result.RawBodies = append(result.RawBodies, rawBodyDefault)

                deltaBody := rawBodyDefault
                deltaBody.ID = idwrap.NewNow()
                deltaBody.ExampleID = deltaExampleID

                // Use templated body for delta if it was created
                if templatedBodyBytes != nil </span><span class="cov0" title="0">{
                        deltaBody.Data = templatedBodyBytes
                        // Handle compression for templated delta body
                        if len(deltaBody.Data) &gt; 1024 </span><span class="cov0" title="0">{
                                compressedData, err := compress.Compress(deltaBody.Data, compress.CompressTypeZstd)
                                if err == nil &amp;&amp; len(compressedData) &lt; len(deltaBody.Data) </span><span class="cov0" title="0">{
                                        deltaBody.Data = compressedData
                                        deltaBody.CompressType = compress.CompressTypeZstd
                                }</span>
                        }
                }

                <span class="cov8" title="1">result.RawBodies = append(result.RawBodies, deltaBody)

                // Create delta headers, queries, form bodies, and URL-encoded bodies
                // ONLY Delta examples use templated values for dependencies
                // Filter deltaHeaders to only include those with dependencies
                var deltaHeadersWithDeps []Header
                for i, header := range deltaHeaders </span><span class="cov8" title="1">{
                        if headersWithDependencies[i] </span><span class="cov8" title="1">{
                                deltaHeadersWithDeps = append(deltaHeadersWithDeps, header)
                        }</span>
                }

                <span class="cov8" title="1">headersDelta := extractHeadersWithDeltaParent(deltaHeadersWithDeps, deltaExampleID, headers)
                result.Headers = append(result.Headers, headersDelta...)

                // Filter deltaQueries to only include those with dependencies
                var deltaQueriesWithDeps []Query
                for i, query := range deltaQueries </span><span class="cov8" title="1">{
                        if queriesWithDependencies[i] </span><span class="cov8" title="1">{
                                deltaQueriesWithDeps = append(deltaQueriesWithDeps, query)
                        }</span>
                }

                <span class="cov8" title="1">queriesDelta := extractQueryParamsWithDeltaParent(deltaQueriesWithDeps, deltaExampleID, queriesApi)
                result.Queries = append(result.Queries, queriesDelta...)

                // Add delta form bodies and URL-encoded bodies if they exist (with templating and proper DeltaParentID)
                if entry.Request.PostData != nil </span><span class="cov8" title="1">{
                        postData := entry.Request.PostData
                        if strings.Contains(postData.MimeType, FormBodyCheck) </span><span class="cov8" title="1">{
                                formBodiesDelta := ConvertParamToFormBodiesWithDeltaParent(postData.Params, deltaExampleID, formBodies, depFinder)
                                result.FormBodies = append(result.FormBodies, formBodiesDelta...)
                        }</span> else<span class="cov8" title="1"> if strings.Contains(postData.MimeType, UrlEncodedBodyCheck) </span><span class="cov8" title="1">{
                                urlEncodedBodiesDelta := ConvertParamToUrlBodiesWithDeltaParent(postData.Params, deltaExampleID, urlEncodedBodies, depFinder)
                                result.UrlEncodedBodies = append(result.UrlEncodedBodies, urlEncodedBodiesDelta...)
                        }</span>
                }

                <span class="cov8" title="1">result.Examples = append(result.Examples, example)
                exampleDefault.BodyType = example.BodyType
                result.Examples = append(result.Examples, exampleDefault)
                result.Examples = append(result.Examples, deltaExample)

                // Create status code assertions for all examples
                if entry.Response.Status &gt; 0 </span><span class="cov8" title="1">{
                        // Create assertion for the normal example
                        assertNormal := createStatusCodeAssertion(exampleID, entry.Response.Status)
                        result.Asserts = append(result.Asserts, assertNormal)

                        // Create assertion for the default example
                        assertDefault := createStatusCodeAssertion(defaultExampleID, entry.Response.Status)
                        result.Asserts = append(result.Asserts, assertDefault)

                        // Create delta assertion for the delta example
                        // The delta assertion references the default assertion as its parent
                        assertDelta := createStatusCodeAssertionWithDeltaParent(deltaExampleID, &amp;assertDefault.ID, entry.Response.Status)
                        result.Asserts = append(result.Asserts, assertDelta)
                }</span>
        }

        <span class="cov8" title="1">for i := range result.Apis </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        prevApi := &amp;result.Apis[i-1]
                        result.Apis[i].Prev = &amp;prevApi.ID
                }</span>
                <span class="cov8" title="1">if i &lt; len(result.Apis)-1 </span><span class="cov8" title="1">{
                        nextApi := &amp;result.Apis[i+1]
                        result.Apis[i].Next = &amp;nextApi.ID
                }</span>
        }

        <span class="cov8" title="1">for i := range result.Examples </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        prevExample := &amp;result.Examples[i-1]
                        result.Examples[i].Prev = &amp;prevExample.ID
                }</span>
                <span class="cov8" title="1">if i &lt; len(result.Examples)-1 </span><span class="cov8" title="1">{
                        nextExample := &amp;result.Examples[i+1]
                        result.Examples[i].Next = &amp;nextExample.ID
                }</span>
        }

        // Set Prev/Next for assertions to maintain ordering
        <span class="cov8" title="1">for i := range result.Asserts </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        prevAssert := &amp;result.Asserts[i-1]
                        result.Asserts[i].Prev = &amp;prevAssert.ID
                }</span>
                <span class="cov8" title="1">if i &lt; len(result.Asserts)-1 </span><span class="cov8" title="1">{
                        nextAssert := &amp;result.Asserts[i+1]
                        result.Asserts[i].Next = &amp;nextAssert.ID
                }</span>
        }

        // After all entries are processed, connect nodes without dependencies to the start node
        // and ensure proper dependency ordering
        <span class="cov8" title="1">err := ensureProperDependencyOrdering(&amp;result, startNodeID, flowID)
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        <span class="cov8" title="1">err = ReorganizeNodePositions(&amp;result)
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// ensureProperDependencyOrdering ensures that:
// 1. Nodes without incoming dependencies are connected to the start node
// 2. Dependency chains are properly ordered
// 3. Redundant transitive edges are removed
func ensureProperDependencyOrdering(result *HarResvoled, startNodeID idwrap.IDWrap, flowID idwrap.IDWrap) error <span class="cov8" title="1">{
        // First, perform transitive reduction to remove redundant edges
        err := performTransitiveReduction(result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Build a map of which nodes have incoming dependencies
        <span class="cov8" title="1">hasIncomingDependencies := make(map[idwrap.IDWrap]bool)

        for _, edge := range result.Edges </span><span class="cov8" title="1">{
                // Skip edges from the start node (these will be added by this function)
                if edge.SourceID != startNodeID </span><span class="cov8" title="1">{
                        hasIncomingDependencies[edge.TargetID] = true
                }</span>
        }

        // Find all request nodes that don't have incoming dependencies
        // and connect them to the start node
        <span class="cov8" title="1">nodeMap := make(map[idwrap.IDWrap]*mnnode.MNode)
        for i := range result.Nodes </span><span class="cov8" title="1">{
                nodeMap[result.Nodes[i].ID] = &amp;result.Nodes[i]
        }</span>

        <span class="cov8" title="1">for _, node := range result.Nodes </span><span class="cov8" title="1">{
                // Skip the start node itself
                if node.ID == startNodeID </span><span class="cov8" title="1">{
                        continue</span>
                }

                // If this request node has no incoming dependencies, connect it to start
                <span class="cov8" title="1">if !hasIncomingDependencies[node.ID] </span><span class="cov8" title="1">{
                        result.Edges = append(result.Edges, edge.Edge{
                                ID:            idwrap.NewNow(),
                                FlowID:        flowID,
                                SourceID:      startNodeID,
                                TargetID:      node.ID,
                                SourceHandler: edge.HandleUnspecified,
                        })
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// performTransitiveReduction removes redundant edges from the dependency graph.
// If there's a path from A to C through B (A→B→C), then a direct edge A→C is redundant.
func performTransitiveReduction(result *HarResvoled) error <span class="cov8" title="1">{
        // Build adjacency list for the graph
        adjacencyList := make(map[idwrap.IDWrap]map[idwrap.IDWrap]bool)
        for _, edge := range result.Edges </span><span class="cov8" title="1">{
                if adjacencyList[edge.SourceID] == nil </span><span class="cov8" title="1">{
                        adjacencyList[edge.SourceID] = make(map[idwrap.IDWrap]bool)
                }</span>
                <span class="cov8" title="1">adjacencyList[edge.SourceID][edge.TargetID] = true</span>
        }

        // For each node, compute all nodes reachable through paths of length &gt; 1
        <span class="cov8" title="1">for source := range adjacencyList </span><span class="cov8" title="1">{
                // Find all nodes reachable from source through intermediate nodes
                reachableThroughPaths := make(map[idwrap.IDWrap]bool)

                // Check all direct neighbors
                for intermediate := range adjacencyList[source] </span><span class="cov8" title="1">{
                        // From each direct neighbor, find what nodes are reachable
                        if intermediateNeighbors, exists := adjacencyList[intermediate]; exists </span><span class="cov8" title="1">{
                                for target := range intermediateNeighbors </span><span class="cov8" title="1">{
                                        // Mark that we can reach 'target' from 'source' through 'intermediate'
                                        reachableThroughPaths[target] = true
                                }</span>
                        }
                }

                // Remove direct edges that are redundant (reachable through other paths)
                <span class="cov8" title="1">for target := range reachableThroughPaths </span><span class="cov8" title="1">{
                        if adjacencyList[source][target] </span><span class="cov8" title="1">{
                                // This edge is redundant, mark it for removal
                                delete(adjacencyList[source], target)
                        }</span>
                }
        }

        // Rebuild the edges list without redundant edges
        <span class="cov8" title="1">var newEdges []edge.Edge
        for _, e := range result.Edges </span><span class="cov8" title="1">{
                if adjacencyList[e.SourceID] != nil &amp;&amp; adjacencyList[e.SourceID][e.TargetID] </span><span class="cov8" title="1">{
                        newEdges = append(newEdges, e)
                }</span>
        }

        // Update the result with the reduced set of edges
        <span class="cov8" title="1">result.Edges = newEdges
        return nil</span>
}

// ConvertHARWithDepFinder allows injecting a custom depFinder (for testing)
func ConvertHARWithDepFinder(har *HAR, collectionID, workspaceID idwrap.IDWrap, depFinder *depfinder.DepFinder) (HarResvoled, error) <span class="cov8" title="1">{
        return convertHARInternal(har, collectionID, workspaceID, depFinder, nil)
}</span>

// ConvertHAR uses a new depFinder (for production)
func ConvertHAR(har *HAR, collectionID, workspaceID idwrap.IDWrap) (HarResvoled, error) <span class="cov8" title="1">{
        return ConvertHARWithDepFinder(har, collectionID, workspaceID, nil)
}</span>

// ConvertHARWithExistingData allows passing pre-loaded folders and APIs for optimization
func ConvertHARWithExistingData(har *HAR, collectionID, workspaceID idwrap.IDWrap, existingFolders []mitemfolder.ItemFolder) (HarResvoled, error) <span class="cov0" title="0">{
        // Build folder map from existing folders
        folderMap := make(map[string]idwrap.IDWrap)

        // First, create a map by ID for quick lookups
        folderByID := make(map[idwrap.IDWrap]*mitemfolder.ItemFolder)
        for i := range existingFolders </span><span class="cov0" title="0">{
                folderByID[existingFolders[i].ID] = &amp;existingFolders[i]
        }</span>

        // Now build the path map
        <span class="cov0" title="0">for i := range existingFolders </span><span class="cov0" title="0">{
                folder := &amp;existingFolders[i]
                path := buildFolderPath(folder, folderByID)
                folderMap[path] = folder.ID

                // Also add just the name for root folders
                if folder.ParentID == nil </span><span class="cov0" title="0">{
                        folderMap[folder.Name] = folder.ID
                }</span>
        }

        // Use existing ConvertHARWithDepFinder but inject folder map
        <span class="cov0" title="0">depFinder := depfinder.NewDepFinder()
        result, err := convertHARInternal(har, collectionID, workspaceID, &amp;depFinder, folderMap)
        return result, err</span>
}

// buildFolderPath reconstructs the full path for a folder
func buildFolderPath(folder *mitemfolder.ItemFolder, folderByID map[idwrap.IDWrap]*mitemfolder.ItemFolder) string <span class="cov0" title="0">{
        if folder.ParentID == nil </span><span class="cov0" title="0">{
                return folder.Name
        }</span>

        <span class="cov0" title="0">parent, exists := folderByID[*folder.ParentID]
        if !exists </span><span class="cov0" title="0">{
                return folder.Name
        }</span>

        <span class="cov0" title="0">parentPath := buildFolderPath(parent, folderByID)
        return parentPath + "/" + folder.Name</span>
}

// ConvertHARWithDepFinderAndFolders is for future use
func ConvertHARWithDepFinderAndFolders(har *HAR, collectionID, workspaceID idwrap.IDWrap, depFinder *depfinder.DepFinder, preloadedFolders map[string]idwrap.IDWrap) (HarResvoled, error) <span class="cov0" title="0">{
        // For now, just use the existing function
        // TODO: Implement folder preloading optimization
        return ConvertHARWithDepFinder(har, collectionID, workspaceID, depFinder)
}</span>

// Helper: returns true if the HAR entry is for an XHR request.
func IsXHRRequest(entry Entry) bool <span class="cov8" title="1">{
        // Check if the entry has _resourceType set to xhr
        if entry.ResourceType == "xhr" </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check the X-Requested-With header – common for XHR.
        <span class="cov8" title="1">for _, header := range entry.Request.Headers </span><span class="cov8" title="1">{
                if strings.EqualFold(header.Name, "X-Requested-With") &amp;&amp;
                        strings.EqualFold(header.Value, "XMLHttpRequest") </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        // Also check the Content-Type header for typical XHR MIME types.
        <span class="cov8" title="1">for _, header := range entry.Request.Headers </span><span class="cov8" title="1">{
                if strings.EqualFold(header.Name, "Content-Type") </span><span class="cov8" title="1">{
                        if strings.Contains(header.Value, "application/json") ||
                                strings.Contains(header.Value, "application/xml") ||
                                strings.Contains(header.Value, "text/plain") </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

func extractHeaders(headers []Header, exampleID idwrap.IDWrap) []mexampleheader.Header <span class="cov8" title="1">{
        var result []mexampleheader.Header
        for _, header := range headers </span><span class="cov8" title="1">{
                if len(header.Name) &gt; 0 </span><span class="cov8" title="1">{
                        // don't support pseudo-header atm
                        if header.Name[0] == ':' </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">h := mexampleheader.Header{
                                ID:        idwrap.NewNow(),
                                ExampleID: exampleID,
                                HeaderKey: header.Name,
                                Value:     header.Value,
                                Enable:    true,
                        }
                        result = append(result, h)</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

func extractHeadersWithDeltaParent(headers []Header, deltaExampleID idwrap.IDWrap, baseHeaders []mexampleheader.Header) []mexampleheader.Header <span class="cov8" title="1">{
        var result []mexampleheader.Header

        // Create a map of base headers by their key for quick lookup
        baseHeaderMap := make(map[string]mexampleheader.Header)
        for _, baseHeader := range baseHeaders </span><span class="cov8" title="1">{
                baseHeaderMap[baseHeader.HeaderKey] = baseHeader
        }</span>

        <span class="cov8" title="1">for _, header := range headers </span><span class="cov8" title="1">{
                if len(header.Name) &gt; 0 </span><span class="cov8" title="1">{
                        // don't support pseudo-header atm
                        if header.Name[0] == ':' </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Find the corresponding base header with matching key
                        <span class="cov8" title="1">var deltaParentID *idwrap.IDWrap
                        if baseHeader, exists := baseHeaderMap[header.Name]; exists </span><span class="cov8" title="1">{
                                deltaParentID = &amp;baseHeader.ID
                        }</span>

                        <span class="cov8" title="1">h := mexampleheader.Header{
                                ID:            idwrap.NewNow(),
                                ExampleID:     deltaExampleID,
                                HeaderKey:     header.Name,
                                Value:         header.Value,
                                Enable:        true,
                                DeltaParentID: deltaParentID,
                        }

                        result = append(result, h)</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

func extractQueryParams(queries []Query, exampleID idwrap.IDWrap) []mexamplequery.Query <span class="cov8" title="1">{
        var result []mexamplequery.Query
        for _, query := range queries </span><span class="cov8" title="1">{
                q := mexamplequery.Query{
                        ID:        idwrap.NewNow(),
                        ExampleID: exampleID,
                        QueryKey:  query.Name,
                        Value:     query.Value,
                        Enable:    true,
                }
                result = append(result, q)
        }</span>
        <span class="cov8" title="1">return result</span>
}

func extractQueryParamsWithDeltaParent(queries []Query, deltaExampleID idwrap.IDWrap, baseQueries []mexamplequery.Query) []mexamplequery.Query <span class="cov8" title="1">{
        var result []mexamplequery.Query

        // Create a map of base queries by their key for quick lookup
        baseQueryMap := make(map[string]mexamplequery.Query)
        for _, baseQuery := range baseQueries </span><span class="cov8" title="1">{
                baseQueryMap[baseQuery.QueryKey] = baseQuery
        }</span>

        <span class="cov8" title="1">for _, query := range queries </span><span class="cov8" title="1">{
                // Find the corresponding base query
                var deltaParentID *idwrap.IDWrap
                if baseQuery, exists := baseQueryMap[query.Name]; exists </span><span class="cov8" title="1">{
                        deltaParentID = &amp;baseQuery.ID
                }</span>

                <span class="cov8" title="1">q := mexamplequery.Query{
                        ID:            idwrap.NewNow(),
                        ExampleID:     deltaExampleID,
                        QueryKey:      query.Name,
                        Value:         query.Value,
                        Enable:        true,
                        DeltaParentID: deltaParentID,
                }
                result = append(result, q)</span>
        }
        <span class="cov8" title="1">return result</span>
}

// ReorganizeNodePositions positions flow nodes using a level-based layout.
// Parallel nodes are positioned at the same Y level, sequential nodes at deeper levels.
func ReorganizeNodePositions(result *HarResvoled) error <span class="cov8" title="1">{
        const (
                nodeSpacingX = 400 // Horizontal spacing between parallel nodes
                nodeSpacingY = 300 // Vertical spacing between levels
                startX       = 0   // Starting X position
                startY       = 0   // Starting Y position
        )

        // Map for quick node lookup
        nodeMap := make(map[idwrap.IDWrap]*mnnode.MNode)
        for i := range result.Nodes </span><span class="cov8" title="1">{
                nodeMap[result.Nodes[i].ID] = &amp;result.Nodes[i]
        }</span>

        // Find start node
        <span class="cov8" title="1">var startNode *mnnode.MNode
        for i := range result.NoopNodes </span><span class="cov8" title="1">{
                if result.NoopNodes[i].Type == mnnoop.NODE_NO_OP_KIND_START </span><span class="cov8" title="1">{
                        startNode = nodeMap[result.NoopNodes[i].FlowNodeID]
                        break</span>
                }
        }
        <span class="cov8" title="1">if startNode == nil </span><span class="cov0" title="0">{
                return errors.New("start node not found")
        }</span>

        // Build adjacency lists from edges
        <span class="cov8" title="1">outgoingEdges := make(map[idwrap.IDWrap][]idwrap.IDWrap)
        incomingEdges := make(map[idwrap.IDWrap][]idwrap.IDWrap)
        for _, e := range result.Edges </span><span class="cov8" title="1">{
                outgoingEdges[e.SourceID] = append(outgoingEdges[e.SourceID], e.TargetID)
                incomingEdges[e.TargetID] = append(incomingEdges[e.TargetID], e.SourceID)
        }</span>

        // Calculate dependency levels using BFS
        <span class="cov8" title="1">nodeLevels := make(map[idwrap.IDWrap]int)
        levelNodes := make(map[int][]idwrap.IDWrap) // level -&gt; nodes at that level

        // BFS to assign levels
        queue := []idwrap.IDWrap{startNode.ID}
        nodeLevels[startNode.ID] = 0
        levelNodes[0] = []idwrap.IDWrap{startNode.ID}

        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                currentNodeID := queue[0]
                queue = queue[1:]

                // Process all children
                for _, childID := range outgoingEdges[currentNodeID] </span><span class="cov8" title="1">{
                        // Calculate the maximum level of all parents + 1
                        maxParentLevel := -1
                        for _, parentID := range incomingEdges[childID] </span><span class="cov8" title="1">{
                                if parentLevel, exists := nodeLevels[parentID]; exists </span><span class="cov8" title="1">{
                                        if parentLevel &gt; maxParentLevel </span><span class="cov8" title="1">{
                                                maxParentLevel = parentLevel
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">childLevel := maxParentLevel + 1

                        // Only update if this is a new node or we found a deeper level
                        if existingLevel, exists := nodeLevels[childID]; !exists || childLevel &gt; existingLevel </span><span class="cov8" title="1">{
                                // Remove from old level if it existed
                                if exists </span><span class="cov0" title="0">{
                                        oldLevelNodes := levelNodes[existingLevel]
                                        for i, nodeID := range oldLevelNodes </span><span class="cov0" title="0">{
                                                if nodeID == childID </span><span class="cov0" title="0">{
                                                        levelNodes[existingLevel] = append(oldLevelNodes[:i], oldLevelNodes[i+1:]...)
                                                        break</span>
                                                }
                                        }
                                }

                                // Add to new level
                                <span class="cov8" title="1">nodeLevels[childID] = childLevel
                                levelNodes[childLevel] = append(levelNodes[childLevel], childID)
                                queue = append(queue, childID)</span>
                        }
                }
        }

        // Position nodes level by level
        <span class="cov8" title="1">for level := 0; level &lt;= len(levelNodes)-1; level++ </span><span class="cov8" title="1">{
                nodes := levelNodes[level]
                if len(nodes) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Calculate Y position for this level
                <span class="cov8" title="1">yPos := float64(startY + level*nodeSpacingY)

                // Calculate starting X position to center the nodes at this level
                totalWidth := float64((len(nodes) - 1) * nodeSpacingX)
                startXForLevel := float64(startX) - totalWidth/2

                // Position each node in this level
                for i, nodeID := range nodes </span><span class="cov8" title="1">{
                        if node := nodeMap[nodeID]; node != nil </span><span class="cov8" title="1">{
                                node.PositionX = startXForLevel + float64(i*nodeSpacingX)
                                node.PositionY = yPos
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func processJSONForTokens(obj interface{}, depFinder depfinder.DepFinder) interface{} <span class="cov8" title="1">{
        switch v := obj.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                // Process map values recursively
                for key, val := range v </span><span class="cov0" title="0">{
                        v[key] = processJSONForTokens(val, depFinder)
                }</span>
                <span class="cov0" title="0">return v</span>
        case []interface{}:<span class="cov0" title="0">
                // Process array elements recursively
                for i, val := range v </span><span class="cov0" title="0">{
                        v[i] = processJSONForTokens(val, depFinder)
                }</span>
                <span class="cov0" title="0">return v</span>
        case string:<span class="cov0" title="0">
                // Try to replace tokens in string values
                if newVal, found, _ := depFinder.ReplaceWithPaths(v); found </span><span class="cov0" title="0">{
                        return newVal
                }</span>
                <span class="cov0" title="0">return v</span>
        default:<span class="cov8" title="1">
                return v</span>
        }
}

// createStatusCodeAssertion creates an assertion for checking the response status code
func createStatusCodeAssertion(exampleID idwrap.IDWrap, statusCode int) massert.Assert <span class="cov8" title="1">{
        // Create the condition expression for status code check
        // The expression uses JSONPath-like syntax to check response.status
        expression := fmt.Sprintf("response.status == %d", statusCode)

        return massert.Assert{
                ID:        idwrap.NewNow(),
                ExampleID: exampleID,
                Condition: mcondition.Condition{
                        Comparisons: mcondition.Comparison{
                                Expression: expression,
                        },
                },
                Enable: true,
                // For HAR imports, we don't set Prev/Next as assertions don't have ordering in this context
                Prev: nil,
                Next: nil,
        }
}</span>

// createStatusCodeAssertionWithDeltaParent creates a delta assertion for status code check
func createStatusCodeAssertionWithDeltaParent(deltaExampleID idwrap.IDWrap, deltaParentID *idwrap.IDWrap, statusCode int) massert.Assert <span class="cov8" title="1">{
        expression := fmt.Sprintf("response.status == %d", statusCode)

        return massert.Assert{
                ID:            idwrap.NewNow(),
                ExampleID:     deltaExampleID,
                DeltaParentID: deltaParentID,
                Condition: mcondition.Condition{
                        Comparisons: mcondition.Comparison{
                                Expression: expression,
                        },
                },
                Enable: true,
                Prev:   nil,
                Next:   nil,
        }
}</span>
</pre>
		
		<pre class="file" id="file138" style="display: none">package theader

import (
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mexampleheader"
        requestv1 "the-dev-tools/spec/dist/buf/go/collection/item/request/v1"
)

func SerializeHeaderModelToRPC(header mexampleheader.Header) *requestv1.Header <span class="cov0" title="0">{

        return &amp;requestv1.Header{
                HeaderId:    header.ID.Bytes(),
                Key:         header.HeaderKey,
                Enabled:     header.Enable,
                Value:       header.Value,
                Description: header.Description,
        }
}</span>

func SerializeHeaderModelToRPCDeltaItem(header mexampleheader.Header) *requestv1.HeaderDeltaListItem <span class="cov0" title="0">{
        return &amp;requestv1.HeaderDeltaListItem{
                HeaderId:    header.ID.Bytes(),
                Key:         header.HeaderKey,
                Enabled:     header.Enable,
                Value:       header.Value,
                Description: header.Description,
        }
}</span>

func SerializeHeaderModelToRPCItem(header mexampleheader.Header) *requestv1.HeaderListItem <span class="cov0" title="0">{

        return &amp;requestv1.HeaderListItem{
                HeaderId:    header.ID.Bytes(),
                Key:         header.HeaderKey,
                Enabled:     header.Enable,
                Value:       header.Value,
                Description: header.Description,
        }
}</span>

func SerlializeHeaderRPCtoModel(header *requestv1.Header, exampleID idwrap.IDWrap) (mexampleheader.Header, error) <span class="cov0" title="0">{
        headerId, err := idwrap.NewFromBytes(header.GetHeaderId())
        if err != nil </span><span class="cov0" title="0">{
                return mexampleheader.Header{}, err
        }</span>
        <span class="cov0" title="0">var deltaParentID *idwrap.IDWrap
        h := SerlializeHeaderRPCtoModelNoID(header, exampleID, deltaParentID)
        h.ID = headerId
        return h, nil</span>
}

func SerlializeHeaderRPCtoModelNoID(header *requestv1.Header, exampleID idwrap.IDWrap, parentID *idwrap.IDWrap) mexampleheader.Header <span class="cov0" title="0">{
        return mexampleheader.Header{
                ExampleID:     exampleID,
                HeaderKey:     header.GetKey(),
                Description:   header.GetDescription(),
                Enable:        header.GetEnabled(),
                Value:         header.GetValue(),
                DeltaParentID: parentID,
        }
}</span>
</pre>
		
		<pre class="file" id="file139" style="display: none">package titemapi

import (
        "errors"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mitemapi"
        endpointv1 "the-dev-tools/spec/dist/buf/go/collection/item/endpoint/v1"
)

func SeralizeRPCToModel(item *endpointv1.Endpoint, collectionID idwrap.IDWrap) (*mitemapi.ItemApi, error) <span class="cov0" title="0">{
        modelItem, err := SeralizeRPCToModelWithoutID(item, collectionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">id, err := idwrap.NewFromBytes(item.GetEndpointId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">modelItem.ID = id
        return modelItem, nil</span>
}

func SeralizeRPCToModelWithoutID(item *endpointv1.Endpoint, collectionID idwrap.IDWrap) (*mitemapi.ItemApi, error) <span class="cov0" title="0">{
        if item == nil </span><span class="cov0" title="0">{
                return nil, errors.New("item is nil")
        }</span>
        <span class="cov0" title="0">var parentID *idwrap.IDWrap
        parentIDBytes := item.GetParentFolderId()
        if len(parentIDBytes) &gt; 0 </span><span class="cov0" title="0">{
                tempParentID, err := idwrap.NewFromBytes(parentIDBytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">parentID = &amp;tempParentID</span>
        }

        <span class="cov0" title="0">var hidden bool
        if item.Hidden != nil </span><span class="cov0" title="0">{
                hidden = *item.Hidden
        }</span>

        <span class="cov0" title="0">return &amp;mitemapi.ItemApi{
                CollectionID: collectionID,
                FolderID:     parentID,
                Url:          item.GetUrl(),
                Name:         item.GetName(),
                Method:       item.GetMethod(),
                Hidden:       hidden,
        }, nil</span>
}

func DeseralizeModelToRPC(item *mitemapi.ItemApi) *endpointv1.Endpoint <span class="cov0" title="0">{
        var parentID []byte = nil
        if item.FolderID != nil </span><span class="cov0" title="0">{
                parentID = item.FolderID.Bytes()
        }</span>
        <span class="cov0" title="0">return &amp;endpointv1.Endpoint{
                EndpointId:     item.ID.Bytes(),
                ParentFolderId: parentID,
                Name:           item.Name,
                Method:         item.Method,
                Url:            item.Url,
                Hidden:         &amp;item.Hidden,
        }</span>
}

func SeralizeModelToRPCItem(item *mitemapi.ItemApi) *endpointv1.EndpointListItem <span class="cov0" title="0">{
        var parentID []byte = nil
        if item.FolderID != nil </span><span class="cov0" title="0">{
                parentID = item.FolderID.Bytes()
        }</span>
        <span class="cov0" title="0">return &amp;endpointv1.EndpointListItem{
                EndpointId:     item.ID.Bytes(),
                ParentFolderId: parentID,
                Name:           item.Name,
                Method:         item.Method,
                Hidden:         &amp;item.Hidden,
        }</span>
}
</pre>
		
		<pre class="file" id="file140" style="display: none">package tnodeexecution

import (
        "encoding/json"
        "the-dev-tools/server/pkg/model/mnodeexecution"
        nodeexecutionv1 "the-dev-tools/spec/dist/buf/go/flow/node/execution/v1"
        nodev1 "the-dev-tools/spec/dist/buf/go/flow/node/v1"
        "time"

        "google.golang.org/protobuf/types/known/structpb"
        "google.golang.org/protobuf/types/known/timestamppb"
)

func SerializeNodeExecutionModelToRPC(ne *mnodeexecution.NodeExecution) (*nodeexecutionv1.NodeExecution, error) <span class="cov0" title="0">{
        rpc := &amp;nodeexecutionv1.NodeExecution{
                NodeExecutionId: ne.ID.Bytes(),
                NodeId:          ne.NodeID.Bytes(),
                Name:            ne.Name,
                State:           nodev1.NodeState(ne.State),
        }

        // Handle optional error
        if ne.Error != nil </span><span class="cov0" title="0">{
                rpc.Error = ne.Error
        }</span>

        // Decompress and convert input JSON to structpb.Value
        <span class="cov0" title="0">if inputJSON, err := ne.GetInputJSON(); err == nil &amp;&amp; inputJSON != nil </span><span class="cov0" title="0">{
                var inputValue interface{}
                if err := json.Unmarshal(inputJSON, &amp;inputValue); err == nil </span><span class="cov0" title="0">{
                        rpc.Input, _ = structpb.NewValue(inputValue)
                }</span>
        }

        // Decompress and convert output JSON to structpb.Value
        <span class="cov0" title="0">if outputJSON, err := ne.GetOutputJSON(); err == nil &amp;&amp; outputJSON != nil </span><span class="cov0" title="0">{
                var outputValue interface{}
                if err := json.Unmarshal(outputJSON, &amp;outputValue); err == nil </span><span class="cov0" title="0">{
                        rpc.Output, _ = structpb.NewValue(outputValue)
                }</span>
        }

        // Convert CompletedAt timestamp
        <span class="cov0" title="0">if ne.CompletedAt != nil </span><span class="cov0" title="0">{
                rpc.CompletedAt = timestamppb.New(time.UnixMilli(*ne.CompletedAt))
        }</span>

        // Handle optional ResponseID
        <span class="cov0" title="0">if ne.ResponseID != nil </span><span class="cov0" title="0">{
                rpc.ResponseId = ne.ResponseID.Bytes()
        }</span>

        <span class="cov0" title="0">return rpc, nil</span>
}

func SerializeNodeExecutionModelToRPCListItem(ne *mnodeexecution.NodeExecution) (*nodeexecutionv1.NodeExecutionListItem, error) <span class="cov0" title="0">{
        rpc := &amp;nodeexecutionv1.NodeExecutionListItem{
                NodeExecutionId: ne.ID.Bytes(),
                NodeId:          ne.NodeID.Bytes(),
                Name:            ne.Name,
                State:           nodev1.NodeState(ne.State),
        }

        // Handle optional error
        if ne.Error != nil </span><span class="cov0" title="0">{
                rpc.Error = ne.Error
        }</span>

        // Convert CompletedAt timestamp
        <span class="cov0" title="0">if ne.CompletedAt != nil </span><span class="cov0" title="0">{
                rpc.CompletedAt = timestamppb.New(time.UnixMilli(*ne.CompletedAt))
        }</span>

        // Handle optional ResponseID
        <span class="cov0" title="0">if ne.ResponseID != nil </span><span class="cov0" title="0">{
                rpc.ResponseId = ne.ResponseID.Bytes()
        }</span>

        <span class="cov0" title="0">return rpc, nil</span>
}

func SerializeNodeExecutionModelToRPCGetResponse(ne *mnodeexecution.NodeExecution) (*nodeexecutionv1.NodeExecutionGetResponse, error) <span class="cov0" title="0">{
        rpc := &amp;nodeexecutionv1.NodeExecutionGetResponse{
                NodeExecutionId: ne.ID.Bytes(),
                NodeId:          ne.NodeID.Bytes(),
                Name:            ne.Name,
                State:           nodev1.NodeState(ne.State),
        }

        // Handle optional error
        if ne.Error != nil </span><span class="cov0" title="0">{
                rpc.Error = ne.Error
        }</span>

        // Decompress and convert input JSON to structpb.Value
        <span class="cov0" title="0">if inputJSON, err := ne.GetInputJSON(); err == nil &amp;&amp; inputJSON != nil </span><span class="cov0" title="0">{
                var inputValue interface{}
                if err := json.Unmarshal(inputJSON, &amp;inputValue); err == nil </span><span class="cov0" title="0">{
                        rpc.Input, _ = structpb.NewValue(inputValue)
                }</span>
        }

        // Decompress and convert output JSON to structpb.Value
        <span class="cov0" title="0">if outputJSON, err := ne.GetOutputJSON(); err == nil &amp;&amp; outputJSON != nil </span><span class="cov0" title="0">{
                var outputValue interface{}
                if err := json.Unmarshal(outputJSON, &amp;outputValue); err == nil </span><span class="cov0" title="0">{
                        rpc.Output, _ = structpb.NewValue(outputValue)
                }</span>
        }

        // Convert CompletedAt timestamp
        <span class="cov0" title="0">if ne.CompletedAt != nil </span><span class="cov0" title="0">{
                rpc.CompletedAt = timestamppb.New(time.UnixMilli(*ne.CompletedAt))
        }</span>

        // Handle optional ResponseID
        <span class="cov0" title="0">if ne.ResponseID != nil </span><span class="cov0" title="0">{
                rpc.ResponseId = ne.ResponseID.Bytes()
        }</span>

        <span class="cov0" title="0">return rpc, nil</span>
}
</pre>
		
		<pre class="file" id="file141" style="display: none">package tpostman

import (
        "errors"
        "fmt"
        "net/url"
        "strings"
        "sync"
        "the-dev-tools/server/pkg/compress"
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mbodyform"
        "the-dev-tools/server/pkg/model/mbodyraw"
        "the-dev-tools/server/pkg/model/mbodyurl"
        "the-dev-tools/server/pkg/model/mexampleheader"
        "the-dev-tools/server/pkg/model/mexamplequery"
        "the-dev-tools/server/pkg/model/mitemapi"
        "the-dev-tools/server/pkg/model/mitemapiexample"
        "the-dev-tools/server/pkg/model/mitemfolder"
        "the-dev-tools/server/pkg/model/postman/v21/mbody"
        "the-dev-tools/server/pkg/model/postman/v21/mheader"
        "the-dev-tools/server/pkg/model/postman/v21/mitem"
        "the-dev-tools/server/pkg/model/postman/v21/mpostmancollection"
        "the-dev-tools/server/pkg/model/postman/v21/mresponse"
        "the-dev-tools/server/pkg/model/postman/v21/murl"
        "the-dev-tools/server/pkg/model/postman/v21/mvariable"
        "the-dev-tools/server/pkg/zstdcompress"
        "time"

        "github.com/goccy/go-json"
)

func SendAllToChannel[I any](items []I, ch chan I) <span class="cov0" title="0">{
        for _, item := range items </span><span class="cov0" title="0">{
                ch &lt;- item
        }</span>
}

func SendAllToChannelPtr[I any](items []*I, ch chan I) <span class="cov8" title="1">{
        for _, item := range items </span><span class="cov8" title="1">{
                ch &lt;- *item
        }</span>
}

func ParsePostmanCollection(data []byte) (mpostmancollection.Collection, error) <span class="cov0" title="0">{
        var collection mpostmancollection.Collection

        err := json.Unmarshal(data, &amp;collection)
        if err != nil </span><span class="cov0" title="0">{
                return collection, err
        }</span>
        <span class="cov0" title="0">return collection, nil</span>
}

type ItemsPair struct {
        ApiExamples    []mitemapiexample.ItemApiExample
        Apis           []mitemapi.ItemApi
        Folders        []mitemfolder.ItemFolder
        Headers        []mexampleheader.Header
        Queries        []mexamplequery.Query
        BodyForm       []mbodyform.BodyForm
        BodyUrlEncoded []mbodyurl.BodyURLEncoded
        BodyRaw        []mbodyraw.ExampleBodyRaw
}

type ItemChannels struct {
        ApiExample     chan mitemapiexample.ItemApiExample
        Api            chan mitemapi.ItemApi
        Folder         chan mitemfolder.ItemFolder
        Header         chan []mexampleheader.Header
        Query          chan []mexamplequery.Query
        BodyForm       chan []mbodyform.BodyForm
        BodyUrlEncoded chan []mbodyurl.BodyURLEncoded
        BodyRaw        chan mbodyraw.ExampleBodyRaw
        Wg             *sync.WaitGroup
        Err            chan error
        Done           chan struct{}
}

func ConvertPostmanCollection(collection mpostmancollection.Collection, collectionID idwrap.IDWrap) (*ItemsPair, error) <span class="cov8" title="1">{
        pair := ItemsPair{
                Apis:    make([]mitemapi.ItemApi, 0, len(collection.Items)),
                Folders: make([]mitemfolder.ItemFolder, 0, len(collection.Items)),
                Headers: make([]mexampleheader.Header, 0, len(collection.Items)*2),
                Queries: make([]mexamplequery.Query, 0, len(collection.Items)*2),
        }

        var wg sync.WaitGroup
        ItemChannels := ItemChannels{
                ApiExample:     make(chan mitemapiexample.ItemApiExample),
                Api:            make(chan mitemapi.ItemApi),
                Folder:         make(chan mitemfolder.ItemFolder),
                Header:         make(chan []mexampleheader.Header),
                Query:          make(chan []mexamplequery.Query),
                BodyForm:       make(chan []mbodyform.BodyForm),
                BodyUrlEncoded: make(chan []mbodyurl.BodyURLEncoded),
                BodyRaw:        make(chan mbodyraw.ExampleBodyRaw),
                Wg:             &amp;wg,
                Done:           make(chan struct{}),
                Err:            make(chan error),
        }

        afterTime := time.After(2 * time.Minute)

        wg.Add(1)
        go GetRecursiveRoots(collection.Items, collectionID, &amp;ItemChannels)

        go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(ItemChannels.Done)
        }</span>()

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-afterTime:<span class="cov0" title="0">
                        return nil, errors.New("timeout")</span>
                case err := &lt;-ItemChannels.Err:<span class="cov0" title="0">
                        return nil, err</span>
                case folder := &lt;-ItemChannels.Folder:<span class="cov8" title="1">
                        pair.Folders = append(pair.Folders, folder)</span>
                case api := &lt;-ItemChannels.Api:<span class="cov8" title="1">
                        pair.Apis = append(pair.Apis, api)</span>
                case apiExample := &lt;-ItemChannels.ApiExample:<span class="cov8" title="1">
                        pair.ApiExamples = append(pair.ApiExamples, apiExample)</span>
                case header := &lt;-ItemChannels.Header:<span class="cov8" title="1">
                        pair.Headers = append(pair.Headers, header...)</span>
                case query := &lt;-ItemChannels.Query:<span class="cov8" title="1">
                        pair.Queries = append(pair.Queries, query...)</span>
                case bodyForm := &lt;-ItemChannels.BodyForm:<span class="cov8" title="1">
                        pair.BodyForm = append(pair.BodyForm, bodyForm...)</span>
                case bodyUrlEncoded := &lt;-ItemChannels.BodyUrlEncoded:<span class="cov8" title="1">
                        pair.BodyUrlEncoded = append(pair.BodyUrlEncoded, bodyUrlEncoded...)</span>
                case bodyRaw := &lt;-ItemChannels.BodyRaw:<span class="cov8" title="1">
                        pair.BodyRaw = append(pair.BodyRaw, bodyRaw)</span>
                case &lt;-ItemChannels.Done:<span class="cov8" title="1">
                        return &amp;pair, nil</span>
                }
        }
}

func GetRecursiveRoots(items []mitem.Items, collectionID idwrap.IDWrap, channels *ItemChannels) <span class="cov8" title="1">{
        go GetRecursiveFolders(items, nil, collectionID, channels)
}</span>

func GetRecursiveFolders(items []mitem.Items, parentID *idwrap.IDWrap, collectionID idwrap.IDWrap, channels *ItemChannels) <span class="cov8" title="1">{
        defer channels.Wg.Done()
        var folderPrev *mitemfolder.ItemFolder
        var folderArr []*mitemfolder.ItemFolder
        var apiArrRaw []*mitem.Items

        for _, item := range items </span><span class="cov8" title="1">{
                if item.Request == nil </span><span class="cov8" title="1">{
                        folder := &amp;mitemfolder.ItemFolder{
                                ID:           idwrap.NewNow(),
                                Name:         item.Name,
                                ParentID:     parentID,
                                CollectionID: collectionID,
                        }

                        if folderPrev != nil </span><span class="cov8" title="1">{
                                folderPrev.Next = &amp;folder.ID
                                folder.Prev = &amp;folder.ID
                        }</span>

                        <span class="cov8" title="1">folderPrev = folder
                        folderArr = append(folderArr, folderPrev)

                        channels.Wg.Add(1)
                        go GetRecursiveFolders(item.Items, &amp;folder.ID, collectionID, channels)</span>
                } else<span class="cov8" title="1"> {
                        apiArrRaw = append(apiArrRaw, &amp;item)
                }</span>
        }

        <span class="cov8" title="1">channels.Wg.Add(1)
        go GetRequest(apiArrRaw, parentID, collectionID, channels)
        SendAllToChannelPtr(folderArr, channels.Folder)</span>
}

func GetRequest(items []*mitem.Items, parentID *idwrap.IDWrap, collectionID idwrap.IDWrap, channels *ItemChannels) <span class="cov8" title="1">{
        defer channels.Wg.Done()

        var apiPrev *mitemapi.ItemApi
        var apiArr []*mitemapi.ItemApi
        for _, item := range items </span><span class="cov8" title="1">{
                if item.Request == nil </span><span class="cov0" title="0">{
                        channels.Err &lt;- errors.New("item is not an api")
                        return
                }</span>
                <span class="cov8" title="1">var URL *murl.URL
                var err error
                if item.Request.URL != nil </span><span class="cov8" title="1">{
                        URL, err = GetQueryParams(item.Request.URL)
                        if err != nil </span><span class="cov0" title="0">{
                                channels.Err &lt;- err
                                return
                        }</span>
                }
                <span class="cov8" title="1">ApiID := idwrap.NewNow()
                api := &amp;mitemapi.ItemApi{
                        ID:           ApiID,
                        CollectionID: collectionID,
                        FolderID:     parentID,
                        Name:         item.Name,
                        Url:          URL.Raw,
                        Method:       item.Request.Method,
                }

                if apiPrev != nil </span><span class="cov8" title="1">{
                        apiPrev.Next = &amp;api.ID
                        api.Prev = &amp;apiPrev.ID
                }</span>

                <span class="cov8" title="1">apiPrev = api
                apiArr = append(apiArr, apiPrev)

                channels.Wg.Add(1)
                go GetResponse(item.Responses, item.Request.Header, item.Request.Body, URL, ApiID, collectionID, channels)</span>
        }

        <span class="cov8" title="1">SendAllToChannelPtr(apiArr, channels.Api)</span>
}

func GetResponse(items []mresponse.Response, reqHeaders []mheader.Header, body *mbody.Body, urlData *murl.URL,
        apiUlid, collectionID idwrap.IDWrap, channels *ItemChannels,
) <span class="cov8" title="1">{
        defer channels.Wg.Done()
        var prevExample *mitemapiexample.ItemApiExample
        var examples []*mitemapiexample.ItemApiExample

        // Create a local copy of items to avoid race condition during concurrent appends
        localItems := make([]mresponse.Response, len(items))
        copy(localItems, items)

        var defaultExample *mresponse.Response
        if len(localItems) != 0 </span><span class="cov8" title="1">{
                ExampleLastDefault := localItems[len(localItems)-1]
                ExampleLastDefault.Name = "Default Example"
                defaultExample = &amp;ExampleLastDefault
        }</span> else<span class="cov8" title="1"> {
                emptyExample := mresponse.Response{
                        Name: "Empty Example",
                }
                defaultExample = &amp;emptyExample
        }</span>
        <span class="cov8" title="1">localItems = append(localItems, *defaultExample)

        for i, item := range localItems </span><span class="cov8" title="1">{
                isDefault := i == len(localItems)-1

                cookies := make(map[string]string)
                for _, v := range item.Cookies </span><span class="cov0" title="0">{
                        cookies[v.Name] = v.Value
                }</span>
                <span class="cov8" title="1">if item.Name == "" </span><span class="cov0" title="0">{
                        item.Name = "Untitled"
                }</span>

                <span class="cov8" title="1">apiExampleID := idwrap.NewNow()
                apiExample := mitemapiexample.ItemApiExample{
                        ID:           apiExampleID,
                        ItemApiID:    apiUlid,
                        CollectionID: collectionID,
                        Name:         item.Name,
                        IsDefault:    isDefault,
                        BodyType:     mitemapiexample.BodyTypeNone,
                }
                if body != nil </span><span class="cov8" title="1">{
                        apiExample.BodyType = BodyType(body.Mode)
                        channels.Wg.Add(1)
                        go GetBody(body, apiExampleID, collectionID, channels)
                }</span> else<span class="cov8" title="1"> {
                        apiExample.BodyType = mitemapiexample.BodyTypeRaw
                        bodyRaw := mbodyraw.ExampleBodyRaw{
                                ID:            idwrap.NewNow(),
                                ExampleID:     apiExampleID,
                                VisualizeMode: mbodyraw.VisualizeModeUndefined,
                                CompressType:  compress.CompressTypeNone,
                                Data:          []byte{},
                        }
                        channels.BodyRaw &lt;- bodyRaw
                }</span>
                <span class="cov8" title="1">if len(reqHeaders) &gt; 0 </span><span class="cov8" title="1">{
                        channels.Wg.Add(1)
                        go GetHeaders(reqHeaders, apiExampleID, collectionID, channels)
                }</span>
                <span class="cov8" title="1">if len(urlData.Query) &gt; 0 </span><span class="cov8" title="1">{
                        channels.Wg.Add(1)
                        go GetQueries(urlData.Query, apiExampleID, collectionID, channels)
                }</span>

                <span class="cov8" title="1">if prevExample != nil &amp;&amp; !isDefault </span><span class="cov8" title="1">{
                        prevExample.Next = &amp;apiExample.ID
                        apiExample.Prev = &amp;prevExample.ID
                }</span>

                <span class="cov8" title="1">prevExample = &amp;apiExample
                examples = append(examples, prevExample)</span>
        }

        <span class="cov8" title="1">SendAllToChannelPtr(examples, channels.ApiExample)</span>
}

func GetHeaders(headers []mheader.Header, exampleID, collectionID idwrap.IDWrap, channels *ItemChannels) <span class="cov8" title="1">{
        defer channels.Wg.Done()
        headerArr := make([]mexampleheader.Header, len(headers))
        for i, item := range headers </span><span class="cov8" title="1">{
                header := mexampleheader.Header{
                        ID:          idwrap.NewNow(),
                        ExampleID:   exampleID,
                        HeaderKey:   item.Key,
                        Enable:      !item.Disabled,
                        Description: item.Description,
                        Value:       item.Value,
                }
                headerArr[i] = header
                // TODO: add ordering
        }</span>
        <span class="cov8" title="1">channels.Header &lt;- headerArr</span>
}

func GetQueries(queries []murl.QueryParamter, exampleID, collectionID idwrap.IDWrap, channels *ItemChannels) <span class="cov8" title="1">{
        defer channels.Wg.Done()
        queryArr := make([]mexamplequery.Query, len(queries))
        for i, item := range queries </span><span class="cov8" title="1">{
                query := mexamplequery.Query{
                        ID:          idwrap.NewNow(),
                        ExampleID:   exampleID,
                        QueryKey:    item.Key,
                        Enable:      !item.Disabled,
                        Description: item.Description,
                        Value:       item.Value,
                }
                queryArr[i] = query
                // TODO: add ordering
        }</span>
        <span class="cov8" title="1">channels.Query &lt;- queryArr</span>
}

// returns RAW URL and GetQueryParams
func GetQueryParams(urlData interface{}) (*murl.URL, error) <span class="cov8" title="1">{
        var murlData murl.URL
        // TODO: put avarage size of query params
        switch urlType := urlData.(type) </span>{
        case string:<span class="cov8" title="1">
                url, err := url.Parse(urlData.(string))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">queryParamsArr := make([]murl.QueryParamter, 0)
                for k, vArr := range url.Query() </span><span class="cov0" title="0">{
                        for _, v := range vArr </span><span class="cov0" title="0">{
                                queryParamsArr = append(queryParamsArr, murl.QueryParamter{
                                        Key:         k,
                                        Value:       v,
                                        Disabled:    false,
                                        Description: "",
                                })
                        }</span>
                }
                <span class="cov8" title="1">url.RawQuery = ""
                murlData = murl.URL{
                        Protocol:  url.Scheme,
                        Host:      []string{url.Host},
                        Raw:       url.String(),
                        Port:      url.Port(),
                        Variables: []mvariable.Variable{},
                        Path:      strings.Split(url.Path, "/"),
                        Query:     queryParamsArr,
                        Hash:      url.Fragment,
                }</span>
        case murl.URL:<span class="cov8" title="1">
                murlData = urlData.(murl.URL)</span>
        case map[string]interface{}:<span class="cov0" title="0">
                urlDataNest := urlData.(map[string]interface{})
                // TODO: seems like ok can fail check later
                queryData, _ := urlDataNest["query"].([]interface{})

                queryParamsArr := make([]murl.QueryParamter, 0)

                raw, ok := urlDataNest["raw"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("raw %T not supported", raw)
                }</span>
                <span class="cov0" title="0">rawData, err := url.Parse(raw)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                        for k, vArr := range rawData.Query() </span><span class="cov0" title="0">{
                                for _, v := range vArr </span><span class="cov0" title="0">{
                                        queryParamsArr = append(queryParamsArr, murl.QueryParamter{
                                                Key:         k,
                                                Value:       v,
                                                Disabled:    false,
                                                Description: "",
                                        })
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        for _, query := range queryData </span><span class="cov0" title="0">{
                                queryMap := query.(map[string]interface{})
                                key, ok := queryMap["key"].(string)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("key %T not supported", key)
                                }</span>
                                <span class="cov0" title="0">value, ok := queryMap["value"].(string)
                                if !ok </span><span class="cov0" title="0">{
                                        value = ""
                                }</span>
                                <span class="cov0" title="0">disabled, ok := queryMap["disabled"].(bool)
                                if !ok </span><span class="cov0" title="0">{
                                        disabled = false
                                }</span>
                                <span class="cov0" title="0">description, ok := queryMap["description"].(string)
                                if !ok </span><span class="cov0" title="0">{
                                        description = ""
                                }</span>

                                <span class="cov0" title="0">queryParamsArr = append(queryParamsArr, murl.QueryParamter{
                                        Key:         key,
                                        Value:       value,
                                        Disabled:    disabled,
                                        Description: description,
                                })</span>
                        }
                }
                <span class="cov0" title="0">rawData.RawQuery = ""
                raw = rawData.String()

                protocol, ok := urlDataNest["protocol"].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("protocol %T not supported", protocol)
                }</span>
                <span class="cov0" title="0">hostInterface, ok := urlDataNest["host"].([]interface{})
                hosts := make([]string, len(hostInterface))
                for i, host := range hostInterface </span><span class="cov0" title="0">{
                        hosts[i] = host.(string)
                }</span>
                <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("host %T not supported", urlDataNest["host"])
                }</span>
                <span class="cov0" title="0">port, ok := urlDataNest["port"].(string)
                if !ok </span><span class="cov0" title="0">{
                        port = "443"
                }</span>
                <span class="cov0" title="0">variables, ok := urlDataNest["variables"].([]mvariable.Variable)
                if !ok </span><span class="cov0" title="0">{
                        variables = []mvariable.Variable{}
                }</span>
                <span class="cov0" title="0">hash, ok := urlDataNest["hash"].(string)
                if !ok </span><span class="cov0" title="0">{
                        hash = ""
                }</span>

                <span class="cov0" title="0">murlData = murl.URL{
                        Raw:       raw,
                        Protocol:  protocol,
                        Host:      hosts,
                        Port:      port,
                        Variables: variables,
                        Query:     queryParamsArr,
                        Hash:      hash,
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("url type %T not supported", urlType)</span>
        }
        <span class="cov8" title="1">return &amp;murlData, nil</span>
}

func GetBody(body *mbody.Body, exampleID, collectionID idwrap.IDWrap, channels *ItemChannels) <span class="cov8" title="1">{
        defer channels.Wg.Done()
        switch body.Mode </span>{
        case mbody.ModeFormData:<span class="cov8" title="1">
                formArr := make([]mbodyform.BodyForm, len(body.FormData))
                for i, v := range body.FormData </span><span class="cov8" title="1">{
                        formArr[i] = mbodyform.BodyForm{
                                ID:          idwrap.NewNow(),
                                ExampleID:   exampleID,
                                BodyKey:     v.Key,
                                Enable:      !v.Disabled,
                                Description: v.Description,
                                Value:       v.Value,
                        }
                }</span>
                <span class="cov8" title="1">channels.BodyForm &lt;- formArr</span>
        case mbody.ModeURLEncoded:<span class="cov8" title="1">
                encodedArr := make([]mbodyurl.BodyURLEncoded, len(body.URLEncoded))
                for i, v := range body.URLEncoded </span><span class="cov8" title="1">{
                        encodedArr[i] = mbodyurl.BodyURLEncoded{
                                ID:          idwrap.NewNow(),
                                ExampleID:   exampleID,
                                BodyKey:     v.Key,
                                Enable:      !v.Disabled,
                                Description: v.Description,
                                Value:       v.Value,
                        }
                }</span>
                <span class="cov8" title="1">channels.BodyUrlEncoded &lt;- encodedArr</span>
        case mbody.ModeRaw:<span class="cov8" title="1">
                rawBytes := []byte(body.Raw)
                bodyRaw := mbodyraw.ExampleBodyRaw{
                        ID:            idwrap.NewNow(),
                        ExampleID:     exampleID,
                        VisualizeMode: mbodyraw.VisualizeModeUndefined,
                }
                if len(rawBytes) &gt; zstdcompress.CompressThreshold </span><span class="cov0" title="0">{
                        bodyRaw.CompressType = compress.CompressTypeZstd
                        bodyRaw.Data = zstdcompress.Compress(rawBytes)
                        if len(bodyRaw.Data) &gt; len(rawBytes) </span><span class="cov0" title="0">{
                                bodyRaw.CompressType = compress.CompressTypeNone
                                bodyRaw.Data = rawBytes
                        }</span>
                } else<span class="cov8" title="1"> {
                        bodyRaw.CompressType = compress.CompressTypeNone
                        bodyRaw.Data = rawBytes
                }</span>

                <span class="cov8" title="1">channels.BodyRaw &lt;- bodyRaw
                return</span>
        default:<span class="cov0" title="0">
                channels.Err &lt;- errors.New("body mode not supported")</span>
        }
        <span class="cov8" title="1">rawDefault := mbodyraw.ExampleBodyRaw{
                ID:            idwrap.NewNow(),
                ExampleID:     exampleID,
                VisualizeMode: mbodyraw.VisualizeModeUndefined,
                CompressType:  compress.CompressTypeNone,
                Data:          []byte{},
        }
        channels.BodyRaw &lt;- rawDefault</span>
}

func RemoveItem[I any](slice []I, s int) []I <span class="cov0" title="0">{
        if s &gt;= len(slice) </span><span class="cov0" title="0">{
                return slice
        }</span>
        <span class="cov0" title="0">return append(slice[:s], slice[s+1:]...)</span>
}

func BodyType(bodyStr string) mitemapiexample.BodyType <span class="cov8" title="1">{
        switch bodyStr </span>{
        case mbody.ModeRaw:<span class="cov8" title="1">
                return mitemapiexample.BodyTypeRaw</span>
        case mbody.ModeFormData:<span class="cov8" title="1">
                return mitemapiexample.BodyTypeForm</span>
        case mbody.ModeURLEncoded:<span class="cov8" title="1">
                return mitemapiexample.BodyTypeUrlencoded</span>
        default:<span class="cov0" title="0">
                return mitemapiexample.BodyTypeNone</span>
        }
}
</pre>
		
		<pre class="file" id="file142" style="display: none">package tquery

import (
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mexamplequery"
        requestv1 "the-dev-tools/spec/dist/buf/go/collection/item/request/v1"
)

func SerializeQueryModelToRPC(query mexamplequery.Query) *requestv1.Query <span class="cov0" title="0">{
        return &amp;requestv1.Query{
                QueryId:     query.ID.Bytes(),
                Key:         query.QueryKey,
                Enabled:     query.Enable,
                Description: query.Description,
                Value:       query.Value,
        }
}</span>

func SerializeQueryModelToRPCItem(query mexamplequery.Query) *requestv1.QueryListItem <span class="cov0" title="0">{
        return &amp;requestv1.QueryListItem{
                QueryId:     query.ID.Bytes(),
                Key:         query.QueryKey,
                Enabled:     query.Enable,
                Description: query.Description,
                Value:       query.Value,
        }
}</span>

func SerlializeQueryRPCtoModel(query *requestv1.Query, exID idwrap.IDWrap) (mexamplequery.Query, error) <span class="cov0" title="0">{
        q, err := SerlializeQueryRPCtoModelNoID(query, exID)
        if err != nil </span><span class="cov0" title="0">{
                return mexamplequery.Query{}, err
        }</span>
        <span class="cov0" title="0">queryId, err := idwrap.NewFromBytes(query.GetQueryId())
        if err != nil </span><span class="cov0" title="0">{
                return mexamplequery.Query{}, err
        }</span>
        <span class="cov0" title="0">q.ID = queryId
        return q, nil</span>
}

func SerlializeQueryRPCtoModelNoID(query *requestv1.Query, exID idwrap.IDWrap) (mexamplequery.Query, error) <span class="cov0" title="0">{
        var parentDeltaIDPtr *idwrap.IDWrap

        return mexamplequery.Query{
                QueryKey:      query.GetKey(),
                ExampleID:     exID,
                Enable:        query.GetEnabled(),
                Description:   query.GetDescription(),
                DeltaParentID: parentDeltaIDPtr,
                Value:         query.GetValue(),
        }, nil
}</span>

func SerlializeQueryRPCtoModelNoIDForDelta(query *requestv1.Query, exID idwrap.IDWrap) (mexamplequery.Query, error) <span class="cov0" title="0">{
        var parentDeltaIDPtr *idwrap.IDWrap

        return mexamplequery.Query{
                QueryKey:      query.GetKey(),
                ExampleID:     exID,
                Enable:        query.GetEnabled(),
                Description:   query.GetDescription(),
                DeltaParentID: parentDeltaIDPtr,
                Value:         query.GetValue(),
        }, nil
}</span>

func SerializeQueryModelToRPCDeltaItem(query mexamplequery.Query) *requestv1.QueryDeltaListItem <span class="cov0" title="0">{
        return &amp;requestv1.QueryDeltaListItem{
                QueryId:     query.ID.Bytes(),
                Key:         query.QueryKey,
                Enabled:     query.Enable,
                Description: query.Description,
                Value:       query.Value,
        }
}</span>
</pre>
		
		<pre class="file" id="file143" style="display: none">package ttag

import (
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mtag"
        tagv1 "the-dev-tools/spec/dist/buf/go/tag/v1"
)

func SeralizeModelToRPCItem(e mtag.Tag) *tagv1.TagListItem <span class="cov0" title="0">{
        return &amp;tagv1.TagListItem{
                TagId: e.ID.Bytes(),
                Name:  e.Name,
                Color: tagv1.TagColor(e.Color),
        }
}</span>

func SeralizeModelToRPC(e mtag.Tag) *tagv1.Tag <span class="cov0" title="0">{
        return &amp;tagv1.Tag{
                TagId: e.ID.Bytes(),
                Name:  e.Name,
                Color: tagv1.TagColor(e.Color),
        }
}</span>

func SeralizeRpcToModel(e *tagv1.Tag, workspaceID idwrap.IDWrap) (*mtag.Tag, error) <span class="cov0" title="0">{
        flow := SeralizeRpcToModelWithoutID(e, workspaceID)
        id, err := idwrap.NewFromBytes(e.GetTagId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">flow.ID = id
        return flow, nil</span>
}

func SeralizeRpcToModelWithoutID(e *tagv1.Tag, workspaceID idwrap.IDWrap) *mtag.Tag <span class="cov0" title="0">{
        return &amp;mtag.Tag{
                Name:        e.Name,
                Color:       uint8(e.Color),
                WorkspaceID: workspaceID,
        }
}</span>
</pre>
		
		<pre class="file" id="file144" style="display: none">package tvar

import (
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/mvar"
        variablev1 "the-dev-tools/spec/dist/buf/go/variable/v1"
)

func SerializeModelToRPC(v mvar.Var) *variablev1.Variable <span class="cov0" title="0">{
        return &amp;variablev1.Variable{
                VariableId:  v.ID.Bytes(),
                Name:        v.VarKey,
                Value:       v.Value,
                Enabled:     v.Enabled,
                Description: v.Description,
        }
}</span>

func SerializeModelToRPCItem(v mvar.Var) *variablev1.VariableListItem <span class="cov0" title="0">{
        return &amp;variablev1.VariableListItem{
                VariableId:  v.ID.Bytes(),
                Name:        v.VarKey,
                Value:       v.Value,
                Enabled:     v.Enabled,
                Description: v.Description,
        }
}</span>

func DeserializeRPCToModel(v *variablev1.Variable) (mvar.Var, error) <span class="cov0" title="0">{
        id, err := idwrap.NewFromBytes(v.VariableId)
        if err != nil </span><span class="cov0" title="0">{
                return mvar.Var{}, err
        }</span>

        <span class="cov0" title="0">return mvar.Var{
                ID:          id,
                VarKey:      v.Name,
                Value:       v.Value,
                Enabled:     v.Enabled,
                Description: v.Description,
        }, nil</span>
}

func DeserializeRPCToModelWithID(id, envID idwrap.IDWrap, v *variablev1.Variable) mvar.Var <span class="cov0" title="0">{
        return mvar.Var{
                ID:          id,
                VarKey:      v.Name,
                EnvID:       envID,
                Value:       v.Value,
                Enabled:     v.Enabled,
                Description: v.Description,
        }
}</span>
</pre>
		
		<pre class="file" id="file145" style="display: none">package tworkspace

import (
        "the-dev-tools/server/pkg/idwrap"
        "the-dev-tools/server/pkg/model/menv"
        "the-dev-tools/server/pkg/model/mworkspace"
        workspacev1 "the-dev-tools/spec/dist/buf/go/workspace/v1"

        "google.golang.org/protobuf/types/known/timestamppb"
)

func SeralizeWorkspace(ws mworkspace.Workspace, env *menv.Env) *workspacev1.Workspace <span class="cov0" title="0">{
        var selectedEnvID []byte = nil
        if env != nil </span><span class="cov0" title="0">{
                selectedEnvID = env.ID.Bytes()
        }</span>

        <span class="cov0" title="0">return &amp;workspacev1.Workspace{
                WorkspaceId:           ws.ID.Bytes(),
                Name:                  ws.Name,
                Updated:               timestamppb.New(ws.Updated),
                SelectedEnvironmentId: selectedEnvID,
                CollectionCount:       ws.CollectionCount,
                FlowCount:             ws.FlowCount,
        }</span>
}

func SeralizeWorkspaceItem(ws mworkspace.Workspace, env *menv.Env) *workspacev1.WorkspaceListItem <span class="cov0" title="0">{
        var selectedEnvID []byte = nil
        if env != nil </span><span class="cov0" title="0">{
                selectedEnvID = env.ID.Bytes()
        }</span>

        <span class="cov0" title="0">return &amp;workspacev1.WorkspaceListItem{
                WorkspaceId:           ws.ID.Bytes(),
                SelectedEnvironmentId: selectedEnvID,
                Name:                  ws.Name,
                Updated:               timestamppb.New(ws.Updated),
                CollectionCount:       ws.CollectionCount,
                FlowCount:             ws.FlowCount,
        }</span>
}

func DeserializeWorkspace(ws *workspacev1.Workspace) (mworkspace.Workspace, error) <span class="cov0" title="0">{
        id, err := idwrap.NewFromBytes(ws.WorkspaceId)
        if err != nil </span><span class="cov0" title="0">{
                return mworkspace.Workspace{}, err
        }</span>

        <span class="cov0" title="0">return mworkspace.Workspace{
                ID:      id,
                Name:    ws.Name,
                Updated: ws.Updated.AsTime(),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file146" style="display: none">package varsystem

import (
        "fmt"
        "maps"
        "os"
        "reflect"
        "strings"
        "the-dev-tools/server/pkg/model/mvar"
        "the-dev-tools/server/pkg/translate/tgeneric"
)

var (
        ErrKeyNotFound = fmt.Errorf("key not found")
        ErrInvalidKey  = fmt.Errorf("invalid key")
)

type VarMap map[string]mvar.Var

func NewVarMap(vars []mvar.Var) VarMap <span class="cov8" title="1">{
        varMap := make(VarMap)
        for _, v := range vars </span><span class="cov8" title="1">{
                varMap[v.VarKey] = v
        }</span>
        <span class="cov8" title="1">return varMap</span>
}

func NewVarMapWithPrefix(vars []mvar.Var, prefix string) VarMap <span class="cov0" title="0">{
        varMap := make(VarMap)
        for _, v := range vars </span><span class="cov0" title="0">{
                varMap[prefix+v.VarKey] = v
        }</span>
        <span class="cov0" title="0">return varMap</span>
}

func NewVarMapFromAnyMap(anyMap map[string]any) VarMap <span class="cov8" title="1">{
        vars := make([]mvar.Var, 0)
        for k, v := range anyMap </span><span class="cov8" title="1">{
                HelperNewAny(&amp;vars, v, k)
        }</span>
        <span class="cov8" title="1">return NewVarMap(vars)</span>
}

// MergeVarMap merges two var maps
// it creates a new var map and does not modify the original var maps
func MergeVarMap(varMap1, varMap2 VarMap) VarMap <span class="cov0" title="0">{

        varMap := make(VarMap)
        maps.Copy(varMap, varMap1)
        maps.Copy(varMap, varMap2)

        return varMap
}</span>

// should convert
// map[string]any{"something": map[string]any{"something": 1}} -&gt; key: "something.something", value: 1
// []int{1} -&gt; key: "1", value: 1

func HelperNewAny(vars *[]mvar.Var, target any, prefix string) <span class="cov8" title="1">{
        prefix = strings.TrimSpace(prefix)
        if target == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">reflectType := reflect.TypeOf(target)
        switch reflectType.Kind() </span>{
        case reflect.Map:<span class="cov8" title="1">
                val := reflect.ValueOf(target)
                if val.Kind() == reflect.Map </span><span class="cov8" title="1">{
                        for _, key := range val.MapKeys() </span><span class="cov8" title="1">{
                                // Convert key to string for the variable name
                                keyStr := fmt.Sprintf("%v", key.Interface())
                                value := val.MapIndex(key).Interface()
                                HelperNewAny(vars, value, prefix+"."+keyStr)
                        }</span>
                }
        case reflect.Slice:<span class="cov8" title="1">
                val := reflect.ValueOf(target)
                if val.Kind() == reflect.Slice </span><span class="cov8" title="1">{
                        for i := 0; i &lt; val.Len(); i++ </span><span class="cov8" title="1">{
                                HelperNewAny(vars, val.Index(i).Interface(), fmt.Sprintf("%s[%d]", prefix, i))
                        }</span>
                }
        case reflect.Int, reflect.Int32, reflect.Int64, reflect.Float32, reflect.Float64, reflect.Bool:<span class="cov8" title="1">
                *vars = append(*vars, mvar.Var{
                        VarKey: prefix,
                        Value:  fmt.Sprintf("%v", target),
                })</span>
        case reflect.String:<span class="cov8" title="1">
                *vars = append(*vars, mvar.Var{
                        VarKey: prefix,
                        Value:  target.(string),
                })</span>
        }
}

func (vm VarMap) ToSlice() []mvar.Var <span class="cov0" title="0">{
        return tgeneric.MapToSlice(vm)
}</span>

func (vm VarMap) Get(varKey string) (mvar.Var, bool) <span class="cov8" title="1">{
        varKey = strings.TrimSpace(varKey)

        // Check if this is a file reference
        if IsFileReference(varKey) </span><span class="cov0" title="0">{
                fileContent, err := ReadFileContentAsString(varKey)
                if err != nil </span><span class="cov0" title="0">{
                        return mvar.Var{}, false
                }</span>
                <span class="cov0" title="0">return mvar.Var{
                        VarKey: varKey,
                        Value:  fileContent,
                }, true</span>
        }

        <span class="cov8" title="1">val, ok := vm[varKey]
        if !ok </span><span class="cov8" title="1">{
                return mvar.Var{}, false
        }</span>
        <span class="cov8" title="1">return val, true</span>
}

// Helper functions
func MergeVars(global, current []mvar.Var) []mvar.Var <span class="cov8" title="1">{
        globalMap := make(map[string]mvar.Var, len(global))
        for _, globalVar := range global </span><span class="cov8" title="1">{
                globalMap[globalVar.VarKey] = globalVar
        }</span>

        <span class="cov8" title="1">for _, currentVar := range current </span><span class="cov8" title="1">{
                globalMap[currentVar.VarKey] = currentVar
        }</span>

        <span class="cov8" title="1">return tgeneric.MapToSlice(globalMap)</span>
}

func FilterVars(vars []mvar.Var, filter func(mvar.Var) bool) []mvar.Var <span class="cov0" title="0">{
        filtered := make([]mvar.Var, 0, len(vars))
        for _, v := range vars </span><span class="cov0" title="0">{
                if filter(v) </span><span class="cov0" title="0">{
                        filtered = append(filtered, v)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

// {{varKey}}
func GetVarKeyFromRaw(raw string) string <span class="cov8" title="1">{
        return raw[mvar.PrefixSize : len(raw)-mvar.SuffixSize]
}</span>

func CheckIsVar(varKey string) bool <span class="cov8" title="1">{
        varKey = strings.TrimSpace(varKey)
        varKey = strings.ToLower(varKey)
        return CheckPrefix(varKey) &amp;&amp; CheckSuffix(varKey)
}</span>

func CheckPrefix(varKey string) bool <span class="cov8" title="1">{
        return len(varKey) &gt;= mvar.PrefixSize &amp;&amp; varKey[:mvar.PrefixSize] == mvar.Prefix
}</span>

func CheckSuffix(varKey string) bool <span class="cov8" title="1">{
        return len(varKey) &gt;= mvar.SuffixSize &amp;&amp; varKey[len(varKey)-mvar.SuffixSize:] == mvar.Suffix
}</span>

func CheckStringHasAnyVarKey(raw string) bool <span class="cov0" title="0">{
        return strings.Contains(raw, mvar.Prefix) &amp;&amp; strings.Contains(raw, mvar.Suffix)
}</span>

// IsFileReference checks if a variable key refers to a file (starts with "file:")
func IsFileReference(key string) bool <span class="cov8" title="1">{
        return strings.HasPrefix(strings.TrimSpace(key), "#file:")
}</span>

// VarMapTracker wraps a VarMap and tracks variable reads
type VarMapTracker struct {
        VarMap   VarMap
        ReadVars map[string]string // stores variable key -&gt; resolved value
}

// NewVarMapTracker creates a new tracking wrapper around a VarMap
func NewVarMapTracker(varMap VarMap) *VarMapTracker <span class="cov8" title="1">{
        return &amp;VarMapTracker{
                VarMap:   varMap,
                ReadVars: make(map[string]string),
        }
}</span>

// Get tracks variable access and delegates to the underlying VarMap
func (vmt *VarMapTracker) Get(varKey string) (mvar.Var, bool) <span class="cov8" title="1">{
        val, ok := vmt.VarMap.Get(varKey)
        if ok </span><span class="cov8" title="1">{
                // Track this variable read
                vmt.ReadVars[varKey] = val.Value
        }</span>
        <span class="cov8" title="1">return val, ok</span>
}

// ReplaceVars tracks all variable reads during replacement and delegates to underlying VarMap
func (vmt *VarMapTracker) ReplaceVars(raw string) (string, error) <span class="cov8" title="1">{
        var result string
        for </span><span class="cov8" title="1">{
                startIndex := strings.Index(raw, mvar.Prefix)
                if startIndex == -1 </span><span class="cov8" title="1">{
                        result += raw
                        break</span>
                }

                <span class="cov8" title="1">endIndex := strings.Index(raw[startIndex:], mvar.Suffix)
                if endIndex == -1 </span><span class="cov0" title="0">{
                        return "", ErrInvalidKey
                }</span>

                <span class="cov8" title="1">rawVar := raw[startIndex : startIndex+endIndex+mvar.SuffixSize]
                if !CheckIsVar(rawVar) </span><span class="cov0" title="0">{
                        return "", ErrInvalidKey
                }</span>

                // Check if key is present in the map
                <span class="cov8" title="1">key := GetVarKeyFromRaw(rawVar)

                // Check if this is a file reference
                if IsFileReference(key) </span><span class="cov0" title="0">{
                        fileContent, err := ReadFileContentAsString(key)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        // Track file reference read
                        <span class="cov0" title="0">vmt.ReadVars[key] = fileContent
                        result += raw[:startIndex] + fileContent</span>
                } else<span class="cov8" title="1"> {
                        val, ok := vmt.VarMap.Get(key)
                        if !ok </span><span class="cov8" title="1">{
                                return "", fmt.Errorf("%s %v", key, ErrKeyNotFound)
                        }</span>
                        // Track variable read
                        <span class="cov8" title="1">vmt.ReadVars[key] = val.Value
                        result += raw[:startIndex] + val.Value</span>
                }

                <span class="cov8" title="1">raw = raw[startIndex+len(rawVar):]</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// GetReadVars returns a copy of all tracked variable reads
func (vmt *VarMapTracker) GetReadVars() map[string]string <span class="cov8" title="1">{
        result := make(map[string]string, len(vmt.ReadVars))
        for k, v := range vmt.ReadVars </span><span class="cov8" title="1">{
                result[k] = v
        }</span>
        <span class="cov8" title="1">return result</span>
}

// ReadFileContentAsString reads the content of a file at the given path
func ReadFileContentAsString(filePath string) (string, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(strings.TrimPrefix(strings.TrimSpace(filePath), "#file:"))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read file: %w", err)
        }</span>
        <span class="cov8" title="1">return string(data), nil</span>
}

func GetIsFileReferencePath(filePath string) string <span class="cov0" title="0">{
        path := strings.TrimPrefix(strings.TrimSpace(filePath), "#file:")
        return path
}</span>

// Get {{ url }}/api/{{ version }}/path or {{url}}/api/{{version}}/path
// returns google.com/api/v1/path
func (vm VarMap) ReplaceVars(raw string) (string, error) <span class="cov8" title="1">{

        var result string
        for </span><span class="cov8" title="1">{
                startIndex := strings.Index(raw, mvar.Prefix)
                if startIndex == -1 </span><span class="cov8" title="1">{
                        result += raw
                        break</span>
                }

                <span class="cov8" title="1">endIndex := strings.Index(raw[startIndex:], mvar.Suffix)
                if endIndex == -1 </span><span class="cov0" title="0">{
                        return "", ErrInvalidKey
                }</span>

                <span class="cov8" title="1">rawVar := raw[startIndex : startIndex+endIndex+mvar.SuffixSize]
                if !CheckIsVar(rawVar) </span><span class="cov0" title="0">{
                        return "", ErrInvalidKey
                }</span>

                // Check if key is present in the map
                <span class="cov8" title="1">key := GetVarKeyFromRaw(rawVar)

                // Check if this is a file reference
                if IsFileReference(key) </span><span class="cov8" title="1">{
                        fileContent, err := ReadFileContentAsString(key)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">result += raw[:startIndex] + fileContent</span>
                } else<span class="cov8" title="1"> {
                        val, ok := vm.Get(key)
                        if !ok </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("%s %v", key, ErrKeyNotFound)
                        }</span>
                        <span class="cov8" title="1">result += raw[:startIndex] + val.Value</span>
                }

                <span class="cov8" title="1">raw = raw[startIndex+len(rawVar):]</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file147" style="display: none">package zstdcompress

import (
        "io"

        "connectrpc.com/connect"
        "github.com/klauspost/compress/zstd"
)

const CompressThreshold = 1024

type errorDecompressor struct {
        err error
}

func (c *errorDecompressor) Read(_ []byte) (int, error) <span class="cov0" title="0">{
        return 0, c.err
}</span>

func (c *errorDecompressor) Reset(_ io.Reader) error <span class="cov0" title="0">{
        return c.err
}</span>

func (c *errorDecompressor) Close() error <span class="cov0" title="0">{
        return c.err
}</span>

type errorCompressor struct {
        err error
}

func (c *errorCompressor) Write(_ []byte) (int, error) <span class="cov0" title="0">{
        return 0, c.err
}</span>

func (c *errorCompressor) Reset(_ io.Writer) {<span class="cov0" title="0">}</span>

func (c *errorCompressor) Close() error <span class="cov0" title="0">{
        return c.err
}</span>

type zstdDecompressor struct {
        decoder *zstd.Decoder
}

func (c *zstdDecompressor) Read(bytes []byte) (int, error) <span class="cov0" title="0">{
        if c.decoder == nil </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>
        <span class="cov0" title="0">return c.decoder.Read(bytes)</span>
}

func (c *zstdDecompressor) Reset(rdr io.Reader) error <span class="cov0" title="0">{
        if c.decoder == nil </span><span class="cov0" title="0">{
                var err error
                c.decoder, err = zstd.NewReader(rdr)
                return err
        }</span>
        <span class="cov0" title="0">return c.decoder.Reset(rdr)</span>
}

func (c *zstdDecompressor) Close() error <span class="cov0" title="0">{
        if c.decoder == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">c.decoder.Close()
        c.decoder = nil
        return nil</span>
}

func NewZstdDecompressor() connect.Decompressor <span class="cov0" title="0">{
        d, err := zstd.NewReader(nil)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;errorDecompressor{err: err}
        }</span>
        <span class="cov0" title="0">return &amp;zstdDecompressor{
                decoder: d,
        }</span>
}

func NewZstdCompressor() connect.Compressor <span class="cov0" title="0">{
        w, err := zstd.NewWriter(nil)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;errorCompressor{err: err}
        }</span>
        <span class="cov0" title="0">return w</span>
}

var encoder, _ = zstd.NewWriter(nil)

// Compress a buffer.
// If you have a destination buffer, the allocation in the call can also be eliminated.
func Compress(src []byte) []byte <span class="cov8" title="1">{
        return encoder.EncodeAll(src, make([]byte, 0, len(src)))
}</span>

var decoder, _ = zstd.NewReader(nil)

func Decompress(src []byte) ([]byte, error) <span class="cov8" title="1">{
        return decoder.DecodeAll(src, nil)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
