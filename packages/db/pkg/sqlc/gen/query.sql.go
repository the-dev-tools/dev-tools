// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package gen

import (
	"context"
	"database/sql"
	"strings"
	"time"

	idwrap "the-dev-tools/server/pkg/idwrap"
)

const checkIFWorkspaceUserExists = `-- name: CheckIFWorkspaceUserExists :one
SELECT
  cast(
  EXISTS (
    SELECT
      1
    FROM
      workspaces_users
    WHERE
      workspace_id = ?
      AND user_id = ?
    LIMIT
      1
) AS boolean
)
`

type CheckIFWorkspaceUserExistsParams struct {
	WorkspaceID idwrap.IDWrap
	UserID      idwrap.IDWrap
}

// WorkspaceUsers
func (q *Queries) CheckIFWorkspaceUserExists(ctx context.Context, arg CheckIFWorkspaceUserExistsParams) (bool, error) {
	row := q.queryRow(ctx, q.checkIFWorkspaceUserExistsStmt, checkIFWorkspaceUserExists, arg.WorkspaceID, arg.UserID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const createAssert = `-- name: CreateAssert :exec
INSERT INTO
  assertion (id, example_id, delta_parent_id, expression, enable, prev, next)
VALUES
  (?, ?, ?, ?, ?, ?, ?)
`

type CreateAssertParams struct {
	ID            idwrap.IDWrap
	ExampleID     idwrap.IDWrap
	DeltaParentID *idwrap.IDWrap
	Expression    string
	Enable        bool
	Prev          *idwrap.IDWrap
	Next          *idwrap.IDWrap
}

func (q *Queries) CreateAssert(ctx context.Context, arg CreateAssertParams) error {
	_, err := q.exec(ctx, q.createAssertStmt, createAssert,
		arg.ID,
		arg.ExampleID,
		arg.DeltaParentID,
		arg.Expression,
		arg.Enable,
		arg.Prev,
		arg.Next,
	)
	return err
}

const createAssertBulk = `-- name: CreateAssertBulk :exec
INSERT INTO
  assertion_result (id, response_id, assertion_id, result)
VALUES
  (?, ?, ?, ?),
  (?, ?, ?, ?),
  (?, ?, ?, ?),
  (?, ?, ?, ?),
  (?, ?, ?, ?)
`

type CreateAssertBulkParams struct {
	ID            idwrap.IDWrap
	ResponseID    idwrap.IDWrap
	AssertionID   idwrap.IDWrap
	Result        bool
	ID_2          idwrap.IDWrap
	ResponseID_2  idwrap.IDWrap
	AssertionID_2 idwrap.IDWrap
	Result_2      bool
	ID_3          idwrap.IDWrap
	ResponseID_3  idwrap.IDWrap
	AssertionID_3 idwrap.IDWrap
	Result_3      bool
	ID_4          idwrap.IDWrap
	ResponseID_4  idwrap.IDWrap
	AssertionID_4 idwrap.IDWrap
	Result_4      bool
	ID_5          idwrap.IDWrap
	ResponseID_5  idwrap.IDWrap
	AssertionID_5 idwrap.IDWrap
	Result_5      bool
}

func (q *Queries) CreateAssertBulk(ctx context.Context, arg CreateAssertBulkParams) error {
	_, err := q.exec(ctx, q.createAssertBulkStmt, createAssertBulk,
		arg.ID,
		arg.ResponseID,
		arg.AssertionID,
		arg.Result,
		arg.ID_2,
		arg.ResponseID_2,
		arg.AssertionID_2,
		arg.Result_2,
		arg.ID_3,
		arg.ResponseID_3,
		arg.AssertionID_3,
		arg.Result_3,
		arg.ID_4,
		arg.ResponseID_4,
		arg.AssertionID_4,
		arg.Result_4,
		arg.ID_5,
		arg.ResponseID_5,
		arg.AssertionID_5,
		arg.Result_5,
	)
	return err
}

const createAssertResult = `-- name: CreateAssertResult :exec
INSERT INTO
  assertion_result (id, response_id, assertion_id, result)
VALUES
  (?, ?, ?, ?)
`

type CreateAssertResultParams struct {
	ID          idwrap.IDWrap
	ResponseID  idwrap.IDWrap
	AssertionID idwrap.IDWrap
	Result      bool
}

func (q *Queries) CreateAssertResult(ctx context.Context, arg CreateAssertResultParams) error {
	_, err := q.exec(ctx, q.createAssertResultStmt, createAssertResult,
		arg.ID,
		arg.ResponseID,
		arg.AssertionID,
		arg.Result,
	)
	return err
}

const createBodyForm = `-- name: CreateBodyForm :exec

INSERT INTO
  example_body_form (id, example_id, delta_parent_id, body_key, enable, description, value)
VALUES
  (?, ?, ?, ?, ?, ?, ?)
`

type CreateBodyFormParams struct {
	ID            idwrap.IDWrap
	ExampleID     idwrap.IDWrap
	DeltaParentID *idwrap.IDWrap
	BodyKey       string
	Enable        bool
	Description   string
	Value         string
}

// BodyForm
func (q *Queries) CreateBodyForm(ctx context.Context, arg CreateBodyFormParams) error {
	_, err := q.exec(ctx, q.createBodyFormStmt, createBodyForm,
		arg.ID,
		arg.ExampleID,
		arg.DeltaParentID,
		arg.BodyKey,
		arg.Enable,
		arg.Description,
		arg.Value,
	)
	return err
}

const createBodyFormBulk = `-- name: CreateBodyFormBulk :exec
INSERT INTO
  example_body_form (id, example_id, delta_parent_id, body_key, enable, description, value)
VALUES
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?)
`

type CreateBodyFormBulkParams struct {
	ID               idwrap.IDWrap
	ExampleID        idwrap.IDWrap
	DeltaParentID    *idwrap.IDWrap
	BodyKey          string
	Enable           bool
	Description      string
	Value            string
	ID_2             idwrap.IDWrap
	ExampleID_2      idwrap.IDWrap
	DeltaParentID_2  *idwrap.IDWrap
	BodyKey_2        string
	Enable_2         bool
	Description_2    string
	Value_2          string
	ID_3             idwrap.IDWrap
	ExampleID_3      idwrap.IDWrap
	DeltaParentID_3  *idwrap.IDWrap
	BodyKey_3        string
	Enable_3         bool
	Description_3    string
	Value_3          string
	ID_4             idwrap.IDWrap
	ExampleID_4      idwrap.IDWrap
	DeltaParentID_4  *idwrap.IDWrap
	BodyKey_4        string
	Enable_4         bool
	Description_4    string
	Value_4          string
	ID_5             idwrap.IDWrap
	ExampleID_5      idwrap.IDWrap
	DeltaParentID_5  *idwrap.IDWrap
	BodyKey_5        string
	Enable_5         bool
	Description_5    string
	Value_5          string
	ID_6             idwrap.IDWrap
	ExampleID_6      idwrap.IDWrap
	DeltaParentID_6  *idwrap.IDWrap
	BodyKey_6        string
	Enable_6         bool
	Description_6    string
	Value_6          string
	ID_7             idwrap.IDWrap
	ExampleID_7      idwrap.IDWrap
	DeltaParentID_7  *idwrap.IDWrap
	BodyKey_7        string
	Enable_7         bool
	Description_7    string
	Value_7          string
	ID_8             idwrap.IDWrap
	ExampleID_8      idwrap.IDWrap
	DeltaParentID_8  *idwrap.IDWrap
	BodyKey_8        string
	Enable_8         bool
	Description_8    string
	Value_8          string
	ID_9             idwrap.IDWrap
	ExampleID_9      idwrap.IDWrap
	DeltaParentID_9  *idwrap.IDWrap
	BodyKey_9        string
	Enable_9         bool
	Description_9    string
	Value_9          string
	ID_10            idwrap.IDWrap
	ExampleID_10     idwrap.IDWrap
	DeltaParentID_10 *idwrap.IDWrap
	BodyKey_10       string
	Enable_10        bool
	Description_10   string
	Value_10         string
}

func (q *Queries) CreateBodyFormBulk(ctx context.Context, arg CreateBodyFormBulkParams) error {
	_, err := q.exec(ctx, q.createBodyFormBulkStmt, createBodyFormBulk,
		arg.ID,
		arg.ExampleID,
		arg.DeltaParentID,
		arg.BodyKey,
		arg.Enable,
		arg.Description,
		arg.Value,
		arg.ID_2,
		arg.ExampleID_2,
		arg.DeltaParentID_2,
		arg.BodyKey_2,
		arg.Enable_2,
		arg.Description_2,
		arg.Value_2,
		arg.ID_3,
		arg.ExampleID_3,
		arg.DeltaParentID_3,
		arg.BodyKey_3,
		arg.Enable_3,
		arg.Description_3,
		arg.Value_3,
		arg.ID_4,
		arg.ExampleID_4,
		arg.DeltaParentID_4,
		arg.BodyKey_4,
		arg.Enable_4,
		arg.Description_4,
		arg.Value_4,
		arg.ID_5,
		arg.ExampleID_5,
		arg.DeltaParentID_5,
		arg.BodyKey_5,
		arg.Enable_5,
		arg.Description_5,
		arg.Value_5,
		arg.ID_6,
		arg.ExampleID_6,
		arg.DeltaParentID_6,
		arg.BodyKey_6,
		arg.Enable_6,
		arg.Description_6,
		arg.Value_6,
		arg.ID_7,
		arg.ExampleID_7,
		arg.DeltaParentID_7,
		arg.BodyKey_7,
		arg.Enable_7,
		arg.Description_7,
		arg.Value_7,
		arg.ID_8,
		arg.ExampleID_8,
		arg.DeltaParentID_8,
		arg.BodyKey_8,
		arg.Enable_8,
		arg.Description_8,
		arg.Value_8,
		arg.ID_9,
		arg.ExampleID_9,
		arg.DeltaParentID_9,
		arg.BodyKey_9,
		arg.Enable_9,
		arg.Description_9,
		arg.Value_9,
		arg.ID_10,
		arg.ExampleID_10,
		arg.DeltaParentID_10,
		arg.BodyKey_10,
		arg.Enable_10,
		arg.Description_10,
		arg.Value_10,
	)
	return err
}

const createBodyRaw = `-- name: CreateBodyRaw :exec
INSERT INTO
  example_body_raw (id, example_id, visualize_mode, compress_type, data)
VALUES
  (?, ?, ?, ?, ?)
`

type CreateBodyRawParams struct {
	ID            idwrap.IDWrap
	ExampleID     idwrap.IDWrap
	VisualizeMode int8
	CompressType  int8
	Data          []byte
}

func (q *Queries) CreateBodyRaw(ctx context.Context, arg CreateBodyRawParams) error {
	_, err := q.exec(ctx, q.createBodyRawStmt, createBodyRaw,
		arg.ID,
		arg.ExampleID,
		arg.VisualizeMode,
		arg.CompressType,
		arg.Data,
	)
	return err
}

const createBodyRawBulk = `-- name: CreateBodyRawBulk :exec
INSERT INTO
  example_body_raw (id, example_id, visualize_mode, compress_type, data)
VALUES
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?)
`

type CreateBodyRawBulkParams struct {
	ID              idwrap.IDWrap
	ExampleID       idwrap.IDWrap
	VisualizeMode   int8
	CompressType    int8
	Data            []byte
	ID_2            idwrap.IDWrap
	ExampleID_2     idwrap.IDWrap
	VisualizeMode_2 int8
	CompressType_2  int8
	Data_2          []byte
	ID_3            idwrap.IDWrap
	ExampleID_3     idwrap.IDWrap
	VisualizeMode_3 int8
	CompressType_3  int8
	Data_3          []byte
	ID_4            idwrap.IDWrap
	ExampleID_4     idwrap.IDWrap
	VisualizeMode_4 int8
	CompressType_4  int8
	Data_4          []byte
	ID_5            idwrap.IDWrap
	ExampleID_5     idwrap.IDWrap
	VisualizeMode_5 int8
	CompressType_5  int8
	Data_5          []byte
}

func (q *Queries) CreateBodyRawBulk(ctx context.Context, arg CreateBodyRawBulkParams) error {
	_, err := q.exec(ctx, q.createBodyRawBulkStmt, createBodyRawBulk,
		arg.ID,
		arg.ExampleID,
		arg.VisualizeMode,
		arg.CompressType,
		arg.Data,
		arg.ID_2,
		arg.ExampleID_2,
		arg.VisualizeMode_2,
		arg.CompressType_2,
		arg.Data_2,
		arg.ID_3,
		arg.ExampleID_3,
		arg.VisualizeMode_3,
		arg.CompressType_3,
		arg.Data_3,
		arg.ID_4,
		arg.ExampleID_4,
		arg.VisualizeMode_4,
		arg.CompressType_4,
		arg.Data_4,
		arg.ID_5,
		arg.ExampleID_5,
		arg.VisualizeMode_5,
		arg.CompressType_5,
		arg.Data_5,
	)
	return err
}

const createBodyUrlEncoded = `-- name: CreateBodyUrlEncoded :exec
INSERT INTO
  example_body_urlencoded (id, example_id, delta_parent_id, body_key, enable, description, value)
VALUES
    (?, ?, ?, ?, ?, ?, ?)
`

type CreateBodyUrlEncodedParams struct {
	ID            idwrap.IDWrap
	ExampleID     idwrap.IDWrap
	DeltaParentID *idwrap.IDWrap
	BodyKey       string
	Enable        bool
	Description   string
	Value         string
}

func (q *Queries) CreateBodyUrlEncoded(ctx context.Context, arg CreateBodyUrlEncodedParams) error {
	_, err := q.exec(ctx, q.createBodyUrlEncodedStmt, createBodyUrlEncoded,
		arg.ID,
		arg.ExampleID,
		arg.DeltaParentID,
		arg.BodyKey,
		arg.Enable,
		arg.Description,
		arg.Value,
	)
	return err
}

const createBodyUrlEncodedBulk = `-- name: CreateBodyUrlEncodedBulk :exec
INSERT INTO
  example_body_urlencoded (id, example_id, delta_parent_id, body_key, enable, description, value)
VALUES
    (?, ?, ?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?, ?, ?)
`

type CreateBodyUrlEncodedBulkParams struct {
	ID               idwrap.IDWrap
	ExampleID        idwrap.IDWrap
	DeltaParentID    *idwrap.IDWrap
	BodyKey          string
	Enable           bool
	Description      string
	Value            string
	ID_2             idwrap.IDWrap
	ExampleID_2      idwrap.IDWrap
	DeltaParentID_2  *idwrap.IDWrap
	BodyKey_2        string
	Enable_2         bool
	Description_2    string
	Value_2          string
	ID_3             idwrap.IDWrap
	ExampleID_3      idwrap.IDWrap
	DeltaParentID_3  *idwrap.IDWrap
	BodyKey_3        string
	Enable_3         bool
	Description_3    string
	Value_3          string
	ID_4             idwrap.IDWrap
	ExampleID_4      idwrap.IDWrap
	DeltaParentID_4  *idwrap.IDWrap
	BodyKey_4        string
	Enable_4         bool
	Description_4    string
	Value_4          string
	ID_5             idwrap.IDWrap
	ExampleID_5      idwrap.IDWrap
	DeltaParentID_5  *idwrap.IDWrap
	BodyKey_5        string
	Enable_5         bool
	Description_5    string
	Value_5          string
	ID_6             idwrap.IDWrap
	ExampleID_6      idwrap.IDWrap
	DeltaParentID_6  *idwrap.IDWrap
	BodyKey_6        string
	Enable_6         bool
	Description_6    string
	Value_6          string
	ID_7             idwrap.IDWrap
	ExampleID_7      idwrap.IDWrap
	DeltaParentID_7  *idwrap.IDWrap
	BodyKey_7        string
	Enable_7         bool
	Description_7    string
	Value_7          string
	ID_8             idwrap.IDWrap
	ExampleID_8      idwrap.IDWrap
	DeltaParentID_8  *idwrap.IDWrap
	BodyKey_8        string
	Enable_8         bool
	Description_8    string
	Value_8          string
	ID_9             idwrap.IDWrap
	ExampleID_9      idwrap.IDWrap
	DeltaParentID_9  *idwrap.IDWrap
	BodyKey_9        string
	Enable_9         bool
	Description_9    string
	Value_9          string
	ID_10            idwrap.IDWrap
	ExampleID_10     idwrap.IDWrap
	DeltaParentID_10 *idwrap.IDWrap
	BodyKey_10       string
	Enable_10        bool
	Description_10   string
	Value_10         string
}

func (q *Queries) CreateBodyUrlEncodedBulk(ctx context.Context, arg CreateBodyUrlEncodedBulkParams) error {
	_, err := q.exec(ctx, q.createBodyUrlEncodedBulkStmt, createBodyUrlEncodedBulk,
		arg.ID,
		arg.ExampleID,
		arg.DeltaParentID,
		arg.BodyKey,
		arg.Enable,
		arg.Description,
		arg.Value,
		arg.ID_2,
		arg.ExampleID_2,
		arg.DeltaParentID_2,
		arg.BodyKey_2,
		arg.Enable_2,
		arg.Description_2,
		arg.Value_2,
		arg.ID_3,
		arg.ExampleID_3,
		arg.DeltaParentID_3,
		arg.BodyKey_3,
		arg.Enable_3,
		arg.Description_3,
		arg.Value_3,
		arg.ID_4,
		arg.ExampleID_4,
		arg.DeltaParentID_4,
		arg.BodyKey_4,
		arg.Enable_4,
		arg.Description_4,
		arg.Value_4,
		arg.ID_5,
		arg.ExampleID_5,
		arg.DeltaParentID_5,
		arg.BodyKey_5,
		arg.Enable_5,
		arg.Description_5,
		arg.Value_5,
		arg.ID_6,
		arg.ExampleID_6,
		arg.DeltaParentID_6,
		arg.BodyKey_6,
		arg.Enable_6,
		arg.Description_6,
		arg.Value_6,
		arg.ID_7,
		arg.ExampleID_7,
		arg.DeltaParentID_7,
		arg.BodyKey_7,
		arg.Enable_7,
		arg.Description_7,
		arg.Value_7,
		arg.ID_8,
		arg.ExampleID_8,
		arg.DeltaParentID_8,
		arg.BodyKey_8,
		arg.Enable_8,
		arg.Description_8,
		arg.Value_8,
		arg.ID_9,
		arg.ExampleID_9,
		arg.DeltaParentID_9,
		arg.BodyKey_9,
		arg.Enable_9,
		arg.Description_9,
		arg.Value_9,
		arg.ID_10,
		arg.ExampleID_10,
		arg.DeltaParentID_10,
		arg.BodyKey_10,
		arg.Enable_10,
		arg.Description_10,
		arg.Value_10,
	)
	return err
}

const createEnvironment = `-- name: CreateEnvironment :exec
INSERT INTO
  environment (id, workspace_id, type, name, description, display_order)
VALUES
  (?, ?, ?, ?, ?, ?)
`

type CreateEnvironmentParams struct {
	ID           idwrap.IDWrap
	WorkspaceID  idwrap.IDWrap
	Type         int8
	Name         string
	Description  string
	DisplayOrder float64
}

func (q *Queries) CreateEnvironment(ctx context.Context, arg CreateEnvironmentParams) error {
	_, err := q.exec(ctx, q.createEnvironmentStmt, createEnvironment,
		arg.ID,
		arg.WorkspaceID,
		arg.Type,
		arg.Name,
		arg.Description,
		arg.DisplayOrder,
	)
	return err
}

const createExampleResp = `-- name: CreateExampleResp :exec
INSERT INTO
  example_resp (id, example_id, status, body, body_compress_type, duration)
VALUES
  (?, ?, ?, ?, ?, ?)
`

type CreateExampleRespParams struct {
	ID               idwrap.IDWrap
	ExampleID        idwrap.IDWrap
	Status           uint16
	Body             []byte
	BodyCompressType int8
	Duration         int32
}

func (q *Queries) CreateExampleResp(ctx context.Context, arg CreateExampleRespParams) error {
	_, err := q.exec(ctx, q.createExampleRespStmt, createExampleResp,
		arg.ID,
		arg.ExampleID,
		arg.Status,
		arg.Body,
		arg.BodyCompressType,
		arg.Duration,
	)
	return err
}

const createExampleRespHeader = `-- name: CreateExampleRespHeader :exec
INSERT INTO
  example_resp_header (id, example_resp_id, header_key, value)
VALUES
  (?, ?, ?, ?)
`

type CreateExampleRespHeaderParams struct {
	ID            idwrap.IDWrap
	ExampleRespID idwrap.IDWrap
	HeaderKey     string
	Value         string
}

func (q *Queries) CreateExampleRespHeader(ctx context.Context, arg CreateExampleRespHeaderParams) error {
	_, err := q.exec(ctx, q.createExampleRespHeaderStmt, createExampleRespHeader,
		arg.ID,
		arg.ExampleRespID,
		arg.HeaderKey,
		arg.Value,
	)
	return err
}

const createExampleRespHeaderBulk = `-- name: CreateExampleRespHeaderBulk :exec
INSERT INTO
  example_resp_header (id, example_resp_id, header_key, value)
VALUES
  (?, ?, ?, ?),
  (?, ?, ?, ?),
  (?, ?, ?, ?),
  (?, ?, ?, ?),
  (?, ?, ?, ?)
`

type CreateExampleRespHeaderBulkParams struct {
	ID              idwrap.IDWrap
	ExampleRespID   idwrap.IDWrap
	HeaderKey       string
	Value           string
	ID_2            idwrap.IDWrap
	ExampleRespID_2 idwrap.IDWrap
	HeaderKey_2     string
	Value_2         string
	ID_3            idwrap.IDWrap
	ExampleRespID_3 idwrap.IDWrap
	HeaderKey_3     string
	Value_3         string
	ID_4            idwrap.IDWrap
	ExampleRespID_4 idwrap.IDWrap
	HeaderKey_4     string
	Value_4         string
	ID_5            idwrap.IDWrap
	ExampleRespID_5 idwrap.IDWrap
	HeaderKey_5     string
	Value_5         string
}

func (q *Queries) CreateExampleRespHeaderBulk(ctx context.Context, arg CreateExampleRespHeaderBulkParams) error {
	_, err := q.exec(ctx, q.createExampleRespHeaderBulkStmt, createExampleRespHeaderBulk,
		arg.ID,
		arg.ExampleRespID,
		arg.HeaderKey,
		arg.Value,
		arg.ID_2,
		arg.ExampleRespID_2,
		arg.HeaderKey_2,
		arg.Value_2,
		arg.ID_3,
		arg.ExampleRespID_3,
		arg.HeaderKey_3,
		arg.Value_3,
		arg.ID_4,
		arg.ExampleRespID_4,
		arg.HeaderKey_4,
		arg.Value_4,
		arg.ID_5,
		arg.ExampleRespID_5,
		arg.HeaderKey_5,
		arg.Value_5,
	)
	return err
}

const createFile = `-- name: CreateFile :exec
INSERT INTO files (id, workspace_id, folder_id, content_id, content_kind, name, display_order, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateFileParams struct {
	ID           idwrap.IDWrap
	WorkspaceID  idwrap.IDWrap
	FolderID     *idwrap.IDWrap
	ContentID    *idwrap.IDWrap
	ContentKind  int8
	Name         string
	DisplayOrder float64
	UpdatedAt    int64
}

// Create a new file
func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) error {
	_, err := q.exec(ctx, q.createFileStmt, createFile,
		arg.ID,
		arg.WorkspaceID,
		arg.FolderID,
		arg.ContentID,
		arg.ContentKind,
		arg.Name,
		arg.DisplayOrder,
		arg.UpdatedAt,
	)
	return err
}

const createFlow = `-- name: CreateFlow :exec
INSERT INTO
  flow (id, workspace_id, version_parent_id, name, duration)
VALUES
  (?, ?, ?, ?, ?)
`

type CreateFlowParams struct {
	ID              idwrap.IDWrap
	WorkspaceID     idwrap.IDWrap
	VersionParentID *idwrap.IDWrap
	Name            string
	Duration        int32
}

func (q *Queries) CreateFlow(ctx context.Context, arg CreateFlowParams) error {
	_, err := q.exec(ctx, q.createFlowStmt, createFlow,
		arg.ID,
		arg.WorkspaceID,
		arg.VersionParentID,
		arg.Name,
		arg.Duration,
	)
	return err
}

const createFlowEdge = `-- name: CreateFlowEdge :exec
INSERT INTO
  flow_edge (id, flow_id, source_id, target_id, source_handle, edge_kind)
VALUES
  (?, ?, ?, ?, ?, ?)
`

type CreateFlowEdgeParams struct {
	ID           idwrap.IDWrap
	FlowID       idwrap.IDWrap
	SourceID     idwrap.IDWrap
	TargetID     idwrap.IDWrap
	SourceHandle int32
	EdgeKind     int32
}

func (q *Queries) CreateFlowEdge(ctx context.Context, arg CreateFlowEdgeParams) error {
	_, err := q.exec(ctx, q.createFlowEdgeStmt, createFlowEdge,
		arg.ID,
		arg.FlowID,
		arg.SourceID,
		arg.TargetID,
		arg.SourceHandle,
		arg.EdgeKind,
	)
	return err
}

const createFlowNode = `-- name: CreateFlowNode :exec
INSERT INTO
  flow_node (id, flow_id, name, node_kind, position_x, position_y)
VALUES
  (?, ?, ?, ?, ?, ?)
`

type CreateFlowNodeParams struct {
	ID        idwrap.IDWrap
	FlowID    idwrap.IDWrap
	Name      string
	NodeKind  int32
	PositionX float64
	PositionY float64
}

func (q *Queries) CreateFlowNode(ctx context.Context, arg CreateFlowNodeParams) error {
	_, err := q.exec(ctx, q.createFlowNodeStmt, createFlowNode,
		arg.ID,
		arg.FlowID,
		arg.Name,
		arg.NodeKind,
		arg.PositionX,
		arg.PositionY,
	)
	return err
}

const createFlowNodeCondition = `-- name: CreateFlowNodeCondition :exec
INSERT INTO
  flow_node_condition (flow_node_id, expression)
VALUES
  (?, ?)
`

type CreateFlowNodeConditionParams struct {
	FlowNodeID idwrap.IDWrap
	Expression string
}

func (q *Queries) CreateFlowNodeCondition(ctx context.Context, arg CreateFlowNodeConditionParams) error {
	_, err := q.exec(ctx, q.createFlowNodeConditionStmt, createFlowNodeCondition, arg.FlowNodeID, arg.Expression)
	return err
}

const createFlowNodeFor = `-- name: CreateFlowNodeFor :exec
INSERT INTO
  flow_node_for (flow_node_id, iter_count, error_handling, expression)
VALUES
  (?, ?, ?, ?)
`

type CreateFlowNodeForParams struct {
	FlowNodeID    idwrap.IDWrap
	IterCount     int64
	ErrorHandling int8
	Expression    string
}

func (q *Queries) CreateFlowNodeFor(ctx context.Context, arg CreateFlowNodeForParams) error {
	_, err := q.exec(ctx, q.createFlowNodeForStmt, createFlowNodeFor,
		arg.FlowNodeID,
		arg.IterCount,
		arg.ErrorHandling,
		arg.Expression,
	)
	return err
}

const createFlowNodeForEach = `-- name: CreateFlowNodeForEach :exec
INSERT INTO
  flow_node_for_each (flow_node_id, iter_expression, error_handling, expression)
VALUES
  (?, ?, ?, ?)
`

type CreateFlowNodeForEachParams struct {
	FlowNodeID     idwrap.IDWrap
	IterExpression string
	ErrorHandling  int8
	Expression     string
}

func (q *Queries) CreateFlowNodeForEach(ctx context.Context, arg CreateFlowNodeForEachParams) error {
	_, err := q.exec(ctx, q.createFlowNodeForEachStmt, createFlowNodeForEach,
		arg.FlowNodeID,
		arg.IterExpression,
		arg.ErrorHandling,
		arg.Expression,
	)
	return err
}

const createFlowNodeJs = `-- name: CreateFlowNodeJs :exec
INSERT INTO
  flow_node_js (flow_node_id, code, code_compress_type)
VALUES
  (?, ?, ?)
`

type CreateFlowNodeJsParams struct {
	FlowNodeID       idwrap.IDWrap
	Code             []byte
	CodeCompressType int8
}

func (q *Queries) CreateFlowNodeJs(ctx context.Context, arg CreateFlowNodeJsParams) error {
	_, err := q.exec(ctx, q.createFlowNodeJsStmt, createFlowNodeJs, arg.FlowNodeID, arg.Code, arg.CodeCompressType)
	return err
}

const createFlowNodeNoop = `-- name: CreateFlowNodeNoop :exec
INSERT INTO
  flow_node_noop (flow_node_id, node_type)
VALUES
  (?, ?)
`

type CreateFlowNodeNoopParams struct {
	FlowNodeID idwrap.IDWrap
	NodeType   int16
}

func (q *Queries) CreateFlowNodeNoop(ctx context.Context, arg CreateFlowNodeNoopParams) error {
	_, err := q.exec(ctx, q.createFlowNodeNoopStmt, createFlowNodeNoop, arg.FlowNodeID, arg.NodeType)
	return err
}

const createFlowNodeRequest = `-- name: CreateFlowNodeRequest :exec
INSERT INTO
  flow_node_request (
    flow_node_id,
    endpoint_id,
    example_id,
    delta_example_id,
    delta_endpoint_id,
    has_request_config
  )
VALUES
  (?, ?, ?, ?, ?, ?)
`

type CreateFlowNodeRequestParams struct {
	FlowNodeID       idwrap.IDWrap
	EndpointID       *idwrap.IDWrap
	ExampleID        *idwrap.IDWrap
	DeltaExampleID   *idwrap.IDWrap
	DeltaEndpointID  *idwrap.IDWrap
	HasRequestConfig bool
}

func (q *Queries) CreateFlowNodeRequest(ctx context.Context, arg CreateFlowNodeRequestParams) error {
	_, err := q.exec(ctx, q.createFlowNodeRequestStmt, createFlowNodeRequest,
		arg.FlowNodeID,
		arg.EndpointID,
		arg.ExampleID,
		arg.DeltaExampleID,
		arg.DeltaEndpointID,
		arg.HasRequestConfig,
	)
	return err
}

const createFlowTag = `-- name: CreateFlowTag :exec
INSERT INTO
  flow_tag (id, flow_id, tag_id)
VALUES
  (?, ?, ?)
`

type CreateFlowTagParams struct {
	ID     idwrap.IDWrap
	FlowID idwrap.IDWrap
	TagID  idwrap.IDWrap
}

func (q *Queries) CreateFlowTag(ctx context.Context, arg CreateFlowTagParams) error {
	_, err := q.exec(ctx, q.createFlowTagStmt, createFlowTag, arg.ID, arg.FlowID, arg.TagID)
	return err
}

const createFlowVariable = `-- name: CreateFlowVariable :exec
INSERT INTO
  flow_variable (id, flow_id, key, value, enabled, description, prev, next)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateFlowVariableParams struct {
	ID          idwrap.IDWrap
	FlowID      idwrap.IDWrap
	Key         string
	Value       string
	Enabled     bool
	Description string
	Prev        *idwrap.IDWrap
	Next        *idwrap.IDWrap
}

func (q *Queries) CreateFlowVariable(ctx context.Context, arg CreateFlowVariableParams) error {
	_, err := q.exec(ctx, q.createFlowVariableStmt, createFlowVariable,
		arg.ID,
		arg.FlowID,
		arg.Key,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.Prev,
		arg.Next,
	)
	return err
}

const createFlowVariableBulk = `-- name: CreateFlowVariableBulk :exec
INSERT INTO
  flow_variable (id, flow_id, key, value, enabled, description, prev, next)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateFlowVariableBulkParams struct {
	ID             idwrap.IDWrap
	FlowID         idwrap.IDWrap
	Key            string
	Value          string
	Enabled        bool
	Description    string
	Prev           *idwrap.IDWrap
	Next           *idwrap.IDWrap
	ID_2           idwrap.IDWrap
	FlowID_2       idwrap.IDWrap
	Key_2          string
	Value_2        string
	Enabled_2      bool
	Description_2  string
	Prev_2         *idwrap.IDWrap
	Next_2         *idwrap.IDWrap
	ID_3           idwrap.IDWrap
	FlowID_3       idwrap.IDWrap
	Key_3          string
	Value_3        string
	Enabled_3      bool
	Description_3  string
	Prev_3         *idwrap.IDWrap
	Next_3         *idwrap.IDWrap
	ID_4           idwrap.IDWrap
	FlowID_4       idwrap.IDWrap
	Key_4          string
	Value_4        string
	Enabled_4      bool
	Description_4  string
	Prev_4         *idwrap.IDWrap
	Next_4         *idwrap.IDWrap
	ID_5           idwrap.IDWrap
	FlowID_5       idwrap.IDWrap
	Key_5          string
	Value_5        string
	Enabled_5      bool
	Description_5  string
	Prev_5         *idwrap.IDWrap
	Next_5         *idwrap.IDWrap
	ID_6           idwrap.IDWrap
	FlowID_6       idwrap.IDWrap
	Key_6          string
	Value_6        string
	Enabled_6      bool
	Description_6  string
	Prev_6         *idwrap.IDWrap
	Next_6         *idwrap.IDWrap
	ID_7           idwrap.IDWrap
	FlowID_7       idwrap.IDWrap
	Key_7          string
	Value_7        string
	Enabled_7      bool
	Description_7  string
	Prev_7         *idwrap.IDWrap
	Next_7         *idwrap.IDWrap
	ID_8           idwrap.IDWrap
	FlowID_8       idwrap.IDWrap
	Key_8          string
	Value_8        string
	Enabled_8      bool
	Description_8  string
	Prev_8         *idwrap.IDWrap
	Next_8         *idwrap.IDWrap
	ID_9           idwrap.IDWrap
	FlowID_9       idwrap.IDWrap
	Key_9          string
	Value_9        string
	Enabled_9      bool
	Description_9  string
	Prev_9         *idwrap.IDWrap
	Next_9         *idwrap.IDWrap
	ID_10          idwrap.IDWrap
	FlowID_10      idwrap.IDWrap
	Key_10         string
	Value_10       string
	Enabled_10     bool
	Description_10 string
	Prev_10        *idwrap.IDWrap
	Next_10        *idwrap.IDWrap
}

func (q *Queries) CreateFlowVariableBulk(ctx context.Context, arg CreateFlowVariableBulkParams) error {
	_, err := q.exec(ctx, q.createFlowVariableBulkStmt, createFlowVariableBulk,
		arg.ID,
		arg.FlowID,
		arg.Key,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.Prev,
		arg.Next,
		arg.ID_2,
		arg.FlowID_2,
		arg.Key_2,
		arg.Value_2,
		arg.Enabled_2,
		arg.Description_2,
		arg.Prev_2,
		arg.Next_2,
		arg.ID_3,
		arg.FlowID_3,
		arg.Key_3,
		arg.Value_3,
		arg.Enabled_3,
		arg.Description_3,
		arg.Prev_3,
		arg.Next_3,
		arg.ID_4,
		arg.FlowID_4,
		arg.Key_4,
		arg.Value_4,
		arg.Enabled_4,
		arg.Description_4,
		arg.Prev_4,
		arg.Next_4,
		arg.ID_5,
		arg.FlowID_5,
		arg.Key_5,
		arg.Value_5,
		arg.Enabled_5,
		arg.Description_5,
		arg.Prev_5,
		arg.Next_5,
		arg.ID_6,
		arg.FlowID_6,
		arg.Key_6,
		arg.Value_6,
		arg.Enabled_6,
		arg.Description_6,
		arg.Prev_6,
		arg.Next_6,
		arg.ID_7,
		arg.FlowID_7,
		arg.Key_7,
		arg.Value_7,
		arg.Enabled_7,
		arg.Description_7,
		arg.Prev_7,
		arg.Next_7,
		arg.ID_8,
		arg.FlowID_8,
		arg.Key_8,
		arg.Value_8,
		arg.Enabled_8,
		arg.Description_8,
		arg.Prev_8,
		arg.Next_8,
		arg.ID_9,
		arg.FlowID_9,
		arg.Key_9,
		arg.Value_9,
		arg.Enabled_9,
		arg.Description_9,
		arg.Prev_9,
		arg.Next_9,
		arg.ID_10,
		arg.FlowID_10,
		arg.Key_10,
		arg.Value_10,
		arg.Enabled_10,
		arg.Description_10,
		arg.Prev_10,
		arg.Next_10,
	)
	return err
}

const createHTTP = `-- name: CreateHTTP :exec
INSERT INTO http (
  id, workspace_id, folder_id, name, url, method, description,
  parent_http_id, is_delta, delta_name, delta_url, delta_method, delta_description,
  created_at, updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPParams struct {
	ID               idwrap.IDWrap
	WorkspaceID      idwrap.IDWrap
	FolderID         *idwrap.IDWrap
	Name             string
	Url              string
	Method           string
	Description      string
	ParentHttpID     *idwrap.IDWrap
	IsDelta          bool
	DeltaName        *string
	DeltaUrl         *string
	DeltaMethod      *string
	DeltaDescription *string
	CreatedAt        int64
	UpdatedAt        int64
}

func (q *Queries) CreateHTTP(ctx context.Context, arg CreateHTTPParams) error {
	_, err := q.exec(ctx, q.createHTTPStmt, createHTTP,
		arg.ID,
		arg.WorkspaceID,
		arg.FolderID,
		arg.Name,
		arg.Url,
		arg.Method,
		arg.Description,
		arg.ParentHttpID,
		arg.IsDelta,
		arg.DeltaName,
		arg.DeltaUrl,
		arg.DeltaMethod,
		arg.DeltaDescription,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createHTTPAssert = `-- name: CreateHTTPAssert :exec
INSERT INTO http_assert (
  id, http_id, key, value, enabled, description, "order",
  parent_http_assert_id, is_delta, delta_key, delta_value,
  delta_enabled, delta_description, delta_order, created_at, updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPAssertParams struct {
	ID                 idwrap.IDWrap
	HttpID             idwrap.IDWrap
	Key                string
	Value              string
	Enabled            bool
	Description        string
	Order              float64
	ParentHttpAssertID []byte
	IsDelta            bool
	DeltaKey           sql.NullString
	DeltaValue         sql.NullString
	DeltaEnabled       *bool
	DeltaDescription   sql.NullString
	DeltaOrder         sql.NullFloat64
	CreatedAt          int64
	UpdatedAt          int64
}

func (q *Queries) CreateHTTPAssert(ctx context.Context, arg CreateHTTPAssertParams) error {
	_, err := q.exec(ctx, q.createHTTPAssertStmt, createHTTPAssert,
		arg.ID,
		arg.HttpID,
		arg.Key,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.Order,
		arg.ParentHttpAssertID,
		arg.IsDelta,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaEnabled,
		arg.DeltaDescription,
		arg.DeltaOrder,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createHTTPAssertBulk = `-- name: CreateHTTPAssertBulk :exec
INSERT INTO http_assert (
  id, http_id, key, value, enabled, description, "order",
  parent_http_assert_id, is_delta, delta_key, delta_value,
  delta_enabled, delta_description, delta_order, created_at, updated_at
)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPAssertBulkParams struct {
	ID                    idwrap.IDWrap
	HttpID                idwrap.IDWrap
	Key                   string
	Value                 string
	Enabled               bool
	Description           string
	Order                 float64
	ParentHttpAssertID    []byte
	IsDelta               bool
	DeltaKey              sql.NullString
	DeltaValue            sql.NullString
	DeltaEnabled          *bool
	DeltaDescription      sql.NullString
	DeltaOrder            sql.NullFloat64
	CreatedAt             int64
	UpdatedAt             int64
	ID_2                  idwrap.IDWrap
	HttpID_2              idwrap.IDWrap
	Key_2                 string
	Value_2               string
	Enabled_2             bool
	Description_2         string
	Order_2               float64
	ParentHttpAssertID_2  []byte
	IsDelta_2             bool
	DeltaKey_2            sql.NullString
	DeltaValue_2          sql.NullString
	DeltaEnabled_2        *bool
	DeltaDescription_2    sql.NullString
	DeltaOrder_2          sql.NullFloat64
	CreatedAt_2           int64
	UpdatedAt_2           int64
	ID_3                  idwrap.IDWrap
	HttpID_3              idwrap.IDWrap
	Key_3                 string
	Value_3               string
	Enabled_3             bool
	Description_3         string
	Order_3               float64
	ParentHttpAssertID_3  []byte
	IsDelta_3             bool
	DeltaKey_3            sql.NullString
	DeltaValue_3          sql.NullString
	DeltaEnabled_3        *bool
	DeltaDescription_3    sql.NullString
	DeltaOrder_3          sql.NullFloat64
	CreatedAt_3           int64
	UpdatedAt_3           int64
	ID_4                  idwrap.IDWrap
	HttpID_4              idwrap.IDWrap
	Key_4                 string
	Value_4               string
	Enabled_4             bool
	Description_4         string
	Order_4               float64
	ParentHttpAssertID_4  []byte
	IsDelta_4             bool
	DeltaKey_4            sql.NullString
	DeltaValue_4          sql.NullString
	DeltaEnabled_4        *bool
	DeltaDescription_4    sql.NullString
	DeltaOrder_4          sql.NullFloat64
	CreatedAt_4           int64
	UpdatedAt_4           int64
	ID_5                  idwrap.IDWrap
	HttpID_5              idwrap.IDWrap
	Key_5                 string
	Value_5               string
	Enabled_5             bool
	Description_5         string
	Order_5               float64
	ParentHttpAssertID_5  []byte
	IsDelta_5             bool
	DeltaKey_5            sql.NullString
	DeltaValue_5          sql.NullString
	DeltaEnabled_5        *bool
	DeltaDescription_5    sql.NullString
	DeltaOrder_5          sql.NullFloat64
	CreatedAt_5           int64
	UpdatedAt_5           int64
	ID_6                  idwrap.IDWrap
	HttpID_6              idwrap.IDWrap
	Key_6                 string
	Value_6               string
	Enabled_6             bool
	Description_6         string
	Order_6               float64
	ParentHttpAssertID_6  []byte
	IsDelta_6             bool
	DeltaKey_6            sql.NullString
	DeltaValue_6          sql.NullString
	DeltaEnabled_6        *bool
	DeltaDescription_6    sql.NullString
	DeltaOrder_6          sql.NullFloat64
	CreatedAt_6           int64
	UpdatedAt_6           int64
	ID_7                  idwrap.IDWrap
	HttpID_7              idwrap.IDWrap
	Key_7                 string
	Value_7               string
	Enabled_7             bool
	Description_7         string
	Order_7               float64
	ParentHttpAssertID_7  []byte
	IsDelta_7             bool
	DeltaKey_7            sql.NullString
	DeltaValue_7          sql.NullString
	DeltaEnabled_7        *bool
	DeltaDescription_7    sql.NullString
	DeltaOrder_7          sql.NullFloat64
	CreatedAt_7           int64
	UpdatedAt_7           int64
	ID_8                  idwrap.IDWrap
	HttpID_8              idwrap.IDWrap
	Key_8                 string
	Value_8               string
	Enabled_8             bool
	Description_8         string
	Order_8               float64
	ParentHttpAssertID_8  []byte
	IsDelta_8             bool
	DeltaKey_8            sql.NullString
	DeltaValue_8          sql.NullString
	DeltaEnabled_8        *bool
	DeltaDescription_8    sql.NullString
	DeltaOrder_8          sql.NullFloat64
	CreatedAt_8           int64
	UpdatedAt_8           int64
	ID_9                  idwrap.IDWrap
	HttpID_9              idwrap.IDWrap
	Key_9                 string
	Value_9               string
	Enabled_9             bool
	Description_9         string
	Order_9               float64
	ParentHttpAssertID_9  []byte
	IsDelta_9             bool
	DeltaKey_9            sql.NullString
	DeltaValue_9          sql.NullString
	DeltaEnabled_9        *bool
	DeltaDescription_9    sql.NullString
	DeltaOrder_9          sql.NullFloat64
	CreatedAt_9           int64
	UpdatedAt_9           int64
	ID_10                 idwrap.IDWrap
	HttpID_10             idwrap.IDWrap
	Key_10                string
	Value_10              string
	Enabled_10            bool
	Description_10        string
	Order_10              float64
	ParentHttpAssertID_10 []byte
	IsDelta_10            bool
	DeltaKey_10           sql.NullString
	DeltaValue_10         sql.NullString
	DeltaEnabled_10       *bool
	DeltaDescription_10   sql.NullString
	DeltaOrder_10         sql.NullFloat64
	CreatedAt_10          int64
	UpdatedAt_10          int64
}

func (q *Queries) CreateHTTPAssertBulk(ctx context.Context, arg CreateHTTPAssertBulkParams) error {
	_, err := q.exec(ctx, q.createHTTPAssertBulkStmt, createHTTPAssertBulk,
		arg.ID,
		arg.HttpID,
		arg.Key,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.Order,
		arg.ParentHttpAssertID,
		arg.IsDelta,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaEnabled,
		arg.DeltaDescription,
		arg.DeltaOrder,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ID_2,
		arg.HttpID_2,
		arg.Key_2,
		arg.Value_2,
		arg.Enabled_2,
		arg.Description_2,
		arg.Order_2,
		arg.ParentHttpAssertID_2,
		arg.IsDelta_2,
		arg.DeltaKey_2,
		arg.DeltaValue_2,
		arg.DeltaEnabled_2,
		arg.DeltaDescription_2,
		arg.DeltaOrder_2,
		arg.CreatedAt_2,
		arg.UpdatedAt_2,
		arg.ID_3,
		arg.HttpID_3,
		arg.Key_3,
		arg.Value_3,
		arg.Enabled_3,
		arg.Description_3,
		arg.Order_3,
		arg.ParentHttpAssertID_3,
		arg.IsDelta_3,
		arg.DeltaKey_3,
		arg.DeltaValue_3,
		arg.DeltaEnabled_3,
		arg.DeltaDescription_3,
		arg.DeltaOrder_3,
		arg.CreatedAt_3,
		arg.UpdatedAt_3,
		arg.ID_4,
		arg.HttpID_4,
		arg.Key_4,
		arg.Value_4,
		arg.Enabled_4,
		arg.Description_4,
		arg.Order_4,
		arg.ParentHttpAssertID_4,
		arg.IsDelta_4,
		arg.DeltaKey_4,
		arg.DeltaValue_4,
		arg.DeltaEnabled_4,
		arg.DeltaDescription_4,
		arg.DeltaOrder_4,
		arg.CreatedAt_4,
		arg.UpdatedAt_4,
		arg.ID_5,
		arg.HttpID_5,
		arg.Key_5,
		arg.Value_5,
		arg.Enabled_5,
		arg.Description_5,
		arg.Order_5,
		arg.ParentHttpAssertID_5,
		arg.IsDelta_5,
		arg.DeltaKey_5,
		arg.DeltaValue_5,
		arg.DeltaEnabled_5,
		arg.DeltaDescription_5,
		arg.DeltaOrder_5,
		arg.CreatedAt_5,
		arg.UpdatedAt_5,
		arg.ID_6,
		arg.HttpID_6,
		arg.Key_6,
		arg.Value_6,
		arg.Enabled_6,
		arg.Description_6,
		arg.Order_6,
		arg.ParentHttpAssertID_6,
		arg.IsDelta_6,
		arg.DeltaKey_6,
		arg.DeltaValue_6,
		arg.DeltaEnabled_6,
		arg.DeltaDescription_6,
		arg.DeltaOrder_6,
		arg.CreatedAt_6,
		arg.UpdatedAt_6,
		arg.ID_7,
		arg.HttpID_7,
		arg.Key_7,
		arg.Value_7,
		arg.Enabled_7,
		arg.Description_7,
		arg.Order_7,
		arg.ParentHttpAssertID_7,
		arg.IsDelta_7,
		arg.DeltaKey_7,
		arg.DeltaValue_7,
		arg.DeltaEnabled_7,
		arg.DeltaDescription_7,
		arg.DeltaOrder_7,
		arg.CreatedAt_7,
		arg.UpdatedAt_7,
		arg.ID_8,
		arg.HttpID_8,
		arg.Key_8,
		arg.Value_8,
		arg.Enabled_8,
		arg.Description_8,
		arg.Order_8,
		arg.ParentHttpAssertID_8,
		arg.IsDelta_8,
		arg.DeltaKey_8,
		arg.DeltaValue_8,
		arg.DeltaEnabled_8,
		arg.DeltaDescription_8,
		arg.DeltaOrder_8,
		arg.CreatedAt_8,
		arg.UpdatedAt_8,
		arg.ID_9,
		arg.HttpID_9,
		arg.Key_9,
		arg.Value_9,
		arg.Enabled_9,
		arg.Description_9,
		arg.Order_9,
		arg.ParentHttpAssertID_9,
		arg.IsDelta_9,
		arg.DeltaKey_9,
		arg.DeltaValue_9,
		arg.DeltaEnabled_9,
		arg.DeltaDescription_9,
		arg.DeltaOrder_9,
		arg.CreatedAt_9,
		arg.UpdatedAt_9,
		arg.ID_10,
		arg.HttpID_10,
		arg.Key_10,
		arg.Value_10,
		arg.Enabled_10,
		arg.Description_10,
		arg.Order_10,
		arg.ParentHttpAssertID_10,
		arg.IsDelta_10,
		arg.DeltaKey_10,
		arg.DeltaValue_10,
		arg.DeltaEnabled_10,
		arg.DeltaDescription_10,
		arg.DeltaOrder_10,
		arg.CreatedAt_10,
		arg.UpdatedAt_10,
	)
	return err
}

const createHTTPBodyForm = `-- name: CreateHTTPBodyForm :exec
INSERT INTO http_body_form (
  id, http_id, key, value, description, enabled, "order",
  parent_http_body_form_id, is_delta, delta_key, delta_value,
  delta_description, delta_enabled, created_at, updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPBodyFormParams struct {
	ID                   idwrap.IDWrap
	HttpID               idwrap.IDWrap
	Key                  string
	Value                string
	Description          string
	Enabled              bool
	Order                float64
	ParentHttpBodyFormID []byte
	IsDelta              bool
	DeltaKey             sql.NullString
	DeltaValue           sql.NullString
	DeltaDescription     *string
	DeltaEnabled         *bool
	CreatedAt            int64
	UpdatedAt            int64
}

func (q *Queries) CreateHTTPBodyForm(ctx context.Context, arg CreateHTTPBodyFormParams) error {
	_, err := q.exec(ctx, q.createHTTPBodyFormStmt, createHTTPBodyForm,
		arg.ID,
		arg.HttpID,
		arg.Key,
		arg.Value,
		arg.Description,
		arg.Enabled,
		arg.Order,
		arg.ParentHttpBodyFormID,
		arg.IsDelta,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaDescription,
		arg.DeltaEnabled,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createHTTPBodyUrlEncoded = `-- name: CreateHTTPBodyUrlEncoded :exec
INSERT INTO http_body_urlencoded (
  id, http_id, key, value, enabled, description, "order",
  parent_http_body_urlencoded_id, is_delta, delta_key, delta_value,
  delta_enabled, delta_description, delta_order, created_at, updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPBodyUrlEncodedParams struct {
	ID                         idwrap.IDWrap
	HttpID                     idwrap.IDWrap
	Key                        string
	Value                      string
	Enabled                    bool
	Description                string
	Order                      float64
	ParentHttpBodyUrlencodedID []byte
	IsDelta                    bool
	DeltaKey                   sql.NullString
	DeltaValue                 sql.NullString
	DeltaEnabled               *bool
	DeltaDescription           *string
	DeltaOrder                 sql.NullFloat64
	CreatedAt                  int64
	UpdatedAt                  int64
}

func (q *Queries) CreateHTTPBodyUrlEncoded(ctx context.Context, arg CreateHTTPBodyUrlEncodedParams) error {
	_, err := q.exec(ctx, q.createHTTPBodyUrlEncodedStmt, createHTTPBodyUrlEncoded,
		arg.ID,
		arg.HttpID,
		arg.Key,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.Order,
		arg.ParentHttpBodyUrlencodedID,
		arg.IsDelta,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaEnabled,
		arg.DeltaDescription,
		arg.DeltaOrder,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createHTTPBodyUrlEncodedBulk = `-- name: CreateHTTPBodyUrlEncodedBulk :exec
INSERT INTO http_body_urlencoded (
  id, http_id, key, value, enabled, description, "order",
  parent_http_body_urlencoded_id, is_delta, delta_key, delta_value,
  delta_enabled, delta_description, delta_order, created_at, updated_at
)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPBodyUrlEncodedBulkParams struct {
	ID                            idwrap.IDWrap
	HttpID                        idwrap.IDWrap
	Key                           string
	Value                         string
	Enabled                       bool
	Description                   string
	Order                         float64
	ParentHttpBodyUrlencodedID    []byte
	IsDelta                       bool
	DeltaKey                      sql.NullString
	DeltaValue                    sql.NullString
	DeltaEnabled                  *bool
	DeltaDescription              *string
	DeltaOrder                    sql.NullFloat64
	CreatedAt                     int64
	UpdatedAt                     int64
	ID_2                          idwrap.IDWrap
	HttpID_2                      idwrap.IDWrap
	Key_2                         string
	Value_2                       string
	Enabled_2                     bool
	Description_2                 string
	Order_2                       float64
	ParentHttpBodyUrlencodedID_2  []byte
	IsDelta_2                     bool
	DeltaKey_2                    sql.NullString
	DeltaValue_2                  sql.NullString
	DeltaEnabled_2                *bool
	DeltaDescription_2            *string
	DeltaOrder_2                  sql.NullFloat64
	CreatedAt_2                   int64
	UpdatedAt_2                   int64
	ID_3                          idwrap.IDWrap
	HttpID_3                      idwrap.IDWrap
	Key_3                         string
	Value_3                       string
	Enabled_3                     bool
	Description_3                 string
	Order_3                       float64
	ParentHttpBodyUrlencodedID_3  []byte
	IsDelta_3                     bool
	DeltaKey_3                    sql.NullString
	DeltaValue_3                  sql.NullString
	DeltaEnabled_3                *bool
	DeltaDescription_3            *string
	DeltaOrder_3                  sql.NullFloat64
	CreatedAt_3                   int64
	UpdatedAt_3                   int64
	ID_4                          idwrap.IDWrap
	HttpID_4                      idwrap.IDWrap
	Key_4                         string
	Value_4                       string
	Enabled_4                     bool
	Description_4                 string
	Order_4                       float64
	ParentHttpBodyUrlencodedID_4  []byte
	IsDelta_4                     bool
	DeltaKey_4                    sql.NullString
	DeltaValue_4                  sql.NullString
	DeltaEnabled_4                *bool
	DeltaDescription_4            *string
	DeltaOrder_4                  sql.NullFloat64
	CreatedAt_4                   int64
	UpdatedAt_4                   int64
	ID_5                          idwrap.IDWrap
	HttpID_5                      idwrap.IDWrap
	Key_5                         string
	Value_5                       string
	Enabled_5                     bool
	Description_5                 string
	Order_5                       float64
	ParentHttpBodyUrlencodedID_5  []byte
	IsDelta_5                     bool
	DeltaKey_5                    sql.NullString
	DeltaValue_5                  sql.NullString
	DeltaEnabled_5                *bool
	DeltaDescription_5            *string
	DeltaOrder_5                  sql.NullFloat64
	CreatedAt_5                   int64
	UpdatedAt_5                   int64
	ID_6                          idwrap.IDWrap
	HttpID_6                      idwrap.IDWrap
	Key_6                         string
	Value_6                       string
	Enabled_6                     bool
	Description_6                 string
	Order_6                       float64
	ParentHttpBodyUrlencodedID_6  []byte
	IsDelta_6                     bool
	DeltaKey_6                    sql.NullString
	DeltaValue_6                  sql.NullString
	DeltaEnabled_6                *bool
	DeltaDescription_6            *string
	DeltaOrder_6                  sql.NullFloat64
	CreatedAt_6                   int64
	UpdatedAt_6                   int64
	ID_7                          idwrap.IDWrap
	HttpID_7                      idwrap.IDWrap
	Key_7                         string
	Value_7                       string
	Enabled_7                     bool
	Description_7                 string
	Order_7                       float64
	ParentHttpBodyUrlencodedID_7  []byte
	IsDelta_7                     bool
	DeltaKey_7                    sql.NullString
	DeltaValue_7                  sql.NullString
	DeltaEnabled_7                *bool
	DeltaDescription_7            *string
	DeltaOrder_7                  sql.NullFloat64
	CreatedAt_7                   int64
	UpdatedAt_7                   int64
	ID_8                          idwrap.IDWrap
	HttpID_8                      idwrap.IDWrap
	Key_8                         string
	Value_8                       string
	Enabled_8                     bool
	Description_8                 string
	Order_8                       float64
	ParentHttpBodyUrlencodedID_8  []byte
	IsDelta_8                     bool
	DeltaKey_8                    sql.NullString
	DeltaValue_8                  sql.NullString
	DeltaEnabled_8                *bool
	DeltaDescription_8            *string
	DeltaOrder_8                  sql.NullFloat64
	CreatedAt_8                   int64
	UpdatedAt_8                   int64
	ID_9                          idwrap.IDWrap
	HttpID_9                      idwrap.IDWrap
	Key_9                         string
	Value_9                       string
	Enabled_9                     bool
	Description_9                 string
	Order_9                       float64
	ParentHttpBodyUrlencodedID_9  []byte
	IsDelta_9                     bool
	DeltaKey_9                    sql.NullString
	DeltaValue_9                  sql.NullString
	DeltaEnabled_9                *bool
	DeltaDescription_9            *string
	DeltaOrder_9                  sql.NullFloat64
	CreatedAt_9                   int64
	UpdatedAt_9                   int64
	ID_10                         idwrap.IDWrap
	HttpID_10                     idwrap.IDWrap
	Key_10                        string
	Value_10                      string
	Enabled_10                    bool
	Description_10                string
	Order_10                      float64
	ParentHttpBodyUrlencodedID_10 []byte
	IsDelta_10                    bool
	DeltaKey_10                   sql.NullString
	DeltaValue_10                 sql.NullString
	DeltaEnabled_10               *bool
	DeltaDescription_10           *string
	DeltaOrder_10                 sql.NullFloat64
	CreatedAt_10                  int64
	UpdatedAt_10                  int64
}

func (q *Queries) CreateHTTPBodyUrlEncodedBulk(ctx context.Context, arg CreateHTTPBodyUrlEncodedBulkParams) error {
	_, err := q.exec(ctx, q.createHTTPBodyUrlEncodedBulkStmt, createHTTPBodyUrlEncodedBulk,
		arg.ID,
		arg.HttpID,
		arg.Key,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.Order,
		arg.ParentHttpBodyUrlencodedID,
		arg.IsDelta,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaEnabled,
		arg.DeltaDescription,
		arg.DeltaOrder,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ID_2,
		arg.HttpID_2,
		arg.Key_2,
		arg.Value_2,
		arg.Enabled_2,
		arg.Description_2,
		arg.Order_2,
		arg.ParentHttpBodyUrlencodedID_2,
		arg.IsDelta_2,
		arg.DeltaKey_2,
		arg.DeltaValue_2,
		arg.DeltaEnabled_2,
		arg.DeltaDescription_2,
		arg.DeltaOrder_2,
		arg.CreatedAt_2,
		arg.UpdatedAt_2,
		arg.ID_3,
		arg.HttpID_3,
		arg.Key_3,
		arg.Value_3,
		arg.Enabled_3,
		arg.Description_3,
		arg.Order_3,
		arg.ParentHttpBodyUrlencodedID_3,
		arg.IsDelta_3,
		arg.DeltaKey_3,
		arg.DeltaValue_3,
		arg.DeltaEnabled_3,
		arg.DeltaDescription_3,
		arg.DeltaOrder_3,
		arg.CreatedAt_3,
		arg.UpdatedAt_3,
		arg.ID_4,
		arg.HttpID_4,
		arg.Key_4,
		arg.Value_4,
		arg.Enabled_4,
		arg.Description_4,
		arg.Order_4,
		arg.ParentHttpBodyUrlencodedID_4,
		arg.IsDelta_4,
		arg.DeltaKey_4,
		arg.DeltaValue_4,
		arg.DeltaEnabled_4,
		arg.DeltaDescription_4,
		arg.DeltaOrder_4,
		arg.CreatedAt_4,
		arg.UpdatedAt_4,
		arg.ID_5,
		arg.HttpID_5,
		arg.Key_5,
		arg.Value_5,
		arg.Enabled_5,
		arg.Description_5,
		arg.Order_5,
		arg.ParentHttpBodyUrlencodedID_5,
		arg.IsDelta_5,
		arg.DeltaKey_5,
		arg.DeltaValue_5,
		arg.DeltaEnabled_5,
		arg.DeltaDescription_5,
		arg.DeltaOrder_5,
		arg.CreatedAt_5,
		arg.UpdatedAt_5,
		arg.ID_6,
		arg.HttpID_6,
		arg.Key_6,
		arg.Value_6,
		arg.Enabled_6,
		arg.Description_6,
		arg.Order_6,
		arg.ParentHttpBodyUrlencodedID_6,
		arg.IsDelta_6,
		arg.DeltaKey_6,
		arg.DeltaValue_6,
		arg.DeltaEnabled_6,
		arg.DeltaDescription_6,
		arg.DeltaOrder_6,
		arg.CreatedAt_6,
		arg.UpdatedAt_6,
		arg.ID_7,
		arg.HttpID_7,
		arg.Key_7,
		arg.Value_7,
		arg.Enabled_7,
		arg.Description_7,
		arg.Order_7,
		arg.ParentHttpBodyUrlencodedID_7,
		arg.IsDelta_7,
		arg.DeltaKey_7,
		arg.DeltaValue_7,
		arg.DeltaEnabled_7,
		arg.DeltaDescription_7,
		arg.DeltaOrder_7,
		arg.CreatedAt_7,
		arg.UpdatedAt_7,
		arg.ID_8,
		arg.HttpID_8,
		arg.Key_8,
		arg.Value_8,
		arg.Enabled_8,
		arg.Description_8,
		arg.Order_8,
		arg.ParentHttpBodyUrlencodedID_8,
		arg.IsDelta_8,
		arg.DeltaKey_8,
		arg.DeltaValue_8,
		arg.DeltaEnabled_8,
		arg.DeltaDescription_8,
		arg.DeltaOrder_8,
		arg.CreatedAt_8,
		arg.UpdatedAt_8,
		arg.ID_9,
		arg.HttpID_9,
		arg.Key_9,
		arg.Value_9,
		arg.Enabled_9,
		arg.Description_9,
		arg.Order_9,
		arg.ParentHttpBodyUrlencodedID_9,
		arg.IsDelta_9,
		arg.DeltaKey_9,
		arg.DeltaValue_9,
		arg.DeltaEnabled_9,
		arg.DeltaDescription_9,
		arg.DeltaOrder_9,
		arg.CreatedAt_9,
		arg.UpdatedAt_9,
		arg.ID_10,
		arg.HttpID_10,
		arg.Key_10,
		arg.Value_10,
		arg.Enabled_10,
		arg.Description_10,
		arg.Order_10,
		arg.ParentHttpBodyUrlencodedID_10,
		arg.IsDelta_10,
		arg.DeltaKey_10,
		arg.DeltaValue_10,
		arg.DeltaEnabled_10,
		arg.DeltaDescription_10,
		arg.DeltaOrder_10,
		arg.CreatedAt_10,
		arg.UpdatedAt_10,
	)
	return err
}

const createHTTPHeader = `-- name: CreateHTTPHeader :exec
INSERT INTO http_header (
  id, http_id, header_key, header_value, description, enabled,
  parent_header_id, is_delta, delta_header_key, delta_header_value,
  delta_description, delta_enabled, prev, next, created_at, updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPHeaderParams struct {
	ID               idwrap.IDWrap
	HttpID           idwrap.IDWrap
	HeaderKey        string
	HeaderValue      string
	Description      string
	Enabled          bool
	ParentHeaderID   *idwrap.IDWrap
	IsDelta          bool
	DeltaHeaderKey   *string
	DeltaHeaderValue *string
	DeltaDescription *string
	DeltaEnabled     *bool
	Prev             *idwrap.IDWrap
	Next             *idwrap.IDWrap
	CreatedAt        int64
	UpdatedAt        int64
}

func (q *Queries) CreateHTTPHeader(ctx context.Context, arg CreateHTTPHeaderParams) error {
	_, err := q.exec(ctx, q.createHTTPHeaderStmt, createHTTPHeader,
		arg.ID,
		arg.HttpID,
		arg.HeaderKey,
		arg.HeaderValue,
		arg.Description,
		arg.Enabled,
		arg.ParentHeaderID,
		arg.IsDelta,
		arg.DeltaHeaderKey,
		arg.DeltaHeaderValue,
		arg.DeltaDescription,
		arg.DeltaEnabled,
		arg.Prev,
		arg.Next,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createHTTPResponse = `-- name: CreateHTTPResponse :exec
INSERT INTO http_response (
  id, http_id, status, body, time, duration, size, created_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPResponseParams struct {
	ID        idwrap.IDWrap
	HttpID    idwrap.IDWrap
	Status    interface{}
	Body      []byte
	Time      time.Time
	Duration  interface{}
	Size      interface{}
	CreatedAt int64
}

func (q *Queries) CreateHTTPResponse(ctx context.Context, arg CreateHTTPResponseParams) error {
	_, err := q.exec(ctx, q.createHTTPResponseStmt, createHTTPResponse,
		arg.ID,
		arg.HttpID,
		arg.Status,
		arg.Body,
		arg.Time,
		arg.Duration,
		arg.Size,
		arg.CreatedAt,
	)
	return err
}

const createHTTPResponseAssert = `-- name: CreateHTTPResponseAssert :exec
INSERT INTO http_response_assert (
  id, http_id, value, success, created_at
)
VALUES (?, ?, ?, ?, ?)
`

type CreateHTTPResponseAssertParams struct {
	ID        []byte
	HttpID    []byte
	Value     string
	Success   bool
	CreatedAt int64
}

func (q *Queries) CreateHTTPResponseAssert(ctx context.Context, arg CreateHTTPResponseAssertParams) error {
	_, err := q.exec(ctx, q.createHTTPResponseAssertStmt, createHTTPResponseAssert,
		arg.ID,
		arg.HttpID,
		arg.Value,
		arg.Success,
		arg.CreatedAt,
	)
	return err
}

const createHTTPResponseAssertBulk = `-- name: CreateHTTPResponseAssertBulk :exec
INSERT INTO http_response_assert (
  id, http_id, value, success, created_at
)
VALUES
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?)
`

type CreateHTTPResponseAssertBulkParams struct {
	ID           []byte
	HttpID       []byte
	Value        string
	Success      bool
	CreatedAt    int64
	ID_2         []byte
	HttpID_2     []byte
	Value_2      string
	Success_2    bool
	CreatedAt_2  int64
	ID_3         []byte
	HttpID_3     []byte
	Value_3      string
	Success_3    bool
	CreatedAt_3  int64
	ID_4         []byte
	HttpID_4     []byte
	Value_4      string
	Success_4    bool
	CreatedAt_4  int64
	ID_5         []byte
	HttpID_5     []byte
	Value_5      string
	Success_5    bool
	CreatedAt_5  int64
	ID_6         []byte
	HttpID_6     []byte
	Value_6      string
	Success_6    bool
	CreatedAt_6  int64
	ID_7         []byte
	HttpID_7     []byte
	Value_7      string
	Success_7    bool
	CreatedAt_7  int64
	ID_8         []byte
	HttpID_8     []byte
	Value_8      string
	Success_8    bool
	CreatedAt_8  int64
	ID_9         []byte
	HttpID_9     []byte
	Value_9      string
	Success_9    bool
	CreatedAt_9  int64
	ID_10        []byte
	HttpID_10    []byte
	Value_10     string
	Success_10   bool
	CreatedAt_10 int64
}

func (q *Queries) CreateHTTPResponseAssertBulk(ctx context.Context, arg CreateHTTPResponseAssertBulkParams) error {
	_, err := q.exec(ctx, q.createHTTPResponseAssertBulkStmt, createHTTPResponseAssertBulk,
		arg.ID,
		arg.HttpID,
		arg.Value,
		arg.Success,
		arg.CreatedAt,
		arg.ID_2,
		arg.HttpID_2,
		arg.Value_2,
		arg.Success_2,
		arg.CreatedAt_2,
		arg.ID_3,
		arg.HttpID_3,
		arg.Value_3,
		arg.Success_3,
		arg.CreatedAt_3,
		arg.ID_4,
		arg.HttpID_4,
		arg.Value_4,
		arg.Success_4,
		arg.CreatedAt_4,
		arg.ID_5,
		arg.HttpID_5,
		arg.Value_5,
		arg.Success_5,
		arg.CreatedAt_5,
		arg.ID_6,
		arg.HttpID_6,
		arg.Value_6,
		arg.Success_6,
		arg.CreatedAt_6,
		arg.ID_7,
		arg.HttpID_7,
		arg.Value_7,
		arg.Success_7,
		arg.CreatedAt_7,
		arg.ID_8,
		arg.HttpID_8,
		arg.Value_8,
		arg.Success_8,
		arg.CreatedAt_8,
		arg.ID_9,
		arg.HttpID_9,
		arg.Value_9,
		arg.Success_9,
		arg.CreatedAt_9,
		arg.ID_10,
		arg.HttpID_10,
		arg.Value_10,
		arg.Success_10,
		arg.CreatedAt_10,
	)
	return err
}

const createHTTPResponseBulk = `-- name: CreateHTTPResponseBulk :exec
INSERT INTO http_response (
  id, http_id, status, body, time, duration, size, created_at
)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPResponseBulkParams struct {
	ID           idwrap.IDWrap
	HttpID       idwrap.IDWrap
	Status       interface{}
	Body         []byte
	Time         time.Time
	Duration     interface{}
	Size         interface{}
	CreatedAt    int64
	ID_2         idwrap.IDWrap
	HttpID_2     idwrap.IDWrap
	Status_2     interface{}
	Body_2       []byte
	Time_2       time.Time
	Duration_2   interface{}
	Size_2       interface{}
	CreatedAt_2  int64
	ID_3         idwrap.IDWrap
	HttpID_3     idwrap.IDWrap
	Status_3     interface{}
	Body_3       []byte
	Time_3       time.Time
	Duration_3   interface{}
	Size_3       interface{}
	CreatedAt_3  int64
	ID_4         idwrap.IDWrap
	HttpID_4     idwrap.IDWrap
	Status_4     interface{}
	Body_4       []byte
	Time_4       time.Time
	Duration_4   interface{}
	Size_4       interface{}
	CreatedAt_4  int64
	ID_5         idwrap.IDWrap
	HttpID_5     idwrap.IDWrap
	Status_5     interface{}
	Body_5       []byte
	Time_5       time.Time
	Duration_5   interface{}
	Size_5       interface{}
	CreatedAt_5  int64
	ID_6         idwrap.IDWrap
	HttpID_6     idwrap.IDWrap
	Status_6     interface{}
	Body_6       []byte
	Time_6       time.Time
	Duration_6   interface{}
	Size_6       interface{}
	CreatedAt_6  int64
	ID_7         idwrap.IDWrap
	HttpID_7     idwrap.IDWrap
	Status_7     interface{}
	Body_7       []byte
	Time_7       time.Time
	Duration_7   interface{}
	Size_7       interface{}
	CreatedAt_7  int64
	ID_8         idwrap.IDWrap
	HttpID_8     idwrap.IDWrap
	Status_8     interface{}
	Body_8       []byte
	Time_8       time.Time
	Duration_8   interface{}
	Size_8       interface{}
	CreatedAt_8  int64
	ID_9         idwrap.IDWrap
	HttpID_9     idwrap.IDWrap
	Status_9     interface{}
	Body_9       []byte
	Time_9       time.Time
	Duration_9   interface{}
	Size_9       interface{}
	CreatedAt_9  int64
	ID_10        idwrap.IDWrap
	HttpID_10    idwrap.IDWrap
	Status_10    interface{}
	Body_10      []byte
	Time_10      time.Time
	Duration_10  interface{}
	Size_10      interface{}
	CreatedAt_10 int64
}

func (q *Queries) CreateHTTPResponseBulk(ctx context.Context, arg CreateHTTPResponseBulkParams) error {
	_, err := q.exec(ctx, q.createHTTPResponseBulkStmt, createHTTPResponseBulk,
		arg.ID,
		arg.HttpID,
		arg.Status,
		arg.Body,
		arg.Time,
		arg.Duration,
		arg.Size,
		arg.CreatedAt,
		arg.ID_2,
		arg.HttpID_2,
		arg.Status_2,
		arg.Body_2,
		arg.Time_2,
		arg.Duration_2,
		arg.Size_2,
		arg.CreatedAt_2,
		arg.ID_3,
		arg.HttpID_3,
		arg.Status_3,
		arg.Body_3,
		arg.Time_3,
		arg.Duration_3,
		arg.Size_3,
		arg.CreatedAt_3,
		arg.ID_4,
		arg.HttpID_4,
		arg.Status_4,
		arg.Body_4,
		arg.Time_4,
		arg.Duration_4,
		arg.Size_4,
		arg.CreatedAt_4,
		arg.ID_5,
		arg.HttpID_5,
		arg.Status_5,
		arg.Body_5,
		arg.Time_5,
		arg.Duration_5,
		arg.Size_5,
		arg.CreatedAt_5,
		arg.ID_6,
		arg.HttpID_6,
		arg.Status_6,
		arg.Body_6,
		arg.Time_6,
		arg.Duration_6,
		arg.Size_6,
		arg.CreatedAt_6,
		arg.ID_7,
		arg.HttpID_7,
		arg.Status_7,
		arg.Body_7,
		arg.Time_7,
		arg.Duration_7,
		arg.Size_7,
		arg.CreatedAt_7,
		arg.ID_8,
		arg.HttpID_8,
		arg.Status_8,
		arg.Body_8,
		arg.Time_8,
		arg.Duration_8,
		arg.Size_8,
		arg.CreatedAt_8,
		arg.ID_9,
		arg.HttpID_9,
		arg.Status_9,
		arg.Body_9,
		arg.Time_9,
		arg.Duration_9,
		arg.Size_9,
		arg.CreatedAt_9,
		arg.ID_10,
		arg.HttpID_10,
		arg.Status_10,
		arg.Body_10,
		arg.Time_10,
		arg.Duration_10,
		arg.Size_10,
		arg.CreatedAt_10,
	)
	return err
}

const createHTTPResponseHeader = `-- name: CreateHTTPResponseHeader :exec
INSERT INTO http_response_header (
  id, http_id, key, value, created_at
)
VALUES (?, ?, ?, ?, ?)
`

type CreateHTTPResponseHeaderParams struct {
	ID        idwrap.IDWrap
	HttpID    []byte
	Key       string
	Value     string
	CreatedAt int64
}

func (q *Queries) CreateHTTPResponseHeader(ctx context.Context, arg CreateHTTPResponseHeaderParams) error {
	_, err := q.exec(ctx, q.createHTTPResponseHeaderStmt, createHTTPResponseHeader,
		arg.ID,
		arg.HttpID,
		arg.Key,
		arg.Value,
		arg.CreatedAt,
	)
	return err
}

const createHTTPResponseHeaderBulk = `-- name: CreateHTTPResponseHeaderBulk :exec
INSERT INTO http_response_header (
  id, http_id, key, value, created_at
)
VALUES
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?)
`

type CreateHTTPResponseHeaderBulkParams struct {
	ID           idwrap.IDWrap
	HttpID       []byte
	Key          string
	Value        string
	CreatedAt    int64
	ID_2         idwrap.IDWrap
	HttpID_2     []byte
	Key_2        string
	Value_2      string
	CreatedAt_2  int64
	ID_3         idwrap.IDWrap
	HttpID_3     []byte
	Key_3        string
	Value_3      string
	CreatedAt_3  int64
	ID_4         idwrap.IDWrap
	HttpID_4     []byte
	Key_4        string
	Value_4      string
	CreatedAt_4  int64
	ID_5         idwrap.IDWrap
	HttpID_5     []byte
	Key_5        string
	Value_5      string
	CreatedAt_5  int64
	ID_6         idwrap.IDWrap
	HttpID_6     []byte
	Key_6        string
	Value_6      string
	CreatedAt_6  int64
	ID_7         idwrap.IDWrap
	HttpID_7     []byte
	Key_7        string
	Value_7      string
	CreatedAt_7  int64
	ID_8         idwrap.IDWrap
	HttpID_8     []byte
	Key_8        string
	Value_8      string
	CreatedAt_8  int64
	ID_9         idwrap.IDWrap
	HttpID_9     []byte
	Key_9        string
	Value_9      string
	CreatedAt_9  int64
	ID_10        idwrap.IDWrap
	HttpID_10    []byte
	Key_10       string
	Value_10     string
	CreatedAt_10 int64
}

func (q *Queries) CreateHTTPResponseHeaderBulk(ctx context.Context, arg CreateHTTPResponseHeaderBulkParams) error {
	_, err := q.exec(ctx, q.createHTTPResponseHeaderBulkStmt, createHTTPResponseHeaderBulk,
		arg.ID,
		arg.HttpID,
		arg.Key,
		arg.Value,
		arg.CreatedAt,
		arg.ID_2,
		arg.HttpID_2,
		arg.Key_2,
		arg.Value_2,
		arg.CreatedAt_2,
		arg.ID_3,
		arg.HttpID_3,
		arg.Key_3,
		arg.Value_3,
		arg.CreatedAt_3,
		arg.ID_4,
		arg.HttpID_4,
		arg.Key_4,
		arg.Value_4,
		arg.CreatedAt_4,
		arg.ID_5,
		arg.HttpID_5,
		arg.Key_5,
		arg.Value_5,
		arg.CreatedAt_5,
		arg.ID_6,
		arg.HttpID_6,
		arg.Key_6,
		arg.Value_6,
		arg.CreatedAt_6,
		arg.ID_7,
		arg.HttpID_7,
		arg.Key_7,
		arg.Value_7,
		arg.CreatedAt_7,
		arg.ID_8,
		arg.HttpID_8,
		arg.Key_8,
		arg.Value_8,
		arg.CreatedAt_8,
		arg.ID_9,
		arg.HttpID_9,
		arg.Key_9,
		arg.Value_9,
		arg.CreatedAt_9,
		arg.ID_10,
		arg.HttpID_10,
		arg.Key_10,
		arg.Value_10,
		arg.CreatedAt_10,
	)
	return err
}

const createHTTPSearchParam = `-- name: CreateHTTPSearchParam :exec
INSERT INTO http_search_param (
  id, http_id, key, value, description, enabled, "order",
  parent_http_search_param_id, is_delta, delta_key, delta_value,
  delta_description, delta_enabled, created_at, updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPSearchParamParams struct {
	ID                      idwrap.IDWrap
	HttpID                  idwrap.IDWrap
	Key                     string
	Value                   string
	Description             string
	Enabled                 bool
	Order                   float64
	ParentHttpSearchParamID []byte
	IsDelta                 bool
	DeltaKey                sql.NullString
	DeltaValue              sql.NullString
	DeltaDescription        *string
	DeltaEnabled            *bool
	CreatedAt               int64
	UpdatedAt               int64
}

func (q *Queries) CreateHTTPSearchParam(ctx context.Context, arg CreateHTTPSearchParamParams) error {
	_, err := q.exec(ctx, q.createHTTPSearchParamStmt, createHTTPSearchParam,
		arg.ID,
		arg.HttpID,
		arg.Key,
		arg.Value,
		arg.Description,
		arg.Enabled,
		arg.Order,
		arg.ParentHttpSearchParamID,
		arg.IsDelta,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaDescription,
		arg.DeltaEnabled,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createHeader = `-- name: CreateHeader :exec
INSERT INTO
  example_header (id, example_id, delta_parent_id, header_key, enable, description, value, prev, next)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHeaderParams struct {
	ID            idwrap.IDWrap
	ExampleID     idwrap.IDWrap
	DeltaParentID *idwrap.IDWrap
	HeaderKey     string
	Enable        bool
	Description   string
	Value         string
	Prev          *idwrap.IDWrap
	Next          *idwrap.IDWrap
}

func (q *Queries) CreateHeader(ctx context.Context, arg CreateHeaderParams) error {
	_, err := q.exec(ctx, q.createHeaderStmt, createHeader,
		arg.ID,
		arg.ExampleID,
		arg.DeltaParentID,
		arg.HeaderKey,
		arg.Enable,
		arg.Description,
		arg.Value,
		arg.Prev,
		arg.Next,
	)
	return err
}

const createHeaderBulk = `-- name: CreateHeaderBulk :exec
INSERT INTO
  example_header (id, example_id, delta_parent_id, header_key, enable, description, value, prev, next)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHeaderBulkParams struct {
	ID               idwrap.IDWrap
	ExampleID        idwrap.IDWrap
	DeltaParentID    *idwrap.IDWrap
	HeaderKey        string
	Enable           bool
	Description      string
	Value            string
	Prev             *idwrap.IDWrap
	Next             *idwrap.IDWrap
	ID_2             idwrap.IDWrap
	ExampleID_2      idwrap.IDWrap
	DeltaParentID_2  *idwrap.IDWrap
	HeaderKey_2      string
	Enable_2         bool
	Description_2    string
	Value_2          string
	Prev_2           *idwrap.IDWrap
	Next_2           *idwrap.IDWrap
	ID_3             idwrap.IDWrap
	ExampleID_3      idwrap.IDWrap
	DeltaParentID_3  *idwrap.IDWrap
	HeaderKey_3      string
	Enable_3         bool
	Description_3    string
	Value_3          string
	Prev_3           *idwrap.IDWrap
	Next_3           *idwrap.IDWrap
	ID_4             idwrap.IDWrap
	ExampleID_4      idwrap.IDWrap
	DeltaParentID_4  *idwrap.IDWrap
	HeaderKey_4      string
	Enable_4         bool
	Description_4    string
	Value_4          string
	Prev_4           *idwrap.IDWrap
	Next_4           *idwrap.IDWrap
	ID_5             idwrap.IDWrap
	ExampleID_5      idwrap.IDWrap
	DeltaParentID_5  *idwrap.IDWrap
	HeaderKey_5      string
	Enable_5         bool
	Description_5    string
	Value_5          string
	Prev_5           *idwrap.IDWrap
	Next_5           *idwrap.IDWrap
	ID_6             idwrap.IDWrap
	ExampleID_6      idwrap.IDWrap
	DeltaParentID_6  *idwrap.IDWrap
	HeaderKey_6      string
	Enable_6         bool
	Description_6    string
	Value_6          string
	Prev_6           *idwrap.IDWrap
	Next_6           *idwrap.IDWrap
	ID_7             idwrap.IDWrap
	ExampleID_7      idwrap.IDWrap
	DeltaParentID_7  *idwrap.IDWrap
	HeaderKey_7      string
	Enable_7         bool
	Description_7    string
	Value_7          string
	Prev_7           *idwrap.IDWrap
	Next_7           *idwrap.IDWrap
	ID_8             idwrap.IDWrap
	ExampleID_8      idwrap.IDWrap
	DeltaParentID_8  *idwrap.IDWrap
	HeaderKey_8      string
	Enable_8         bool
	Description_8    string
	Value_8          string
	Prev_8           *idwrap.IDWrap
	Next_8           *idwrap.IDWrap
	ID_9             idwrap.IDWrap
	ExampleID_9      idwrap.IDWrap
	DeltaParentID_9  *idwrap.IDWrap
	HeaderKey_9      string
	Enable_9         bool
	Description_9    string
	Value_9          string
	Prev_9           *idwrap.IDWrap
	Next_9           *idwrap.IDWrap
	ID_10            idwrap.IDWrap
	ExampleID_10     idwrap.IDWrap
	DeltaParentID_10 *idwrap.IDWrap
	HeaderKey_10     string
	Enable_10        bool
	Description_10   string
	Value_10         string
	Prev_10          *idwrap.IDWrap
	Next_10          *idwrap.IDWrap
	ID_11            idwrap.IDWrap
	ExampleID_11     idwrap.IDWrap
	DeltaParentID_11 *idwrap.IDWrap
	HeaderKey_11     string
	Enable_11        bool
	Description_11   string
	Value_11         string
	Prev_11          *idwrap.IDWrap
	Next_11          *idwrap.IDWrap
	ID_12            idwrap.IDWrap
	ExampleID_12     idwrap.IDWrap
	DeltaParentID_12 *idwrap.IDWrap
	HeaderKey_12     string
	Enable_12        bool
	Description_12   string
	Value_12         string
	Prev_12          *idwrap.IDWrap
	Next_12          *idwrap.IDWrap
	ID_13            idwrap.IDWrap
	ExampleID_13     idwrap.IDWrap
	DeltaParentID_13 *idwrap.IDWrap
	HeaderKey_13     string
	Enable_13        bool
	Description_13   string
	Value_13         string
	Prev_13          *idwrap.IDWrap
	Next_13          *idwrap.IDWrap
	ID_14            idwrap.IDWrap
	ExampleID_14     idwrap.IDWrap
	DeltaParentID_14 *idwrap.IDWrap
	HeaderKey_14     string
	Enable_14        bool
	Description_14   string
	Value_14         string
	Prev_14          *idwrap.IDWrap
	Next_14          *idwrap.IDWrap
	ID_15            idwrap.IDWrap
	ExampleID_15     idwrap.IDWrap
	DeltaParentID_15 *idwrap.IDWrap
	HeaderKey_15     string
	Enable_15        bool
	Description_15   string
	Value_15         string
	Prev_15          *idwrap.IDWrap
	Next_15          *idwrap.IDWrap
}

func (q *Queries) CreateHeaderBulk(ctx context.Context, arg CreateHeaderBulkParams) error {
	_, err := q.exec(ctx, q.createHeaderBulkStmt, createHeaderBulk,
		arg.ID,
		arg.ExampleID,
		arg.DeltaParentID,
		arg.HeaderKey,
		arg.Enable,
		arg.Description,
		arg.Value,
		arg.Prev,
		arg.Next,
		arg.ID_2,
		arg.ExampleID_2,
		arg.DeltaParentID_2,
		arg.HeaderKey_2,
		arg.Enable_2,
		arg.Description_2,
		arg.Value_2,
		arg.Prev_2,
		arg.Next_2,
		arg.ID_3,
		arg.ExampleID_3,
		arg.DeltaParentID_3,
		arg.HeaderKey_3,
		arg.Enable_3,
		arg.Description_3,
		arg.Value_3,
		arg.Prev_3,
		arg.Next_3,
		arg.ID_4,
		arg.ExampleID_4,
		arg.DeltaParentID_4,
		arg.HeaderKey_4,
		arg.Enable_4,
		arg.Description_4,
		arg.Value_4,
		arg.Prev_4,
		arg.Next_4,
		arg.ID_5,
		arg.ExampleID_5,
		arg.DeltaParentID_5,
		arg.HeaderKey_5,
		arg.Enable_5,
		arg.Description_5,
		arg.Value_5,
		arg.Prev_5,
		arg.Next_5,
		arg.ID_6,
		arg.ExampleID_6,
		arg.DeltaParentID_6,
		arg.HeaderKey_6,
		arg.Enable_6,
		arg.Description_6,
		arg.Value_6,
		arg.Prev_6,
		arg.Next_6,
		arg.ID_7,
		arg.ExampleID_7,
		arg.DeltaParentID_7,
		arg.HeaderKey_7,
		arg.Enable_7,
		arg.Description_7,
		arg.Value_7,
		arg.Prev_7,
		arg.Next_7,
		arg.ID_8,
		arg.ExampleID_8,
		arg.DeltaParentID_8,
		arg.HeaderKey_8,
		arg.Enable_8,
		arg.Description_8,
		arg.Value_8,
		arg.Prev_8,
		arg.Next_8,
		arg.ID_9,
		arg.ExampleID_9,
		arg.DeltaParentID_9,
		arg.HeaderKey_9,
		arg.Enable_9,
		arg.Description_9,
		arg.Value_9,
		arg.Prev_9,
		arg.Next_9,
		arg.ID_10,
		arg.ExampleID_10,
		arg.DeltaParentID_10,
		arg.HeaderKey_10,
		arg.Enable_10,
		arg.Description_10,
		arg.Value_10,
		arg.Prev_10,
		arg.Next_10,
		arg.ID_11,
		arg.ExampleID_11,
		arg.DeltaParentID_11,
		arg.HeaderKey_11,
		arg.Enable_11,
		arg.Description_11,
		arg.Value_11,
		arg.Prev_11,
		arg.Next_11,
		arg.ID_12,
		arg.ExampleID_12,
		arg.DeltaParentID_12,
		arg.HeaderKey_12,
		arg.Enable_12,
		arg.Description_12,
		arg.Value_12,
		arg.Prev_12,
		arg.Next_12,
		arg.ID_13,
		arg.ExampleID_13,
		arg.DeltaParentID_13,
		arg.HeaderKey_13,
		arg.Enable_13,
		arg.Description_13,
		arg.Value_13,
		arg.Prev_13,
		arg.Next_13,
		arg.ID_14,
		arg.ExampleID_14,
		arg.DeltaParentID_14,
		arg.HeaderKey_14,
		arg.Enable_14,
		arg.Description_14,
		arg.Value_14,
		arg.Prev_14,
		arg.Next_14,
		arg.ID_15,
		arg.ExampleID_15,
		arg.DeltaParentID_15,
		arg.HeaderKey_15,
		arg.Enable_15,
		arg.Description_15,
		arg.Value_15,
		arg.Prev_15,
		arg.Next_15,
	)
	return err
}

const createItemApi = `-- name: CreateItemApi :exec
INSERT INTO
  item_api (id, folder_id, name, url, method, version_parent_id, delta_parent_id, hidden, prev, next)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateItemApiParams struct {
	ID              idwrap.IDWrap
	FolderID        *idwrap.IDWrap
	Name            string
	Url             string
	Method          string
	VersionParentID *idwrap.IDWrap
	DeltaParentID   *idwrap.IDWrap
	Hidden          bool
	Prev            *idwrap.IDWrap
	Next            *idwrap.IDWrap
}

func (q *Queries) CreateItemApi(ctx context.Context, arg CreateItemApiParams) error {
	_, err := q.exec(ctx, q.createItemApiStmt, createItemApi,
		arg.ID,
		arg.FolderID,
		arg.Name,
		arg.Url,
		arg.Method,
		arg.VersionParentID,
		arg.DeltaParentID,
		arg.Hidden,
		arg.Prev,
		arg.Next,
	)
	return err
}

const createItemApiBulk = `-- name: CreateItemApiBulk :exec
INSERT INTO
  item_api (id, folder_id, name, url, method, version_parent_id, delta_parent_id, hidden, prev, next)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateItemApiBulkParams struct {
	ID                 idwrap.IDWrap
	FolderID           *idwrap.IDWrap
	Name               string
	Url                string
	Method             string
	VersionParentID    *idwrap.IDWrap
	DeltaParentID      *idwrap.IDWrap
	Hidden             bool
	Prev               *idwrap.IDWrap
	Next               *idwrap.IDWrap
	ID_2               idwrap.IDWrap
	FolderID_2         *idwrap.IDWrap
	Name_2             string
	Url_2              string
	Method_2           string
	VersionParentID_2  *idwrap.IDWrap
	DeltaParentID_2    *idwrap.IDWrap
	Hidden_2           bool
	Prev_2             *idwrap.IDWrap
	Next_2             *idwrap.IDWrap
	ID_3               idwrap.IDWrap
	FolderID_3         *idwrap.IDWrap
	Name_3             string
	Url_3              string
	Method_3           string
	VersionParentID_3  *idwrap.IDWrap
	DeltaParentID_3    *idwrap.IDWrap
	Hidden_3           bool
	Prev_3             *idwrap.IDWrap
	Next_3             *idwrap.IDWrap
	ID_4               idwrap.IDWrap
	FolderID_4         *idwrap.IDWrap
	Name_4             string
	Url_4              string
	Method_4           string
	VersionParentID_4  *idwrap.IDWrap
	DeltaParentID_4    *idwrap.IDWrap
	Hidden_4           bool
	Prev_4             *idwrap.IDWrap
	Next_4             *idwrap.IDWrap
	ID_5               idwrap.IDWrap
	FolderID_5         *idwrap.IDWrap
	Name_5             string
	Url_5              string
	Method_5           string
	VersionParentID_5  *idwrap.IDWrap
	DeltaParentID_5    *idwrap.IDWrap
	Hidden_5           bool
	Prev_5             *idwrap.IDWrap
	Next_5             *idwrap.IDWrap
	ID_6               idwrap.IDWrap
	FolderID_6         *idwrap.IDWrap
	Name_6             string
	Url_6              string
	Method_6           string
	VersionParentID_6  *idwrap.IDWrap
	DeltaParentID_6    *idwrap.IDWrap
	Hidden_6           bool
	Prev_6             *idwrap.IDWrap
	Next_6             *idwrap.IDWrap
	ID_7               idwrap.IDWrap
	FolderID_7         *idwrap.IDWrap
	Name_7             string
	Url_7              string
	Method_7           string
	VersionParentID_7  *idwrap.IDWrap
	DeltaParentID_7    *idwrap.IDWrap
	Hidden_7           bool
	Prev_7             *idwrap.IDWrap
	Next_7             *idwrap.IDWrap
	ID_8               idwrap.IDWrap
	FolderID_8         *idwrap.IDWrap
	Name_8             string
	Url_8              string
	Method_8           string
	VersionParentID_8  *idwrap.IDWrap
	DeltaParentID_8    *idwrap.IDWrap
	Hidden_8           bool
	Prev_8             *idwrap.IDWrap
	Next_8             *idwrap.IDWrap
	ID_9               idwrap.IDWrap
	FolderID_9         *idwrap.IDWrap
	Name_9             string
	Url_9              string
	Method_9           string
	VersionParentID_9  *idwrap.IDWrap
	DeltaParentID_9    *idwrap.IDWrap
	Hidden_9           bool
	Prev_9             *idwrap.IDWrap
	Next_9             *idwrap.IDWrap
	ID_10              idwrap.IDWrap
	FolderID_10        *idwrap.IDWrap
	Name_10            string
	Url_10             string
	Method_10          string
	VersionParentID_10 *idwrap.IDWrap
	DeltaParentID_10   *idwrap.IDWrap
	Hidden_10          bool
	Prev_10            *idwrap.IDWrap
	Next_10            *idwrap.IDWrap
}

func (q *Queries) CreateItemApiBulk(ctx context.Context, arg CreateItemApiBulkParams) error {
	_, err := q.exec(ctx, q.createItemApiBulkStmt, createItemApiBulk,
		arg.ID,
		arg.FolderID,
		arg.Name,
		arg.Url,
		arg.Method,
		arg.VersionParentID,
		arg.DeltaParentID,
		arg.Hidden,
		arg.Prev,
		arg.Next,
		arg.ID_2,
		arg.FolderID_2,
		arg.Name_2,
		arg.Url_2,
		arg.Method_2,
		arg.VersionParentID_2,
		arg.DeltaParentID_2,
		arg.Hidden_2,
		arg.Prev_2,
		arg.Next_2,
		arg.ID_3,
		arg.FolderID_3,
		arg.Name_3,
		arg.Url_3,
		arg.Method_3,
		arg.VersionParentID_3,
		arg.DeltaParentID_3,
		arg.Hidden_3,
		arg.Prev_3,
		arg.Next_3,
		arg.ID_4,
		arg.FolderID_4,
		arg.Name_4,
		arg.Url_4,
		arg.Method_4,
		arg.VersionParentID_4,
		arg.DeltaParentID_4,
		arg.Hidden_4,
		arg.Prev_4,
		arg.Next_4,
		arg.ID_5,
		arg.FolderID_5,
		arg.Name_5,
		arg.Url_5,
		arg.Method_5,
		arg.VersionParentID_5,
		arg.DeltaParentID_5,
		arg.Hidden_5,
		arg.Prev_5,
		arg.Next_5,
		arg.ID_6,
		arg.FolderID_6,
		arg.Name_6,
		arg.Url_6,
		arg.Method_6,
		arg.VersionParentID_6,
		arg.DeltaParentID_6,
		arg.Hidden_6,
		arg.Prev_6,
		arg.Next_6,
		arg.ID_7,
		arg.FolderID_7,
		arg.Name_7,
		arg.Url_7,
		arg.Method_7,
		arg.VersionParentID_7,
		arg.DeltaParentID_7,
		arg.Hidden_7,
		arg.Prev_7,
		arg.Next_7,
		arg.ID_8,
		arg.FolderID_8,
		arg.Name_8,
		arg.Url_8,
		arg.Method_8,
		arg.VersionParentID_8,
		arg.DeltaParentID_8,
		arg.Hidden_8,
		arg.Prev_8,
		arg.Next_8,
		arg.ID_9,
		arg.FolderID_9,
		arg.Name_9,
		arg.Url_9,
		arg.Method_9,
		arg.VersionParentID_9,
		arg.DeltaParentID_9,
		arg.Hidden_9,
		arg.Prev_9,
		arg.Next_9,
		arg.ID_10,
		arg.FolderID_10,
		arg.Name_10,
		arg.Url_10,
		arg.Method_10,
		arg.VersionParentID_10,
		arg.DeltaParentID_10,
		arg.Hidden_10,
		arg.Prev_10,
		arg.Next_10,
	)
	return err
}

const createItemApiExample = `-- name: CreateItemApiExample :exec
INSERT INTO
  item_api_example (
    id,
    item_api_id,
    is_default,
    body_type,
    name,
    version_parent_id,
    prev,
    next
  )
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateItemApiExampleParams struct {
	ID              idwrap.IDWrap
	ItemApiID       idwrap.IDWrap
	IsDefault       bool
	BodyType        int8
	Name            string
	VersionParentID *idwrap.IDWrap
	Prev            *idwrap.IDWrap
	Next            *idwrap.IDWrap
}

func (q *Queries) CreateItemApiExample(ctx context.Context, arg CreateItemApiExampleParams) error {
	_, err := q.exec(ctx, q.createItemApiExampleStmt, createItemApiExample,
		arg.ID,
		arg.ItemApiID,
		arg.IsDefault,
		arg.BodyType,
		arg.Name,
		arg.VersionParentID,
		arg.Prev,
		arg.Next,
	)
	return err
}

const createItemApiExampleBulk = `-- name: CreateItemApiExampleBulk :exec
INSERT INTO
  item_api_example (
    id,
    item_api_id,
    is_default,
    body_type,
    name,
    version_parent_id,
    prev,
    next
  )
VALUES
    (?, ?, ?, ?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateItemApiExampleBulkParams struct {
	ID                 idwrap.IDWrap
	ItemApiID          idwrap.IDWrap
	IsDefault          bool
	BodyType           int8
	Name               string
	VersionParentID    *idwrap.IDWrap
	Prev               *idwrap.IDWrap
	Next               *idwrap.IDWrap
	ID_2               idwrap.IDWrap
	ItemApiID_2        idwrap.IDWrap
	IsDefault_2        bool
	BodyType_2         int8
	Name_2             string
	VersionParentID_2  *idwrap.IDWrap
	Prev_2             *idwrap.IDWrap
	Next_2             *idwrap.IDWrap
	ID_3               idwrap.IDWrap
	ItemApiID_3        idwrap.IDWrap
	IsDefault_3        bool
	BodyType_3         int8
	Name_3             string
	VersionParentID_3  *idwrap.IDWrap
	Prev_3             *idwrap.IDWrap
	Next_3             *idwrap.IDWrap
	ID_4               idwrap.IDWrap
	ItemApiID_4        idwrap.IDWrap
	IsDefault_4        bool
	BodyType_4         int8
	Name_4             string
	VersionParentID_4  *idwrap.IDWrap
	Prev_4             *idwrap.IDWrap
	Next_4             *idwrap.IDWrap
	ID_5               idwrap.IDWrap
	ItemApiID_5        idwrap.IDWrap
	IsDefault_5        bool
	BodyType_5         int8
	Name_5             string
	VersionParentID_5  *idwrap.IDWrap
	Prev_5             *idwrap.IDWrap
	Next_5             *idwrap.IDWrap
	ID_6               idwrap.IDWrap
	ItemApiID_6        idwrap.IDWrap
	IsDefault_6        bool
	BodyType_6         int8
	Name_6             string
	VersionParentID_6  *idwrap.IDWrap
	Prev_6             *idwrap.IDWrap
	Next_6             *idwrap.IDWrap
	ID_7               idwrap.IDWrap
	ItemApiID_7        idwrap.IDWrap
	IsDefault_7        bool
	BodyType_7         int8
	Name_7             string
	VersionParentID_7  *idwrap.IDWrap
	Prev_7             *idwrap.IDWrap
	Next_7             *idwrap.IDWrap
	ID_8               idwrap.IDWrap
	ItemApiID_8        idwrap.IDWrap
	IsDefault_8        bool
	BodyType_8         int8
	Name_8             string
	VersionParentID_8  *idwrap.IDWrap
	Prev_8             *idwrap.IDWrap
	Next_8             *idwrap.IDWrap
	ID_9               idwrap.IDWrap
	ItemApiID_9        idwrap.IDWrap
	IsDefault_9        bool
	BodyType_9         int8
	Name_9             string
	VersionParentID_9  *idwrap.IDWrap
	Prev_9             *idwrap.IDWrap
	Next_9             *idwrap.IDWrap
	ID_10              idwrap.IDWrap
	ItemApiID_10       idwrap.IDWrap
	IsDefault_10       bool
	BodyType_10        int8
	Name_10            string
	VersionParentID_10 *idwrap.IDWrap
	Prev_10            *idwrap.IDWrap
	Next_10            *idwrap.IDWrap
}

func (q *Queries) CreateItemApiExampleBulk(ctx context.Context, arg CreateItemApiExampleBulkParams) error {
	_, err := q.exec(ctx, q.createItemApiExampleBulkStmt, createItemApiExampleBulk,
		arg.ID,
		arg.ItemApiID,
		arg.IsDefault,
		arg.BodyType,
		arg.Name,
		arg.VersionParentID,
		arg.Prev,
		arg.Next,
		arg.ID_2,
		arg.ItemApiID_2,
		arg.IsDefault_2,
		arg.BodyType_2,
		arg.Name_2,
		arg.VersionParentID_2,
		arg.Prev_2,
		arg.Next_2,
		arg.ID_3,
		arg.ItemApiID_3,
		arg.IsDefault_3,
		arg.BodyType_3,
		arg.Name_3,
		arg.VersionParentID_3,
		arg.Prev_3,
		arg.Next_3,
		arg.ID_4,
		arg.ItemApiID_4,
		arg.IsDefault_4,
		arg.BodyType_4,
		arg.Name_4,
		arg.VersionParentID_4,
		arg.Prev_4,
		arg.Next_4,
		arg.ID_5,
		arg.ItemApiID_5,
		arg.IsDefault_5,
		arg.BodyType_5,
		arg.Name_5,
		arg.VersionParentID_5,
		arg.Prev_5,
		arg.Next_5,
		arg.ID_6,
		arg.ItemApiID_6,
		arg.IsDefault_6,
		arg.BodyType_6,
		arg.Name_6,
		arg.VersionParentID_6,
		arg.Prev_6,
		arg.Next_6,
		arg.ID_7,
		arg.ItemApiID_7,
		arg.IsDefault_7,
		arg.BodyType_7,
		arg.Name_7,
		arg.VersionParentID_7,
		arg.Prev_7,
		arg.Next_7,
		arg.ID_8,
		arg.ItemApiID_8,
		arg.IsDefault_8,
		arg.BodyType_8,
		arg.Name_8,
		arg.VersionParentID_8,
		arg.Prev_8,
		arg.Next_8,
		arg.ID_9,
		arg.ItemApiID_9,
		arg.IsDefault_9,
		arg.BodyType_9,
		arg.Name_9,
		arg.VersionParentID_9,
		arg.Prev_9,
		arg.Next_9,
		arg.ID_10,
		arg.ItemApiID_10,
		arg.IsDefault_10,
		arg.BodyType_10,
		arg.Name_10,
		arg.VersionParentID_10,
		arg.Prev_10,
		arg.Next_10,
	)
	return err
}

const createItemFolder = `-- name: CreateItemFolder :exec
INSERT INTO
    item_folder (id, name, parent_id, prev, next)
VALUES
    (?, ?, ?, ?, ?)
`

type CreateItemFolderParams struct {
	ID       idwrap.IDWrap
	Name     string
	ParentID *idwrap.IDWrap
	Prev     *idwrap.IDWrap
	Next     *idwrap.IDWrap
}

func (q *Queries) CreateItemFolder(ctx context.Context, arg CreateItemFolderParams) error {
	_, err := q.exec(ctx, q.createItemFolderStmt, createItemFolder,
		arg.ID,
		arg.Name,
		arg.ParentID,
		arg.Prev,
		arg.Next,
	)
	return err
}

const createItemFolderBulk = `-- name: CreateItemFolderBulk :exec
INSERT INTO
    item_folder (id, name, parent_id, prev, next)
VALUES
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?)
`

type CreateItemFolderBulkParams struct {
	ID          idwrap.IDWrap
	Name        string
	ParentID    *idwrap.IDWrap
	Prev        *idwrap.IDWrap
	Next        *idwrap.IDWrap
	ID_2        idwrap.IDWrap
	Name_2      string
	ParentID_2  *idwrap.IDWrap
	Prev_2      *idwrap.IDWrap
	Next_2      *idwrap.IDWrap
	ID_3        idwrap.IDWrap
	Name_3      string
	ParentID_3  *idwrap.IDWrap
	Prev_3      *idwrap.IDWrap
	Next_3      *idwrap.IDWrap
	ID_4        idwrap.IDWrap
	Name_4      string
	ParentID_4  *idwrap.IDWrap
	Prev_4      *idwrap.IDWrap
	Next_4      *idwrap.IDWrap
	ID_5        idwrap.IDWrap
	Name_5      string
	ParentID_5  *idwrap.IDWrap
	Prev_5      *idwrap.IDWrap
	Next_5      *idwrap.IDWrap
	ID_6        idwrap.IDWrap
	Name_6      string
	ParentID_6  *idwrap.IDWrap
	Prev_6      *idwrap.IDWrap
	Next_6      *idwrap.IDWrap
	ID_7        idwrap.IDWrap
	Name_7      string
	ParentID_7  *idwrap.IDWrap
	Prev_7      *idwrap.IDWrap
	Next_7      *idwrap.IDWrap
	ID_8        idwrap.IDWrap
	Name_8      string
	ParentID_8  *idwrap.IDWrap
	Prev_8      *idwrap.IDWrap
	Next_8      *idwrap.IDWrap
	ID_9        idwrap.IDWrap
	Name_9      string
	ParentID_9  *idwrap.IDWrap
	Prev_9      *idwrap.IDWrap
	Next_9      *idwrap.IDWrap
	ID_10       idwrap.IDWrap
	Name_10     string
	ParentID_10 *idwrap.IDWrap
	Prev_10     *idwrap.IDWrap
	Next_10     *idwrap.IDWrap
}

func (q *Queries) CreateItemFolderBulk(ctx context.Context, arg CreateItemFolderBulkParams) error {
	_, err := q.exec(ctx, q.createItemFolderBulkStmt, createItemFolderBulk,
		arg.ID,
		arg.Name,
		arg.ParentID,
		arg.Prev,
		arg.Next,
		arg.ID_2,
		arg.Name_2,
		arg.ParentID_2,
		arg.Prev_2,
		arg.Next_2,
		arg.ID_3,
		arg.Name_3,
		arg.ParentID_3,
		arg.Prev_3,
		arg.Next_3,
		arg.ID_4,
		arg.Name_4,
		arg.ParentID_4,
		arg.Prev_4,
		arg.Next_4,
		arg.ID_5,
		arg.Name_5,
		arg.ParentID_5,
		arg.Prev_5,
		arg.Next_5,
		arg.ID_6,
		arg.Name_6,
		arg.ParentID_6,
		arg.Prev_6,
		arg.Next_6,
		arg.ID_7,
		arg.Name_7,
		arg.ParentID_7,
		arg.Prev_7,
		arg.Next_7,
		arg.ID_8,
		arg.Name_8,
		arg.ParentID_8,
		arg.Prev_8,
		arg.Next_8,
		arg.ID_9,
		arg.Name_9,
		arg.ParentID_9,
		arg.Prev_9,
		arg.Next_9,
		arg.ID_10,
		arg.Name_10,
		arg.ParentID_10,
		arg.Prev_10,
		arg.Next_10,
	)
	return err
}

const createMigration = `-- name: CreateMigration :exec
INSERT INTO
  migration (id, version, description, apply_at)
VALUES
  (?, ?, ?, ?)
`

type CreateMigrationParams struct {
	ID          []byte
	Version     int32
	Description string
	ApplyAt     int64
}

func (q *Queries) CreateMigration(ctx context.Context, arg CreateMigrationParams) error {
	_, err := q.exec(ctx, q.createMigrationStmt, createMigration,
		arg.ID,
		arg.Version,
		arg.Description,
		arg.ApplyAt,
	)
	return err
}

const createNodeExecution = `-- name: CreateNodeExecution :one
INSERT INTO node_execution (
  id, node_id, name, state, error, input_data, input_data_compress_type,
  output_data, output_data_compress_type, response_id, completed_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, response_id, completed_at
`

type CreateNodeExecutionParams struct {
	ID                     idwrap.IDWrap
	NodeID                 idwrap.IDWrap
	Name                   string
	State                  int8
	Error                  sql.NullString
	InputData              []byte
	InputDataCompressType  int8
	OutputData             []byte
	OutputDataCompressType int8
	ResponseID             []byte
	CompletedAt            sql.NullInt64
}

func (q *Queries) CreateNodeExecution(ctx context.Context, arg CreateNodeExecutionParams) (NodeExecution, error) {
	row := q.queryRow(ctx, q.createNodeExecutionStmt, createNodeExecution,
		arg.ID,
		arg.NodeID,
		arg.Name,
		arg.State,
		arg.Error,
		arg.InputData,
		arg.InputDataCompressType,
		arg.OutputData,
		arg.OutputDataCompressType,
		arg.ResponseID,
		arg.CompletedAt,
	)
	var i NodeExecution
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Name,
		&i.State,
		&i.Error,
		&i.InputData,
		&i.InputDataCompressType,
		&i.OutputData,
		&i.OutputDataCompressType,
		&i.ResponseID,
		&i.CompletedAt,
	)
	return i, err
}

const createQuery = `-- name: CreateQuery :exec
INSERT INTO
  example_query (id, example_id, delta_parent_id, query_key, enable, description, value)
VALUES
  (?, ?, ?, ?, ?, ?, ?)
`

type CreateQueryParams struct {
	ID            idwrap.IDWrap
	ExampleID     idwrap.IDWrap
	DeltaParentID *idwrap.IDWrap
	QueryKey      string
	Enable        bool
	Description   string
	Value         string
}

func (q *Queries) CreateQuery(ctx context.Context, arg CreateQueryParams) error {
	_, err := q.exec(ctx, q.createQueryStmt, createQuery,
		arg.ID,
		arg.ExampleID,
		arg.DeltaParentID,
		arg.QueryKey,
		arg.Enable,
		arg.Description,
		arg.Value,
	)
	return err
}

const createQueryBulk = `-- name: CreateQueryBulk :exec
INSERT INTO
  example_query (id, example_id, delta_parent_id, query_key, enable, description, value)
VALUES
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?)
`

type CreateQueryBulkParams struct {
	ID               idwrap.IDWrap
	ExampleID        idwrap.IDWrap
	DeltaParentID    *idwrap.IDWrap
	QueryKey         string
	Enable           bool
	Description      string
	Value            string
	ID_2             idwrap.IDWrap
	ExampleID_2      idwrap.IDWrap
	DeltaParentID_2  *idwrap.IDWrap
	QueryKey_2       string
	Enable_2         bool
	Description_2    string
	Value_2          string
	ID_3             idwrap.IDWrap
	ExampleID_3      idwrap.IDWrap
	DeltaParentID_3  *idwrap.IDWrap
	QueryKey_3       string
	Enable_3         bool
	Description_3    string
	Value_3          string
	ID_4             idwrap.IDWrap
	ExampleID_4      idwrap.IDWrap
	DeltaParentID_4  *idwrap.IDWrap
	QueryKey_4       string
	Enable_4         bool
	Description_4    string
	Value_4          string
	ID_5             idwrap.IDWrap
	ExampleID_5      idwrap.IDWrap
	DeltaParentID_5  *idwrap.IDWrap
	QueryKey_5       string
	Enable_5         bool
	Description_5    string
	Value_5          string
	ID_6             idwrap.IDWrap
	ExampleID_6      idwrap.IDWrap
	DeltaParentID_6  *idwrap.IDWrap
	QueryKey_6       string
	Enable_6         bool
	Description_6    string
	Value_6          string
	ID_7             idwrap.IDWrap
	ExampleID_7      idwrap.IDWrap
	DeltaParentID_7  *idwrap.IDWrap
	QueryKey_7       string
	Enable_7         bool
	Description_7    string
	Value_7          string
	ID_8             idwrap.IDWrap
	ExampleID_8      idwrap.IDWrap
	DeltaParentID_8  *idwrap.IDWrap
	QueryKey_8       string
	Enable_8         bool
	Description_8    string
	Value_8          string
	ID_9             idwrap.IDWrap
	ExampleID_9      idwrap.IDWrap
	DeltaParentID_9  *idwrap.IDWrap
	QueryKey_9       string
	Enable_9         bool
	Description_9    string
	Value_9          string
	ID_10            idwrap.IDWrap
	ExampleID_10     idwrap.IDWrap
	DeltaParentID_10 *idwrap.IDWrap
	QueryKey_10      string
	Enable_10        bool
	Description_10   string
	Value_10         string
}

func (q *Queries) CreateQueryBulk(ctx context.Context, arg CreateQueryBulkParams) error {
	_, err := q.exec(ctx, q.createQueryBulkStmt, createQueryBulk,
		arg.ID,
		arg.ExampleID,
		arg.DeltaParentID,
		arg.QueryKey,
		arg.Enable,
		arg.Description,
		arg.Value,
		arg.ID_2,
		arg.ExampleID_2,
		arg.DeltaParentID_2,
		arg.QueryKey_2,
		arg.Enable_2,
		arg.Description_2,
		arg.Value_2,
		arg.ID_3,
		arg.ExampleID_3,
		arg.DeltaParentID_3,
		arg.QueryKey_3,
		arg.Enable_3,
		arg.Description_3,
		arg.Value_3,
		arg.ID_4,
		arg.ExampleID_4,
		arg.DeltaParentID_4,
		arg.QueryKey_4,
		arg.Enable_4,
		arg.Description_4,
		arg.Value_4,
		arg.ID_5,
		arg.ExampleID_5,
		arg.DeltaParentID_5,
		arg.QueryKey_5,
		arg.Enable_5,
		arg.Description_5,
		arg.Value_5,
		arg.ID_6,
		arg.ExampleID_6,
		arg.DeltaParentID_6,
		arg.QueryKey_6,
		arg.Enable_6,
		arg.Description_6,
		arg.Value_6,
		arg.ID_7,
		arg.ExampleID_7,
		arg.DeltaParentID_7,
		arg.QueryKey_7,
		arg.Enable_7,
		arg.Description_7,
		arg.Value_7,
		arg.ID_8,
		arg.ExampleID_8,
		arg.DeltaParentID_8,
		arg.QueryKey_8,
		arg.Enable_8,
		arg.Description_8,
		arg.Value_8,
		arg.ID_9,
		arg.ExampleID_9,
		arg.DeltaParentID_9,
		arg.QueryKey_9,
		arg.Enable_9,
		arg.Description_9,
		arg.Value_9,
		arg.ID_10,
		arg.ExampleID_10,
		arg.DeltaParentID_10,
		arg.QueryKey_10,
		arg.Enable_10,
		arg.Description_10,
		arg.Value_10,
	)
	return err
}

const createTag = `-- name: CreateTag :exec
INSERT INTO
  tag (id, workspace_id, name, color)
VALUES
  (?, ?, ?, ?)
`

type CreateTagParams struct {
	ID          idwrap.IDWrap
	WorkspaceID idwrap.IDWrap
	Name        string
	Color       int8
}

func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) error {
	_, err := q.exec(ctx, q.createTagStmt, createTag,
		arg.ID,
		arg.WorkspaceID,
		arg.Name,
		arg.Color,
	)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO
  users (
    id,
    email,
    password_hash,
    provider_type,
    provider_id
  )
VALUES
  (?, ?, ?, ?, ?)
`

type CreateUserParams struct {
	ID           idwrap.IDWrap
	Email        string
	PasswordHash []byte
	ProviderType int8
	ProviderID   sql.NullString
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.exec(ctx, q.createUserStmt, createUser,
		arg.ID,
		arg.Email,
		arg.PasswordHash,
		arg.ProviderType,
		arg.ProviderID,
	)
	return err
}

const createVariable = `-- name: CreateVariable :exec
INSERT INTO
  variable (id, env_id, var_key, value, enabled, description, display_order)
VALUES
  (?, ?, ?, ?, ?, ?, ?)
`

type CreateVariableParams struct {
	ID           idwrap.IDWrap
	EnvID        idwrap.IDWrap
	VarKey       string
	Value        string
	Enabled      bool
	Description  string
	DisplayOrder float64
}

func (q *Queries) CreateVariable(ctx context.Context, arg CreateVariableParams) error {
	_, err := q.exec(ctx, q.createVariableStmt, createVariable,
		arg.ID,
		arg.EnvID,
		arg.VarKey,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.DisplayOrder,
	)
	return err
}

const createVariableBulk = `-- name: CreateVariableBulk :exec
INSERT INTO
  variable (id, env_id, var_key, value, enabled, description, display_order)
VALUES
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?)
`

type CreateVariableBulkParams struct {
	ID             idwrap.IDWrap
	EnvID          idwrap.IDWrap
	VarKey         string
	Value          string
	Enabled        bool
	Description    string
	DisplayOrder   float64
	ID_2           idwrap.IDWrap
	EnvID_2        idwrap.IDWrap
	VarKey_2       string
	Value_2        string
	Enabled_2      bool
	Description_2  string
	DisplayOrder_2 float64
	ID_3           idwrap.IDWrap
	EnvID_3        idwrap.IDWrap
	VarKey_3       string
	Value_3        string
	Enabled_3      bool
	Description_3  string
	DisplayOrder_3 float64
	ID_4           idwrap.IDWrap
	EnvID_4        idwrap.IDWrap
	VarKey_4       string
	Value_4        string
	Enabled_4      bool
	Description_4  string
	DisplayOrder_4 float64
}

func (q *Queries) CreateVariableBulk(ctx context.Context, arg CreateVariableBulkParams) error {
	_, err := q.exec(ctx, q.createVariableBulkStmt, createVariableBulk,
		arg.ID,
		arg.EnvID,
		arg.VarKey,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.DisplayOrder,
		arg.ID_2,
		arg.EnvID_2,
		arg.VarKey_2,
		arg.Value_2,
		arg.Enabled_2,
		arg.Description_2,
		arg.DisplayOrder_2,
		arg.ID_3,
		arg.EnvID_3,
		arg.VarKey_3,
		arg.Value_3,
		arg.Enabled_3,
		arg.Description_3,
		arg.DisplayOrder_3,
		arg.ID_4,
		arg.EnvID_4,
		arg.VarKey_4,
		arg.Value_4,
		arg.Enabled_4,
		arg.Description_4,
		arg.DisplayOrder_4,
	)
	return err
}

const createWorkspace = `-- name: CreateWorkspace :exec
INSERT INTO
  workspaces (id, name, updated, collection_count, flow_count, active_env, global_env, prev, next)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateWorkspaceParams struct {
	ID              idwrap.IDWrap
	Name            string
	Updated         int64
	CollectionCount int32
	FlowCount       int32
	ActiveEnv       idwrap.IDWrap
	GlobalEnv       idwrap.IDWrap
	Prev            *idwrap.IDWrap
	Next            *idwrap.IDWrap
}

func (q *Queries) CreateWorkspace(ctx context.Context, arg CreateWorkspaceParams) error {
	_, err := q.exec(ctx, q.createWorkspaceStmt, createWorkspace,
		arg.ID,
		arg.Name,
		arg.Updated,
		arg.CollectionCount,
		arg.FlowCount,
		arg.ActiveEnv,
		arg.GlobalEnv,
		arg.Prev,
		arg.Next,
	)
	return err
}

const createWorkspaceUser = `-- name: CreateWorkspaceUser :exec
INSERT INTO
  workspaces_users (id, workspace_id, user_id, role)
VALUES
  (?, ?, ?, ?)
`

type CreateWorkspaceUserParams struct {
	ID          idwrap.IDWrap
	WorkspaceID idwrap.IDWrap
	UserID      idwrap.IDWrap
	Role        int8
}

func (q *Queries) CreateWorkspaceUser(ctx context.Context, arg CreateWorkspaceUserParams) error {
	_, err := q.exec(ctx, q.createWorkspaceUserStmt, createWorkspaceUser,
		arg.ID,
		arg.WorkspaceID,
		arg.UserID,
		arg.Role,
	)
	return err
}

const deleteAssert = `-- name: DeleteAssert :exec
DELETE FROM assertion
WHERE
  id = ?
`

func (q *Queries) DeleteAssert(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteAssertStmt, deleteAssert, id)
	return err
}

const deleteAssertResult = `-- name: DeleteAssertResult :exec
DELETE FROM assertion_result
WHERE
  id = ?
`

func (q *Queries) DeleteAssertResult(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteAssertResultStmt, deleteAssertResult, id)
	return err
}

const deleteBodyForm = `-- name: DeleteBodyForm :exec
DELETE FROM example_body_form
WHERE
  id = ?
`

func (q *Queries) DeleteBodyForm(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteBodyFormStmt, deleteBodyForm, id)
	return err
}

const deleteBodyRaw = `-- name: DeleteBodyRaw :exec
DELETE FROM example_body_raw
WHERE
  id = ?
`

func (q *Queries) DeleteBodyRaw(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteBodyRawStmt, deleteBodyRaw, id)
	return err
}

const deleteBodyURLEncoded = `-- name: DeleteBodyURLEncoded :exec
DELETE FROM example_body_urlencoded
WHERE
  id = ?
`

func (q *Queries) DeleteBodyURLEncoded(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteBodyURLEncodedStmt, deleteBodyURLEncoded, id)
	return err
}

const deleteEnvironment = `-- name: DeleteEnvironment :exec
DELETE FROM environment
WHERE
  id = ?
`

func (q *Queries) DeleteEnvironment(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteEnvironmentStmt, deleteEnvironment, id)
	return err
}

const deleteExampleResp = `-- name: DeleteExampleResp :exec
DELETE FROM example_resp
WHERE
  id = ?
`

func (q *Queries) DeleteExampleResp(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteExampleRespStmt, deleteExampleResp, id)
	return err
}

const deleteExampleRespHeader = `-- name: DeleteExampleRespHeader :exec
DELETE FROM example_resp_header
WHERE
  id = ?
`

func (q *Queries) DeleteExampleRespHeader(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteExampleRespHeaderStmt, deleteExampleRespHeader, id)
	return err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM files WHERE id = ?
`

// Delete a file by ID
func (q *Queries) DeleteFile(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFileStmt, deleteFile, id)
	return err
}

const deleteFlow = `-- name: DeleteFlow :exec
DELETE FROM flow
WHERE
  id = ?
`

func (q *Queries) DeleteFlow(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowStmt, deleteFlow, id)
	return err
}

const deleteFlowEdge = `-- name: DeleteFlowEdge :exec
DELETE FROM
  flow_edge
WHERE
  id = ?
`

func (q *Queries) DeleteFlowEdge(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowEdgeStmt, deleteFlowEdge, id)
	return err
}

const deleteFlowNode = `-- name: DeleteFlowNode :exec
DELETE FROM flow_node
WHERE
  id = ?
`

func (q *Queries) DeleteFlowNode(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeStmt, deleteFlowNode, id)
	return err
}

const deleteFlowNodeCondition = `-- name: DeleteFlowNodeCondition :exec
DELETE FROM flow_node_condition
WHERE
  flow_node_id = ?
`

func (q *Queries) DeleteFlowNodeCondition(ctx context.Context, flowNodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeConditionStmt, deleteFlowNodeCondition, flowNodeID)
	return err
}

const deleteFlowNodeFor = `-- name: DeleteFlowNodeFor :exec
DELETE FROM flow_node_for
WHERE
  flow_node_id = ?
`

func (q *Queries) DeleteFlowNodeFor(ctx context.Context, flowNodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeForStmt, deleteFlowNodeFor, flowNodeID)
	return err
}

const deleteFlowNodeForEach = `-- name: DeleteFlowNodeForEach :exec
DELETE FROM flow_node_for_each
WHERE
  flow_node_id = ?
`

func (q *Queries) DeleteFlowNodeForEach(ctx context.Context, flowNodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeForEachStmt, deleteFlowNodeForEach, flowNodeID)
	return err
}

const deleteFlowNodeJs = `-- name: DeleteFlowNodeJs :exec
DELETE FROM flow_node_js
WHERE
  flow_node_id = ?
`

func (q *Queries) DeleteFlowNodeJs(ctx context.Context, flowNodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeJsStmt, deleteFlowNodeJs, flowNodeID)
	return err
}

const deleteFlowNodeNoop = `-- name: DeleteFlowNodeNoop :exec
DELETE from flow_node_noop
WHERE
  flow_node_id = ?
`

func (q *Queries) DeleteFlowNodeNoop(ctx context.Context, flowNodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeNoopStmt, deleteFlowNodeNoop, flowNodeID)
	return err
}

const deleteFlowNodeRequest = `-- name: DeleteFlowNodeRequest :exec
DELETE FROM flow_node_request
WHERE
  flow_node_id = ?
`

func (q *Queries) DeleteFlowNodeRequest(ctx context.Context, flowNodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeRequestStmt, deleteFlowNodeRequest, flowNodeID)
	return err
}

const deleteFlowTag = `-- name: DeleteFlowTag :exec
DELETE FROM flow_tag
WHERE
  id = ?
`

func (q *Queries) DeleteFlowTag(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowTagStmt, deleteFlowTag, id)
	return err
}

const deleteFlowVariable = `-- name: DeleteFlowVariable :exec
DELETE FROM flow_variable
WHERE
  id = ?
`

func (q *Queries) DeleteFlowVariable(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowVariableStmt, deleteFlowVariable, id)
	return err
}

const deleteHTTP = `-- name: DeleteHTTP :exec
DELETE FROM http
WHERE id = ?
`

func (q *Queries) DeleteHTTP(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHTTPStmt, deleteHTTP, id)
	return err
}

const deleteHTTPAssert = `-- name: DeleteHTTPAssert :exec
DELETE FROM http_assert WHERE id = ?
`

func (q *Queries) DeleteHTTPAssert(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHTTPAssertStmt, deleteHTTPAssert, id)
	return err
}

const deleteHTTPBodyForm = `-- name: DeleteHTTPBodyForm :exec
DELETE FROM http_body_form WHERE id = ?
`

func (q *Queries) DeleteHTTPBodyForm(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHTTPBodyFormStmt, deleteHTTPBodyForm, id)
	return err
}

const deleteHTTPBodyUrlEncoded = `-- name: DeleteHTTPBodyUrlEncoded :exec
DELETE FROM http_body_urlencoded WHERE id = ?
`

func (q *Queries) DeleteHTTPBodyUrlEncoded(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHTTPBodyUrlEncodedStmt, deleteHTTPBodyUrlEncoded, id)
	return err
}

const deleteHTTPHeader = `-- name: DeleteHTTPHeader :exec
DELETE FROM http_header
WHERE id = ?
`

func (q *Queries) DeleteHTTPHeader(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHTTPHeaderStmt, deleteHTTPHeader, id)
	return err
}

const deleteHTTPResponse = `-- name: DeleteHTTPResponse :exec
DELETE FROM http_response WHERE id = ?
`

func (q *Queries) DeleteHTTPResponse(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHTTPResponseStmt, deleteHTTPResponse, id)
	return err
}

const deleteHTTPResponseAssert = `-- name: DeleteHTTPResponseAssert :exec
DELETE FROM http_response_assert WHERE id = ?
`

func (q *Queries) DeleteHTTPResponseAssert(ctx context.Context, id []byte) error {
	_, err := q.exec(ctx, q.deleteHTTPResponseAssertStmt, deleteHTTPResponseAssert, id)
	return err
}

const deleteHTTPResponseHeader = `-- name: DeleteHTTPResponseHeader :exec
DELETE FROM http_response_header WHERE id = ?
`

func (q *Queries) DeleteHTTPResponseHeader(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHTTPResponseHeaderStmt, deleteHTTPResponseHeader, id)
	return err
}

const deleteHTTPSearchParam = `-- name: DeleteHTTPSearchParam :exec
DELETE FROM http_search_param
WHERE id = ?
`

func (q *Queries) DeleteHTTPSearchParam(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHTTPSearchParamStmt, deleteHTTPSearchParam, id)
	return err
}

const deleteHeader = `-- name: DeleteHeader :exec
DELETE FROM example_header
WHERE
  id = ?
`

func (q *Queries) DeleteHeader(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHeaderStmt, deleteHeader, id)
	return err
}

const deleteItemApi = `-- name: DeleteItemApi :exec
DELETE FROM item_api
WHERE
  id = ?
`

func (q *Queries) DeleteItemApi(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteItemApiStmt, deleteItemApi, id)
	return err
}

const deleteItemApiExample = `-- name: DeleteItemApiExample :exec
DELETE FROM item_api_example
WHERE
  id = ?
`

func (q *Queries) DeleteItemApiExample(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteItemApiExampleStmt, deleteItemApiExample, id)
	return err
}

const deleteItemFolder = `-- name: DeleteItemFolder :exec
DELETE FROM item_folder
WHERE
  id = ?
`

func (q *Queries) DeleteItemFolder(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteItemFolderStmt, deleteItemFolder, id)
	return err
}

const deleteMigration = `-- name: DeleteMigration :exec
DELETE FROM migration
WHERE
  id = ?
`

func (q *Queries) DeleteMigration(ctx context.Context, id []byte) error {
	_, err := q.exec(ctx, q.deleteMigrationStmt, deleteMigration, id)
	return err
}

const deleteNodeExecutionsByNodeID = `-- name: DeleteNodeExecutionsByNodeID :exec
DELETE FROM node_execution WHERE node_id = ?
`

func (q *Queries) DeleteNodeExecutionsByNodeID(ctx context.Context, nodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteNodeExecutionsByNodeIDStmt, deleteNodeExecutionsByNodeID, nodeID)
	return err
}

const deleteNodeExecutionsByNodeIDs = `-- name: DeleteNodeExecutionsByNodeIDs :exec
DELETE FROM node_execution WHERE node_id IN (/*SLICE:node_ids*/?)
`

func (q *Queries) DeleteNodeExecutionsByNodeIDs(ctx context.Context, nodeIds []idwrap.IDWrap) error {
	query := deleteNodeExecutionsByNodeIDs
	var queryParams []interface{}
	if len(nodeIds) > 0 {
		for _, v := range nodeIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:node_ids*/?", strings.Repeat(",?", len(nodeIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:node_ids*/?", "NULL", 1)
	}
	_, err := q.exec(ctx, nil, query, queryParams...)
	return err
}

const deleteQuery = `-- name: DeleteQuery :exec
DELETE FROM example_query
WHERE
  id = ?
`

func (q *Queries) DeleteQuery(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteQueryStmt, deleteQuery, id)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tag
WHERE
  id = ?
`

func (q *Queries) DeleteTag(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteTagStmt, deleteTag, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE
  id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteUserStmt, deleteUser, id)
	return err
}

const deleteVariable = `-- name: DeleteVariable :exec
DELETE FROM variable
WHERE
  id = ?
`

func (q *Queries) DeleteVariable(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteVariableStmt, deleteVariable, id)
	return err
}

const deleteWorkspace = `-- name: DeleteWorkspace :exec
DELETE FROM workspaces
WHERE
  id = ?
`

func (q *Queries) DeleteWorkspace(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteWorkspaceStmt, deleteWorkspace, id)
	return err
}

const deleteWorkspaceUser = `-- name: DeleteWorkspaceUser :exec
DELETE FROM workspaces_users
WHERE
  id = ?
`

func (q *Queries) DeleteWorkspaceUser(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteWorkspaceUserStmt, deleteWorkspaceUser, id)
	return err
}

const deltaFormDeltaDelete = `-- name: DeltaFormDeltaDelete :exec
DELETE FROM delta_form_delta WHERE example_id = ? AND id = ?
`

type DeltaFormDeltaDeleteParams struct {
	ExampleID []byte
	ID        []byte
}

func (q *Queries) DeltaFormDeltaDelete(ctx context.Context, arg DeltaFormDeltaDeleteParams) error {
	_, err := q.exec(ctx, q.deltaFormDeltaDeleteStmt, deltaFormDeltaDelete, arg.ExampleID, arg.ID)
	return err
}

const deltaFormDeltaExists = `-- name: DeltaFormDeltaExists :one
SELECT 1 FROM delta_form_delta WHERE example_id = ? AND id = ?
`

type DeltaFormDeltaExistsParams struct {
	ExampleID []byte
	ID        []byte
}

func (q *Queries) DeltaFormDeltaExists(ctx context.Context, arg DeltaFormDeltaExistsParams) (int64, error) {
	row := q.queryRow(ctx, q.deltaFormDeltaExistsStmt, deltaFormDeltaExists, arg.ExampleID, arg.ID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const deltaFormDeltaGet = `-- name: DeltaFormDeltaGet :one
SELECT body_key, value, description, enabled FROM delta_form_delta WHERE example_id = ? AND id = ?
`

type DeltaFormDeltaGetParams struct {
	ExampleID []byte
	ID        []byte
}

type DeltaFormDeltaGetRow struct {
	BodyKey     string
	Value       string
	Description string
	Enabled     bool
}

func (q *Queries) DeltaFormDeltaGet(ctx context.Context, arg DeltaFormDeltaGetParams) (DeltaFormDeltaGetRow, error) {
	row := q.queryRow(ctx, q.deltaFormDeltaGetStmt, deltaFormDeltaGet, arg.ExampleID, arg.ID)
	var i DeltaFormDeltaGetRow
	err := row.Scan(
		&i.BodyKey,
		&i.Value,
		&i.Description,
		&i.Enabled,
	)
	return i, err
}

const deltaFormDeltaInsert = `-- name: DeltaFormDeltaInsert :exec
INSERT INTO delta_form_delta(example_id, id, body_key, value, description, enabled) VALUES (?,?,?,?,?, ?)
`

type DeltaFormDeltaInsertParams struct {
	ExampleID   []byte
	ID          []byte
	BodyKey     string
	Value       string
	Description string
	Enabled     bool
}

// Delta rows
func (q *Queries) DeltaFormDeltaInsert(ctx context.Context, arg DeltaFormDeltaInsertParams) error {
	_, err := q.exec(ctx, q.deltaFormDeltaInsertStmt, deltaFormDeltaInsert,
		arg.ExampleID,
		arg.ID,
		arg.BodyKey,
		arg.Value,
		arg.Description,
		arg.Enabled,
	)
	return err
}

const deltaFormDeltaUpdate = `-- name: DeltaFormDeltaUpdate :exec
UPDATE delta_form_delta SET body_key = ?, value = ?, description = ?, enabled = ?, updated_at = unixepoch() WHERE example_id = ? AND id = ?
`

type DeltaFormDeltaUpdateParams struct {
	BodyKey     string
	Value       string
	Description string
	Enabled     bool
	ExampleID   []byte
	ID          []byte
}

func (q *Queries) DeltaFormDeltaUpdate(ctx context.Context, arg DeltaFormDeltaUpdateParams) error {
	_, err := q.exec(ctx, q.deltaFormDeltaUpdateStmt, deltaFormDeltaUpdate,
		arg.BodyKey,
		arg.Value,
		arg.Description,
		arg.Enabled,
		arg.ExampleID,
		arg.ID,
	)
	return err
}

const deltaFormOrderCount = `-- name: DeltaFormOrderCount :one
SELECT COUNT(*) FROM delta_form_order WHERE example_id = ?
`

// Overlay (Delta) queries: Forms
//
// Order
func (q *Queries) DeltaFormOrderCount(ctx context.Context, exampleID []byte) (int64, error) {
	row := q.queryRow(ctx, q.deltaFormOrderCountStmt, deltaFormOrderCount, exampleID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deltaFormOrderDeleteByRef = `-- name: DeltaFormOrderDeleteByRef :exec
DELETE FROM delta_form_order WHERE example_id = ? AND ref_id = ?
`

type DeltaFormOrderDeleteByRefParams struct {
	ExampleID []byte
	RefID     []byte
}

func (q *Queries) DeltaFormOrderDeleteByRef(ctx context.Context, arg DeltaFormOrderDeleteByRefParams) error {
	_, err := q.exec(ctx, q.deltaFormOrderDeleteByRefStmt, deltaFormOrderDeleteByRef, arg.ExampleID, arg.RefID)
	return err
}

const deltaFormOrderExists = `-- name: DeltaFormOrderExists :one
SELECT 1 FROM delta_form_order WHERE example_id = ? AND ref_kind = ? AND ref_id = ?
`

type DeltaFormOrderExistsParams struct {
	ExampleID []byte
	RefKind   int16
	RefID     []byte
}

func (q *Queries) DeltaFormOrderExists(ctx context.Context, arg DeltaFormOrderExistsParams) (int64, error) {
	row := q.queryRow(ctx, q.deltaFormOrderExistsStmt, deltaFormOrderExists, arg.ExampleID, arg.RefKind, arg.RefID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const deltaFormOrderInsertIgnore = `-- name: DeltaFormOrderInsertIgnore :exec
INSERT OR IGNORE INTO delta_form_order(example_id, ref_kind, ref_id, rank, revision) VALUES (?,?,?,?,?)
`

type DeltaFormOrderInsertIgnoreParams struct {
	ExampleID []byte
	RefKind   int16
	RefID     []byte
	Rank      string
	Revision  int64
}

func (q *Queries) DeltaFormOrderInsertIgnore(ctx context.Context, arg DeltaFormOrderInsertIgnoreParams) error {
	_, err := q.exec(ctx, q.deltaFormOrderInsertIgnoreStmt, deltaFormOrderInsertIgnore,
		arg.ExampleID,
		arg.RefKind,
		arg.RefID,
		arg.Rank,
		arg.Revision,
	)
	return err
}

const deltaFormOrderLastRank = `-- name: DeltaFormOrderLastRank :one
SELECT rank FROM delta_form_order WHERE example_id = ? ORDER BY rank DESC LIMIT 1
`

func (q *Queries) DeltaFormOrderLastRank(ctx context.Context, exampleID []byte) (string, error) {
	row := q.queryRow(ctx, q.deltaFormOrderLastRankStmt, deltaFormOrderLastRank, exampleID)
	var rank string
	err := row.Scan(&rank)
	return rank, err
}

const deltaFormOrderSelectAsc = `-- name: DeltaFormOrderSelectAsc :many
SELECT ref_kind, ref_id, rank, revision FROM delta_form_order WHERE example_id = ? ORDER BY rank ASC
`

type DeltaFormOrderSelectAscRow struct {
	RefKind  int16
	RefID    []byte
	Rank     string
	Revision int64
}

func (q *Queries) DeltaFormOrderSelectAsc(ctx context.Context, exampleID []byte) ([]DeltaFormOrderSelectAscRow, error) {
	rows, err := q.query(ctx, q.deltaFormOrderSelectAscStmt, deltaFormOrderSelectAsc, exampleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeltaFormOrderSelectAscRow{}
	for rows.Next() {
		var i DeltaFormOrderSelectAscRow
		if err := rows.Scan(
			&i.RefKind,
			&i.RefID,
			&i.Rank,
			&i.Revision,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deltaFormOrderUpsert = `-- name: DeltaFormOrderUpsert :exec
INSERT INTO delta_form_order(example_id, ref_kind, ref_id, rank, revision)
VALUES (?,?,?,?,?)
ON CONFLICT(example_id, ref_kind, ref_id) DO UPDATE SET rank=excluded.rank, revision=excluded.revision
`

type DeltaFormOrderUpsertParams struct {
	ExampleID []byte
	RefKind   int16
	RefID     []byte
	Rank      string
	Revision  int64
}

func (q *Queries) DeltaFormOrderUpsert(ctx context.Context, arg DeltaFormOrderUpsertParams) error {
	_, err := q.exec(ctx, q.deltaFormOrderUpsertStmt, deltaFormOrderUpsert,
		arg.ExampleID,
		arg.RefKind,
		arg.RefID,
		arg.Rank,
		arg.Revision,
	)
	return err
}

const deltaFormResolveExampleByDeltaID = `-- name: DeltaFormResolveExampleByDeltaID :one
SELECT example_id FROM delta_form_delta WHERE id = ? LIMIT 1
`

func (q *Queries) DeltaFormResolveExampleByDeltaID(ctx context.Context, id []byte) ([]byte, error) {
	row := q.queryRow(ctx, q.deltaFormResolveExampleByDeltaIDStmt, deltaFormResolveExampleByDeltaID, id)
	var example_id []byte
	err := row.Scan(&example_id)
	return example_id, err
}

const deltaFormResolveExampleByOrderRefID = `-- name: DeltaFormResolveExampleByOrderRefID :one
SELECT example_id FROM delta_form_order WHERE ref_id = ? LIMIT 1
`

func (q *Queries) DeltaFormResolveExampleByOrderRefID(ctx context.Context, refID []byte) ([]byte, error) {
	row := q.queryRow(ctx, q.deltaFormResolveExampleByOrderRefIDStmt, deltaFormResolveExampleByOrderRefID, refID)
	var example_id []byte
	err := row.Scan(&example_id)
	return example_id, err
}

const deltaFormStateClearOverrides = `-- name: DeltaFormStateClearOverrides :exec
UPDATE delta_form_state SET body_key=NULL, value=NULL, description=NULL, enabled=NULL, updated_at = unixepoch() WHERE example_id = ? AND origin_id = ?
`

type DeltaFormStateClearOverridesParams struct {
	ExampleID []byte
	OriginID  []byte
}

func (q *Queries) DeltaFormStateClearOverrides(ctx context.Context, arg DeltaFormStateClearOverridesParams) error {
	_, err := q.exec(ctx, q.deltaFormStateClearOverridesStmt, deltaFormStateClearOverrides, arg.ExampleID, arg.OriginID)
	return err
}

const deltaFormStateGet = `-- name: DeltaFormStateGet :one
SELECT suppressed, body_key, value, description, enabled FROM delta_form_state WHERE example_id = ? AND origin_id = ?
`

type DeltaFormStateGetParams struct {
	ExampleID []byte
	OriginID  []byte
}

type DeltaFormStateGetRow struct {
	Suppressed  bool
	BodyKey     interface{}
	Value       interface{}
	Description interface{}
	Enabled     interface{}
}

func (q *Queries) DeltaFormStateGet(ctx context.Context, arg DeltaFormStateGetParams) (DeltaFormStateGetRow, error) {
	row := q.queryRow(ctx, q.deltaFormStateGetStmt, deltaFormStateGet, arg.ExampleID, arg.OriginID)
	var i DeltaFormStateGetRow
	err := row.Scan(
		&i.Suppressed,
		&i.BodyKey,
		&i.Value,
		&i.Description,
		&i.Enabled,
	)
	return i, err
}

const deltaFormStateSuppress = `-- name: DeltaFormStateSuppress :exec
INSERT INTO delta_form_state(example_id, origin_id, suppressed, updated_at)
VALUES (?,?, TRUE, unixepoch())
ON CONFLICT(example_id, origin_id) DO UPDATE SET suppressed=TRUE, updated_at=unixepoch()
`

type DeltaFormStateSuppressParams struct {
	ExampleID []byte
	OriginID  []byte
}

func (q *Queries) DeltaFormStateSuppress(ctx context.Context, arg DeltaFormStateSuppressParams) error {
	_, err := q.exec(ctx, q.deltaFormStateSuppressStmt, deltaFormStateSuppress, arg.ExampleID, arg.OriginID)
	return err
}

const deltaFormStateUnsuppress = `-- name: DeltaFormStateUnsuppress :exec
UPDATE delta_form_state SET suppressed = FALSE, updated_at = unixepoch() WHERE example_id = ? AND origin_id = ?
`

type DeltaFormStateUnsuppressParams struct {
	ExampleID []byte
	OriginID  []byte
}

func (q *Queries) DeltaFormStateUnsuppress(ctx context.Context, arg DeltaFormStateUnsuppressParams) error {
	_, err := q.exec(ctx, q.deltaFormStateUnsuppressStmt, deltaFormStateUnsuppress, arg.ExampleID, arg.OriginID)
	return err
}

const deltaFormStateUpsert = `-- name: DeltaFormStateUpsert :exec
INSERT INTO delta_form_state(example_id, origin_id, suppressed, body_key, value, description, enabled, updated_at)
VALUES (?,?,?,?,?,?,?, unixepoch())
ON CONFLICT(example_id, origin_id) DO UPDATE SET
  suppressed=excluded.suppressed,
  body_key=COALESCE(excluded.body_key, delta_form_state.body_key),
  value=COALESCE(excluded.value, delta_form_state.value),
  description=COALESCE(excluded.description, delta_form_state.description),
  enabled=COALESCE(excluded.enabled, delta_form_state.enabled),
  updated_at=unixepoch()
`

type DeltaFormStateUpsertParams struct {
	ExampleID   []byte
	OriginID    []byte
	Suppressed  bool
	BodyKey     interface{}
	Value       interface{}
	Description interface{}
	Enabled     interface{}
}

// State
func (q *Queries) DeltaFormStateUpsert(ctx context.Context, arg DeltaFormStateUpsertParams) error {
	_, err := q.exec(ctx, q.deltaFormStateUpsertStmt, deltaFormStateUpsert,
		arg.ExampleID,
		arg.OriginID,
		arg.Suppressed,
		arg.BodyKey,
		arg.Value,
		arg.Description,
		arg.Enabled,
	)
	return err
}

const deltaHeaderDeltaDelete = `-- name: DeltaHeaderDeltaDelete :exec
DELETE FROM delta_header_delta WHERE example_id = ? AND id = ?
`

type DeltaHeaderDeltaDeleteParams struct {
	ExampleID []byte
	ID        []byte
}

func (q *Queries) DeltaHeaderDeltaDelete(ctx context.Context, arg DeltaHeaderDeltaDeleteParams) error {
	_, err := q.exec(ctx, q.deltaHeaderDeltaDeleteStmt, deltaHeaderDeltaDelete, arg.ExampleID, arg.ID)
	return err
}

const deltaHeaderDeltaExists = `-- name: DeltaHeaderDeltaExists :one
SELECT 1 FROM delta_header_delta WHERE example_id = ? AND id = ?
`

type DeltaHeaderDeltaExistsParams struct {
	ExampleID []byte
	ID        []byte
}

func (q *Queries) DeltaHeaderDeltaExists(ctx context.Context, arg DeltaHeaderDeltaExistsParams) (int64, error) {
	row := q.queryRow(ctx, q.deltaHeaderDeltaExistsStmt, deltaHeaderDeltaExists, arg.ExampleID, arg.ID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const deltaHeaderDeltaGet = `-- name: DeltaHeaderDeltaGet :one
SELECT header_key, value, description, enabled FROM delta_header_delta WHERE example_id = ? AND id = ?
`

type DeltaHeaderDeltaGetParams struct {
	ExampleID []byte
	ID        []byte
}

type DeltaHeaderDeltaGetRow struct {
	HeaderKey   string
	Value       string
	Description string
	Enabled     bool
}

func (q *Queries) DeltaHeaderDeltaGet(ctx context.Context, arg DeltaHeaderDeltaGetParams) (DeltaHeaderDeltaGetRow, error) {
	row := q.queryRow(ctx, q.deltaHeaderDeltaGetStmt, deltaHeaderDeltaGet, arg.ExampleID, arg.ID)
	var i DeltaHeaderDeltaGetRow
	err := row.Scan(
		&i.HeaderKey,
		&i.Value,
		&i.Description,
		&i.Enabled,
	)
	return i, err
}

const deltaHeaderDeltaInsert = `-- name: DeltaHeaderDeltaInsert :exec
INSERT INTO delta_header_delta(example_id, id, header_key, value, description, enabled) VALUES (?,?,?,?,?, ?)
`

type DeltaHeaderDeltaInsertParams struct {
	ExampleID   []byte
	ID          []byte
	HeaderKey   string
	Value       string
	Description string
	Enabled     bool
}

// Delta rows
func (q *Queries) DeltaHeaderDeltaInsert(ctx context.Context, arg DeltaHeaderDeltaInsertParams) error {
	_, err := q.exec(ctx, q.deltaHeaderDeltaInsertStmt, deltaHeaderDeltaInsert,
		arg.ExampleID,
		arg.ID,
		arg.HeaderKey,
		arg.Value,
		arg.Description,
		arg.Enabled,
	)
	return err
}

const deltaHeaderDeltaUpdate = `-- name: DeltaHeaderDeltaUpdate :exec
UPDATE delta_header_delta SET header_key = ?, value = ?, description = ?, enabled = ?, updated_at = unixepoch() WHERE example_id = ? AND id = ?
`

type DeltaHeaderDeltaUpdateParams struct {
	HeaderKey   string
	Value       string
	Description string
	Enabled     bool
	ExampleID   []byte
	ID          []byte
}

func (q *Queries) DeltaHeaderDeltaUpdate(ctx context.Context, arg DeltaHeaderDeltaUpdateParams) error {
	_, err := q.exec(ctx, q.deltaHeaderDeltaUpdateStmt, deltaHeaderDeltaUpdate,
		arg.HeaderKey,
		arg.Value,
		arg.Description,
		arg.Enabled,
		arg.ExampleID,
		arg.ID,
	)
	return err
}

const deltaHeaderOrderCount = `-- name: DeltaHeaderOrderCount :one
SELECT COUNT(*) FROM delta_header_order WHERE example_id = ?
`

// Overlay (Delta) queries: Headers
//
// Order
func (q *Queries) DeltaHeaderOrderCount(ctx context.Context, exampleID []byte) (int64, error) {
	row := q.queryRow(ctx, q.deltaHeaderOrderCountStmt, deltaHeaderOrderCount, exampleID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deltaHeaderOrderDeleteByRef = `-- name: DeltaHeaderOrderDeleteByRef :exec
DELETE FROM delta_header_order WHERE example_id = ? AND ref_id = ?
`

type DeltaHeaderOrderDeleteByRefParams struct {
	ExampleID []byte
	RefID     []byte
}

func (q *Queries) DeltaHeaderOrderDeleteByRef(ctx context.Context, arg DeltaHeaderOrderDeleteByRefParams) error {
	_, err := q.exec(ctx, q.deltaHeaderOrderDeleteByRefStmt, deltaHeaderOrderDeleteByRef, arg.ExampleID, arg.RefID)
	return err
}

const deltaHeaderOrderExists = `-- name: DeltaHeaderOrderExists :one
SELECT 1 FROM delta_header_order WHERE example_id = ? AND ref_kind = ? AND ref_id = ?
`

type DeltaHeaderOrderExistsParams struct {
	ExampleID []byte
	RefKind   int16
	RefID     []byte
}

func (q *Queries) DeltaHeaderOrderExists(ctx context.Context, arg DeltaHeaderOrderExistsParams) (int64, error) {
	row := q.queryRow(ctx, q.deltaHeaderOrderExistsStmt, deltaHeaderOrderExists, arg.ExampleID, arg.RefKind, arg.RefID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const deltaHeaderOrderInsertIgnore = `-- name: DeltaHeaderOrderInsertIgnore :exec
INSERT OR IGNORE INTO delta_header_order(example_id, ref_kind, ref_id, rank, revision) VALUES (?,?,?,?,?)
`

type DeltaHeaderOrderInsertIgnoreParams struct {
	ExampleID []byte
	RefKind   int16
	RefID     []byte
	Rank      string
	Revision  int64
}

func (q *Queries) DeltaHeaderOrderInsertIgnore(ctx context.Context, arg DeltaHeaderOrderInsertIgnoreParams) error {
	_, err := q.exec(ctx, q.deltaHeaderOrderInsertIgnoreStmt, deltaHeaderOrderInsertIgnore,
		arg.ExampleID,
		arg.RefKind,
		arg.RefID,
		arg.Rank,
		arg.Revision,
	)
	return err
}

const deltaHeaderOrderLastRank = `-- name: DeltaHeaderOrderLastRank :one
SELECT rank FROM delta_header_order WHERE example_id = ? ORDER BY rank DESC LIMIT 1
`

func (q *Queries) DeltaHeaderOrderLastRank(ctx context.Context, exampleID []byte) (string, error) {
	row := q.queryRow(ctx, q.deltaHeaderOrderLastRankStmt, deltaHeaderOrderLastRank, exampleID)
	var rank string
	err := row.Scan(&rank)
	return rank, err
}

const deltaHeaderOrderSelectAsc = `-- name: DeltaHeaderOrderSelectAsc :many
SELECT ref_kind, ref_id, rank, revision FROM delta_header_order WHERE example_id = ? ORDER BY rank ASC
`

type DeltaHeaderOrderSelectAscRow struct {
	RefKind  int16
	RefID    []byte
	Rank     string
	Revision int64
}

func (q *Queries) DeltaHeaderOrderSelectAsc(ctx context.Context, exampleID []byte) ([]DeltaHeaderOrderSelectAscRow, error) {
	rows, err := q.query(ctx, q.deltaHeaderOrderSelectAscStmt, deltaHeaderOrderSelectAsc, exampleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeltaHeaderOrderSelectAscRow{}
	for rows.Next() {
		var i DeltaHeaderOrderSelectAscRow
		if err := rows.Scan(
			&i.RefKind,
			&i.RefID,
			&i.Rank,
			&i.Revision,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deltaHeaderOrderUpsert = `-- name: DeltaHeaderOrderUpsert :exec
INSERT INTO delta_header_order(example_id, ref_kind, ref_id, rank, revision)
VALUES (?,?,?,?,?)
ON CONFLICT(example_id, ref_kind, ref_id) DO UPDATE SET rank=excluded.rank, revision=excluded.revision
`

type DeltaHeaderOrderUpsertParams struct {
	ExampleID []byte
	RefKind   int16
	RefID     []byte
	Rank      string
	Revision  int64
}

func (q *Queries) DeltaHeaderOrderUpsert(ctx context.Context, arg DeltaHeaderOrderUpsertParams) error {
	_, err := q.exec(ctx, q.deltaHeaderOrderUpsertStmt, deltaHeaderOrderUpsert,
		arg.ExampleID,
		arg.RefKind,
		arg.RefID,
		arg.Rank,
		arg.Revision,
	)
	return err
}

const deltaHeaderResolveExampleByDeltaID = `-- name: DeltaHeaderResolveExampleByDeltaID :one
SELECT example_id FROM delta_header_delta WHERE id = ? LIMIT 1
`

func (q *Queries) DeltaHeaderResolveExampleByDeltaID(ctx context.Context, id []byte) ([]byte, error) {
	row := q.queryRow(ctx, q.deltaHeaderResolveExampleByDeltaIDStmt, deltaHeaderResolveExampleByDeltaID, id)
	var example_id []byte
	err := row.Scan(&example_id)
	return example_id, err
}

const deltaHeaderResolveExampleByOrderRefID = `-- name: DeltaHeaderResolveExampleByOrderRefID :one
SELECT example_id FROM delta_header_order WHERE ref_id = ? LIMIT 1
`

func (q *Queries) DeltaHeaderResolveExampleByOrderRefID(ctx context.Context, refID []byte) ([]byte, error) {
	row := q.queryRow(ctx, q.deltaHeaderResolveExampleByOrderRefIDStmt, deltaHeaderResolveExampleByOrderRefID, refID)
	var example_id []byte
	err := row.Scan(&example_id)
	return example_id, err
}

const deltaHeaderStateClearOverrides = `-- name: DeltaHeaderStateClearOverrides :exec
UPDATE delta_header_state SET header_key=NULL, value=NULL, description=NULL, enabled=NULL, updated_at = unixepoch() WHERE example_id = ? AND origin_id = ?
`

type DeltaHeaderStateClearOverridesParams struct {
	ExampleID []byte
	OriginID  []byte
}

func (q *Queries) DeltaHeaderStateClearOverrides(ctx context.Context, arg DeltaHeaderStateClearOverridesParams) error {
	_, err := q.exec(ctx, q.deltaHeaderStateClearOverridesStmt, deltaHeaderStateClearOverrides, arg.ExampleID, arg.OriginID)
	return err
}

const deltaHeaderStateGet = `-- name: DeltaHeaderStateGet :one
SELECT suppressed, header_key, value, description, enabled FROM delta_header_state WHERE example_id = ? AND origin_id = ?
`

type DeltaHeaderStateGetParams struct {
	ExampleID []byte
	OriginID  []byte
}

type DeltaHeaderStateGetRow struct {
	Suppressed  bool
	HeaderKey   interface{}
	Value       interface{}
	Description interface{}
	Enabled     interface{}
}

func (q *Queries) DeltaHeaderStateGet(ctx context.Context, arg DeltaHeaderStateGetParams) (DeltaHeaderStateGetRow, error) {
	row := q.queryRow(ctx, q.deltaHeaderStateGetStmt, deltaHeaderStateGet, arg.ExampleID, arg.OriginID)
	var i DeltaHeaderStateGetRow
	err := row.Scan(
		&i.Suppressed,
		&i.HeaderKey,
		&i.Value,
		&i.Description,
		&i.Enabled,
	)
	return i, err
}

const deltaHeaderStateSuppress = `-- name: DeltaHeaderStateSuppress :exec
INSERT INTO delta_header_state(example_id, origin_id, suppressed, updated_at)
VALUES (?,?, TRUE, unixepoch())
ON CONFLICT(example_id, origin_id) DO UPDATE SET suppressed=TRUE, updated_at=unixepoch()
`

type DeltaHeaderStateSuppressParams struct {
	ExampleID []byte
	OriginID  []byte
}

func (q *Queries) DeltaHeaderStateSuppress(ctx context.Context, arg DeltaHeaderStateSuppressParams) error {
	_, err := q.exec(ctx, q.deltaHeaderStateSuppressStmt, deltaHeaderStateSuppress, arg.ExampleID, arg.OriginID)
	return err
}

const deltaHeaderStateUnsuppress = `-- name: DeltaHeaderStateUnsuppress :exec
UPDATE delta_header_state SET suppressed = FALSE, updated_at = unixepoch() WHERE example_id = ? AND origin_id = ?
`

type DeltaHeaderStateUnsuppressParams struct {
	ExampleID []byte
	OriginID  []byte
}

func (q *Queries) DeltaHeaderStateUnsuppress(ctx context.Context, arg DeltaHeaderStateUnsuppressParams) error {
	_, err := q.exec(ctx, q.deltaHeaderStateUnsuppressStmt, deltaHeaderStateUnsuppress, arg.ExampleID, arg.OriginID)
	return err
}

const deltaHeaderStateUpsert = `-- name: DeltaHeaderStateUpsert :exec
INSERT INTO delta_header_state(example_id, origin_id, suppressed, header_key, value, description, enabled, updated_at)
VALUES (?,?,?,?,?,?,?, unixepoch())
ON CONFLICT(example_id, origin_id) DO UPDATE SET
  suppressed=excluded.suppressed,
  header_key=COALESCE(excluded.header_key, delta_header_state.header_key),
  value=COALESCE(excluded.value, delta_header_state.value),
  description=COALESCE(excluded.description, delta_header_state.description),
  enabled=COALESCE(excluded.enabled, delta_header_state.enabled),
  updated_at=unixepoch()
`

type DeltaHeaderStateUpsertParams struct {
	ExampleID   []byte
	OriginID    []byte
	Suppressed  bool
	HeaderKey   interface{}
	Value       interface{}
	Description interface{}
	Enabled     interface{}
}

// State
func (q *Queries) DeltaHeaderStateUpsert(ctx context.Context, arg DeltaHeaderStateUpsertParams) error {
	_, err := q.exec(ctx, q.deltaHeaderStateUpsertStmt, deltaHeaderStateUpsert,
		arg.ExampleID,
		arg.OriginID,
		arg.Suppressed,
		arg.HeaderKey,
		arg.Value,
		arg.Description,
		arg.Enabled,
	)
	return err
}

const deltaQueryDeltaDelete = `-- name: DeltaQueryDeltaDelete :exec
DELETE FROM delta_query_delta WHERE example_id = ? AND id = ?
`

type DeltaQueryDeltaDeleteParams struct {
	ExampleID []byte
	ID        []byte
}

func (q *Queries) DeltaQueryDeltaDelete(ctx context.Context, arg DeltaQueryDeltaDeleteParams) error {
	_, err := q.exec(ctx, q.deltaQueryDeltaDeleteStmt, deltaQueryDeltaDelete, arg.ExampleID, arg.ID)
	return err
}

const deltaQueryDeltaExists = `-- name: DeltaQueryDeltaExists :one
SELECT 1 FROM delta_query_delta WHERE example_id = ? AND id = ?
`

type DeltaQueryDeltaExistsParams struct {
	ExampleID []byte
	ID        []byte
}

func (q *Queries) DeltaQueryDeltaExists(ctx context.Context, arg DeltaQueryDeltaExistsParams) (int64, error) {
	row := q.queryRow(ctx, q.deltaQueryDeltaExistsStmt, deltaQueryDeltaExists, arg.ExampleID, arg.ID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const deltaQueryDeltaGet = `-- name: DeltaQueryDeltaGet :one
SELECT query_key, value, description, enabled FROM delta_query_delta WHERE example_id = ? AND id = ?
`

type DeltaQueryDeltaGetParams struct {
	ExampleID []byte
	ID        []byte
}

type DeltaQueryDeltaGetRow struct {
	QueryKey    string
	Value       string
	Description string
	Enabled     bool
}

func (q *Queries) DeltaQueryDeltaGet(ctx context.Context, arg DeltaQueryDeltaGetParams) (DeltaQueryDeltaGetRow, error) {
	row := q.queryRow(ctx, q.deltaQueryDeltaGetStmt, deltaQueryDeltaGet, arg.ExampleID, arg.ID)
	var i DeltaQueryDeltaGetRow
	err := row.Scan(
		&i.QueryKey,
		&i.Value,
		&i.Description,
		&i.Enabled,
	)
	return i, err
}

const deltaQueryDeltaInsert = `-- name: DeltaQueryDeltaInsert :exec
INSERT INTO delta_query_delta(example_id, id, query_key, value, description, enabled) VALUES (?,?,?,?,?, ?)
`

type DeltaQueryDeltaInsertParams struct {
	ExampleID   []byte
	ID          []byte
	QueryKey    string
	Value       string
	Description string
	Enabled     bool
}

// Delta rows
func (q *Queries) DeltaQueryDeltaInsert(ctx context.Context, arg DeltaQueryDeltaInsertParams) error {
	_, err := q.exec(ctx, q.deltaQueryDeltaInsertStmt, deltaQueryDeltaInsert,
		arg.ExampleID,
		arg.ID,
		arg.QueryKey,
		arg.Value,
		arg.Description,
		arg.Enabled,
	)
	return err
}

const deltaQueryDeltaUpdate = `-- name: DeltaQueryDeltaUpdate :exec
UPDATE delta_query_delta SET query_key = ?, value = ?, description = ?, enabled = ?, updated_at = unixepoch() WHERE example_id = ? AND id = ?
`

type DeltaQueryDeltaUpdateParams struct {
	QueryKey    string
	Value       string
	Description string
	Enabled     bool
	ExampleID   []byte
	ID          []byte
}

func (q *Queries) DeltaQueryDeltaUpdate(ctx context.Context, arg DeltaQueryDeltaUpdateParams) error {
	_, err := q.exec(ctx, q.deltaQueryDeltaUpdateStmt, deltaQueryDeltaUpdate,
		arg.QueryKey,
		arg.Value,
		arg.Description,
		arg.Enabled,
		arg.ExampleID,
		arg.ID,
	)
	return err
}

const deltaQueryOrderCount = `-- name: DeltaQueryOrderCount :one
SELECT COUNT(*) FROM delta_query_order WHERE example_id = ?
`

// Overlay (Delta) queries: Queries
//
// Order
func (q *Queries) DeltaQueryOrderCount(ctx context.Context, exampleID []byte) (int64, error) {
	row := q.queryRow(ctx, q.deltaQueryOrderCountStmt, deltaQueryOrderCount, exampleID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deltaQueryOrderDeleteByRef = `-- name: DeltaQueryOrderDeleteByRef :exec
DELETE FROM delta_query_order WHERE example_id = ? AND ref_id = ?
`

type DeltaQueryOrderDeleteByRefParams struct {
	ExampleID []byte
	RefID     []byte
}

func (q *Queries) DeltaQueryOrderDeleteByRef(ctx context.Context, arg DeltaQueryOrderDeleteByRefParams) error {
	_, err := q.exec(ctx, q.deltaQueryOrderDeleteByRefStmt, deltaQueryOrderDeleteByRef, arg.ExampleID, arg.RefID)
	return err
}

const deltaQueryOrderExists = `-- name: DeltaQueryOrderExists :one
SELECT 1 FROM delta_query_order WHERE example_id = ? AND ref_kind = ? AND ref_id = ?
`

type DeltaQueryOrderExistsParams struct {
	ExampleID []byte
	RefKind   int16
	RefID     []byte
}

func (q *Queries) DeltaQueryOrderExists(ctx context.Context, arg DeltaQueryOrderExistsParams) (int64, error) {
	row := q.queryRow(ctx, q.deltaQueryOrderExistsStmt, deltaQueryOrderExists, arg.ExampleID, arg.RefKind, arg.RefID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const deltaQueryOrderInsertIgnore = `-- name: DeltaQueryOrderInsertIgnore :exec
INSERT OR IGNORE INTO delta_query_order(example_id, ref_kind, ref_id, rank, revision) VALUES (?,?,?,?,?)
`

type DeltaQueryOrderInsertIgnoreParams struct {
	ExampleID []byte
	RefKind   int16
	RefID     []byte
	Rank      string
	Revision  int64
}

func (q *Queries) DeltaQueryOrderInsertIgnore(ctx context.Context, arg DeltaQueryOrderInsertIgnoreParams) error {
	_, err := q.exec(ctx, q.deltaQueryOrderInsertIgnoreStmt, deltaQueryOrderInsertIgnore,
		arg.ExampleID,
		arg.RefKind,
		arg.RefID,
		arg.Rank,
		arg.Revision,
	)
	return err
}

const deltaQueryOrderLastRank = `-- name: DeltaQueryOrderLastRank :one
SELECT rank FROM delta_query_order WHERE example_id = ? ORDER BY rank DESC LIMIT 1
`

func (q *Queries) DeltaQueryOrderLastRank(ctx context.Context, exampleID []byte) (string, error) {
	row := q.queryRow(ctx, q.deltaQueryOrderLastRankStmt, deltaQueryOrderLastRank, exampleID)
	var rank string
	err := row.Scan(&rank)
	return rank, err
}

const deltaQueryOrderSelectAsc = `-- name: DeltaQueryOrderSelectAsc :many
SELECT ref_kind, ref_id, rank, revision FROM delta_query_order WHERE example_id = ? ORDER BY rank ASC
`

type DeltaQueryOrderSelectAscRow struct {
	RefKind  int16
	RefID    []byte
	Rank     string
	Revision int64
}

func (q *Queries) DeltaQueryOrderSelectAsc(ctx context.Context, exampleID []byte) ([]DeltaQueryOrderSelectAscRow, error) {
	rows, err := q.query(ctx, q.deltaQueryOrderSelectAscStmt, deltaQueryOrderSelectAsc, exampleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeltaQueryOrderSelectAscRow{}
	for rows.Next() {
		var i DeltaQueryOrderSelectAscRow
		if err := rows.Scan(
			&i.RefKind,
			&i.RefID,
			&i.Rank,
			&i.Revision,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deltaQueryOrderUpsert = `-- name: DeltaQueryOrderUpsert :exec
INSERT INTO delta_query_order(example_id, ref_kind, ref_id, rank, revision)
VALUES (?,?,?,?,?)
ON CONFLICT(example_id, ref_kind, ref_id) DO UPDATE SET rank=excluded.rank, revision=excluded.revision
`

type DeltaQueryOrderUpsertParams struct {
	ExampleID []byte
	RefKind   int16
	RefID     []byte
	Rank      string
	Revision  int64
}

func (q *Queries) DeltaQueryOrderUpsert(ctx context.Context, arg DeltaQueryOrderUpsertParams) error {
	_, err := q.exec(ctx, q.deltaQueryOrderUpsertStmt, deltaQueryOrderUpsert,
		arg.ExampleID,
		arg.RefKind,
		arg.RefID,
		arg.Rank,
		arg.Revision,
	)
	return err
}

const deltaQueryResolveExampleByDeltaID = `-- name: DeltaQueryResolveExampleByDeltaID :one
SELECT example_id FROM delta_query_delta WHERE id = ? LIMIT 1
`

func (q *Queries) DeltaQueryResolveExampleByDeltaID(ctx context.Context, id []byte) ([]byte, error) {
	row := q.queryRow(ctx, q.deltaQueryResolveExampleByDeltaIDStmt, deltaQueryResolveExampleByDeltaID, id)
	var example_id []byte
	err := row.Scan(&example_id)
	return example_id, err
}

const deltaQueryResolveExampleByOrderRefID = `-- name: DeltaQueryResolveExampleByOrderRefID :one
SELECT example_id FROM delta_query_order WHERE ref_id = ? LIMIT 1
`

func (q *Queries) DeltaQueryResolveExampleByOrderRefID(ctx context.Context, refID []byte) ([]byte, error) {
	row := q.queryRow(ctx, q.deltaQueryResolveExampleByOrderRefIDStmt, deltaQueryResolveExampleByOrderRefID, refID)
	var example_id []byte
	err := row.Scan(&example_id)
	return example_id, err
}

const deltaQueryStateClearOverrides = `-- name: DeltaQueryStateClearOverrides :exec
UPDATE delta_query_state SET query_key=NULL, value=NULL, description=NULL, enabled=NULL, updated_at = unixepoch() WHERE example_id = ? AND origin_id = ?
`

type DeltaQueryStateClearOverridesParams struct {
	ExampleID []byte
	OriginID  []byte
}

func (q *Queries) DeltaQueryStateClearOverrides(ctx context.Context, arg DeltaQueryStateClearOverridesParams) error {
	_, err := q.exec(ctx, q.deltaQueryStateClearOverridesStmt, deltaQueryStateClearOverrides, arg.ExampleID, arg.OriginID)
	return err
}

const deltaQueryStateGet = `-- name: DeltaQueryStateGet :one
SELECT suppressed, query_key, value, description, enabled FROM delta_query_state WHERE example_id = ? AND origin_id = ?
`

type DeltaQueryStateGetParams struct {
	ExampleID []byte
	OriginID  []byte
}

type DeltaQueryStateGetRow struct {
	Suppressed  bool
	QueryKey    interface{}
	Value       interface{}
	Description interface{}
	Enabled     interface{}
}

func (q *Queries) DeltaQueryStateGet(ctx context.Context, arg DeltaQueryStateGetParams) (DeltaQueryStateGetRow, error) {
	row := q.queryRow(ctx, q.deltaQueryStateGetStmt, deltaQueryStateGet, arg.ExampleID, arg.OriginID)
	var i DeltaQueryStateGetRow
	err := row.Scan(
		&i.Suppressed,
		&i.QueryKey,
		&i.Value,
		&i.Description,
		&i.Enabled,
	)
	return i, err
}

const deltaQueryStateSuppress = `-- name: DeltaQueryStateSuppress :exec
INSERT INTO delta_query_state(example_id, origin_id, suppressed, updated_at)
VALUES (?,?, TRUE, unixepoch())
ON CONFLICT(example_id, origin_id) DO UPDATE SET suppressed=TRUE, updated_at=unixepoch()
`

type DeltaQueryStateSuppressParams struct {
	ExampleID []byte
	OriginID  []byte
}

func (q *Queries) DeltaQueryStateSuppress(ctx context.Context, arg DeltaQueryStateSuppressParams) error {
	_, err := q.exec(ctx, q.deltaQueryStateSuppressStmt, deltaQueryStateSuppress, arg.ExampleID, arg.OriginID)
	return err
}

const deltaQueryStateUnsuppress = `-- name: DeltaQueryStateUnsuppress :exec
UPDATE delta_query_state SET suppressed = FALSE, updated_at = unixepoch() WHERE example_id = ? AND origin_id = ?
`

type DeltaQueryStateUnsuppressParams struct {
	ExampleID []byte
	OriginID  []byte
}

func (q *Queries) DeltaQueryStateUnsuppress(ctx context.Context, arg DeltaQueryStateUnsuppressParams) error {
	_, err := q.exec(ctx, q.deltaQueryStateUnsuppressStmt, deltaQueryStateUnsuppress, arg.ExampleID, arg.OriginID)
	return err
}

const deltaQueryStateUpsert = `-- name: DeltaQueryStateUpsert :exec
INSERT INTO delta_query_state(example_id, origin_id, suppressed, query_key, value, description, enabled, updated_at)
VALUES (?,?,?,?,?,?,?, unixepoch())
ON CONFLICT(example_id, origin_id) DO UPDATE SET
  suppressed=excluded.suppressed,
  query_key=COALESCE(excluded.query_key, delta_query_state.query_key),
  value=COALESCE(excluded.value, delta_query_state.value),
  description=COALESCE(excluded.description, delta_query_state.description),
  enabled=COALESCE(excluded.enabled, delta_query_state.enabled),
  updated_at=unixepoch()
`

type DeltaQueryStateUpsertParams struct {
	ExampleID   []byte
	OriginID    []byte
	Suppressed  bool
	QueryKey    interface{}
	Value       interface{}
	Description interface{}
	Enabled     interface{}
}

// State
func (q *Queries) DeltaQueryStateUpsert(ctx context.Context, arg DeltaQueryStateUpsertParams) error {
	_, err := q.exec(ctx, q.deltaQueryStateUpsertStmt, deltaQueryStateUpsert,
		arg.ExampleID,
		arg.OriginID,
		arg.Suppressed,
		arg.QueryKey,
		arg.Value,
		arg.Description,
		arg.Enabled,
	)
	return err
}

const deltaUrlencDeltaDelete = `-- name: DeltaUrlencDeltaDelete :exec
DELETE FROM delta_urlenc_delta WHERE example_id = ? AND id = ?
`

type DeltaUrlencDeltaDeleteParams struct {
	ExampleID []byte
	ID        []byte
}

func (q *Queries) DeltaUrlencDeltaDelete(ctx context.Context, arg DeltaUrlencDeltaDeleteParams) error {
	_, err := q.exec(ctx, q.deltaUrlencDeltaDeleteStmt, deltaUrlencDeltaDelete, arg.ExampleID, arg.ID)
	return err
}

const deltaUrlencDeltaExists = `-- name: DeltaUrlencDeltaExists :one
SELECT 1 FROM delta_urlenc_delta WHERE example_id = ? AND id = ?
`

type DeltaUrlencDeltaExistsParams struct {
	ExampleID []byte
	ID        []byte
}

func (q *Queries) DeltaUrlencDeltaExists(ctx context.Context, arg DeltaUrlencDeltaExistsParams) (int64, error) {
	row := q.queryRow(ctx, q.deltaUrlencDeltaExistsStmt, deltaUrlencDeltaExists, arg.ExampleID, arg.ID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const deltaUrlencDeltaGet = `-- name: DeltaUrlencDeltaGet :one
SELECT body_key, value, description, enabled FROM delta_urlenc_delta WHERE example_id = ? AND id = ?
`

type DeltaUrlencDeltaGetParams struct {
	ExampleID []byte
	ID        []byte
}

type DeltaUrlencDeltaGetRow struct {
	BodyKey     string
	Value       string
	Description string
	Enabled     bool
}

func (q *Queries) DeltaUrlencDeltaGet(ctx context.Context, arg DeltaUrlencDeltaGetParams) (DeltaUrlencDeltaGetRow, error) {
	row := q.queryRow(ctx, q.deltaUrlencDeltaGetStmt, deltaUrlencDeltaGet, arg.ExampleID, arg.ID)
	var i DeltaUrlencDeltaGetRow
	err := row.Scan(
		&i.BodyKey,
		&i.Value,
		&i.Description,
		&i.Enabled,
	)
	return i, err
}

const deltaUrlencDeltaInsert = `-- name: DeltaUrlencDeltaInsert :exec
INSERT INTO delta_urlenc_delta(example_id, id, body_key, value, description, enabled) VALUES (?,?,?,?,?, ?)
`

type DeltaUrlencDeltaInsertParams struct {
	ExampleID   []byte
	ID          []byte
	BodyKey     string
	Value       string
	Description string
	Enabled     bool
}

// Delta rows
func (q *Queries) DeltaUrlencDeltaInsert(ctx context.Context, arg DeltaUrlencDeltaInsertParams) error {
	_, err := q.exec(ctx, q.deltaUrlencDeltaInsertStmt, deltaUrlencDeltaInsert,
		arg.ExampleID,
		arg.ID,
		arg.BodyKey,
		arg.Value,
		arg.Description,
		arg.Enabled,
	)
	return err
}

const deltaUrlencDeltaUpdate = `-- name: DeltaUrlencDeltaUpdate :exec
UPDATE delta_urlenc_delta SET body_key = ?, value = ?, description = ?, enabled = ?, updated_at = unixepoch() WHERE example_id = ? AND id = ?
`

type DeltaUrlencDeltaUpdateParams struct {
	BodyKey     string
	Value       string
	Description string
	Enabled     bool
	ExampleID   []byte
	ID          []byte
}

func (q *Queries) DeltaUrlencDeltaUpdate(ctx context.Context, arg DeltaUrlencDeltaUpdateParams) error {
	_, err := q.exec(ctx, q.deltaUrlencDeltaUpdateStmt, deltaUrlencDeltaUpdate,
		arg.BodyKey,
		arg.Value,
		arg.Description,
		arg.Enabled,
		arg.ExampleID,
		arg.ID,
	)
	return err
}

const deltaUrlencOrderCount = `-- name: DeltaUrlencOrderCount :one
SELECT COUNT(*) FROM delta_urlenc_order WHERE example_id = ?
`

// Overlay (Delta) queries: URL-encoded
//
// Order
func (q *Queries) DeltaUrlencOrderCount(ctx context.Context, exampleID []byte) (int64, error) {
	row := q.queryRow(ctx, q.deltaUrlencOrderCountStmt, deltaUrlencOrderCount, exampleID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deltaUrlencOrderDeleteByRef = `-- name: DeltaUrlencOrderDeleteByRef :exec
DELETE FROM delta_urlenc_order WHERE example_id = ? AND ref_id = ?
`

type DeltaUrlencOrderDeleteByRefParams struct {
	ExampleID []byte
	RefID     []byte
}

func (q *Queries) DeltaUrlencOrderDeleteByRef(ctx context.Context, arg DeltaUrlencOrderDeleteByRefParams) error {
	_, err := q.exec(ctx, q.deltaUrlencOrderDeleteByRefStmt, deltaUrlencOrderDeleteByRef, arg.ExampleID, arg.RefID)
	return err
}

const deltaUrlencOrderExists = `-- name: DeltaUrlencOrderExists :one
SELECT 1 FROM delta_urlenc_order WHERE example_id = ? AND ref_kind = ? AND ref_id = ?
`

type DeltaUrlencOrderExistsParams struct {
	ExampleID []byte
	RefKind   int16
	RefID     []byte
}

func (q *Queries) DeltaUrlencOrderExists(ctx context.Context, arg DeltaUrlencOrderExistsParams) (int64, error) {
	row := q.queryRow(ctx, q.deltaUrlencOrderExistsStmt, deltaUrlencOrderExists, arg.ExampleID, arg.RefKind, arg.RefID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const deltaUrlencOrderInsertIgnore = `-- name: DeltaUrlencOrderInsertIgnore :exec
INSERT OR IGNORE INTO delta_urlenc_order(example_id, ref_kind, ref_id, rank, revision) VALUES (?,?,?,?,?)
`

type DeltaUrlencOrderInsertIgnoreParams struct {
	ExampleID []byte
	RefKind   int16
	RefID     []byte
	Rank      string
	Revision  int64
}

func (q *Queries) DeltaUrlencOrderInsertIgnore(ctx context.Context, arg DeltaUrlencOrderInsertIgnoreParams) error {
	_, err := q.exec(ctx, q.deltaUrlencOrderInsertIgnoreStmt, deltaUrlencOrderInsertIgnore,
		arg.ExampleID,
		arg.RefKind,
		arg.RefID,
		arg.Rank,
		arg.Revision,
	)
	return err
}

const deltaUrlencOrderLastRank = `-- name: DeltaUrlencOrderLastRank :one
SELECT rank FROM delta_urlenc_order WHERE example_id = ? ORDER BY rank DESC LIMIT 1
`

func (q *Queries) DeltaUrlencOrderLastRank(ctx context.Context, exampleID []byte) (string, error) {
	row := q.queryRow(ctx, q.deltaUrlencOrderLastRankStmt, deltaUrlencOrderLastRank, exampleID)
	var rank string
	err := row.Scan(&rank)
	return rank, err
}

const deltaUrlencOrderSelectAsc = `-- name: DeltaUrlencOrderSelectAsc :many
SELECT ref_kind, ref_id, rank, revision FROM delta_urlenc_order WHERE example_id = ? ORDER BY rank ASC
`

type DeltaUrlencOrderSelectAscRow struct {
	RefKind  int16
	RefID    []byte
	Rank     string
	Revision int64
}

func (q *Queries) DeltaUrlencOrderSelectAsc(ctx context.Context, exampleID []byte) ([]DeltaUrlencOrderSelectAscRow, error) {
	rows, err := q.query(ctx, q.deltaUrlencOrderSelectAscStmt, deltaUrlencOrderSelectAsc, exampleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeltaUrlencOrderSelectAscRow{}
	for rows.Next() {
		var i DeltaUrlencOrderSelectAscRow
		if err := rows.Scan(
			&i.RefKind,
			&i.RefID,
			&i.Rank,
			&i.Revision,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deltaUrlencOrderUpsert = `-- name: DeltaUrlencOrderUpsert :exec
INSERT INTO delta_urlenc_order(example_id, ref_kind, ref_id, rank, revision)
VALUES (?,?,?,?,?)
ON CONFLICT(example_id, ref_kind, ref_id) DO UPDATE SET rank=excluded.rank, revision=excluded.revision
`

type DeltaUrlencOrderUpsertParams struct {
	ExampleID []byte
	RefKind   int16
	RefID     []byte
	Rank      string
	Revision  int64
}

func (q *Queries) DeltaUrlencOrderUpsert(ctx context.Context, arg DeltaUrlencOrderUpsertParams) error {
	_, err := q.exec(ctx, q.deltaUrlencOrderUpsertStmt, deltaUrlencOrderUpsert,
		arg.ExampleID,
		arg.RefKind,
		arg.RefID,
		arg.Rank,
		arg.Revision,
	)
	return err
}

const deltaUrlencResolveExampleByDeltaID = `-- name: DeltaUrlencResolveExampleByDeltaID :one
SELECT example_id FROM delta_urlenc_delta WHERE id = ? LIMIT 1
`

func (q *Queries) DeltaUrlencResolveExampleByDeltaID(ctx context.Context, id []byte) ([]byte, error) {
	row := q.queryRow(ctx, q.deltaUrlencResolveExampleByDeltaIDStmt, deltaUrlencResolveExampleByDeltaID, id)
	var example_id []byte
	err := row.Scan(&example_id)
	return example_id, err
}

const deltaUrlencResolveExampleByOrderRefID = `-- name: DeltaUrlencResolveExampleByOrderRefID :one
SELECT example_id FROM delta_urlenc_order WHERE ref_id = ? LIMIT 1
`

func (q *Queries) DeltaUrlencResolveExampleByOrderRefID(ctx context.Context, refID []byte) ([]byte, error) {
	row := q.queryRow(ctx, q.deltaUrlencResolveExampleByOrderRefIDStmt, deltaUrlencResolveExampleByOrderRefID, refID)
	var example_id []byte
	err := row.Scan(&example_id)
	return example_id, err
}

const deltaUrlencStateClearOverrides = `-- name: DeltaUrlencStateClearOverrides :exec
UPDATE delta_urlenc_state SET body_key=NULL, value=NULL, description=NULL, enabled=NULL, updated_at = unixepoch() WHERE example_id = ? AND origin_id = ?
`

type DeltaUrlencStateClearOverridesParams struct {
	ExampleID []byte
	OriginID  []byte
}

func (q *Queries) DeltaUrlencStateClearOverrides(ctx context.Context, arg DeltaUrlencStateClearOverridesParams) error {
	_, err := q.exec(ctx, q.deltaUrlencStateClearOverridesStmt, deltaUrlencStateClearOverrides, arg.ExampleID, arg.OriginID)
	return err
}

const deltaUrlencStateGet = `-- name: DeltaUrlencStateGet :one
SELECT suppressed, body_key, value, description, enabled FROM delta_urlenc_state WHERE example_id = ? AND origin_id = ?
`

type DeltaUrlencStateGetParams struct {
	ExampleID []byte
	OriginID  []byte
}

type DeltaUrlencStateGetRow struct {
	Suppressed  bool
	BodyKey     interface{}
	Value       interface{}
	Description interface{}
	Enabled     interface{}
}

func (q *Queries) DeltaUrlencStateGet(ctx context.Context, arg DeltaUrlencStateGetParams) (DeltaUrlencStateGetRow, error) {
	row := q.queryRow(ctx, q.deltaUrlencStateGetStmt, deltaUrlencStateGet, arg.ExampleID, arg.OriginID)
	var i DeltaUrlencStateGetRow
	err := row.Scan(
		&i.Suppressed,
		&i.BodyKey,
		&i.Value,
		&i.Description,
		&i.Enabled,
	)
	return i, err
}

const deltaUrlencStateSuppress = `-- name: DeltaUrlencStateSuppress :exec
INSERT INTO delta_urlenc_state(example_id, origin_id, suppressed, updated_at)
VALUES (?,?, TRUE, unixepoch())
ON CONFLICT(example_id, origin_id) DO UPDATE SET suppressed=TRUE, updated_at=unixepoch()
`

type DeltaUrlencStateSuppressParams struct {
	ExampleID []byte
	OriginID  []byte
}

func (q *Queries) DeltaUrlencStateSuppress(ctx context.Context, arg DeltaUrlencStateSuppressParams) error {
	_, err := q.exec(ctx, q.deltaUrlencStateSuppressStmt, deltaUrlencStateSuppress, arg.ExampleID, arg.OriginID)
	return err
}

const deltaUrlencStateUnsuppress = `-- name: DeltaUrlencStateUnsuppress :exec
UPDATE delta_urlenc_state SET suppressed = FALSE, updated_at = unixepoch() WHERE example_id = ? AND origin_id = ?
`

type DeltaUrlencStateUnsuppressParams struct {
	ExampleID []byte
	OriginID  []byte
}

func (q *Queries) DeltaUrlencStateUnsuppress(ctx context.Context, arg DeltaUrlencStateUnsuppressParams) error {
	_, err := q.exec(ctx, q.deltaUrlencStateUnsuppressStmt, deltaUrlencStateUnsuppress, arg.ExampleID, arg.OriginID)
	return err
}

const deltaUrlencStateUpsert = `-- name: DeltaUrlencStateUpsert :exec
INSERT INTO delta_urlenc_state(example_id, origin_id, suppressed, body_key, value, description, enabled, updated_at)
VALUES (?,?,?,?,?,?,?, unixepoch())
ON CONFLICT(example_id, origin_id) DO UPDATE SET
  suppressed=excluded.suppressed,
  body_key=COALESCE(excluded.body_key, delta_urlenc_state.body_key),
  value=COALESCE(excluded.value, delta_urlenc_state.value),
  description=COALESCE(excluded.description, delta_urlenc_state.description),
  enabled=COALESCE(excluded.enabled, delta_urlenc_state.enabled),
  updated_at=unixepoch()
`

type DeltaUrlencStateUpsertParams struct {
	ExampleID   []byte
	OriginID    []byte
	Suppressed  bool
	BodyKey     interface{}
	Value       interface{}
	Description interface{}
	Enabled     interface{}
}

// State
func (q *Queries) DeltaUrlencStateUpsert(ctx context.Context, arg DeltaUrlencStateUpsertParams) error {
	_, err := q.exec(ctx, q.deltaUrlencStateUpsertStmt, deltaUrlencStateUpsert,
		arg.ExampleID,
		arg.OriginID,
		arg.Suppressed,
		arg.BodyKey,
		arg.Value,
		arg.Description,
		arg.Enabled,
	)
	return err
}

const getAPIContent = `-- name: GetAPIContent :one
SELECT id, name, url, method
FROM item_api
WHERE id = ?
`

type GetAPIContentRow struct {
	ID     idwrap.IDWrap
	Name   string
	Url    string
	Method string
}

// Get API content by content_id (for union type resolution)
func (q *Queries) GetAPIContent(ctx context.Context, id idwrap.IDWrap) (GetAPIContentRow, error) {
	row := q.queryRow(ctx, q.getAPIContentStmt, getAPIContent, id)
	var i GetAPIContentRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.Method,
	)
	return i, err
}

const getAllExamplesByEndpointID = `-- name: GetAllExamplesByEndpointID :many
SELECT
  id,
  item_api_id,
  is_default,
  body_type,
  name,
  version_parent_id,
  prev,
  next
FROM
  item_api_example
WHERE
  item_api_id = ? AND
  version_parent_id IS NULL AND
  is_default = FALSE
ORDER BY
  name ASC
`

// Returns ALL examples for an endpoint, including isolated ones (prev=NULL, next=NULL)
// Unlike GetExamplesByEndpointIDOrdered, this query finds examples regardless of linked-list state
// Essential for finding examples that became isolated during failed move operations
func (q *Queries) GetAllExamplesByEndpointID(ctx context.Context, itemApiID idwrap.IDWrap) ([]ItemApiExample, error) {
	rows, err := q.query(ctx, q.getAllExamplesByEndpointIDStmt, getAllExamplesByEndpointID, itemApiID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ItemApiExample{}
	for rows.Next() {
		var i ItemApiExample
		if err := rows.Scan(
			&i.ID,
			&i.ItemApiID,
			&i.IsDefault,
			&i.BodyType,
			&i.Name,
			&i.VersionParentID,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllHeadersByExampleID = `-- name: GetAllHeadersByExampleID :many
SELECT
  id,
  example_id,
  delta_parent_id,
  header_key,
  enable,
  description,
  value,
  prev,
  next
FROM
  example_header
WHERE
  example_id = ?
ORDER BY
  header_key ASC
`

// Returns ALL headers for an example, including isolated ones (prev=NULL, next=NULL)
// Unlike GetHeadersByExampleIDOrdered, this query finds headers regardless of linked-list state
// Essential for finding headers that became isolated during failed move operations
func (q *Queries) GetAllHeadersByExampleID(ctx context.Context, exampleID idwrap.IDWrap) ([]ExampleHeader, error) {
	rows, err := q.query(ctx, q.getAllHeadersByExampleIDStmt, getAllHeadersByExampleID, exampleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExampleHeader{}
	for rows.Next() {
		var i ExampleHeader
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.DeltaParentID,
			&i.HeaderKey,
			&i.Enable,
			&i.Description,
			&i.Value,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllItemsApiByFolderID = `-- name: GetAllItemsApiByFolderID :many
SELECT
  id,
  folder_id,
  name,
  url,
  method,
  version_parent_id,
  delta_parent_id,
  hidden,
  prev,
  next
FROM
  item_api
WHERE
  folder_id = ? AND
  version_parent_id is NULL AND
  delta_parent_id is NULL
`

func (q *Queries) GetAllItemsApiByFolderID(ctx context.Context, folderID *idwrap.IDWrap) ([]ItemApi, error) {
	rows, err := q.query(ctx, q.getAllItemsApiByFolderIDStmt, getAllItemsApiByFolderID, folderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ItemApi{}
	for rows.Next() {
		var i ItemApi
		if err := rows.Scan(
			&i.ID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.VersionParentID,
			&i.DeltaParentID,
			&i.Hidden,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllWorkspacesByUserID = `-- name: GetAllWorkspacesByUserID :many
SELECT
  w.id,
  w.name,
  w.updated,
  w.collection_count,
  w.flow_count,
  w.active_env,
  w.global_env,
  w.prev,
  w.next
FROM
  workspaces w
INNER JOIN workspaces_users wu ON w.id = wu.workspace_id
WHERE
  wu.user_id = ?
ORDER BY
  w.updated DESC
`

// Returns ALL workspaces for a user, including isolated ones (prev=NULL, next=NULL)
// Unlike GetWorkspacesByUserIDOrdered, this query finds workspaces regardless of linked-list state
// Essential for finding new workspaces that haven't been linked yet
func (q *Queries) GetAllWorkspacesByUserID(ctx context.Context, userID idwrap.IDWrap) ([]Workspace, error) {
	rows, err := q.query(ctx, q.getAllWorkspacesByUserIDStmt, getAllWorkspacesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workspace{}
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Updated,
			&i.CollectionCount,
			&i.FlowCount,
			&i.ActiveEnv,
			&i.GlobalEnv,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssert = `-- name: GetAssert :one
/*
* INFO: Asserts
*/

SELECT
  id,
  example_id,
  delta_parent_id,
  expression,
  enable,
  prev,
  next
FROM
  assertion
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetAssert(ctx context.Context, id idwrap.IDWrap) (Assertion, error) {
	row := q.queryRow(ctx, q.getAssertStmt, getAssert, id)
	var i Assertion
	err := row.Scan(
		&i.ID,
		&i.ExampleID,
		&i.DeltaParentID,
		&i.Expression,
		&i.Enable,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getAssertResult = `-- name: GetAssertResult :one
/*
* INFO: assert_result
*/

SELECT
  id,
  response_id,
  assertion_id,
  result
FROM
  assertion_result
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetAssertResult(ctx context.Context, id idwrap.IDWrap) (AssertionResult, error) {
	row := q.queryRow(ctx, q.getAssertResultStmt, getAssertResult, id)
	var i AssertionResult
	err := row.Scan(
		&i.ID,
		&i.ResponseID,
		&i.AssertionID,
		&i.Result,
	)
	return i, err
}

const getAssertResultsByAssertID = `-- name: GetAssertResultsByAssertID :many
SELECT
  id,
  response_id,
  assertion_id,
  result
FROM
  assertion_result
WHERE
  assertion_id = ?
`

func (q *Queries) GetAssertResultsByAssertID(ctx context.Context, assertionID idwrap.IDWrap) ([]AssertionResult, error) {
	rows, err := q.query(ctx, q.getAssertResultsByAssertIDStmt, getAssertResultsByAssertID, assertionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AssertionResult{}
	for rows.Next() {
		var i AssertionResult
		if err := rows.Scan(
			&i.ID,
			&i.ResponseID,
			&i.AssertionID,
			&i.Result,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssertResultsByResponseID = `-- name: GetAssertResultsByResponseID :many
SELECT
  id,
  response_id,
  assertion_id,
  result
FROM
  assertion_result
WHERE
  response_id = ?
`

func (q *Queries) GetAssertResultsByResponseID(ctx context.Context, responseID idwrap.IDWrap) ([]AssertionResult, error) {
	rows, err := q.query(ctx, q.getAssertResultsByResponseIDStmt, getAssertResultsByResponseID, responseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AssertionResult{}
	for rows.Next() {
		var i AssertionResult
		if err := rows.Scan(
			&i.ID,
			&i.ResponseID,
			&i.AssertionID,
			&i.Result,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssertTail = `-- name: GetAssertTail :one
SELECT
  id,
  example_id,
  delta_parent_id,
  expression,
  enable,
  prev,
  next
FROM
  assertion
WHERE
  example_id = ? AND
  next IS NULL
LIMIT
  1
`

// Get the last assertion in the list (tail) for an example
// Used when appending new assertions to the end of the list
func (q *Queries) GetAssertTail(ctx context.Context, exampleID idwrap.IDWrap) (Assertion, error) {
	row := q.queryRow(ctx, q.getAssertTailStmt, getAssertTail, exampleID)
	var i Assertion
	err := row.Scan(
		&i.ID,
		&i.ExampleID,
		&i.DeltaParentID,
		&i.Expression,
		&i.Enable,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getAssertsByDeltaParent = `-- name: GetAssertsByDeltaParent :many
SELECT
  id,
  example_id,
  delta_parent_id,
  expression,
  enable,
  prev,
  next
FROM
  assertion
WHERE
  delta_parent_id = ?
`

func (q *Queries) GetAssertsByDeltaParent(ctx context.Context, deltaParentID *idwrap.IDWrap) ([]Assertion, error) {
	rows, err := q.query(ctx, q.getAssertsByDeltaParentStmt, getAssertsByDeltaParent, deltaParentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Assertion{}
	for rows.Next() {
		var i Assertion
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.DeltaParentID,
			&i.Expression,
			&i.Enable,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssertsByExampleID = `-- name: GetAssertsByExampleID :many
SELECT
  id,
  example_id,
  delta_parent_id,
  expression,
  enable,
  prev,
  next
FROM
  assertion
WHERE
  example_id = ?
`

func (q *Queries) GetAssertsByExampleID(ctx context.Context, exampleID idwrap.IDWrap) ([]Assertion, error) {
	rows, err := q.query(ctx, q.getAssertsByExampleIDStmt, getAssertsByExampleID, exampleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Assertion{}
	for rows.Next() {
		var i Assertion
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.DeltaParentID,
			&i.Expression,
			&i.Enable,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssertsByExampleIDOrdered = `-- name: GetAssertsByExampleIDOrdered :many
WITH RECURSIVE ordered_asserts AS (
  -- Base case: Find the head (prev IS NULL) for this example
  SELECT
    a.id,
    a.example_id,
    a.delta_parent_id,
    a.expression,
    a.enable,
    a.prev,
    a.next,
    0 as position
  FROM
    assertion a
  WHERE
    a.example_id = ? AND
    a.prev IS NULL
  
  UNION ALL
  
  -- Recursive case: Follow the next pointers
  SELECT
    a.id,
    a.example_id,
    a.delta_parent_id,
    a.expression,
    a.enable,
    a.prev,
    a.next,
    oa.position + 1
  FROM
    assertion a
  INNER JOIN ordered_asserts oa ON a.prev = oa.id
  WHERE
    a.example_id = ?
)
SELECT
  oa.id,
  oa.example_id,
  oa.delta_parent_id,
  oa.expression,
  oa.enable,
  oa.prev,
  oa.next,
  oa.position
FROM
  ordered_asserts oa
ORDER BY
  oa.position
`

type GetAssertsByExampleIDOrderedParams struct {
	ExampleID   idwrap.IDWrap
	ExampleID_2 idwrap.IDWrap
}

type GetAssertsByExampleIDOrderedRow struct {
	ID            []byte
	ExampleID     []byte
	DeltaParentID []byte
	Expression    string
	Enable        bool
	Prev          []byte
	Next          []byte
	Position      int64
}

// Uses WITH RECURSIVE CTE to traverse linked list from head to tail for example-scoped ordering
// Assertions are scoped to specific examples via example_id column
func (q *Queries) GetAssertsByExampleIDOrdered(ctx context.Context, arg GetAssertsByExampleIDOrderedParams) ([]GetAssertsByExampleIDOrderedRow, error) {
	rows, err := q.query(ctx, q.getAssertsByExampleIDOrderedStmt, getAssertsByExampleIDOrdered, arg.ExampleID, arg.ExampleID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAssertsByExampleIDOrderedRow{}
	for rows.Next() {
		var i GetAssertsByExampleIDOrderedRow
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.DeltaParentID,
			&i.Expression,
			&i.Enable,
			&i.Prev,
			&i.Next,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssertsByExampleIDs = `-- name: GetAssertsByExampleIDs :many
SELECT
  id,
  example_id,
  delta_parent_id,
  expression,
  enable,
  prev,
  next
FROM
  assertion
WHERE
  example_id IN (/*SLICE:example_ids*/?)
ORDER BY example_id
`

func (q *Queries) GetAssertsByExampleIDs(ctx context.Context, exampleIds []idwrap.IDWrap) ([]Assertion, error) {
	query := getAssertsByExampleIDs
	var queryParams []interface{}
	if len(exampleIds) > 0 {
		for _, v := range exampleIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:example_ids*/?", strings.Repeat(",?", len(exampleIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:example_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Assertion{}
	for rows.Next() {
		var i Assertion
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.DeltaParentID,
			&i.Expression,
			&i.Enable,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBodyForm = `-- name: GetBodyForm :one
/*
*
* body_form
*
*/

SELECT
  id,
  example_id,
  delta_parent_id,
  body_key,
  enable,
  description,
  value
FROM
    example_body_form
WHERE
    id = ?
LIMIT 1
`

func (q *Queries) GetBodyForm(ctx context.Context, id idwrap.IDWrap) (ExampleBodyForm, error) {
	row := q.queryRow(ctx, q.getBodyFormStmt, getBodyForm, id)
	var i ExampleBodyForm
	err := row.Scan(
		&i.ID,
		&i.ExampleID,
		&i.DeltaParentID,
		&i.BodyKey,
		&i.Enable,
		&i.Description,
		&i.Value,
	)
	return i, err
}

const getBodyFormsByDeltaParentID = `-- name: GetBodyFormsByDeltaParentID :many
SELECT
  id,
  example_id,
  delta_parent_id,
  body_key,
  enable,
  description,
  value
FROM
    example_body_form
WHERE
    delta_parent_id = ?
`

func (q *Queries) GetBodyFormsByDeltaParentID(ctx context.Context, deltaParentID *idwrap.IDWrap) ([]ExampleBodyForm, error) {
	rows, err := q.query(ctx, q.getBodyFormsByDeltaParentIDStmt, getBodyFormsByDeltaParentID, deltaParentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExampleBodyForm{}
	for rows.Next() {
		var i ExampleBodyForm
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.DeltaParentID,
			&i.BodyKey,
			&i.Enable,
			&i.Description,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBodyFormsByExampleID = `-- name: GetBodyFormsByExampleID :many
SELECT
  id,
  example_id,
  delta_parent_id,
  body_key,
  enable,
  description,
  value
FROM
    example_body_form
WHERE
    example_id = ?
`

func (q *Queries) GetBodyFormsByExampleID(ctx context.Context, exampleID idwrap.IDWrap) ([]ExampleBodyForm, error) {
	rows, err := q.query(ctx, q.getBodyFormsByExampleIDStmt, getBodyFormsByExampleID, exampleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExampleBodyForm{}
	for rows.Next() {
		var i ExampleBodyForm
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.DeltaParentID,
			&i.BodyKey,
			&i.Enable,
			&i.Description,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBodyFormsByExampleIDs = `-- name: GetBodyFormsByExampleIDs :many
SELECT
  id,
  example_id,
  delta_parent_id,
  body_key,
  enable,
  description,
  value
FROM
    example_body_form
WHERE
    example_id IN (/*SLICE:example_ids*/?)
ORDER BY example_id
`

func (q *Queries) GetBodyFormsByExampleIDs(ctx context.Context, exampleIds []idwrap.IDWrap) ([]ExampleBodyForm, error) {
	query := getBodyFormsByExampleIDs
	var queryParams []interface{}
	if len(exampleIds) > 0 {
		for _, v := range exampleIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:example_ids*/?", strings.Repeat(",?", len(exampleIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:example_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExampleBodyForm{}
	for rows.Next() {
		var i ExampleBodyForm
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.DeltaParentID,
			&i.BodyKey,
			&i.Enable,
			&i.Description,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBodyRaw = `-- name: GetBodyRaw :one
/*
* Body Raw
*/

SELECT
  id,
  example_id,
  visualize_mode,
  compress_type,
  data
FROM
  example_body_raw
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetBodyRaw(ctx context.Context, id idwrap.IDWrap) (ExampleBodyRaw, error) {
	row := q.queryRow(ctx, q.getBodyRawStmt, getBodyRaw, id)
	var i ExampleBodyRaw
	err := row.Scan(
		&i.ID,
		&i.ExampleID,
		&i.VisualizeMode,
		&i.CompressType,
		&i.Data,
	)
	return i, err
}

const getBodyRawsByExampleID = `-- name: GetBodyRawsByExampleID :one
SELECT
  id,
  example_id,
  visualize_mode,
  compress_type,
  data
FROM
  example_body_raw
WHERE
  example_id = ?
LIMIT 1
`

func (q *Queries) GetBodyRawsByExampleID(ctx context.Context, exampleID idwrap.IDWrap) (ExampleBodyRaw, error) {
	row := q.queryRow(ctx, q.getBodyRawsByExampleIDStmt, getBodyRawsByExampleID, exampleID)
	var i ExampleBodyRaw
	err := row.Scan(
		&i.ID,
		&i.ExampleID,
		&i.VisualizeMode,
		&i.CompressType,
		&i.Data,
	)
	return i, err
}

const getBodyRawsByExampleIDs = `-- name: GetBodyRawsByExampleIDs :many
SELECT
  id,
  example_id,
  visualize_mode,
  compress_type,
  data
FROM
  example_body_raw
WHERE
  example_id IN (/*SLICE:example_ids*/?)
ORDER BY example_id
`

func (q *Queries) GetBodyRawsByExampleIDs(ctx context.Context, exampleIds []idwrap.IDWrap) ([]ExampleBodyRaw, error) {
	query := getBodyRawsByExampleIDs
	var queryParams []interface{}
	if len(exampleIds) > 0 {
		for _, v := range exampleIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:example_ids*/?", strings.Repeat(",?", len(exampleIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:example_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExampleBodyRaw{}
	for rows.Next() {
		var i ExampleBodyRaw
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.VisualizeMode,
			&i.CompressType,
			&i.Data,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBodyUrlEncoded = `-- name: GetBodyUrlEncoded :one

SELECT
  id,
  example_id,
  delta_parent_id,
  body_key,
  enable,
  description,
  value
FROM
  example_body_urlencoded
WHERE
  id = ?
LIMIT 1
`

type GetBodyUrlEncodedRow struct {
	ID            idwrap.IDWrap
	ExampleID     idwrap.IDWrap
	DeltaParentID *idwrap.IDWrap
	BodyKey       string
	Enable        bool
	Description   string
	Value         string
}

// Body Url Encoded
func (q *Queries) GetBodyUrlEncoded(ctx context.Context, id idwrap.IDWrap) (GetBodyUrlEncodedRow, error) {
	row := q.queryRow(ctx, q.getBodyUrlEncodedStmt, getBodyUrlEncoded, id)
	var i GetBodyUrlEncodedRow
	err := row.Scan(
		&i.ID,
		&i.ExampleID,
		&i.DeltaParentID,
		&i.BodyKey,
		&i.Enable,
		&i.Description,
		&i.Value,
	)
	return i, err
}

const getBodyUrlEncodedLinks = `-- name: GetBodyUrlEncodedLinks :one
SELECT
  example_id,
  prev,
  next
FROM
  example_body_urlencoded
WHERE
  id = ?
LIMIT 1
`

type GetBodyUrlEncodedLinksRow struct {
	ExampleID idwrap.IDWrap
	Prev      []byte
	Next      []byte
}

func (q *Queries) GetBodyUrlEncodedLinks(ctx context.Context, id idwrap.IDWrap) (GetBodyUrlEncodedLinksRow, error) {
	row := q.queryRow(ctx, q.getBodyUrlEncodedLinksStmt, getBodyUrlEncodedLinks, id)
	var i GetBodyUrlEncodedLinksRow
	err := row.Scan(&i.ExampleID, &i.Prev, &i.Next)
	return i, err
}

const getBodyUrlEncodedTail = `-- name: GetBodyUrlEncodedTail :one
SELECT
  id,
  example_id,
  delta_parent_id,
  body_key,
  enable,
  description,
  value,
  prev,
  next
FROM
  example_body_urlencoded
WHERE
  example_id = ? AND
  next IS NULL
LIMIT
  1
`

// Get the last URL-encoded pair in the list (tail) for an example
// Used when appending new pairs to the end of the list
func (q *Queries) GetBodyUrlEncodedTail(ctx context.Context, exampleID idwrap.IDWrap) (ExampleBodyUrlencoded, error) {
	row := q.queryRow(ctx, q.getBodyUrlEncodedTailStmt, getBodyUrlEncodedTail, exampleID)
	var i ExampleBodyUrlencoded
	err := row.Scan(
		&i.ID,
		&i.ExampleID,
		&i.DeltaParentID,
		&i.BodyKey,
		&i.Enable,
		&i.Description,
		&i.Value,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getBodyUrlEncodedTailExcludingID = `-- name: GetBodyUrlEncodedTailExcludingID :one
SELECT
  id,
  example_id,
  delta_parent_id,
  body_key,
  enable,
  description,
  value,
  prev,
  next
FROM
  example_body_urlencoded
WHERE
  example_id = ? AND
  id <> ? AND
  next IS NULL
LIMIT
  1
`

type GetBodyUrlEncodedTailExcludingIDParams struct {
	ExampleID idwrap.IDWrap
	ID        idwrap.IDWrap
}

func (q *Queries) GetBodyUrlEncodedTailExcludingID(ctx context.Context, arg GetBodyUrlEncodedTailExcludingIDParams) (ExampleBodyUrlencoded, error) {
	row := q.queryRow(ctx, q.getBodyUrlEncodedTailExcludingIDStmt, getBodyUrlEncodedTailExcludingID, arg.ExampleID, arg.ID)
	var i ExampleBodyUrlencoded
	err := row.Scan(
		&i.ID,
		&i.ExampleID,
		&i.DeltaParentID,
		&i.BodyKey,
		&i.Enable,
		&i.Description,
		&i.Value,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getBodyUrlEncodedsByDeltaParentID = `-- name: GetBodyUrlEncodedsByDeltaParentID :many
SELECT
  id,
  example_id,
  delta_parent_id,
  body_key,
  enable,
  description,
  value
FROM
  example_body_urlencoded
WHERE
  delta_parent_id = ?
`

type GetBodyUrlEncodedsByDeltaParentIDRow struct {
	ID            idwrap.IDWrap
	ExampleID     idwrap.IDWrap
	DeltaParentID *idwrap.IDWrap
	BodyKey       string
	Enable        bool
	Description   string
	Value         string
}

func (q *Queries) GetBodyUrlEncodedsByDeltaParentID(ctx context.Context, deltaParentID *idwrap.IDWrap) ([]GetBodyUrlEncodedsByDeltaParentIDRow, error) {
	rows, err := q.query(ctx, q.getBodyUrlEncodedsByDeltaParentIDStmt, getBodyUrlEncodedsByDeltaParentID, deltaParentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBodyUrlEncodedsByDeltaParentIDRow{}
	for rows.Next() {
		var i GetBodyUrlEncodedsByDeltaParentIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.DeltaParentID,
			&i.BodyKey,
			&i.Enable,
			&i.Description,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBodyUrlEncodedsByExampleID = `-- name: GetBodyUrlEncodedsByExampleID :many
SELECT
  id,
  example_id,
  delta_parent_id,
  body_key,
  enable,
  description,
  value,
  prev,
  next
FROM
  example_body_urlencoded
WHERE
  example_id = ?
`

func (q *Queries) GetBodyUrlEncodedsByExampleID(ctx context.Context, exampleID idwrap.IDWrap) ([]ExampleBodyUrlencoded, error) {
	rows, err := q.query(ctx, q.getBodyUrlEncodedsByExampleIDStmt, getBodyUrlEncodedsByExampleID, exampleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExampleBodyUrlencoded{}
	for rows.Next() {
		var i ExampleBodyUrlencoded
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.DeltaParentID,
			&i.BodyKey,
			&i.Enable,
			&i.Description,
			&i.Value,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBodyUrlEncodedsByExampleIDOrdered = `-- name: GetBodyUrlEncodedsByExampleIDOrdered :many
WITH RECURSIVE ordered_urlenc AS (
  -- Base case: Find the head (prev IS NULL) for this example
  SELECT
    b.id,
    b.example_id,
    b.delta_parent_id,
    b.body_key,
    b.enable,
    b.description,
    b.value,
    b.prev,
    b.next,
    0 as position
  FROM
    example_body_urlencoded b
  WHERE
    b.example_id = ? AND
    b.prev IS NULL

  UNION ALL

  -- Recursive case: Follow the next pointers
  SELECT
    b.id,
    b.example_id,
    b.delta_parent_id,
    b.body_key,
    b.enable,
    b.description,
    b.value,
    b.prev,
    b.next,
    ou.position + 1
  FROM
    example_body_urlencoded b
  INNER JOIN ordered_urlenc ou ON b.prev = ou.id
  WHERE
    b.example_id = ?
)
SELECT
  ou.id,
  ou.example_id,
  ou.delta_parent_id,
  ou.body_key,
  ou.enable,
  ou.description,
  ou.value,
  ou.prev,
  ou.next,
  ou.position
FROM
  ordered_urlenc ou
ORDER BY
  ou.position
`

type GetBodyUrlEncodedsByExampleIDOrderedParams struct {
	ExampleID   idwrap.IDWrap
	ExampleID_2 idwrap.IDWrap
}

type GetBodyUrlEncodedsByExampleIDOrderedRow struct {
	ID            []byte
	ExampleID     []byte
	DeltaParentID []byte
	BodyKey       string
	Enable        bool
	Description   string
	Value         string
	Prev          []byte
	Next          []byte
	Position      int64
}

// Uses WITH RECURSIVE CTE to traverse linked list from head to tail for example-scoped ordering
// URL-encoded body fields are scoped to specific examples via example_id column
func (q *Queries) GetBodyUrlEncodedsByExampleIDOrdered(ctx context.Context, arg GetBodyUrlEncodedsByExampleIDOrderedParams) ([]GetBodyUrlEncodedsByExampleIDOrderedRow, error) {
	rows, err := q.query(ctx, q.getBodyUrlEncodedsByExampleIDOrderedStmt, getBodyUrlEncodedsByExampleIDOrdered, arg.ExampleID, arg.ExampleID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBodyUrlEncodedsByExampleIDOrderedRow{}
	for rows.Next() {
		var i GetBodyUrlEncodedsByExampleIDOrderedRow
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.DeltaParentID,
			&i.BodyKey,
			&i.Enable,
			&i.Description,
			&i.Value,
			&i.Prev,
			&i.Next,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBodyUrlEncodedsByExampleIDs = `-- name: GetBodyUrlEncodedsByExampleIDs :many
SELECT
  id,
  example_id,
  delta_parent_id,
  body_key,
  enable,
  description,
  value,
  prev,
  next
FROM
  example_body_urlencoded
WHERE
  example_id IN (/*SLICE:example_ids*/?)
ORDER BY example_id
`

func (q *Queries) GetBodyUrlEncodedsByExampleIDs(ctx context.Context, exampleIds []idwrap.IDWrap) ([]ExampleBodyUrlencoded, error) {
	query := getBodyUrlEncodedsByExampleIDs
	var queryParams []interface{}
	if len(exampleIds) > 0 {
		for _, v := range exampleIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:example_ids*/?", strings.Repeat(",?", len(exampleIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:example_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExampleBodyUrlencoded{}
	for rows.Next() {
		var i ExampleBodyUrlencoded
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.DeltaParentID,
			&i.BodyKey,
			&i.Enable,
			&i.Description,
			&i.Value,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnvironment = `-- name: GetEnvironment :one
/*
* Environment
*/

SELECT
  id,
  workspace_id,
  type,
  name,
  description,
  display_order
FROM
  environment
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetEnvironment(ctx context.Context, id idwrap.IDWrap) (Environment, error) {
	row := q.queryRow(ctx, q.getEnvironmentStmt, getEnvironment, id)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Type,
		&i.Name,
		&i.Description,
		&i.DisplayOrder,
	)
	return i, err
}

const getEnvironmentWorkspaceID = `-- name: GetEnvironmentWorkspaceID :one
SELECT
  workspace_id
FROM
  environment
WHERE
  id = ?
LIMIT
  1
`

func (q *Queries) GetEnvironmentWorkspaceID(ctx context.Context, id idwrap.IDWrap) (idwrap.IDWrap, error) {
	row := q.queryRow(ctx, q.getEnvironmentWorkspaceIDStmt, getEnvironmentWorkspaceID, id)
	var workspace_id idwrap.IDWrap
	err := row.Scan(&workspace_id)
	return workspace_id, err
}

const getEnvironmentsByWorkspaceID = `-- name: GetEnvironmentsByWorkspaceID :many
SELECT
  id,
  workspace_id,
  type,
  name,
  description,
  display_order
FROM
  environment
WHERE
  workspace_id = ?
ORDER BY
  display_order
`

func (q *Queries) GetEnvironmentsByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]Environment, error) {
	rows, err := q.query(ctx, q.getEnvironmentsByWorkspaceIDStmt, getEnvironmentsByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Environment{}
	for rows.Next() {
		var i Environment
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Type,
			&i.Name,
			&i.Description,
			&i.DisplayOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnvironmentsByWorkspaceIDOrdered = `-- name: GetEnvironmentsByWorkspaceIDOrdered :many
SELECT
  id,
  workspace_id,
  type,
  name,
  description,
  display_order
FROM
  environment
WHERE
  workspace_id = ?
ORDER BY
  display_order
`

func (q *Queries) GetEnvironmentsByWorkspaceIDOrdered(ctx context.Context, workspaceID idwrap.IDWrap) ([]Environment, error) {
	rows, err := q.query(ctx, q.getEnvironmentsByWorkspaceIDOrderedStmt, getEnvironmentsByWorkspaceIDOrdered, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Environment{}
	for rows.Next() {
		var i Environment
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Type,
			&i.Name,
			&i.Description,
			&i.DisplayOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExampleResp = `-- name: GetExampleResp :one
SELECT
    id, example_id, status, body, body_compress_type, duration
FROM
  example_resp
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetExampleResp(ctx context.Context, id idwrap.IDWrap) (ExampleResp, error) {
	row := q.queryRow(ctx, q.getExampleRespStmt, getExampleResp, id)
	var i ExampleResp
	err := row.Scan(
		&i.ID,
		&i.ExampleID,
		&i.Status,
		&i.Body,
		&i.BodyCompressType,
		&i.Duration,
	)
	return i, err
}

const getExampleRespByExampleID = `-- name: GetExampleRespByExampleID :one
SELECT
    id, example_id, status, body, body_compress_type, duration
FROM
  example_resp
WHERE
  example_id = ?
LIMIT 1
`

func (q *Queries) GetExampleRespByExampleID(ctx context.Context, exampleID idwrap.IDWrap) (ExampleResp, error) {
	row := q.queryRow(ctx, q.getExampleRespByExampleIDStmt, getExampleRespByExampleID, exampleID)
	var i ExampleResp
	err := row.Scan(
		&i.ID,
		&i.ExampleID,
		&i.Status,
		&i.Body,
		&i.BodyCompressType,
		&i.Duration,
	)
	return i, err
}

const getExampleRespByExampleIDLatest = `-- name: GetExampleRespByExampleIDLatest :one
SELECT
    id, example_id, status, body, body_compress_type, duration
FROM
  example_resp
WHERE
  example_id = ?
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) GetExampleRespByExampleIDLatest(ctx context.Context, exampleID idwrap.IDWrap) (ExampleResp, error) {
	row := q.queryRow(ctx, q.getExampleRespByExampleIDLatestStmt, getExampleRespByExampleIDLatest, exampleID)
	var i ExampleResp
	err := row.Scan(
		&i.ID,
		&i.ExampleID,
		&i.Status,
		&i.Body,
		&i.BodyCompressType,
		&i.Duration,
	)
	return i, err
}

const getExampleRespByExampleIDsLatest = `-- name: GetExampleRespByExampleIDsLatest :many
SELECT
  id,
  example_id,
  status,
  body,
  body_compress_type,
  duration
FROM (
  SELECT
    er.id, er.example_id, er.status, er.body, er.body_compress_type, er.duration, 
    ROW_NUMBER() OVER (PARTITION BY er.example_id ORDER BY er.id DESC) AS rn
  FROM
    example_resp er
  WHERE
    er.example_id IN (/*SLICE:example_ids*/?)
)
WHERE
  rn = 1
`

func (q *Queries) GetExampleRespByExampleIDsLatest(ctx context.Context, exampleIds []idwrap.IDWrap) ([]ExampleResp, error) {
	query := getExampleRespByExampleIDsLatest
	var queryParams []interface{}
	if len(exampleIds) > 0 {
		for _, v := range exampleIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:example_ids*/?", strings.Repeat(",?", len(exampleIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:example_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExampleResp{}
	for rows.Next() {
		var i ExampleResp
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.Status,
			&i.Body,
			&i.BodyCompressType,
			&i.Duration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExampleRespHeader = `-- name: GetExampleRespHeader :one
/*
* example_resp_header
*/

SELECT
  id,
  example_resp_id,
  header_key,
  value
FROM
  example_resp_header
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetExampleRespHeader(ctx context.Context, id idwrap.IDWrap) (ExampleRespHeader, error) {
	row := q.queryRow(ctx, q.getExampleRespHeaderStmt, getExampleRespHeader, id)
	var i ExampleRespHeader
	err := row.Scan(
		&i.ID,
		&i.ExampleRespID,
		&i.HeaderKey,
		&i.Value,
	)
	return i, err
}

const getExampleRespHeadersByRespID = `-- name: GetExampleRespHeadersByRespID :many
SELECT
  id,
  example_resp_id,
  header_key,
  value
FROM
  example_resp_header
WHERE
  example_resp_id = ?
`

func (q *Queries) GetExampleRespHeadersByRespID(ctx context.Context, exampleRespID idwrap.IDWrap) ([]ExampleRespHeader, error) {
	rows, err := q.query(ctx, q.getExampleRespHeadersByRespIDStmt, getExampleRespHeadersByRespID, exampleRespID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExampleRespHeader{}
	for rows.Next() {
		var i ExampleRespHeader
		if err := rows.Scan(
			&i.ID,
			&i.ExampleRespID,
			&i.HeaderKey,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExampleRespHeadersByRespIDs = `-- name: GetExampleRespHeadersByRespIDs :many
SELECT
  id,
  example_resp_id,
  header_key,
  value
FROM
  example_resp_header
WHERE
  example_resp_id IN (/*SLICE:resp_ids*/?)
ORDER BY example_resp_id
`

func (q *Queries) GetExampleRespHeadersByRespIDs(ctx context.Context, respIds []idwrap.IDWrap) ([]ExampleRespHeader, error) {
	query := getExampleRespHeadersByRespIDs
	var queryParams []interface{}
	if len(respIds) > 0 {
		for _, v := range respIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:resp_ids*/?", strings.Repeat(",?", len(respIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:resp_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExampleRespHeader{}
	for rows.Next() {
		var i ExampleRespHeader
		if err := rows.Scan(
			&i.ID,
			&i.ExampleRespID,
			&i.HeaderKey,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExamplesByEndpointIDOrdered = `-- name: GetExamplesByEndpointIDOrdered :many
WITH RECURSIVE ordered_examples AS (
  -- Base case: Find the head (prev IS NULL) for this endpoint
  SELECT
    e.id,
    e.item_api_id,
    e.is_default,
    e.body_type,
    e.name,
    e.version_parent_id,
    e.prev,
    e.next,
    0 as position
  FROM
    item_api_example e
  WHERE
    e.item_api_id = ? AND
    e.version_parent_id IS NULL AND
    e.is_default = FALSE AND
    e.prev IS NULL
  
  UNION ALL
  
  -- Recursive case: Follow the next pointers
  SELECT
    e.id,
    e.item_api_id,
    e.is_default,
    e.body_type,
    e.name,
    e.version_parent_id,
    e.prev,
    e.next,
    oe.position + 1
  FROM
    item_api_example e
  INNER JOIN ordered_examples oe ON e.prev = oe.id
  WHERE
    e.item_api_id = ? AND
    e.version_parent_id IS NULL AND
    e.is_default = FALSE
)
SELECT
  oe.id,
  oe.item_api_id,
  oe.is_default,
  oe.body_type,
  oe.name,
  oe.version_parent_id,
  oe.prev,
  oe.next,
  oe.position
FROM
  ordered_examples oe
ORDER BY
  oe.position
`

type GetExamplesByEndpointIDOrderedParams struct {
	ItemApiID   idwrap.IDWrap
	ItemApiID_2 idwrap.IDWrap
}

type GetExamplesByEndpointIDOrderedRow struct {
	ID              []byte
	ItemApiID       []byte
	IsDefault       bool
	BodyType        int8
	Name            string
	VersionParentID []byte
	Prev            []byte
	Next            []byte
	Position        int64
}

// Uses WITH RECURSIVE CTE to traverse linked list from head to tail for endpoint-scoped ordering
// Examples are scoped to specific endpoints via item_api_id column
// Excludes default examples (is_default = FALSE) to match other example queries
func (q *Queries) GetExamplesByEndpointIDOrdered(ctx context.Context, arg GetExamplesByEndpointIDOrderedParams) ([]GetExamplesByEndpointIDOrderedRow, error) {
	rows, err := q.query(ctx, q.getExamplesByEndpointIDOrderedStmt, getExamplesByEndpointIDOrdered, arg.ItemApiID, arg.ItemApiID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetExamplesByEndpointIDOrderedRow{}
	for rows.Next() {
		var i GetExamplesByEndpointIDOrderedRow
		if err := rows.Scan(
			&i.ID,
			&i.ItemApiID,
			&i.IsDefault,
			&i.BodyType,
			&i.Name,
			&i.VersionParentID,
			&i.Prev,
			&i.Next,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFile = `-- name: GetFile :one







SELECT id, workspace_id, folder_id, content_id, content_kind, name, display_order, updated_at
FROM files
WHERE id = ?
`

// File System
//
// Get a single file by ID
func (q *Queries) GetFile(ctx context.Context, id idwrap.IDWrap) (File, error) {
	row := q.queryRow(ctx, q.getFileStmt, getFile, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.FolderID,
		&i.ContentID,
		&i.ContentKind,
		&i.Name,
		&i.DisplayOrder,
		&i.UpdatedAt,
	)
	return i, err
}

const getFileWithContent = `-- name: GetFileWithContent :one
SELECT id, workspace_id, folder_id, content_id, content_kind, name, display_order, updated_at
FROM files
WHERE id = ?
`

// Get a file with its content (two-query pattern for union types)
func (q *Queries) GetFileWithContent(ctx context.Context, id idwrap.IDWrap) (File, error) {
	row := q.queryRow(ctx, q.getFileWithContentStmt, getFileWithContent, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.FolderID,
		&i.ContentID,
		&i.ContentKind,
		&i.Name,
		&i.DisplayOrder,
		&i.UpdatedAt,
	)
	return i, err
}

const getFileWorkspaceID = `-- name: GetFileWorkspaceID :one
SELECT workspace_id 
FROM files
WHERE id = ?
`

// Get the workspace_id for a file
func (q *Queries) GetFileWorkspaceID(ctx context.Context, id idwrap.IDWrap) (idwrap.IDWrap, error) {
	row := q.queryRow(ctx, q.getFileWorkspaceIDStmt, getFileWorkspaceID, id)
	var workspace_id idwrap.IDWrap
	err := row.Scan(&workspace_id)
	return workspace_id, err
}

const getFilesByFolderID = `-- name: GetFilesByFolderID :many
SELECT id, workspace_id, folder_id, content_id, content_kind, name, display_order, updated_at
FROM files
WHERE folder_id = ?
`

// Get all files directly under a folder (unordered)
func (q *Queries) GetFilesByFolderID(ctx context.Context, folderID *idwrap.IDWrap) ([]File, error) {
	rows, err := q.query(ctx, q.getFilesByFolderIDStmt, getFilesByFolderID, folderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.ContentID,
			&i.ContentKind,
			&i.Name,
			&i.DisplayOrder,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesByFolderIDOrdered = `-- name: GetFilesByFolderIDOrdered :many
SELECT id, workspace_id, folder_id, content_id, content_kind, name, display_order, updated_at
FROM files
WHERE folder_id = ?
ORDER BY display_order, id
`

// Get all files directly under a folder ordered by display_order
func (q *Queries) GetFilesByFolderIDOrdered(ctx context.Context, folderID *idwrap.IDWrap) ([]File, error) {
	rows, err := q.query(ctx, q.getFilesByFolderIDOrderedStmt, getFilesByFolderIDOrdered, folderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.ContentID,
			&i.ContentKind,
			&i.Name,
			&i.DisplayOrder,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesByWorkspaceID = `-- name: GetFilesByWorkspaceID :many
SELECT id, workspace_id, folder_id, content_id, content_kind, name, display_order, updated_at
FROM files
WHERE workspace_id = ?
`

// Get all files in a workspace (unordered)
func (q *Queries) GetFilesByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]File, error) {
	rows, err := q.query(ctx, q.getFilesByWorkspaceIDStmt, getFilesByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.ContentID,
			&i.ContentKind,
			&i.Name,
			&i.DisplayOrder,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesByWorkspaceIDOrdered = `-- name: GetFilesByWorkspaceIDOrdered :many
SELECT id, workspace_id, folder_id, content_id, content_kind, name, display_order, updated_at
FROM files
WHERE workspace_id = ?
ORDER BY display_order, id
`

// Get all files in a workspace ordered by display_order
func (q *Queries) GetFilesByWorkspaceIDOrdered(ctx context.Context, workspaceID idwrap.IDWrap) ([]File, error) {
	rows, err := q.query(ctx, q.getFilesByWorkspaceIDOrderedStmt, getFilesByWorkspaceIDOrdered, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.ContentID,
			&i.ContentKind,
			&i.Name,
			&i.DisplayOrder,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlow = `-- name: GetFlow :one
SELECT
  id,
  workspace_id,
  version_parent_id,
  name,
  duration
FROM
  flow
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetFlow(ctx context.Context, id idwrap.IDWrap) (Flow, error) {
	row := q.queryRow(ctx, q.getFlowStmt, getFlow, id)
	var i Flow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.VersionParentID,
		&i.Name,
		&i.Duration,
	)
	return i, err
}

const getFlowContent = `-- name: GetFlowContent :one
SELECT id, name, duration
FROM flow
WHERE id = ?
`

type GetFlowContentRow struct {
	ID       idwrap.IDWrap
	Name     string
	Duration int32
}

// Get flow content by content_id (for union type resolution)
func (q *Queries) GetFlowContent(ctx context.Context, id idwrap.IDWrap) (GetFlowContentRow, error) {
	row := q.queryRow(ctx, q.getFlowContentStmt, getFlowContent, id)
	var i GetFlowContentRow
	err := row.Scan(&i.ID, &i.Name, &i.Duration)
	return i, err
}

const getFlowEdge = `-- name: GetFlowEdge :one
SELECT
  id,
  flow_id,
  source_id,
  target_id,
  source_handle,
  edge_kind
FROM
  flow_edge
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetFlowEdge(ctx context.Context, id idwrap.IDWrap) (FlowEdge, error) {
	row := q.queryRow(ctx, q.getFlowEdgeStmt, getFlowEdge, id)
	var i FlowEdge
	err := row.Scan(
		&i.ID,
		&i.FlowID,
		&i.SourceID,
		&i.TargetID,
		&i.SourceHandle,
		&i.EdgeKind,
	)
	return i, err
}

const getFlowEdgesByFlowID = `-- name: GetFlowEdgesByFlowID :many
SELECT
  id,
  flow_id,
  source_id,
  target_id,
  source_handle,
  edge_kind
FROM
  flow_edge
WHERE
  flow_id = ?
`

func (q *Queries) GetFlowEdgesByFlowID(ctx context.Context, flowID idwrap.IDWrap) ([]FlowEdge, error) {
	rows, err := q.query(ctx, q.getFlowEdgesByFlowIDStmt, getFlowEdgesByFlowID, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowEdge{}
	for rows.Next() {
		var i FlowEdge
		if err := rows.Scan(
			&i.ID,
			&i.FlowID,
			&i.SourceID,
			&i.TargetID,
			&i.SourceHandle,
			&i.EdgeKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowNode = `-- name: GetFlowNode :one
SELECT
  id,
  flow_id,
  name,
  node_kind,
  position_x,
  position_y
FROM
  flow_node
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetFlowNode(ctx context.Context, id idwrap.IDWrap) (FlowNode, error) {
	row := q.queryRow(ctx, q.getFlowNodeStmt, getFlowNode, id)
	var i FlowNode
	err := row.Scan(
		&i.ID,
		&i.FlowID,
		&i.Name,
		&i.NodeKind,
		&i.PositionX,
		&i.PositionY,
	)
	return i, err
}

const getFlowNodeCondition = `-- name: GetFlowNodeCondition :one
SELECT
  flow_node_id,
  expression
FROM
  flow_node_condition
WHERE
  flow_node_id = ?
LIMIT 1
`

func (q *Queries) GetFlowNodeCondition(ctx context.Context, flowNodeID idwrap.IDWrap) (FlowNodeCondition, error) {
	row := q.queryRow(ctx, q.getFlowNodeConditionStmt, getFlowNodeCondition, flowNodeID)
	var i FlowNodeCondition
	err := row.Scan(&i.FlowNodeID, &i.Expression)
	return i, err
}

const getFlowNodeFor = `-- name: GetFlowNodeFor :one
SELECT
  flow_node_id,
  iter_count,
  error_handling,
  expression
FROM
  flow_node_for
WHERE
  flow_node_id = ?
LIMIT 1
`

func (q *Queries) GetFlowNodeFor(ctx context.Context, flowNodeID idwrap.IDWrap) (FlowNodeFor, error) {
	row := q.queryRow(ctx, q.getFlowNodeForStmt, getFlowNodeFor, flowNodeID)
	var i FlowNodeFor
	err := row.Scan(
		&i.FlowNodeID,
		&i.IterCount,
		&i.ErrorHandling,
		&i.Expression,
	)
	return i, err
}

const getFlowNodeForEach = `-- name: GetFlowNodeForEach :one
SELECT
  flow_node_id,
  iter_expression,
  error_handling,
  expression
FROM
  flow_node_for_each
WHERE
  flow_node_id = ?
LIMIT 1
`

func (q *Queries) GetFlowNodeForEach(ctx context.Context, flowNodeID idwrap.IDWrap) (FlowNodeForEach, error) {
	row := q.queryRow(ctx, q.getFlowNodeForEachStmt, getFlowNodeForEach, flowNodeID)
	var i FlowNodeForEach
	err := row.Scan(
		&i.FlowNodeID,
		&i.IterExpression,
		&i.ErrorHandling,
		&i.Expression,
	)
	return i, err
}

const getFlowNodeJs = `-- name: GetFlowNodeJs :one
SELECT
  flow_node_id,
  code,
  code_compress_type
FROM
  flow_node_js
WHERE
  flow_node_id = ?
LIMIT 1
`

func (q *Queries) GetFlowNodeJs(ctx context.Context, flowNodeID idwrap.IDWrap) (FlowNodeJ, error) {
	row := q.queryRow(ctx, q.getFlowNodeJsStmt, getFlowNodeJs, flowNodeID)
	var i FlowNodeJ
	err := row.Scan(&i.FlowNodeID, &i.Code, &i.CodeCompressType)
	return i, err
}

const getFlowNodeNoop = `-- name: GetFlowNodeNoop :one
SELECT
  flow_node_id,
  node_type
FROM
  flow_node_noop
where
  flow_node_id = ?
LIMIT 1
`

func (q *Queries) GetFlowNodeNoop(ctx context.Context, flowNodeID idwrap.IDWrap) (FlowNodeNoop, error) {
	row := q.queryRow(ctx, q.getFlowNodeNoopStmt, getFlowNodeNoop, flowNodeID)
	var i FlowNodeNoop
	err := row.Scan(&i.FlowNodeID, &i.NodeType)
	return i, err
}

const getFlowNodeRequest = `-- name: GetFlowNodeRequest :one
SELECT
  flow_node_id,
  endpoint_id,
  example_id,
  delta_example_id,
  delta_endpoint_id,
  has_request_config
FROM
  flow_node_request
WHERE
  flow_node_id = ?
LIMIT 1
`

func (q *Queries) GetFlowNodeRequest(ctx context.Context, flowNodeID idwrap.IDWrap) (FlowNodeRequest, error) {
	row := q.queryRow(ctx, q.getFlowNodeRequestStmt, getFlowNodeRequest, flowNodeID)
	var i FlowNodeRequest
	err := row.Scan(
		&i.FlowNodeID,
		&i.EndpointID,
		&i.ExampleID,
		&i.DeltaExampleID,
		&i.DeltaEndpointID,
		&i.HasRequestConfig,
	)
	return i, err
}

const getFlowNodesByFlowID = `-- name: GetFlowNodesByFlowID :many
SELECT
  id,
  flow_id,
  name,
  node_kind,
  position_x,
  position_y
FROM
  flow_node
WHERE
  flow_id = ?
`

func (q *Queries) GetFlowNodesByFlowID(ctx context.Context, flowID idwrap.IDWrap) ([]FlowNode, error) {
	rows, err := q.query(ctx, q.getFlowNodesByFlowIDStmt, getFlowNodesByFlowID, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowNode{}
	for rows.Next() {
		var i FlowNode
		if err := rows.Scan(
			&i.ID,
			&i.FlowID,
			&i.Name,
			&i.NodeKind,
			&i.PositionX,
			&i.PositionY,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowTag = `-- name: GetFlowTag :one
SELECT
  id,
  flow_id,
  tag_id
FROM flow_tag
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetFlowTag(ctx context.Context, id idwrap.IDWrap) (FlowTag, error) {
	row := q.queryRow(ctx, q.getFlowTagStmt, getFlowTag, id)
	var i FlowTag
	err := row.Scan(&i.ID, &i.FlowID, &i.TagID)
	return i, err
}

const getFlowTagsByFlowID = `-- name: GetFlowTagsByFlowID :many
SELECT
  id,
  flow_id,
  tag_id
FROM
  flow_tag
WHERE
  flow_id = ?
`

func (q *Queries) GetFlowTagsByFlowID(ctx context.Context, flowID idwrap.IDWrap) ([]FlowTag, error) {
	rows, err := q.query(ctx, q.getFlowTagsByFlowIDStmt, getFlowTagsByFlowID, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowTag{}
	for rows.Next() {
		var i FlowTag
		if err := rows.Scan(&i.ID, &i.FlowID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowTagsByTagID = `-- name: GetFlowTagsByTagID :many
SELECT
  id,
  flow_id,
  tag_id
FROM
  flow_tag
WHERE
  tag_id = ?
`

func (q *Queries) GetFlowTagsByTagID(ctx context.Context, tagID idwrap.IDWrap) ([]FlowTag, error) {
	rows, err := q.query(ctx, q.getFlowTagsByTagIDStmt, getFlowTagsByTagID, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowTag{}
	for rows.Next() {
		var i FlowTag
		if err := rows.Scan(&i.ID, &i.FlowID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowVariable = `-- name: GetFlowVariable :one
SELECT
  id,
  flow_id,
  key,
  value,
  enabled,
  description,
  prev,
  next
FROM
  flow_variable
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetFlowVariable(ctx context.Context, id idwrap.IDWrap) (FlowVariable, error) {
	row := q.queryRow(ctx, q.getFlowVariableStmt, getFlowVariable, id)
	var i FlowVariable
	err := row.Scan(
		&i.ID,
		&i.FlowID,
		&i.Key,
		&i.Value,
		&i.Enabled,
		&i.Description,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getFlowVariablesByFlowID = `-- name: GetFlowVariablesByFlowID :many
SELECT
  id,
  flow_id,
  key,
  value,
  enabled,
  description,
  prev,
  next
FROM
  flow_variable
WHERE
  flow_id = ?
`

func (q *Queries) GetFlowVariablesByFlowID(ctx context.Context, flowID idwrap.IDWrap) ([]FlowVariable, error) {
	rows, err := q.query(ctx, q.getFlowVariablesByFlowIDStmt, getFlowVariablesByFlowID, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowVariable{}
	for rows.Next() {
		var i FlowVariable
		if err := rows.Scan(
			&i.ID,
			&i.FlowID,
			&i.Key,
			&i.Value,
			&i.Enabled,
			&i.Description,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowVariablesByFlowIDOrdered = `-- name: GetFlowVariablesByFlowIDOrdered :many
WITH RECURSIVE ordered_flow_variables AS (
  -- Base case: Find the head (prev IS NULL)
  SELECT
    fv.id,
    fv.flow_id,
    fv.key,
    fv.value,
    fv.enabled,
    fv.description,
    fv.prev,
    fv.next,
    0 as position
  FROM
    flow_variable fv
  WHERE
    fv.flow_id = ? AND
    fv.prev IS NULL
  
  UNION ALL
  
  -- Recursive case: Follow the next pointers
  SELECT
    fv.id,
    fv.flow_id,
    fv.key,
    fv.value,
    fv.enabled,
    fv.description,
    fv.prev,
    fv.next,
    ofv.position + 1
  FROM
    flow_variable fv
  INNER JOIN ordered_flow_variables ofv ON fv.prev = ofv.id
  WHERE
    fv.flow_id = ?
)
SELECT
  ofv.id,
  ofv.flow_id,
  ofv.key,
  ofv.value,
  ofv.enabled,
  ofv.description,
  ofv.prev,
  ofv.next,
  ofv.position
FROM
  ordered_flow_variables ofv
ORDER BY
  ofv.position
`

type GetFlowVariablesByFlowIDOrderedParams struct {
	FlowID   idwrap.IDWrap
	FlowID_2 idwrap.IDWrap
}

type GetFlowVariablesByFlowIDOrderedRow struct {
	ID          []byte
	FlowID      []byte
	Key         string
	Value       string
	Enabled     bool
	Description string
	Prev        []byte
	Next        []byte
	Position    int64
}

// Uses WITH RECURSIVE CTE to traverse linked list from head to tail
// Requires index on (flow_id, prev) for optimal performance
func (q *Queries) GetFlowVariablesByFlowIDOrdered(ctx context.Context, arg GetFlowVariablesByFlowIDOrderedParams) ([]GetFlowVariablesByFlowIDOrderedRow, error) {
	rows, err := q.query(ctx, q.getFlowVariablesByFlowIDOrderedStmt, getFlowVariablesByFlowIDOrdered, arg.FlowID, arg.FlowID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFlowVariablesByFlowIDOrderedRow{}
	for rows.Next() {
		var i GetFlowVariablesByFlowIDOrderedRow
		if err := rows.Scan(
			&i.ID,
			&i.FlowID,
			&i.Key,
			&i.Value,
			&i.Enabled,
			&i.Description,
			&i.Prev,
			&i.Next,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowsByVersionParentID = `-- name: GetFlowsByVersionParentID :many
SELECT
  id,
  workspace_id,
  version_parent_id,
  name,
  duration
FROM
  flow
WHERE
  version_parent_id is ?
`

func (q *Queries) GetFlowsByVersionParentID(ctx context.Context, versionParentID *idwrap.IDWrap) ([]Flow, error) {
	rows, err := q.query(ctx, q.getFlowsByVersionParentIDStmt, getFlowsByVersionParentID, versionParentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Flow{}
	for rows.Next() {
		var i Flow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.VersionParentID,
			&i.Name,
			&i.Duration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowsByWorkspaceID = `-- name: GetFlowsByWorkspaceID :many
SELECT
  id,
  workspace_id,
  version_parent_id,
  name,
  duration
FROM
  flow
WHERE
  workspace_id = ? AND
  version_parent_id is NULL
`

func (q *Queries) GetFlowsByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]Flow, error) {
	rows, err := q.query(ctx, q.getFlowsByWorkspaceIDStmt, getFlowsByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Flow{}
	for rows.Next() {
		var i Flow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.VersionParentID,
			&i.Name,
			&i.Duration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFolderContent = `-- name: GetFolderContent :one
SELECT id, name
FROM item_folder
WHERE id = ?
`

type GetFolderContentRow struct {
	ID   idwrap.IDWrap
	Name string
}

// Get folder content by content_id (for union type resolution)
func (q *Queries) GetFolderContent(ctx context.Context, id idwrap.IDWrap) (GetFolderContentRow, error) {
	row := q.queryRow(ctx, q.getFolderContentStmt, getFolderContent, id)
	var i GetFolderContentRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getHTTP = `-- name: GetHTTP :one
/*
 *
 * HTTP SYSTEM QUERIES
 * Single-table approach with delta fields for Phase 1 HTTP implementation
 *
 */


SELECT
  id,
  workspace_id,
  folder_id,
  name,
  url,
  method,
  description,
  parent_http_id,
  is_delta,
  delta_name,
  delta_url,
  delta_method,
  delta_description,
  created_at,
  updated_at
FROM http
WHERE id = ?
LIMIT 1
`

// HTTP Core Queries
func (q *Queries) GetHTTP(ctx context.Context, id idwrap.IDWrap) (Http, error) {
	row := q.queryRow(ctx, q.getHTTPStmt, getHTTP, id)
	var i Http
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.FolderID,
		&i.Name,
		&i.Url,
		&i.Method,
		&i.Description,
		&i.ParentHttpID,
		&i.IsDelta,
		&i.DeltaName,
		&i.DeltaUrl,
		&i.DeltaMethod,
		&i.DeltaDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHTTPAssert = `-- name: GetHTTPAssert :one

SELECT
  id,
  http_id,
  key,
  value,
  enabled,
  description,
  "order",
  parent_http_assert_id,
  is_delta,
  delta_key,
  delta_value,
  delta_enabled,
  delta_description,
  delta_order,
  created_at,
  updated_at
FROM http_assert
WHERE id = ?
LIMIT 1
`

// HTTP Assert Queries (TypeSpec-compliant)
func (q *Queries) GetHTTPAssert(ctx context.Context, id idwrap.IDWrap) (HttpAssert, error) {
	row := q.queryRow(ctx, q.getHTTPAssertStmt, getHTTPAssert, id)
	var i HttpAssert
	err := row.Scan(
		&i.ID,
		&i.HttpID,
		&i.Key,
		&i.Value,
		&i.Enabled,
		&i.Description,
		&i.Order,
		&i.ParentHttpAssertID,
		&i.IsDelta,
		&i.DeltaKey,
		&i.DeltaValue,
		&i.DeltaEnabled,
		&i.DeltaDescription,
		&i.DeltaOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHTTPAssertsByHttpID = `-- name: GetHTTPAssertsByHttpID :many
SELECT
  id,
  http_id,
  key,
  value,
  enabled,
  description,
  "order",
  parent_http_assert_id,
  is_delta,
  delta_key,
  delta_value,
  delta_enabled,
  delta_description,
  delta_order,
  created_at,
  updated_at
FROM http_assert
WHERE http_id = ? AND is_delta = FALSE
ORDER BY "order"
`

func (q *Queries) GetHTTPAssertsByHttpID(ctx context.Context, httpID idwrap.IDWrap) ([]HttpAssert, error) {
	rows, err := q.query(ctx, q.getHTTPAssertsByHttpIDStmt, getHTTPAssertsByHttpID, httpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpAssert{}
	for rows.Next() {
		var i HttpAssert
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.Enabled,
			&i.Description,
			&i.Order,
			&i.ParentHttpAssertID,
			&i.IsDelta,
			&i.DeltaKey,
			&i.DeltaValue,
			&i.DeltaEnabled,
			&i.DeltaDescription,
			&i.DeltaOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPAssertsByIDs = `-- name: GetHTTPAssertsByIDs :many
SELECT
  id,
  http_id,
  key,
  value,
  enabled,
  description,
  "order",
  parent_http_assert_id,
  is_delta,
  delta_key,
  delta_value,
  delta_enabled,
  delta_description,
  delta_order,
  created_at,
  updated_at
FROM http_assert
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) GetHTTPAssertsByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]HttpAssert, error) {
	query := getHTTPAssertsByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpAssert{}
	for rows.Next() {
		var i HttpAssert
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.Enabled,
			&i.Description,
			&i.Order,
			&i.ParentHttpAssertID,
			&i.IsDelta,
			&i.DeltaKey,
			&i.DeltaValue,
			&i.DeltaEnabled,
			&i.DeltaDescription,
			&i.DeltaOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPBatchForStreaming = `-- name: GetHTTPBatchForStreaming :many
SELECT 
  h.id,
  h.workspace_id,
  h.folder_id,
  h.name,
  h.url,
  h.method,
  h.description,
  h.parent_http_id,
  h.is_delta,
  h.delta_name,
  h.delta_url,
  h.delta_method,
  h.delta_description,
  h.created_at,
  h.updated_at
FROM http h
WHERE h.id IN (/*SLICE:http_ids*/?)
  AND h.updated_at <= ?
ORDER BY h.updated_at DESC
`

type GetHTTPBatchForStreamingParams struct {
	HttpIds   []idwrap.IDWrap
	UpdatedAt int64
}

// HTTP Batch Operations for Streaming
// Batch query for processing multiple HTTP records efficiently
// Optimized for high-throughput streaming operations
func (q *Queries) GetHTTPBatchForStreaming(ctx context.Context, arg GetHTTPBatchForStreamingParams) ([]Http, error) {
	query := getHTTPBatchForStreaming
	var queryParams []interface{}
	if len(arg.HttpIds) > 0 {
		for _, v := range arg.HttpIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:http_ids*/?", strings.Repeat(",?", len(arg.HttpIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:http_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UpdatedAt)
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Http{}
	for rows.Next() {
		var i Http
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.Description,
			&i.ParentHttpID,
			&i.IsDelta,
			&i.DeltaName,
			&i.DeltaUrl,
			&i.DeltaMethod,
			&i.DeltaDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPBodyFormStreaming = `-- name: GetHTTPBodyFormStreaming :many
SELECT 
  hbf.id,
  hbf.http_id,
  hbf.key,
  hbf.value,
  hbf.description,
  hbf.enabled,
  hbf.parent_http_body_form_id,
  hbf.is_delta,
  hbf.delta_key,
  hbf.delta_value,
  hbf.delta_description,
  hbf.delta_enabled,
  hbf.created_at,
  hbf.updated_at
FROM http_body_form hbf
WHERE hbf.http_id IN (/*SLICE:http_ids*/?)
  AND hbf.enabled = TRUE
  AND hbf.updated_at <= ?
ORDER BY hbf.http_id, hbf.updated_at DESC
`

type GetHTTPBodyFormStreamingParams struct {
	HttpIds   []idwrap.IDWrap
	UpdatedAt int64
}

type GetHTTPBodyFormStreamingRow struct {
	ID                   idwrap.IDWrap
	HttpID               idwrap.IDWrap
	Key                  string
	Value                string
	Description          string
	Enabled              bool
	ParentHttpBodyFormID []byte
	IsDelta              bool
	DeltaKey             sql.NullString
	DeltaValue           sql.NullString
	DeltaDescription     *string
	DeltaEnabled         *bool
	CreatedAt            int64
	UpdatedAt            int64
}

// Optimized form body query for streaming
func (q *Queries) GetHTTPBodyFormStreaming(ctx context.Context, arg GetHTTPBodyFormStreamingParams) ([]GetHTTPBodyFormStreamingRow, error) {
	query := getHTTPBodyFormStreaming
	var queryParams []interface{}
	if len(arg.HttpIds) > 0 {
		for _, v := range arg.HttpIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:http_ids*/?", strings.Repeat(",?", len(arg.HttpIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:http_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UpdatedAt)
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPBodyFormStreamingRow{}
	for rows.Next() {
		var i GetHTTPBodyFormStreamingRow
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.Enabled,
			&i.ParentHttpBodyFormID,
			&i.IsDelta,
			&i.DeltaKey,
			&i.DeltaValue,
			&i.DeltaDescription,
			&i.DeltaEnabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPBodyForms = `-- name: GetHTTPBodyForms :many

SELECT
  id,
  http_id,
  key,
  value,
  description,
  enabled,
  parent_http_body_form_id,
  is_delta,
  delta_key,
  delta_value,
  delta_description,
  delta_enabled,
  "order",
  created_at,
  updated_at
FROM http_body_form
WHERE http_id = ? AND is_delta = FALSE
ORDER BY "order"
`

type GetHTTPBodyFormsRow struct {
	ID                   idwrap.IDWrap
	HttpID               idwrap.IDWrap
	Key                  string
	Value                string
	Description          string
	Enabled              bool
	ParentHttpBodyFormID []byte
	IsDelta              bool
	DeltaKey             sql.NullString
	DeltaValue           sql.NullString
	DeltaDescription     *string
	DeltaEnabled         *bool
	Order                float64
	CreatedAt            int64
	UpdatedAt            int64
}

// HTTP Body Form Queries
func (q *Queries) GetHTTPBodyForms(ctx context.Context, httpID idwrap.IDWrap) ([]GetHTTPBodyFormsRow, error) {
	rows, err := q.query(ctx, q.getHTTPBodyFormsStmt, getHTTPBodyForms, httpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPBodyFormsRow{}
	for rows.Next() {
		var i GetHTTPBodyFormsRow
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.Enabled,
			&i.ParentHttpBodyFormID,
			&i.IsDelta,
			&i.DeltaKey,
			&i.DeltaValue,
			&i.DeltaDescription,
			&i.DeltaEnabled,
			&i.Order,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPBodyFormsByIDs = `-- name: GetHTTPBodyFormsByIDs :many
SELECT
  id,
  http_id,
  key,
  value,
  description,
  enabled,
  parent_http_body_form_id,
  is_delta,
  delta_key,
  delta_value,
  delta_description,
  delta_enabled,
  "order",
  created_at,
  updated_at
FROM http_body_form
WHERE id IN (/*SLICE:ids*/?)
`

type GetHTTPBodyFormsByIDsRow struct {
	ID                   idwrap.IDWrap
	HttpID               idwrap.IDWrap
	Key                  string
	Value                string
	Description          string
	Enabled              bool
	ParentHttpBodyFormID []byte
	IsDelta              bool
	DeltaKey             sql.NullString
	DeltaValue           sql.NullString
	DeltaDescription     *string
	DeltaEnabled         *bool
	Order                float64
	CreatedAt            int64
	UpdatedAt            int64
}

func (q *Queries) GetHTTPBodyFormsByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]GetHTTPBodyFormsByIDsRow, error) {
	query := getHTTPBodyFormsByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPBodyFormsByIDsRow{}
	for rows.Next() {
		var i GetHTTPBodyFormsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.Enabled,
			&i.ParentHttpBodyFormID,
			&i.IsDelta,
			&i.DeltaKey,
			&i.DeltaValue,
			&i.DeltaDescription,
			&i.DeltaEnabled,
			&i.Order,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPBodyUrlEncoded = `-- name: GetHTTPBodyUrlEncoded :one

SELECT
  id,
  http_id,
  key,
  value,
  enabled,
  description,
  "order",
  parent_http_body_urlencoded_id,
  is_delta,
  delta_key,
  delta_value,
  delta_enabled,
  delta_description,
  delta_order,
  created_at,
  updated_at
FROM http_body_urlencoded
WHERE id = ?
LIMIT 1
`

// HTTP Body URL-Encoded Queries (TypeSpec-compliant)
func (q *Queries) GetHTTPBodyUrlEncoded(ctx context.Context, id idwrap.IDWrap) (HttpBodyUrlencoded, error) {
	row := q.queryRow(ctx, q.getHTTPBodyUrlEncodedStmt, getHTTPBodyUrlEncoded, id)
	var i HttpBodyUrlencoded
	err := row.Scan(
		&i.ID,
		&i.HttpID,
		&i.Key,
		&i.Value,
		&i.Enabled,
		&i.Description,
		&i.Order,
		&i.ParentHttpBodyUrlencodedID,
		&i.IsDelta,
		&i.DeltaKey,
		&i.DeltaValue,
		&i.DeltaEnabled,
		&i.DeltaDescription,
		&i.DeltaOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHTTPBodyUrlEncodedByHttpID = `-- name: GetHTTPBodyUrlEncodedByHttpID :many
SELECT
  id,
  http_id,
  key,
  value,
  enabled,
  description,
  "order",
  parent_http_body_urlencoded_id,
  is_delta,
  delta_key,
  delta_value,
  delta_enabled,
  delta_description,
  delta_order,
  created_at,
  updated_at
FROM http_body_urlencoded
WHERE http_id = ? AND is_delta = FALSE
ORDER BY "order"
`

func (q *Queries) GetHTTPBodyUrlEncodedByHttpID(ctx context.Context, httpID idwrap.IDWrap) ([]HttpBodyUrlencoded, error) {
	rows, err := q.query(ctx, q.getHTTPBodyUrlEncodedByHttpIDStmt, getHTTPBodyUrlEncodedByHttpID, httpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpBodyUrlencoded{}
	for rows.Next() {
		var i HttpBodyUrlencoded
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.Enabled,
			&i.Description,
			&i.Order,
			&i.ParentHttpBodyUrlencodedID,
			&i.IsDelta,
			&i.DeltaKey,
			&i.DeltaValue,
			&i.DeltaEnabled,
			&i.DeltaDescription,
			&i.DeltaOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPBodyUrlEncodedsByIDs = `-- name: GetHTTPBodyUrlEncodedsByIDs :many
SELECT
  id,
  http_id,
  key,
  value,
  enabled,
  description,
  "order",
  parent_http_body_urlencoded_id,
  is_delta,
  delta_key,
  delta_value,
  delta_enabled,
  delta_description,
  delta_order,
  created_at,
  updated_at
FROM http_body_urlencoded
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) GetHTTPBodyUrlEncodedsByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]HttpBodyUrlencoded, error) {
	query := getHTTPBodyUrlEncodedsByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpBodyUrlencoded{}
	for rows.Next() {
		var i HttpBodyUrlencoded
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.Enabled,
			&i.Description,
			&i.Order,
			&i.ParentHttpBodyUrlencodedID,
			&i.IsDelta,
			&i.DeltaKey,
			&i.DeltaValue,
			&i.DeltaEnabled,
			&i.DeltaDescription,
			&i.DeltaOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPDeltasByParentID = `-- name: GetHTTPDeltasByParentID :many
SELECT
  id,
  workspace_id,
  folder_id,
  name,
  url,
  method,
  description,
  parent_http_id,
  is_delta,
  delta_name,
  delta_url,
  delta_method,
  delta_description,
  created_at,
  updated_at
FROM http
WHERE parent_http_id = ? AND is_delta = TRUE
ORDER BY created_at DESC
`

func (q *Queries) GetHTTPDeltasByParentID(ctx context.Context, parentHttpID *idwrap.IDWrap) ([]Http, error) {
	rows, err := q.query(ctx, q.getHTTPDeltasByParentIDStmt, getHTTPDeltasByParentID, parentHttpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Http{}
	for rows.Next() {
		var i Http
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.Description,
			&i.ParentHttpID,
			&i.IsDelta,
			&i.DeltaName,
			&i.DeltaUrl,
			&i.DeltaMethod,
			&i.DeltaDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPDeltasSince = `-- name: GetHTTPDeltasSince :many
SELECT 
  h.id,
  h.workspace_id,
  h.folder_id,
  h.name,
  h.url,
  h.method,
  h.description,
  h.parent_http_id,
  h.is_delta,
  h.delta_name,
  h.delta_url,
  h.delta_method,
  h.delta_description,
  h.created_at,
  h.updated_at
FROM http h
WHERE h.parent_http_id IN (/*SLICE:parent_ids*/?)
  AND h.is_delta = TRUE
  AND h.updated_at > ?
  AND h.updated_at <= ?
ORDER BY h.parent_http_id, h.updated_at ASC
`

type GetHTTPDeltasSinceParams struct {
	ParentIds   []*idwrap.IDWrap
	UpdatedAt   int64
	UpdatedAt_2 int64
}

// Delta-specific streaming query for conflict resolution
// Uses delta resolution index for optimal performance
func (q *Queries) GetHTTPDeltasSince(ctx context.Context, arg GetHTTPDeltasSinceParams) ([]Http, error) {
	query := getHTTPDeltasSince
	var queryParams []interface{}
	if len(arg.ParentIds) > 0 {
		for _, v := range arg.ParentIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:parent_ids*/?", strings.Repeat(",?", len(arg.ParentIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:parent_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UpdatedAt)
	queryParams = append(queryParams, arg.UpdatedAt_2)
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Http{}
	for rows.Next() {
		var i Http
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.Description,
			&i.ParentHttpID,
			&i.IsDelta,
			&i.DeltaName,
			&i.DeltaUrl,
			&i.DeltaMethod,
			&i.DeltaDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPHeaders = `-- name: GetHTTPHeaders :many

SELECT
  id,
  http_id,
  header_key,
  header_value,
  description,
  enabled,
  parent_header_id,
  is_delta,
  delta_header_key,
  delta_header_value,
  delta_description,
  delta_enabled,
  prev,
  next,
  created_at,
  updated_at
FROM http_header
WHERE http_id = ? AND is_delta = FALSE
ORDER BY created_at ASC
`

// HTTP Header Queries
func (q *Queries) GetHTTPHeaders(ctx context.Context, httpID idwrap.IDWrap) ([]HttpHeader, error) {
	rows, err := q.query(ctx, q.getHTTPHeadersStmt, getHTTPHeaders, httpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpHeader{}
	for rows.Next() {
		var i HttpHeader
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.HeaderKey,
			&i.HeaderValue,
			&i.Description,
			&i.Enabled,
			&i.ParentHeaderID,
			&i.IsDelta,
			&i.DeltaHeaderKey,
			&i.DeltaHeaderValue,
			&i.DeltaDescription,
			&i.DeltaEnabled,
			&i.Prev,
			&i.Next,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPHeadersByIDs = `-- name: GetHTTPHeadersByIDs :many
SELECT
  id,
  http_id,
  header_key,
  header_value,
  description,
  enabled,
  parent_header_id,
  is_delta,
  delta_header_key,
  delta_header_value,
  delta_description,
  delta_enabled,
  prev,
  next,
  created_at,
  updated_at
FROM http_header
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) GetHTTPHeadersByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]HttpHeader, error) {
	query := getHTTPHeadersByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpHeader{}
	for rows.Next() {
		var i HttpHeader
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.HeaderKey,
			&i.HeaderValue,
			&i.Description,
			&i.Enabled,
			&i.ParentHeaderID,
			&i.IsDelta,
			&i.DeltaHeaderKey,
			&i.DeltaHeaderValue,
			&i.DeltaDescription,
			&i.DeltaEnabled,
			&i.Prev,
			&i.Next,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPHeadersStreaming = `-- name: GetHTTPHeadersStreaming :many
SELECT 
  hh.id,
  hh.http_id,
  hh.header_key,
  hh.header_value,
  hh.description,
  hh.enabled,
  hh.parent_header_id,
  hh.is_delta,
  hh.delta_header_key,
  hh.delta_header_value,
  hh.delta_description,
  hh.delta_enabled,
  hh.created_at,
  hh.updated_at
FROM http_header hh
WHERE hh.http_id IN (/*SLICE:http_ids*/?)
  AND hh.enabled = TRUE
  AND hh.updated_at <= ?
ORDER BY hh.http_id, hh.updated_at DESC
`

type GetHTTPHeadersStreamingParams struct {
	HttpIds   []idwrap.IDWrap
	UpdatedAt int64
}

type GetHTTPHeadersStreamingRow struct {
	ID               idwrap.IDWrap
	HttpID           idwrap.IDWrap
	HeaderKey        string
	HeaderValue      string
	Description      string
	Enabled          bool
	ParentHeaderID   *idwrap.IDWrap
	IsDelta          bool
	DeltaHeaderKey   *string
	DeltaHeaderValue *string
	DeltaDescription *string
	DeltaEnabled     *bool
	CreatedAt        int64
	UpdatedAt        int64
}

// HTTP Child Record Streaming Queries
// Optimized headers query for streaming with enabled filter
func (q *Queries) GetHTTPHeadersStreaming(ctx context.Context, arg GetHTTPHeadersStreamingParams) ([]GetHTTPHeadersStreamingRow, error) {
	query := getHTTPHeadersStreaming
	var queryParams []interface{}
	if len(arg.HttpIds) > 0 {
		for _, v := range arg.HttpIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:http_ids*/?", strings.Repeat(",?", len(arg.HttpIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:http_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UpdatedAt)
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPHeadersStreamingRow{}
	for rows.Next() {
		var i GetHTTPHeadersStreamingRow
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.HeaderKey,
			&i.HeaderValue,
			&i.Description,
			&i.Enabled,
			&i.ParentHeaderID,
			&i.IsDelta,
			&i.DeltaHeaderKey,
			&i.DeltaHeaderValue,
			&i.DeltaDescription,
			&i.DeltaEnabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPIncrementalUpdates = `-- name: GetHTTPIncrementalUpdates :many
SELECT 
  h.id,
  h.workspace_id,
  h.folder_id,
  h.name,
  h.url,
  h.method,
  h.description,
  h.parent_http_id,
  h.is_delta,
  h.delta_name,
  h.delta_url,
  h.delta_method,
  h.delta_description,
  h.created_at,
  h.updated_at
FROM http h
WHERE h.workspace_id = ? 
  AND h.updated_at > ?
  AND h.updated_at <= ?
ORDER BY h.updated_at ASC, h.id
`

type GetHTTPIncrementalUpdatesParams struct {
	WorkspaceID idwrap.IDWrap
	UpdatedAt   int64
	UpdatedAt_2 int64
}

// HTTP Incremental Streaming Queries
// Real-time streaming query for changes since last update
// Optimized with streaming indexes for minimal latency
func (q *Queries) GetHTTPIncrementalUpdates(ctx context.Context, arg GetHTTPIncrementalUpdatesParams) ([]Http, error) {
	rows, err := q.query(ctx, q.getHTTPIncrementalUpdatesStmt, getHTTPIncrementalUpdates, arg.WorkspaceID, arg.UpdatedAt, arg.UpdatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Http{}
	for rows.Next() {
		var i Http
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.Description,
			&i.ParentHttpID,
			&i.IsDelta,
			&i.DeltaName,
			&i.DeltaUrl,
			&i.DeltaMethod,
			&i.DeltaDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPResponse = `-- name: GetHTTPResponse :one

SELECT
  id,
  http_id,
  status,
  body,
  time,
  duration,
  size,
  created_at
FROM http_response
WHERE id = ?
LIMIT 1
`

// HTTP Response Queries (TypeSpec-compliant)
//
// HTTP Response Queries (TypeSpec-compliant)
func (q *Queries) GetHTTPResponse(ctx context.Context, id idwrap.IDWrap) (HttpResponse, error) {
	row := q.queryRow(ctx, q.getHTTPResponseStmt, getHTTPResponse, id)
	var i HttpResponse
	err := row.Scan(
		&i.ID,
		&i.HttpID,
		&i.Status,
		&i.Body,
		&i.Time,
		&i.Duration,
		&i.Size,
		&i.CreatedAt,
	)
	return i, err
}

const getHTTPResponseAssert = `-- name: GetHTTPResponseAssert :one

SELECT
  id,
  http_id,
  value,
  success,
  created_at
FROM http_response_assert
WHERE id = ?
LIMIT 1
`

// HTTP Response Assert Queries (TypeSpec-compliant)
func (q *Queries) GetHTTPResponseAssert(ctx context.Context, id []byte) (HttpResponseAssert, error) {
	row := q.queryRow(ctx, q.getHTTPResponseAssertStmt, getHTTPResponseAssert, id)
	var i HttpResponseAssert
	err := row.Scan(
		&i.ID,
		&i.HttpID,
		&i.Value,
		&i.Success,
		&i.CreatedAt,
	)
	return i, err
}

const getHTTPResponseAssertsByHttpID = `-- name: GetHTTPResponseAssertsByHttpID :many
SELECT
  id,
  http_id,
  value,
  success,
  created_at
FROM http_response_assert
WHERE http_id = ?
ORDER BY created_at DESC
`

func (q *Queries) GetHTTPResponseAssertsByHttpID(ctx context.Context, httpID []byte) ([]HttpResponseAssert, error) {
	rows, err := q.query(ctx, q.getHTTPResponseAssertsByHttpIDStmt, getHTTPResponseAssertsByHttpID, httpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpResponseAssert{}
	for rows.Next() {
		var i HttpResponseAssert
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Value,
			&i.Success,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPResponseAssertsByIDs = `-- name: GetHTTPResponseAssertsByIDs :many
SELECT
  id,
  http_id,
  value,
  success,
  created_at
FROM http_response_assert
WHERE id IN (/*SLICE:ids*/?)
ORDER BY created_at DESC
`

func (q *Queries) GetHTTPResponseAssertsByIDs(ctx context.Context, ids [][]byte) ([]HttpResponseAssert, error) {
	query := getHTTPResponseAssertsByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpResponseAssert{}
	for rows.Next() {
		var i HttpResponseAssert
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Value,
			&i.Success,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPResponseHeader = `-- name: GetHTTPResponseHeader :one

SELECT
  id,
  http_id,
  key,
  value,
  created_at
FROM http_response_header
WHERE id = ?
LIMIT 1
`

// HTTP Response Header Queries (TypeSpec-compliant)
func (q *Queries) GetHTTPResponseHeader(ctx context.Context, id idwrap.IDWrap) (HttpResponseHeader, error) {
	row := q.queryRow(ctx, q.getHTTPResponseHeaderStmt, getHTTPResponseHeader, id)
	var i HttpResponseHeader
	err := row.Scan(
		&i.ID,
		&i.HttpID,
		&i.Key,
		&i.Value,
		&i.CreatedAt,
	)
	return i, err
}

const getHTTPResponseHeadersByHttpID = `-- name: GetHTTPResponseHeadersByHttpID :many
SELECT
  id,
  http_id,
  key,
  value,
  created_at
FROM http_response_header
WHERE http_id = ?
ORDER BY key
`

func (q *Queries) GetHTTPResponseHeadersByHttpID(ctx context.Context, httpID []byte) ([]HttpResponseHeader, error) {
	rows, err := q.query(ctx, q.getHTTPResponseHeadersByHttpIDStmt, getHTTPResponseHeadersByHttpID, httpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpResponseHeader{}
	for rows.Next() {
		var i HttpResponseHeader
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPResponseHeadersByIDs = `-- name: GetHTTPResponseHeadersByIDs :many
SELECT
  id,
  http_id,
  key,
  value,
  created_at
FROM http_response_header
WHERE id IN (/*SLICE:ids*/?)
ORDER BY http_id, key
`

func (q *Queries) GetHTTPResponseHeadersByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]HttpResponseHeader, error) {
	query := getHTTPResponseHeadersByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpResponseHeader{}
	for rows.Next() {
		var i HttpResponseHeader
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPResponsesByHttpID = `-- name: GetHTTPResponsesByHttpID :many
SELECT
  id,
  http_id,
  status,
  body,
  time,
  duration,
  size,
  created_at
FROM http_response
WHERE http_id = ?
ORDER BY time DESC
`

func (q *Queries) GetHTTPResponsesByHttpID(ctx context.Context, httpID idwrap.IDWrap) ([]HttpResponse, error) {
	rows, err := q.query(ctx, q.getHTTPResponsesByHttpIDStmt, getHTTPResponsesByHttpID, httpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpResponse{}
	for rows.Next() {
		var i HttpResponse
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Status,
			&i.Body,
			&i.Time,
			&i.Duration,
			&i.Size,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPResponsesByIDs = `-- name: GetHTTPResponsesByIDs :many
SELECT
  id,
  http_id,
  status,
  body,
  time,
  duration,
  size,
  created_at
FROM http_response
WHERE id IN (/*SLICE:ids*/?)
ORDER BY time DESC
`

func (q *Queries) GetHTTPResponsesByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]HttpResponse, error) {
	query := getHTTPResponsesByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpResponse{}
	for rows.Next() {
		var i HttpResponse
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Status,
			&i.Body,
			&i.Time,
			&i.Duration,
			&i.Size,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPSearchParams = `-- name: GetHTTPSearchParams :many

SELECT
  id,
  http_id,
  key,
  value,
  description,
  enabled,
  parent_http_search_param_id,
  is_delta,
  delta_key,
  delta_value,
  delta_description,
  delta_enabled,
  "order",
  created_at,
  updated_at
FROM http_search_param
WHERE http_id = ? AND is_delta = FALSE
ORDER BY "order"
`

type GetHTTPSearchParamsRow struct {
	ID                      idwrap.IDWrap
	HttpID                  idwrap.IDWrap
	Key                     string
	Value                   string
	Description             string
	Enabled                 bool
	ParentHttpSearchParamID []byte
	IsDelta                 bool
	DeltaKey                sql.NullString
	DeltaValue              sql.NullString
	DeltaDescription        *string
	DeltaEnabled            *bool
	Order                   float64
	CreatedAt               int64
	UpdatedAt               int64
}

// HTTP Search Parameter Queries
func (q *Queries) GetHTTPSearchParams(ctx context.Context, httpID idwrap.IDWrap) ([]GetHTTPSearchParamsRow, error) {
	rows, err := q.query(ctx, q.getHTTPSearchParamsStmt, getHTTPSearchParams, httpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPSearchParamsRow{}
	for rows.Next() {
		var i GetHTTPSearchParamsRow
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.Enabled,
			&i.ParentHttpSearchParamID,
			&i.IsDelta,
			&i.DeltaKey,
			&i.DeltaValue,
			&i.DeltaDescription,
			&i.DeltaEnabled,
			&i.Order,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPSearchParamsByIDs = `-- name: GetHTTPSearchParamsByIDs :many
SELECT
  id,
  http_id,
  key,
  value,
  description,
  enabled,
  parent_http_search_param_id,
  is_delta,
  delta_key,
  delta_value,
  delta_description,
  delta_enabled,
  "order",
  created_at,
  updated_at
FROM http_search_param
WHERE id IN (/*SLICE:ids*/?)
`

type GetHTTPSearchParamsByIDsRow struct {
	ID                      idwrap.IDWrap
	HttpID                  idwrap.IDWrap
	Key                     string
	Value                   string
	Description             string
	Enabled                 bool
	ParentHttpSearchParamID []byte
	IsDelta                 bool
	DeltaKey                sql.NullString
	DeltaValue              sql.NullString
	DeltaDescription        *string
	DeltaEnabled            *bool
	Order                   float64
	CreatedAt               int64
	UpdatedAt               int64
}

func (q *Queries) GetHTTPSearchParamsByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]GetHTTPSearchParamsByIDsRow, error) {
	query := getHTTPSearchParamsByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPSearchParamsByIDsRow{}
	for rows.Next() {
		var i GetHTTPSearchParamsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.Enabled,
			&i.ParentHttpSearchParamID,
			&i.IsDelta,
			&i.DeltaKey,
			&i.DeltaValue,
			&i.DeltaDescription,
			&i.DeltaEnabled,
			&i.Order,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPSearchParamsStreaming = `-- name: GetHTTPSearchParamsStreaming :many
SELECT 
  hsp.id,
  hsp.http_id,
  hsp.key,
  hsp.value,
  hsp.description,
  hsp.enabled,
  hsp.parent_http_search_param_id,
  hsp.is_delta,
  hsp.delta_key,
  hsp.delta_value,
  hsp.delta_description,
  hsp.delta_enabled,
  hsp.created_at,
  hsp.updated_at
FROM http_search_param hsp
WHERE hsp.http_id IN (/*SLICE:http_ids*/?)
  AND hsp.enabled = TRUE
  AND hsp.updated_at <= ?
ORDER BY hsp.http_id, hsp.updated_at DESC
`

type GetHTTPSearchParamsStreamingParams struct {
	HttpIds   []idwrap.IDWrap
	UpdatedAt int64
}

type GetHTTPSearchParamsStreamingRow struct {
	ID                      idwrap.IDWrap
	HttpID                  idwrap.IDWrap
	Key                     string
	Value                   string
	Description             string
	Enabled                 bool
	ParentHttpSearchParamID []byte
	IsDelta                 bool
	DeltaKey                sql.NullString
	DeltaValue              sql.NullString
	DeltaDescription        *string
	DeltaEnabled            *bool
	CreatedAt               int64
	UpdatedAt               int64
}

// Optimized search parameters query for streaming
func (q *Queries) GetHTTPSearchParamsStreaming(ctx context.Context, arg GetHTTPSearchParamsStreamingParams) ([]GetHTTPSearchParamsStreamingRow, error) {
	query := getHTTPSearchParamsStreaming
	var queryParams []interface{}
	if len(arg.HttpIds) > 0 {
		for _, v := range arg.HttpIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:http_ids*/?", strings.Repeat(",?", len(arg.HttpIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:http_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UpdatedAt)
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPSearchParamsStreamingRow{}
	for rows.Next() {
		var i GetHTTPSearchParamsStreamingRow
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.Enabled,
			&i.ParentHttpSearchParamID,
			&i.IsDelta,
			&i.DeltaKey,
			&i.DeltaValue,
			&i.DeltaDescription,
			&i.DeltaEnabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPSnapshotCount = `-- name: GetHTTPSnapshotCount :one
SELECT COUNT(*) as total_count
FROM http h
WHERE h.workspace_id = ? 
  AND h.is_delta = FALSE
  AND h.updated_at <= ?
`

type GetHTTPSnapshotCountParams struct {
	WorkspaceID idwrap.IDWrap
	UpdatedAt   int64
}

// Count query for pagination progress tracking
func (q *Queries) GetHTTPSnapshotCount(ctx context.Context, arg GetHTTPSnapshotCountParams) (int64, error) {
	row := q.queryRow(ctx, q.getHTTPSnapshotCountStmt, getHTTPSnapshotCount, arg.WorkspaceID, arg.UpdatedAt)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const getHTTPSnapshotPage = `-- name: GetHTTPSnapshotPage :many
/*
 *
 * HTTP STREAMING OPTIMIZATION QUERIES
 * High-performance queries for Phase 2a HTTP streaming implementation
 *
 */

SELECT 
  h.id,
  h.workspace_id,
  h.folder_id,
  h.name,
  h.url,
  h.method,
  h.description,
  h.parent_http_id,
  h.is_delta,
  h.delta_name,
  h.delta_url,
  h.delta_method,
  h.delta_description,
  h.created_at,
  h.updated_at
FROM http h
WHERE h.workspace_id = ? 
  AND h.is_delta = FALSE
  AND h.updated_at <= ?
ORDER BY h.updated_at DESC, h.id
LIMIT ?
`

type GetHTTPSnapshotPageParams struct {
	WorkspaceID idwrap.IDWrap
	UpdatedAt   int64
	Limit       int64
}

// HTTP Snapshot Queries for Streaming
// High-performance paginated snapshot query for initial data load
// Uses optimized streaming indexes for fast workspace-scoped access
func (q *Queries) GetHTTPSnapshotPage(ctx context.Context, arg GetHTTPSnapshotPageParams) ([]Http, error) {
	rows, err := q.query(ctx, q.getHTTPSnapshotPageStmt, getHTTPSnapshotPage, arg.WorkspaceID, arg.UpdatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Http{}
	for rows.Next() {
		var i Http
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.Description,
			&i.ParentHttpID,
			&i.IsDelta,
			&i.DeltaName,
			&i.DeltaUrl,
			&i.DeltaMethod,
			&i.DeltaDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPStreamingMetrics = `-- name: GetHTTPStreamingMetrics :one
SELECT 
  COUNT(*) as total_http_records,
  COUNT(CASE WHEN is_delta = FALSE THEN 1 END) as base_records,
  COUNT(CASE WHEN is_delta = TRUE THEN 1 END) as delta_records,
  MAX(updated_at) as latest_update,
  MIN(updated_at) as earliest_update,
  COUNT(CASE WHEN updated_at > ? THEN 1 END) as recent_changes
FROM http 
WHERE workspace_id = ?
`

type GetHTTPStreamingMetricsParams struct {
	UpdatedAt   int64
	WorkspaceID idwrap.IDWrap
}

type GetHTTPStreamingMetricsRow struct {
	TotalHttpRecords int64
	BaseRecords      int64
	DeltaRecords     int64
	LatestUpdate     interface{}
	EarliestUpdate   interface{}
	RecentChanges    int64
}

// HTTP Performance Monitoring Queries
// Performance metrics query for monitoring streaming operations
func (q *Queries) GetHTTPStreamingMetrics(ctx context.Context, arg GetHTTPStreamingMetricsParams) (GetHTTPStreamingMetricsRow, error) {
	row := q.queryRow(ctx, q.getHTTPStreamingMetricsStmt, getHTTPStreamingMetrics, arg.UpdatedAt, arg.WorkspaceID)
	var i GetHTTPStreamingMetricsRow
	err := row.Scan(
		&i.TotalHttpRecords,
		&i.BaseRecords,
		&i.DeltaRecords,
		&i.LatestUpdate,
		&i.EarliestUpdate,
		&i.RecentChanges,
	)
	return i, err
}

const getHTTPWorkspaceActivity = `-- name: GetHTTPWorkspaceActivity :many
SELECT 
  DATE(updated_at, 'unixepoch') as activity_date,
  COUNT(*) as changes_count,
  COUNT(CASE WHEN is_delta = TRUE THEN 1 END) as delta_count,
  COUNT(CASE WHEN is_delta = FALSE THEN 1 END) as base_count
FROM http
WHERE workspace_id = ?
  AND updated_at >= ?
GROUP BY DATE(updated_at, 'unixepoch')
ORDER BY activity_date DESC
LIMIT 30
`

type GetHTTPWorkspaceActivityParams struct {
	WorkspaceID idwrap.IDWrap
	UpdatedAt   int64
}

type GetHTTPWorkspaceActivityRow struct {
	ActivityDate interface{}
	ChangesCount int64
	DeltaCount   int64
	BaseCount    int64
}

// Activity monitoring query for workspace streaming health
func (q *Queries) GetHTTPWorkspaceActivity(ctx context.Context, arg GetHTTPWorkspaceActivityParams) ([]GetHTTPWorkspaceActivityRow, error) {
	rows, err := q.query(ctx, q.getHTTPWorkspaceActivityStmt, getHTTPWorkspaceActivity, arg.WorkspaceID, arg.UpdatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPWorkspaceActivityRow{}
	for rows.Next() {
		var i GetHTTPWorkspaceActivityRow
		if err := rows.Scan(
			&i.ActivityDate,
			&i.ChangesCount,
			&i.DeltaCount,
			&i.BaseCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPWorkspaceID = `-- name: GetHTTPWorkspaceID :one
SELECT workspace_id
FROM http
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetHTTPWorkspaceID(ctx context.Context, id idwrap.IDWrap) (idwrap.IDWrap, error) {
	row := q.queryRow(ctx, q.getHTTPWorkspaceIDStmt, getHTTPWorkspaceID, id)
	var workspace_id idwrap.IDWrap
	err := row.Scan(&workspace_id)
	return workspace_id, err
}

const getHTTPsByFolderID = `-- name: GetHTTPsByFolderID :many
SELECT
  id,
  workspace_id,
  folder_id,
  name,
  url,
  method,
  description,
  parent_http_id,
  is_delta,
  delta_name,
  delta_url,
  delta_method,
  delta_description,
  created_at,
  updated_at
FROM http
WHERE folder_id = ? AND is_delta = FALSE
ORDER BY updated_at DESC
`

func (q *Queries) GetHTTPsByFolderID(ctx context.Context, folderID *idwrap.IDWrap) ([]Http, error) {
	rows, err := q.query(ctx, q.getHTTPsByFolderIDStmt, getHTTPsByFolderID, folderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Http{}
	for rows.Next() {
		var i Http
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.Description,
			&i.ParentHttpID,
			&i.IsDelta,
			&i.DeltaName,
			&i.DeltaUrl,
			&i.DeltaMethod,
			&i.DeltaDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPsByIDs = `-- name: GetHTTPsByIDs :many
SELECT
  id,
  workspace_id,
  folder_id,
  name,
  url,
  method,
  description,
  parent_http_id,
  is_delta,
  delta_name,
  delta_url,
  delta_method,
  delta_description,
  created_at,
  updated_at
FROM http
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) GetHTTPsByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]Http, error) {
	query := getHTTPsByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Http{}
	for rows.Next() {
		var i Http
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.Description,
			&i.ParentHttpID,
			&i.IsDelta,
			&i.DeltaName,
			&i.DeltaUrl,
			&i.DeltaMethod,
			&i.DeltaDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPsByWorkspaceID = `-- name: GetHTTPsByWorkspaceID :many
SELECT
  id,
  workspace_id,
  folder_id,
  name,
  url,
  method,
  description,
  parent_http_id,
  is_delta,
  delta_name,
  delta_url,
  delta_method,
  delta_description,
  created_at,
  updated_at
FROM http
WHERE workspace_id = ? AND is_delta = FALSE
ORDER BY updated_at DESC
`

func (q *Queries) GetHTTPsByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]Http, error) {
	rows, err := q.query(ctx, q.getHTTPsByWorkspaceIDStmt, getHTTPsByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Http{}
	for rows.Next() {
		var i Http
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.Description,
			&i.ParentHttpID,
			&i.IsDelta,
			&i.DeltaName,
			&i.DeltaUrl,
			&i.DeltaMethod,
			&i.DeltaDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHeader = `-- name: GetHeader :one
/*
*
* Header
*
*/

SELECT
  id,
  example_id,
  delta_parent_id,
  header_key,
  enable,
  description,
  value,
  prev,
  next
FROM
  example_header
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetHeader(ctx context.Context, id idwrap.IDWrap) (ExampleHeader, error) {
	row := q.queryRow(ctx, q.getHeaderStmt, getHeader, id)
	var i ExampleHeader
	err := row.Scan(
		&i.ID,
		&i.ExampleID,
		&i.DeltaParentID,
		&i.HeaderKey,
		&i.Enable,
		&i.Description,
		&i.Value,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getHeaderByDeltaParentID = `-- name: GetHeaderByDeltaParentID :one
SELECT
  id,
  example_id,
  delta_parent_id,
  header_key,
  enable,
  description,
  value,
  prev,
  next
FROM
  example_header
WHERE
  delta_parent_id = ?
LIMIT 1
`

func (q *Queries) GetHeaderByDeltaParentID(ctx context.Context, deltaParentID *idwrap.IDWrap) (ExampleHeader, error) {
	row := q.queryRow(ctx, q.getHeaderByDeltaParentIDStmt, getHeaderByDeltaParentID, deltaParentID)
	var i ExampleHeader
	err := row.Scan(
		&i.ID,
		&i.ExampleID,
		&i.DeltaParentID,
		&i.HeaderKey,
		&i.Enable,
		&i.Description,
		&i.Value,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getHeaderTail = `-- name: GetHeaderTail :one
SELECT
  id,
  example_id,
  delta_parent_id,
  header_key,
  enable,
  description,
  value,
  prev,
  next
FROM
  example_header
WHERE
  example_id = ? AND
  next IS NULL
LIMIT
  1
`

// Get the last header in the list (tail) for an example
// Used when appending new headers to the end of the list
func (q *Queries) GetHeaderTail(ctx context.Context, exampleID idwrap.IDWrap) (ExampleHeader, error) {
	row := q.queryRow(ctx, q.getHeaderTailStmt, getHeaderTail, exampleID)
	var i ExampleHeader
	err := row.Scan(
		&i.ID,
		&i.ExampleID,
		&i.DeltaParentID,
		&i.HeaderKey,
		&i.Enable,
		&i.Description,
		&i.Value,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getHeadersByExampleID = `-- name: GetHeadersByExampleID :many
SELECT
  id,
  example_id,
  delta_parent_id,
  header_key,
  enable,
  description,
  value,
  prev,
  next
FROM
  example_header
WHERE
  example_id = ?
`

func (q *Queries) GetHeadersByExampleID(ctx context.Context, exampleID idwrap.IDWrap) ([]ExampleHeader, error) {
	rows, err := q.query(ctx, q.getHeadersByExampleIDStmt, getHeadersByExampleID, exampleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExampleHeader{}
	for rows.Next() {
		var i ExampleHeader
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.DeltaParentID,
			&i.HeaderKey,
			&i.Enable,
			&i.Description,
			&i.Value,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHeadersByExampleIDOrdered = `-- name: GetHeadersByExampleIDOrdered :many
WITH RECURSIVE ordered_headers AS (
  -- Base case: Find the head (prev IS NULL) for this example
  SELECT
    h.id,
    h.example_id,
    h.delta_parent_id,
    h.header_key,
    h.enable,
    h.description,
    h.value,
    h.prev,
    h.next,
    0 as position
  FROM
    example_header h
  WHERE
    h.example_id = ? AND
    h.prev IS NULL
  
  UNION ALL
  
  -- Recursive case: Follow the next pointers
  SELECT
    h.id,
    h.example_id,
    h.delta_parent_id,
    h.header_key,
    h.enable,
    h.description,
    h.value,
    h.prev,
    h.next,
    oh.position + 1
  FROM
    example_header h
  INNER JOIN ordered_headers oh ON h.prev = oh.id
  WHERE
    h.example_id = ?
)
SELECT
  oh.id,
  oh.example_id,
  oh.delta_parent_id,
  oh.header_key,
  oh.enable,
  oh.description,
  oh.value,
  oh.prev,
  oh.next,
  oh.position
FROM
  ordered_headers oh
ORDER BY
  oh.position
`

type GetHeadersByExampleIDOrderedParams struct {
	ExampleID   idwrap.IDWrap
	ExampleID_2 idwrap.IDWrap
}

type GetHeadersByExampleIDOrderedRow struct {
	ID            []byte
	ExampleID     []byte
	DeltaParentID []byte
	HeaderKey     string
	Enable        bool
	Description   string
	Value         string
	Prev          []byte
	Next          []byte
	Position      int64
}

// Uses WITH RECURSIVE CTE to traverse linked list from head to tail for example-scoped ordering
// Headers are scoped to specific examples via example_id column
func (q *Queries) GetHeadersByExampleIDOrdered(ctx context.Context, arg GetHeadersByExampleIDOrderedParams) ([]GetHeadersByExampleIDOrderedRow, error) {
	rows, err := q.query(ctx, q.getHeadersByExampleIDOrderedStmt, getHeadersByExampleIDOrdered, arg.ExampleID, arg.ExampleID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHeadersByExampleIDOrderedRow{}
	for rows.Next() {
		var i GetHeadersByExampleIDOrderedRow
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.DeltaParentID,
			&i.HeaderKey,
			&i.Enable,
			&i.Description,
			&i.Value,
			&i.Prev,
			&i.Next,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHeadersByExampleIDs = `-- name: GetHeadersByExampleIDs :many
SELECT
  id,
  example_id,
  delta_parent_id,
  header_key,
  enable,
  description,
  value,
  prev,
  next
FROM
  example_header
WHERE
  example_id IN (/*SLICE:example_ids*/?)
ORDER BY example_id
`

func (q *Queries) GetHeadersByExampleIDs(ctx context.Context, exampleIds []idwrap.IDWrap) ([]ExampleHeader, error) {
	query := getHeadersByExampleIDs
	var queryParams []interface{}
	if len(exampleIds) > 0 {
		for _, v := range exampleIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:example_ids*/?", strings.Repeat(",?", len(exampleIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:example_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExampleHeader{}
	for rows.Next() {
		var i ExampleHeader
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.DeltaParentID,
			&i.HeaderKey,
			&i.Enable,
			&i.Description,
			&i.Value,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemApi = `-- name: GetItemApi :one
SELECT
  id,
  folder_id,
  name,
  url,
  method,
  version_parent_id,
  delta_parent_id,
  hidden,
  prev,
  next
FROM
  item_api
WHERE
  id = ?
LIMIT
  1
`

// This file is the source of truth for application's db schema
//
// ItemApi
func (q *Queries) GetItemApi(ctx context.Context, id idwrap.IDWrap) (ItemApi, error) {
	row := q.queryRow(ctx, q.getItemApiStmt, getItemApi, id)
	var i ItemApi
	err := row.Scan(
		&i.ID,
		&i.FolderID,
		&i.Name,
		&i.Url,
		&i.Method,
		&i.VersionParentID,
		&i.DeltaParentID,
		&i.Hidden,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getItemApiByFolderIDAndNextID = `-- name: GetItemApiByFolderIDAndNextID :one
SELECT
  id,
  folder_id,
  name,
  url,
  method,
  version_parent_id,
  delta_parent_id,
  hidden,
  prev,
  next
FROM
  item_api
WHERE
  next = ? AND
  folder_id = ?
LIMIT
  1
`

type GetItemApiByFolderIDAndNextIDParams struct {
	Next     *idwrap.IDWrap
	FolderID *idwrap.IDWrap
}

func (q *Queries) GetItemApiByFolderIDAndNextID(ctx context.Context, arg GetItemApiByFolderIDAndNextIDParams) (ItemApi, error) {
	row := q.queryRow(ctx, q.getItemApiByFolderIDAndNextIDStmt, getItemApiByFolderIDAndNextID, arg.Next, arg.FolderID)
	var i ItemApi
	err := row.Scan(
		&i.ID,
		&i.FolderID,
		&i.Name,
		&i.Url,
		&i.Method,
		&i.VersionParentID,
		&i.DeltaParentID,
		&i.Hidden,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getItemApiByFolderIDAndURLAndMethod = `-- name: GetItemApiByFolderIDAndURLAndMethod :one
SELECT
  id,
  folder_id,
  name,
  url,
  method,
  version_parent_id,
  delta_parent_id,
  hidden,
  prev,
  next
FROM
  item_api
WHERE
  folder_id = ? AND
  url = ? AND
  method = ? AND
  version_parent_id is NULL AND
  delta_parent_id is NULL
LIMIT
  1
`

type GetItemApiByFolderIDAndURLAndMethodParams struct {
	FolderID *idwrap.IDWrap
	Url      string
	Method   string
}

func (q *Queries) GetItemApiByFolderIDAndURLAndMethod(ctx context.Context, arg GetItemApiByFolderIDAndURLAndMethodParams) (ItemApi, error) {
	row := q.queryRow(ctx, q.getItemApiByFolderIDAndURLAndMethodStmt, getItemApiByFolderIDAndURLAndMethod, arg.FolderID, arg.Url, arg.Method)
	var i ItemApi
	err := row.Scan(
		&i.ID,
		&i.FolderID,
		&i.Name,
		&i.Url,
		&i.Method,
		&i.VersionParentID,
		&i.DeltaParentID,
		&i.Hidden,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getItemApiExample = `-- name: GetItemApiExample :one
SELECT
    id,
    item_api_id,
    is_default,
    body_type,
    name,
    version_parent_id,
    prev,
    next
FROM
  item_api_example
WHERE
  id = ?
LIMIT
  1
`

// Item Api Example
func (q *Queries) GetItemApiExample(ctx context.Context, id idwrap.IDWrap) (ItemApiExample, error) {
	row := q.queryRow(ctx, q.getItemApiExampleStmt, getItemApiExample, id)
	var i ItemApiExample
	err := row.Scan(
		&i.ID,
		&i.ItemApiID,
		&i.IsDefault,
		&i.BodyType,
		&i.Name,
		&i.VersionParentID,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getItemApiExampleByVersionParentID = `-- name: GetItemApiExampleByVersionParentID :many
SELECT
    id,
    item_api_id,
    is_default,
    body_type,
    name,
    version_parent_id,
    prev,
    next
FROM
  item_api_example
WHERE
  version_parent_id = ?
`

func (q *Queries) GetItemApiExampleByVersionParentID(ctx context.Context, versionParentID *idwrap.IDWrap) ([]ItemApiExample, error) {
	rows, err := q.query(ctx, q.getItemApiExampleByVersionParentIDStmt, getItemApiExampleByVersionParentID, versionParentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ItemApiExample{}
	for rows.Next() {
		var i ItemApiExample
		if err := rows.Scan(
			&i.ID,
			&i.ItemApiID,
			&i.IsDefault,
			&i.BodyType,
			&i.Name,
			&i.VersionParentID,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemApiExampleDefault = `-- name: GetItemApiExampleDefault :one
SELECT
    id,
    item_api_id,
    is_default,
    body_type,
    name,
    version_parent_id,
    prev,
    next
FROM
  item_api_example
WHERE
  item_api_id = ?
  AND is_default = true
LIMIT
  1
`

func (q *Queries) GetItemApiExampleDefault(ctx context.Context, itemApiID idwrap.IDWrap) (ItemApiExample, error) {
	row := q.queryRow(ctx, q.getItemApiExampleDefaultStmt, getItemApiExampleDefault, itemApiID)
	var i ItemApiExample
	err := row.Scan(
		&i.ID,
		&i.ItemApiID,
		&i.IsDefault,
		&i.BodyType,
		&i.Name,
		&i.VersionParentID,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getItemApiExamples = `-- name: GetItemApiExamples :many
SELECT
    id,
    item_api_id,
    is_default,
    body_type,
    name,
    version_parent_id,
    prev,
    next
FROM
  item_api_example
WHERE
  item_api_id = ? AND
  is_default is false AND
  version_parent_id is NULL
`

func (q *Queries) GetItemApiExamples(ctx context.Context, itemApiID idwrap.IDWrap) ([]ItemApiExample, error) {
	rows, err := q.query(ctx, q.getItemApiExamplesStmt, getItemApiExamples, itemApiID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ItemApiExample{}
	for rows.Next() {
		var i ItemApiExample
		if err := rows.Scan(
			&i.ID,
			&i.ItemApiID,
			&i.IsDefault,
			&i.BodyType,
			&i.Name,
			&i.VersionParentID,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemApiExamplesByIDs = `-- name: GetItemApiExamplesByIDs :many
SELECT
    id,
    item_api_id,
    is_default,
    body_type,
    name,
    version_parent_id,
    prev,
    next
FROM
  item_api_example
WHERE
  id IN (/*SLICE:ids*/?)
`

func (q *Queries) GetItemApiExamplesByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]ItemApiExample, error) {
	query := getItemApiExamplesByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ItemApiExample{}
	for rows.Next() {
		var i ItemApiExample
		if err := rows.Scan(
			&i.ID,
			&i.ItemApiID,
			&i.IsDefault,
			&i.BodyType,
			&i.Name,
			&i.VersionParentID,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemApiExamplesByItemApiID = `-- name: GetItemApiExamplesByItemApiID :many
SELECT
    id,
    item_api_id,
    is_default,
    body_type,
    name,
    version_parent_id,
    prev,
    next
FROM
  item_api_example
WHERE
  item_api_id = ? AND
  version_parent_id is NULL
`

func (q *Queries) GetItemApiExamplesByItemApiID(ctx context.Context, itemApiID idwrap.IDWrap) ([]ItemApiExample, error) {
	rows, err := q.query(ctx, q.getItemApiExamplesByItemApiIDStmt, getItemApiExamplesByItemApiID, itemApiID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ItemApiExample{}
	for rows.Next() {
		var i ItemApiExample
		if err := rows.Scan(
			&i.ID,
			&i.ItemApiID,
			&i.IsDefault,
			&i.BodyType,
			&i.Name,
			&i.VersionParentID,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemApiExamplesWithDefaults = `-- name: GetItemApiExamplesWithDefaults :many
SELECT
    id,
    item_api_id,
    is_default,
    body_type,
    name,
    version_parent_id,
    prev,
    next
FROM
  item_api_example
WHERE
  item_api_id = ? AND
  version_parent_id is NULL
`

func (q *Queries) GetItemApiExamplesWithDefaults(ctx context.Context, itemApiID idwrap.IDWrap) ([]ItemApiExample, error) {
	rows, err := q.query(ctx, q.getItemApiExamplesWithDefaultsStmt, getItemApiExamplesWithDefaults, itemApiID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ItemApiExample{}
	for rows.Next() {
		var i ItemApiExample
		if err := rows.Scan(
			&i.ID,
			&i.ItemApiID,
			&i.IsDefault,
			&i.BodyType,
			&i.Name,
			&i.VersionParentID,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemApisByIDs = `-- name: GetItemApisByIDs :many
SELECT
  id,
  folder_id,
  name,
  url,
  method,
  version_parent_id,
  delta_parent_id,
  hidden,
  prev,
  next
FROM
  item_api
WHERE
  id IN (/*SLICE:ids*/?)
`

func (q *Queries) GetItemApisByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]ItemApi, error) {
	query := getItemApisByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ItemApi{}
	for rows.Next() {
		var i ItemApi
		if err := rows.Scan(
			&i.ID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.VersionParentID,
			&i.DeltaParentID,
			&i.Hidden,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemExampleByNextIDAndItemApiID = `-- name: GetItemExampleByNextIDAndItemApiID :one
SELECT
    id,
    item_api_id,
    is_default,
    body_type,
    name,
    version_parent_id,
    prev,
    next
FROM
  item_api_example
WHERE
  next = ? AND
  prev = ?
LIMIT
  1
`

type GetItemExampleByNextIDAndItemApiIDParams struct {
	Next *idwrap.IDWrap
	Prev *idwrap.IDWrap
}

func (q *Queries) GetItemExampleByNextIDAndItemApiID(ctx context.Context, arg GetItemExampleByNextIDAndItemApiIDParams) (ItemApiExample, error) {
	row := q.queryRow(ctx, q.getItemExampleByNextIDAndItemApiIDStmt, getItemExampleByNextIDAndItemApiID, arg.Next, arg.Prev)
	var i ItemApiExample
	err := row.Scan(
		&i.ID,
		&i.ItemApiID,
		&i.IsDefault,
		&i.BodyType,
		&i.Name,
		&i.VersionParentID,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getItemFolder = `-- name: GetItemFolder :one


SELECT
  id,
  parent_id,
  name,
  prev,
  next
FROM
  item_folder
WHERE
  id = ?
LIMIT
  1
`

// ItemFolder
func (q *Queries) GetItemFolder(ctx context.Context, id idwrap.IDWrap) (ItemFolder, error) {
	row := q.queryRow(ctx, q.getItemFolderStmt, getItemFolder, id)
	var i ItemFolder
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Name,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getItemFolderByParentIDAndNextID = `-- name: GetItemFolderByParentIDAndNextID :one
SELECT
  id,
  parent_id,
  name,
  prev,
  next
FROM
  item_folder
WHERE
  next = ? AND
  parent_id = ?
LIMIT
  1
`

type GetItemFolderByParentIDAndNextIDParams struct {
	Next     *idwrap.IDWrap
	ParentID *idwrap.IDWrap
}

func (q *Queries) GetItemFolderByParentIDAndNextID(ctx context.Context, arg GetItemFolderByParentIDAndNextIDParams) (ItemFolder, error) {
	row := q.queryRow(ctx, q.getItemFolderByParentIDAndNextIDStmt, getItemFolderByParentIDAndNextID, arg.Next, arg.ParentID)
	var i ItemFolder
	err := row.Scan(
		&i.ID,
		&i.ParentID,
		&i.Name,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getItemFoldersByParentID = `-- name: GetItemFoldersByParentID :many
SELECT
  id,
  parent_id,
  name,
  prev,
  next
FROM
  item_folder
WHERE
  parent_id = ?
`

func (q *Queries) GetItemFoldersByParentID(ctx context.Context, parentID *idwrap.IDWrap) ([]ItemFolder, error) {
	rows, err := q.query(ctx, q.getItemFoldersByParentIDStmt, getItemFoldersByParentID, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ItemFolder{}
	for rows.Next() {
		var i ItemFolder
		if err := rows.Scan(
			&i.ID,
			&i.ParentID,
			&i.Name,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemsApiByFolderID = `-- name: GetItemsApiByFolderID :many
SELECT
  id,
  folder_id,
  name,
  url,
  method,
  version_parent_id,
  delta_parent_id,
  hidden,
  prev,
  next
FROM
  item_api
WHERE
  folder_id = ? AND
  version_parent_id is NULL AND
  delta_parent_id is NULL AND
  hidden = FALSE
`

func (q *Queries) GetItemsApiByFolderID(ctx context.Context, folderID *idwrap.IDWrap) ([]ItemApi, error) {
	rows, err := q.query(ctx, q.getItemsApiByFolderIDStmt, getItemsApiByFolderID, folderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ItemApi{}
	for rows.Next() {
		var i ItemApi
		if err := rows.Scan(
			&i.ID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.VersionParentID,
			&i.DeltaParentID,
			&i.Hidden,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestNodeExecutionByNodeID = `-- name: GetLatestNodeExecutionByNodeID :one
SELECT id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, response_id, completed_at
FROM node_execution
WHERE node_id = ? AND completed_at IS NOT NULL
ORDER BY completed_at DESC, id DESC
LIMIT 1
`

func (q *Queries) GetLatestNodeExecutionByNodeID(ctx context.Context, nodeID idwrap.IDWrap) (NodeExecution, error) {
	row := q.queryRow(ctx, q.getLatestNodeExecutionByNodeIDStmt, getLatestNodeExecutionByNodeID, nodeID)
	var i NodeExecution
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Name,
		&i.State,
		&i.Error,
		&i.InputData,
		&i.InputDataCompressType,
		&i.OutputData,
		&i.OutputDataCompressType,
		&i.ResponseID,
		&i.CompletedAt,
	)
	return i, err
}

const getMigration = `-- name: GetMigration :one
SELECT
  id,
  version,
  description,
  apply_at
FROM
  migration
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetMigration(ctx context.Context, id []byte) (Migration, error) {
	row := q.queryRow(ctx, q.getMigrationStmt, getMigration, id)
	var i Migration
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.Description,
		&i.ApplyAt,
	)
	return i, err
}

const getMigrations = `-- name: GetMigrations :many
SELECT
  id,
  version,
  description,
  apply_at
FROM
  migration
`

func (q *Queries) GetMigrations(ctx context.Context) ([]Migration, error) {
	rows, err := q.query(ctx, q.getMigrationsStmt, getMigrations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Migration{}
	for rows.Next() {
		var i Migration
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Description,
			&i.ApplyAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeExecution = `-- name: GetNodeExecution :one
SELECT id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, response_id, completed_at FROM node_execution
WHERE id = ?
`

// Node Execution
func (q *Queries) GetNodeExecution(ctx context.Context, id idwrap.IDWrap) (NodeExecution, error) {
	row := q.queryRow(ctx, q.getNodeExecutionStmt, getNodeExecution, id)
	var i NodeExecution
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Name,
		&i.State,
		&i.Error,
		&i.InputData,
		&i.InputDataCompressType,
		&i.OutputData,
		&i.OutputDataCompressType,
		&i.ResponseID,
		&i.CompletedAt,
	)
	return i, err
}

const getNodeExecutionsByNodeID = `-- name: GetNodeExecutionsByNodeID :many
SELECT id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, response_id, completed_at
FROM node_execution
WHERE node_id = ? AND completed_at IS NOT NULL
ORDER BY completed_at DESC, id DESC
`

func (q *Queries) GetNodeExecutionsByNodeID(ctx context.Context, nodeID idwrap.IDWrap) ([]NodeExecution, error) {
	rows, err := q.query(ctx, q.getNodeExecutionsByNodeIDStmt, getNodeExecutionsByNodeID, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NodeExecution{}
	for rows.Next() {
		var i NodeExecution
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.Name,
			&i.State,
			&i.Error,
			&i.InputData,
			&i.InputDataCompressType,
			&i.OutputData,
			&i.OutputDataCompressType,
			&i.ResponseID,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQueriesByExampleID = `-- name: GetQueriesByExampleID :many
SELECT
  id,
  example_id,
  delta_parent_id,
  query_key,
  enable,
  description,
  value
FROM
  example_query
WHERE
  example_id = ?
`

func (q *Queries) GetQueriesByExampleID(ctx context.Context, exampleID idwrap.IDWrap) ([]ExampleQuery, error) {
	rows, err := q.query(ctx, q.getQueriesByExampleIDStmt, getQueriesByExampleID, exampleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExampleQuery{}
	for rows.Next() {
		var i ExampleQuery
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.DeltaParentID,
			&i.QueryKey,
			&i.Enable,
			&i.Description,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQueriesByExampleIDs = `-- name: GetQueriesByExampleIDs :many
SELECT
  id,
  example_id,
  delta_parent_id,
  query_key,
  enable,
  description,
  value
FROM
  example_query
WHERE
  example_id IN (/*SLICE:example_ids*/?)
ORDER BY example_id
`

func (q *Queries) GetQueriesByExampleIDs(ctx context.Context, exampleIds []idwrap.IDWrap) ([]ExampleQuery, error) {
	query := getQueriesByExampleIDs
	var queryParams []interface{}
	if len(exampleIds) > 0 {
		for _, v := range exampleIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:example_ids*/?", strings.Repeat(",?", len(exampleIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:example_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExampleQuery{}
	for rows.Next() {
		var i ExampleQuery
		if err := rows.Scan(
			&i.ID,
			&i.ExampleID,
			&i.DeltaParentID,
			&i.QueryKey,
			&i.Enable,
			&i.Description,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuery = `-- name: GetQuery :one
/*
*
* Query
*
*/

SELECT
  id,
  example_id,
  delta_parent_id,
  query_key,
  enable,
  description,
  value
FROM
  example_query
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetQuery(ctx context.Context, id idwrap.IDWrap) (ExampleQuery, error) {
	row := q.queryRow(ctx, q.getQueryStmt, getQuery, id)
	var i ExampleQuery
	err := row.Scan(
		&i.ID,
		&i.ExampleID,
		&i.DeltaParentID,
		&i.QueryKey,
		&i.Enable,
		&i.Description,
		&i.Value,
	)
	return i, err
}

const getQueryByDeltaParentID = `-- name: GetQueryByDeltaParentID :one
SELECT
  id,
  example_id,
  delta_parent_id,
  query_key,
  enable,
  description,
  value
FROM
  example_query
WHERE
  delta_parent_id = ?
lIMIT 1
`

func (q *Queries) GetQueryByDeltaParentID(ctx context.Context, deltaParentID *idwrap.IDWrap) (ExampleQuery, error) {
	row := q.queryRow(ctx, q.getQueryByDeltaParentIDStmt, getQueryByDeltaParentID, deltaParentID)
	var i ExampleQuery
	err := row.Scan(
		&i.ID,
		&i.ExampleID,
		&i.DeltaParentID,
		&i.QueryKey,
		&i.Enable,
		&i.Description,
		&i.Value,
	)
	return i, err
}

const getRootFilesByWorkspaceID = `-- name: GetRootFilesByWorkspaceID :many
SELECT id, workspace_id, folder_id, content_id, content_kind, name, display_order, updated_at
FROM files
WHERE workspace_id = ? AND folder_id IS NULL
ORDER BY display_order, id
`

// Get root-level files (no parent folder) in a workspace ordered by display_order
func (q *Queries) GetRootFilesByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]File, error) {
	rows, err := q.query(ctx, q.getRootFilesByWorkspaceIDStmt, getRootFilesByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.ContentID,
			&i.ContentKind,
			&i.Name,
			&i.DisplayOrder,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTag = `-- name: GetTag :one
SELECT
  id,
  workspace_id,
  name,
  color
FROM
  tag
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetTag(ctx context.Context, id idwrap.IDWrap) (Tag, error) {
	row := q.queryRow(ctx, q.getTagStmt, getTag, id)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Name,
		&i.Color,
	)
	return i, err
}

const getTagsByWorkspaceID = `-- name: GetTagsByWorkspaceID :many
SELECT
  id,
  workspace_id,
  name,
  color
FROM
  tag
WHERE
  workspace_id = ?
`

func (q *Queries) GetTagsByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]Tag, error) {
	rows, err := q.query(ctx, q.getTagsByWorkspaceIDStmt, getTagsByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT
  id,
  email,
  password_hash,
  provider_type,
  provider_id
FROM
  users
WHERE
  id = ?
LIMIT
  1
`

type GetUserRow struct {
	ID           idwrap.IDWrap
	Email        string
	PasswordHash []byte
	ProviderType int8
	ProviderID   sql.NullString
}

// Users
func (q *Queries) GetUser(ctx context.Context, id idwrap.IDWrap) (GetUserRow, error) {
	row := q.queryRow(ctx, q.getUserStmt, getUser, id)
	var i GetUserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.ProviderType,
		&i.ProviderID,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT
  id,
  email,
  password_hash,
  provider_type,
  provider_id
FROM
  users
WHERE
  email = ?
LIMIT
  1
`

type GetUserByEmailRow struct {
	ID           idwrap.IDWrap
	Email        string
	PasswordHash []byte
	ProviderType int8
	ProviderID   sql.NullString
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.queryRow(ctx, q.getUserByEmailStmt, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.ProviderType,
		&i.ProviderID,
	)
	return i, err
}

const getUserByEmailAndProviderType = `-- name: GetUserByEmailAndProviderType :one
SELECT
  id,
  email,
  password_hash,
  provider_type,
  provider_id
FROM
  users
WHERE
  email = ?
  AND provider_type = ?
LIMIT
  1
`

type GetUserByEmailAndProviderTypeParams struct {
	Email        string
	ProviderType int8
}

type GetUserByEmailAndProviderTypeRow struct {
	ID           idwrap.IDWrap
	Email        string
	PasswordHash []byte
	ProviderType int8
	ProviderID   sql.NullString
}

func (q *Queries) GetUserByEmailAndProviderType(ctx context.Context, arg GetUserByEmailAndProviderTypeParams) (GetUserByEmailAndProviderTypeRow, error) {
	row := q.queryRow(ctx, q.getUserByEmailAndProviderTypeStmt, getUserByEmailAndProviderType, arg.Email, arg.ProviderType)
	var i GetUserByEmailAndProviderTypeRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.ProviderType,
		&i.ProviderID,
	)
	return i, err
}

const getUserByProviderIDandType = `-- name: GetUserByProviderIDandType :one
SELECT
  id,
  email,
  password_hash,
  provider_type,
  provider_id
FROM
  users
WHERE
  provider_id = ?
  AND provider_type = ?
LIMIT
  1
`

type GetUserByProviderIDandTypeParams struct {
	ProviderID   sql.NullString
	ProviderType int8
}

type GetUserByProviderIDandTypeRow struct {
	ID           idwrap.IDWrap
	Email        string
	PasswordHash []byte
	ProviderType int8
	ProviderID   sql.NullString
}

func (q *Queries) GetUserByProviderIDandType(ctx context.Context, arg GetUserByProviderIDandTypeParams) (GetUserByProviderIDandTypeRow, error) {
	row := q.queryRow(ctx, q.getUserByProviderIDandTypeStmt, getUserByProviderIDandType, arg.ProviderID, arg.ProviderType)
	var i GetUserByProviderIDandTypeRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.ProviderType,
		&i.ProviderID,
	)
	return i, err
}

const getVariable = `-- name: GetVariable :one
/*
* Variables
*/

SELECT
  id,
  env_id,
  var_key,
  value,
  enabled,
  description,
  display_order
FROM
  variable
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetVariable(ctx context.Context, id idwrap.IDWrap) (Variable, error) {
	row := q.queryRow(ctx, q.getVariableStmt, getVariable, id)
	var i Variable
	err := row.Scan(
		&i.ID,
		&i.EnvID,
		&i.VarKey,
		&i.Value,
		&i.Enabled,
		&i.Description,
		&i.DisplayOrder,
	)
	return i, err
}

const getVariablesByEnvironmentID = `-- name: GetVariablesByEnvironmentID :many
SELECT
  id,
  env_id,
  var_key,
  value,
  enabled,
  description,
  display_order
FROM
  variable
WHERE
  env_id = ?
ORDER BY
  display_order
`

func (q *Queries) GetVariablesByEnvironmentID(ctx context.Context, envID idwrap.IDWrap) ([]Variable, error) {
	rows, err := q.query(ctx, q.getVariablesByEnvironmentIDStmt, getVariablesByEnvironmentID, envID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Variable{}
	for rows.Next() {
		var i Variable
		if err := rows.Scan(
			&i.ID,
			&i.EnvID,
			&i.VarKey,
			&i.Value,
			&i.Enabled,
			&i.Description,
			&i.DisplayOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVariablesByEnvironmentIDOrdered = `-- name: GetVariablesByEnvironmentIDOrdered :many
SELECT
  id,
  env_id,
  var_key,
  value,
  enabled,
  description,
  display_order
FROM
  variable
WHERE
  env_id = ?
ORDER BY
  display_order
`

func (q *Queries) GetVariablesByEnvironmentIDOrdered(ctx context.Context, envID idwrap.IDWrap) ([]Variable, error) {
	rows, err := q.query(ctx, q.getVariablesByEnvironmentIDOrderedStmt, getVariablesByEnvironmentIDOrdered, envID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Variable{}
	for rows.Next() {
		var i Variable
		if err := rows.Scan(
			&i.ID,
			&i.EnvID,
			&i.VarKey,
			&i.Value,
			&i.Enabled,
			&i.Description,
			&i.DisplayOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspace = `-- name: GetWorkspace :one
SELECT
  id,
  name,
  updated,
  collection_count,
  flow_count,
  active_env,
  global_env
FROM
  workspaces
WHERE
  id = ?
LIMIT
  1
`

type GetWorkspaceRow struct {
	ID              idwrap.IDWrap
	Name            string
	Updated         int64
	CollectionCount int32
	FlowCount       int32
	ActiveEnv       idwrap.IDWrap
	GlobalEnv       idwrap.IDWrap
}

// Workspaces
func (q *Queries) GetWorkspace(ctx context.Context, id idwrap.IDWrap) (GetWorkspaceRow, error) {
	row := q.queryRow(ctx, q.getWorkspaceStmt, getWorkspace, id)
	var i GetWorkspaceRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Updated,
		&i.CollectionCount,
		&i.FlowCount,
		&i.ActiveEnv,
		&i.GlobalEnv,
	)
	return i, err
}

const getWorkspaceByUserID = `-- name: GetWorkspaceByUserID :one
SELECT
  id,
  name,
  updated,
  collection_count,
  flow_count,
  active_env,
  global_env
FROM
  workspaces
WHERE
  id = (
    SELECT
      workspace_id
    FROM
      workspaces_users
    WHERE
      user_id = ?
    LIMIT
      1
  )
LIMIT
  1
`

type GetWorkspaceByUserIDRow struct {
	ID              idwrap.IDWrap
	Name            string
	Updated         int64
	CollectionCount int32
	FlowCount       int32
	ActiveEnv       idwrap.IDWrap
	GlobalEnv       idwrap.IDWrap
}

func (q *Queries) GetWorkspaceByUserID(ctx context.Context, userID idwrap.IDWrap) (GetWorkspaceByUserIDRow, error) {
	row := q.queryRow(ctx, q.getWorkspaceByUserIDStmt, getWorkspaceByUserID, userID)
	var i GetWorkspaceByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Updated,
		&i.CollectionCount,
		&i.FlowCount,
		&i.ActiveEnv,
		&i.GlobalEnv,
	)
	return i, err
}

const getWorkspaceByUserIDandWorkspaceID = `-- name: GetWorkspaceByUserIDandWorkspaceID :one
SELECT
  id,
  name,
  updated,
  collection_count,
  flow_count,
  active_env,
  global_env,
  prev,
  next
FROM
  workspaces
WHERE
  id = (
    SELECT
      workspace_id
    FROM
      workspaces_users
    WHERE
      workspace_id = ?
      AND user_id = ?
    LIMIT
      1
  )
LIMIT
  1
`

type GetWorkspaceByUserIDandWorkspaceIDParams struct {
	WorkspaceID idwrap.IDWrap
	UserID      idwrap.IDWrap
}

func (q *Queries) GetWorkspaceByUserIDandWorkspaceID(ctx context.Context, arg GetWorkspaceByUserIDandWorkspaceIDParams) (Workspace, error) {
	row := q.queryRow(ctx, q.getWorkspaceByUserIDandWorkspaceIDStmt, getWorkspaceByUserIDandWorkspaceID, arg.WorkspaceID, arg.UserID)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Updated,
		&i.CollectionCount,
		&i.FlowCount,
		&i.ActiveEnv,
		&i.GlobalEnv,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getWorkspaceUser = `-- name: GetWorkspaceUser :one
SELECT
  id,
  workspace_id,
  user_id,
  role
FROM
  workspaces_users
WHERE
  id = ?
LIMIT
  1
`

func (q *Queries) GetWorkspaceUser(ctx context.Context, id idwrap.IDWrap) (WorkspacesUser, error) {
	row := q.queryRow(ctx, q.getWorkspaceUserStmt, getWorkspaceUser, id)
	var i WorkspacesUser
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.UserID,
		&i.Role,
	)
	return i, err
}

const getWorkspaceUserByUserID = `-- name: GetWorkspaceUserByUserID :many
SELECT
  id,
  workspace_id,
  user_id,
  role
FROM
  workspaces_users
WHERE
  user_id = ?
`

func (q *Queries) GetWorkspaceUserByUserID(ctx context.Context, userID idwrap.IDWrap) ([]WorkspacesUser, error) {
	rows, err := q.query(ctx, q.getWorkspaceUserByUserIDStmt, getWorkspaceUserByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WorkspacesUser{}
	for rows.Next() {
		var i WorkspacesUser
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.UserID,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspaceUserByWorkspaceID = `-- name: GetWorkspaceUserByWorkspaceID :many
SELECT
  id,
  workspace_id,
  user_id,
  role
FROM
  workspaces_users
WHERE
  workspace_id = ?
`

func (q *Queries) GetWorkspaceUserByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]WorkspacesUser, error) {
	rows, err := q.query(ctx, q.getWorkspaceUserByWorkspaceIDStmt, getWorkspaceUserByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WorkspacesUser{}
	for rows.Next() {
		var i WorkspacesUser
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.UserID,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspaceUserByWorkspaceIDAndUserID = `-- name: GetWorkspaceUserByWorkspaceIDAndUserID :one
SELECT
  id,
  workspace_id,
  user_id,
  role
FROM
  workspaces_users
WHERE
  workspace_id = ?
  AND user_id = ?
LIMIT
  1
`

type GetWorkspaceUserByWorkspaceIDAndUserIDParams struct {
	WorkspaceID idwrap.IDWrap
	UserID      idwrap.IDWrap
}

func (q *Queries) GetWorkspaceUserByWorkspaceIDAndUserID(ctx context.Context, arg GetWorkspaceUserByWorkspaceIDAndUserIDParams) (WorkspacesUser, error) {
	row := q.queryRow(ctx, q.getWorkspaceUserByWorkspaceIDAndUserIDStmt, getWorkspaceUserByWorkspaceIDAndUserID, arg.WorkspaceID, arg.UserID)
	var i WorkspacesUser
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.UserID,
		&i.Role,
	)
	return i, err
}

const getWorkspacesByUserID = `-- name: GetWorkspacesByUserID :many
SELECT
  id,
  name,
  updated,
  collection_count,
  flow_count,
  active_env,
  global_env,
  prev,
  next
FROM
  workspaces
WHERE
  id IN (
    SELECT
      workspace_id
    FROM
      workspaces_users
    WHERE
      user_id = ?
  )
`

func (q *Queries) GetWorkspacesByUserID(ctx context.Context, userID idwrap.IDWrap) ([]Workspace, error) {
	rows, err := q.query(ctx, q.getWorkspacesByUserIDStmt, getWorkspacesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workspace{}
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Updated,
			&i.CollectionCount,
			&i.FlowCount,
			&i.ActiveEnv,
			&i.GlobalEnv,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspacesByUserIDOrdered = `-- name: GetWorkspacesByUserIDOrdered :many
WITH RECURSIVE ordered_workspaces AS (
  -- Base case: Find the head (prev IS NULL) for this user
  SELECT
    w.id,
    w.name,
    w.updated,
    w.collection_count,
    w.flow_count,
    w.active_env,
    w.global_env,
    w.prev,
    w.next,
    0 as position
  FROM
    workspaces w
  INNER JOIN workspaces_users wu ON w.id = wu.workspace_id
  WHERE
    wu.user_id = ? AND
    w.prev IS NULL
  
  UNION ALL
  
  -- Recursive case: Follow the next pointers
  SELECT
    w.id,
    w.name,
    w.updated,
    w.collection_count,
    w.flow_count,
    w.active_env,
    w.global_env,
    w.prev,
    w.next,
    ow.position + 1
  FROM
    workspaces w
  INNER JOIN workspaces_users wu ON w.id = wu.workspace_id
  INNER JOIN ordered_workspaces ow ON w.prev = ow.id
  WHERE
    wu.user_id = ?
)
SELECT
  ow.id,
  ow.name,
  ow.updated,
  ow.collection_count,
  ow.flow_count,
  ow.active_env,
  ow.global_env,
  ow.prev,
  ow.next,
  ow.position
FROM
  ordered_workspaces ow
ORDER BY
  ow.position
`

type GetWorkspacesByUserIDOrderedParams struct {
	UserID   idwrap.IDWrap
	UserID_2 idwrap.IDWrap
}

type GetWorkspacesByUserIDOrderedRow struct {
	ID              []byte
	Name            string
	Updated         int64
	CollectionCount int32
	FlowCount       int32
	ActiveEnv       []byte
	GlobalEnv       []byte
	Prev            []byte
	Next            []byte
	Position        int64
}

// Uses WITH RECURSIVE CTE to traverse linked list from head to tail for user-scoped ordering
// Each user has their own workspace ordering maintained via workspaces_users table
func (q *Queries) GetWorkspacesByUserIDOrdered(ctx context.Context, arg GetWorkspacesByUserIDOrderedParams) ([]GetWorkspacesByUserIDOrderedRow, error) {
	rows, err := q.query(ctx, q.getWorkspacesByUserIDOrderedStmt, getWorkspacesByUserIDOrdered, arg.UserID, arg.UserID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWorkspacesByUserIDOrderedRow{}
	for rows.Next() {
		var i GetWorkspacesByUserIDOrderedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Updated,
			&i.CollectionCount,
			&i.FlowCount,
			&i.ActiveEnv,
			&i.GlobalEnv,
			&i.Prev,
			&i.Next,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodeExecutions = `-- name: ListNodeExecutions :many
SELECT id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, response_id, completed_at FROM node_execution
WHERE node_id = ?
ORDER BY completed_at DESC
LIMIT ? OFFSET ?
`

type ListNodeExecutionsParams struct {
	NodeID idwrap.IDWrap
	Limit  int64
	Offset int64
}

func (q *Queries) ListNodeExecutions(ctx context.Context, arg ListNodeExecutionsParams) ([]NodeExecution, error) {
	rows, err := q.query(ctx, q.listNodeExecutionsStmt, listNodeExecutions, arg.NodeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NodeExecution{}
	for rows.Next() {
		var i NodeExecution
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.Name,
			&i.State,
			&i.Error,
			&i.InputData,
			&i.InputDataCompressType,
			&i.OutputData,
			&i.OutputDataCompressType,
			&i.ResponseID,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodeExecutionsByFlowRun = `-- name: ListNodeExecutionsByFlowRun :many
SELECT ne.id, ne.node_id, ne.name, ne.state, ne.error, ne.input_data, ne.input_data_compress_type, ne.output_data, ne.output_data_compress_type, ne.response_id, ne.completed_at FROM node_execution ne
JOIN flow_node fn ON ne.node_id = fn.id
WHERE fn.flow_id = ?
ORDER BY ne.completed_at DESC
`

func (q *Queries) ListNodeExecutionsByFlowRun(ctx context.Context, flowID idwrap.IDWrap) ([]NodeExecution, error) {
	rows, err := q.query(ctx, q.listNodeExecutionsByFlowRunStmt, listNodeExecutionsByFlowRun, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NodeExecution{}
	for rows.Next() {
		var i NodeExecution
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.Name,
			&i.State,
			&i.Error,
			&i.InputData,
			&i.InputDataCompressType,
			&i.OutputData,
			&i.OutputDataCompressType,
			&i.ResponseID,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodeExecutionsByState = `-- name: ListNodeExecutionsByState :many
SELECT id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, response_id, completed_at FROM node_execution
WHERE node_id = ? AND state = ?
ORDER BY completed_at DESC
LIMIT ? OFFSET ?
`

type ListNodeExecutionsByStateParams struct {
	NodeID idwrap.IDWrap
	State  int8
	Limit  int64
	Offset int64
}

func (q *Queries) ListNodeExecutionsByState(ctx context.Context, arg ListNodeExecutionsByStateParams) ([]NodeExecution, error) {
	rows, err := q.query(ctx, q.listNodeExecutionsByStateStmt, listNodeExecutionsByState,
		arg.NodeID,
		arg.State,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NodeExecution{}
	for rows.Next() {
		var i NodeExecution
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.Name,
			&i.State,
			&i.Error,
			&i.InputData,
			&i.InputDataCompressType,
			&i.OutputData,
			&i.OutputDataCompressType,
			&i.ResponseID,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetHTTPBodyFormDelta = `-- name: ResetHTTPBodyFormDelta :exec
UPDATE http_body_form
SET
  is_delta = false,
  parent_http_body_form_id = NULL,
  delta_key = NULL,
  delta_value = NULL,
  delta_description = NULL,
  delta_enabled = NULL,
  delta_order = NULL,
  updated_at = unixepoch()
WHERE id = ?
`

func (q *Queries) ResetHTTPBodyFormDelta(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.resetHTTPBodyFormDeltaStmt, resetHTTPBodyFormDelta, id)
	return err
}

const resolveHTTPWithDeltas = `-- name: ResolveHTTPWithDeltas :one
WITH RECURSIVE delta_chain AS (
  -- Base case: Start with the parent HTTP record
  SELECT 
    h.id,
    h.workspace_id,
    h.folder_id,
    h.name,
    h.url,
    h.method,
    h.description,
    h.parent_http_id,
    h.is_delta,
    h.delta_name,
    h.delta_url,
    h.delta_method,
    h.delta_description,
    h.created_at,
    h.updated_at,
    0 as delta_level
  FROM http h
  WHERE h.id = ? AND h.is_delta = FALSE
  
  UNION ALL
  
  -- Recursive case: Apply deltas in chronological order
  SELECT 
    h.id,
    h.workspace_id,
    h.folder_id,
    COALESCE(h.delta_name, dc.name, dc.name) as name,
    COALESCE(h.delta_url, dc.url, dc.url) as url,
    COALESCE(h.delta_method, dc.method, dc.method) as method,
    COALESCE(h.delta_description, dc.description, dc.description) as description,
    h.parent_http_id,
    h.is_delta,
    h.delta_name,
    h.delta_url,
    h.delta_method,
    h.delta_description,
    h.created_at,
    h.updated_at,
    dc.delta_level + 1
  FROM http h
  INNER JOIN delta_chain dc ON h.parent_http_id = dc.id
  WHERE h.is_delta = TRUE
    AND h.updated_at <= ?
)
SELECT 
  id,
  workspace_id,
  folder_id,
  name,
  url,
  method,
  description,
  parent_http_id,
  is_delta,
  delta_name,
  delta_url,
  delta_method,
  delta_description,
  created_at,
  updated_at
FROM delta_chain
ORDER BY delta_level DESC
LIMIT 1
`

type ResolveHTTPWithDeltasParams struct {
	ID        idwrap.IDWrap
	UpdatedAt int64
}

type ResolveHTTPWithDeltasRow struct {
	ID               []byte
	WorkspaceID      []byte
	FolderID         []byte
	Name             string
	Url              string
	Method           string
	Description      string
	ParentHttpID     []byte
	IsDelta          bool
	DeltaName        interface{}
	DeltaUrl         interface{}
	DeltaMethod      interface{}
	DeltaDescription interface{}
	CreatedAt        int64
	UpdatedAt        int64
}

// HTTP Delta Resolution Queries
// CTE-optimized query to resolve HTTP record with all applicable deltas
// Single query for complete delta resolution with minimal joins
func (q *Queries) ResolveHTTPWithDeltas(ctx context.Context, arg ResolveHTTPWithDeltasParams) (ResolveHTTPWithDeltasRow, error) {
	row := q.queryRow(ctx, q.resolveHTTPWithDeltasStmt, resolveHTTPWithDeltas, arg.ID, arg.UpdatedAt)
	var i ResolveHTTPWithDeltasRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.FolderID,
		&i.Name,
		&i.Url,
		&i.Method,
		&i.Description,
		&i.ParentHttpID,
		&i.IsDelta,
		&i.DeltaName,
		&i.DeltaUrl,
		&i.DeltaMethod,
		&i.DeltaDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setBodyFormEnable = `-- name: SetBodyFormEnable :exec
UPDATE example_body_form
SET
  enable = ?
WHERE
  id = ?
`

type SetBodyFormEnableParams struct {
	Enable bool
	ID     idwrap.IDWrap
}

func (q *Queries) SetBodyFormEnable(ctx context.Context, arg SetBodyFormEnableParams) error {
	_, err := q.exec(ctx, q.setBodyFormEnableStmt, setBodyFormEnable, arg.Enable, arg.ID)
	return err
}

const setHeaderEnable = `-- name: SetHeaderEnable :exec
UPDATE example_header
    SET
  enable = ?
WHERE
  id = ?
`

type SetHeaderEnableParams struct {
	Enable bool
	ID     idwrap.IDWrap
}

func (q *Queries) SetHeaderEnable(ctx context.Context, arg SetHeaderEnableParams) error {
	_, err := q.exec(ctx, q.setHeaderEnableStmt, setHeaderEnable, arg.Enable, arg.ID)
	return err
}

const setQueryEnable = `-- name: SetQueryEnable :exec
UPDATE example_query
SET
  enable = ?
WHERE
  id = ?
`

type SetQueryEnableParams struct {
	Enable bool
	ID     idwrap.IDWrap
}

func (q *Queries) SetQueryEnable(ctx context.Context, arg SetQueryEnableParams) error {
	_, err := q.exec(ctx, q.setQueryEnableStmt, setQueryEnable, arg.Enable, arg.ID)
	return err
}

const updateAssert = `-- name: UpdateAssert :exec
UPDATE assertion
SET
  delta_parent_id = ?,
  expression = ?,
  enable = ?
WHERE
  id = ?
`

type UpdateAssertParams struct {
	DeltaParentID *idwrap.IDWrap
	Expression    string
	Enable        bool
	ID            idwrap.IDWrap
}

func (q *Queries) UpdateAssert(ctx context.Context, arg UpdateAssertParams) error {
	_, err := q.exec(ctx, q.updateAssertStmt, updateAssert,
		arg.DeltaParentID,
		arg.Expression,
		arg.Enable,
		arg.ID,
	)
	return err
}

const updateAssertNext = `-- name: UpdateAssertNext :exec
UPDATE assertion
SET
  next = ?
WHERE
  id = ? AND
  example_id = ?
`

type UpdateAssertNextParams struct {
	Next      *idwrap.IDWrap
	ID        idwrap.IDWrap
	ExampleID idwrap.IDWrap
}

// Update only the next pointer for an assertion with example validation (used in deletion)
func (q *Queries) UpdateAssertNext(ctx context.Context, arg UpdateAssertNextParams) error {
	_, err := q.exec(ctx, q.updateAssertNextStmt, updateAssertNext, arg.Next, arg.ID, arg.ExampleID)
	return err
}

const updateAssertOrder = `-- name: UpdateAssertOrder :exec
UPDATE assertion
SET
  prev = ?,
  next = ?
WHERE
  id = ? AND
  example_id = ?
`

type UpdateAssertOrderParams struct {
	Prev      *idwrap.IDWrap
	Next      *idwrap.IDWrap
	ID        idwrap.IDWrap
	ExampleID idwrap.IDWrap
}

// Update the prev/next pointers for a single assertion with example validation
// Used for moving assertions within the example's linked list
func (q *Queries) UpdateAssertOrder(ctx context.Context, arg UpdateAssertOrderParams) error {
	_, err := q.exec(ctx, q.updateAssertOrderStmt, updateAssertOrder,
		arg.Prev,
		arg.Next,
		arg.ID,
		arg.ExampleID,
	)
	return err
}

const updateAssertPrev = `-- name: UpdateAssertPrev :exec
UPDATE assertion
SET
  prev = ?
WHERE
  id = ? AND
  example_id = ?
`

type UpdateAssertPrevParams struct {
	Prev      *idwrap.IDWrap
	ID        idwrap.IDWrap
	ExampleID idwrap.IDWrap
}

// Update only the prev pointer for an assertion with example validation (used in deletion)
func (q *Queries) UpdateAssertPrev(ctx context.Context, arg UpdateAssertPrevParams) error {
	_, err := q.exec(ctx, q.updateAssertPrevStmt, updateAssertPrev, arg.Prev, arg.ID, arg.ExampleID)
	return err
}

const updateAssertResult = `-- name: UpdateAssertResult :exec
UPDATE assertion_result
SET
  result = ?
WHERE
  id = ?
`

type UpdateAssertResultParams struct {
	Result bool
	ID     idwrap.IDWrap
}

func (q *Queries) UpdateAssertResult(ctx context.Context, arg UpdateAssertResultParams) error {
	_, err := q.exec(ctx, q.updateAssertResultStmt, updateAssertResult, arg.Result, arg.ID)
	return err
}

const updateBodyForm = `-- name: UpdateBodyForm :exec
UPDATE example_body_form
SET
  body_key = ?,
  enable = ?,
  description = ?,
  value = ?
WHERE
  id = ?
`

type UpdateBodyFormParams struct {
	BodyKey     string
	Enable      bool
	Description string
	Value       string
	ID          idwrap.IDWrap
}

func (q *Queries) UpdateBodyForm(ctx context.Context, arg UpdateBodyFormParams) error {
	_, err := q.exec(ctx, q.updateBodyFormStmt, updateBodyForm,
		arg.BodyKey,
		arg.Enable,
		arg.Description,
		arg.Value,
		arg.ID,
	)
	return err
}

const updateBodyRawData = `-- name: UpdateBodyRawData :exec
UPDATE example_body_raw
SET
  compress_type = ?,
  data = ?
WHERE
  id = ?
`

type UpdateBodyRawDataParams struct {
	CompressType int8
	Data         []byte
	ID           idwrap.IDWrap
}

func (q *Queries) UpdateBodyRawData(ctx context.Context, arg UpdateBodyRawDataParams) error {
	_, err := q.exec(ctx, q.updateBodyRawDataStmt, updateBodyRawData, arg.CompressType, arg.Data, arg.ID)
	return err
}

const updateBodyUrlEncoded = `-- name: UpdateBodyUrlEncoded :exec
UPDATE example_body_urlencoded
    SET
      body_key = ?,
      enable = ?,
      description = ?,
      value = ?
    WHERE
      id = ?
`

type UpdateBodyUrlEncodedParams struct {
	BodyKey     string
	Enable      bool
	Description string
	Value       string
	ID          idwrap.IDWrap
}

func (q *Queries) UpdateBodyUrlEncoded(ctx context.Context, arg UpdateBodyUrlEncodedParams) error {
	_, err := q.exec(ctx, q.updateBodyUrlEncodedStmt, updateBodyUrlEncoded,
		arg.BodyKey,
		arg.Enable,
		arg.Description,
		arg.Value,
		arg.ID,
	)
	return err
}

const updateBodyUrlEncodedNext = `-- name: UpdateBodyUrlEncodedNext :exec
UPDATE example_body_urlencoded
SET
  next = ?
WHERE
  id = ? AND
  example_id = ?
`

type UpdateBodyUrlEncodedNextParams struct {
	Next      []byte
	ID        idwrap.IDWrap
	ExampleID idwrap.IDWrap
}

// Update only the next pointer for a URL-encoded body with example validation (used in deletion or moves)
func (q *Queries) UpdateBodyUrlEncodedNext(ctx context.Context, arg UpdateBodyUrlEncodedNextParams) error {
	_, err := q.exec(ctx, q.updateBodyUrlEncodedNextStmt, updateBodyUrlEncodedNext, arg.Next, arg.ID, arg.ExampleID)
	return err
}

const updateBodyUrlEncodedOrder = `-- name: UpdateBodyUrlEncodedOrder :exec
UPDATE example_body_urlencoded
SET
  prev = ?,
  next = ?
WHERE
  id = ? AND
  example_id = ?
`

type UpdateBodyUrlEncodedOrderParams struct {
	Prev      []byte
	Next      []byte
	ID        idwrap.IDWrap
	ExampleID idwrap.IDWrap
}

// Update the prev/next pointers for a single URL-encoded body with example validation
// Used for moving items within the example's linked list
func (q *Queries) UpdateBodyUrlEncodedOrder(ctx context.Context, arg UpdateBodyUrlEncodedOrderParams) error {
	_, err := q.exec(ctx, q.updateBodyUrlEncodedOrderStmt, updateBodyUrlEncodedOrder,
		arg.Prev,
		arg.Next,
		arg.ID,
		arg.ExampleID,
	)
	return err
}

const updateBodyUrlEncodedPrev = `-- name: UpdateBodyUrlEncodedPrev :exec
UPDATE example_body_urlencoded
SET
  prev = ?
WHERE
  id = ? AND
  example_id = ?
`

type UpdateBodyUrlEncodedPrevParams struct {
	Prev      []byte
	ID        idwrap.IDWrap
	ExampleID idwrap.IDWrap
}

// Update only the prev pointer for a URL-encoded body with example validation (used in deletion or moves)
func (q *Queries) UpdateBodyUrlEncodedPrev(ctx context.Context, arg UpdateBodyUrlEncodedPrevParams) error {
	_, err := q.exec(ctx, q.updateBodyUrlEncodedPrevStmt, updateBodyUrlEncodedPrev, arg.Prev, arg.ID, arg.ExampleID)
	return err
}

const updateEnvironment = `-- name: UpdateEnvironment :exec
UPDATE environment
SET
    type = ?,
    name = ?,
    description = ?,
    display_order = ?
WHERE
    id = ?
`

type UpdateEnvironmentParams struct {
	Type         int8
	Name         string
	Description  string
	DisplayOrder float64
	ID           idwrap.IDWrap
}

func (q *Queries) UpdateEnvironment(ctx context.Context, arg UpdateEnvironmentParams) error {
	_, err := q.exec(ctx, q.updateEnvironmentStmt, updateEnvironment,
		arg.Type,
		arg.Name,
		arg.Description,
		arg.DisplayOrder,
		arg.ID,
	)
	return err
}

const updateExampleNext = `-- name: UpdateExampleNext :exec
UPDATE item_api_example
SET
  next = ?
WHERE
  id = ? AND
  item_api_id = ?
`

type UpdateExampleNextParams struct {
	Next      *idwrap.IDWrap
	ID        idwrap.IDWrap
	ItemApiID idwrap.IDWrap
}

// Update only the next pointer for an example with endpoint validation (used in deletion)
func (q *Queries) UpdateExampleNext(ctx context.Context, arg UpdateExampleNextParams) error {
	_, err := q.exec(ctx, q.updateExampleNextStmt, updateExampleNext, arg.Next, arg.ID, arg.ItemApiID)
	return err
}

const updateExampleOrder = `-- name: UpdateExampleOrder :exec
UPDATE item_api_example
SET
  prev = ?,
  next = ?
WHERE
  id = ? AND
  item_api_id = ?
`

type UpdateExampleOrderParams struct {
	Prev      *idwrap.IDWrap
	Next      *idwrap.IDWrap
	ID        idwrap.IDWrap
	ItemApiID idwrap.IDWrap
}

// Update the prev/next pointers for a single example with endpoint validation
// Used for moving examples within the endpoint's linked list
func (q *Queries) UpdateExampleOrder(ctx context.Context, arg UpdateExampleOrderParams) error {
	_, err := q.exec(ctx, q.updateExampleOrderStmt, updateExampleOrder,
		arg.Prev,
		arg.Next,
		arg.ID,
		arg.ItemApiID,
	)
	return err
}

const updateExamplePrev = `-- name: UpdateExamplePrev :exec
UPDATE item_api_example
SET
  prev = ?
WHERE
  id = ? AND
  item_api_id = ?
`

type UpdateExamplePrevParams struct {
	Prev      *idwrap.IDWrap
	ID        idwrap.IDWrap
	ItemApiID idwrap.IDWrap
}

// Update only the prev pointer for an example with endpoint validation (used in deletion)
func (q *Queries) UpdateExamplePrev(ctx context.Context, arg UpdateExamplePrevParams) error {
	_, err := q.exec(ctx, q.updateExamplePrevStmt, updateExamplePrev, arg.Prev, arg.ID, arg.ItemApiID)
	return err
}

const updateExampleResp = `-- name: UpdateExampleResp :exec
UPDATE example_resp
SET
  status = ?,
  body = ?,
  body_compress_type = ?,
  duration = ?
WHERE
  id = ?
`

type UpdateExampleRespParams struct {
	Status           uint16
	Body             []byte
	BodyCompressType int8
	Duration         int32
	ID               idwrap.IDWrap
}

func (q *Queries) UpdateExampleResp(ctx context.Context, arg UpdateExampleRespParams) error {
	_, err := q.exec(ctx, q.updateExampleRespStmt, updateExampleResp,
		arg.Status,
		arg.Body,
		arg.BodyCompressType,
		arg.Duration,
		arg.ID,
	)
	return err
}

const updateExampleRespHeader = `-- name: UpdateExampleRespHeader :exec
UPDATE example_resp_header
SET
  header_key = ?,
  value = ?
WHERE
  id = ?
`

type UpdateExampleRespHeaderParams struct {
	HeaderKey string
	Value     string
	ID        idwrap.IDWrap
}

func (q *Queries) UpdateExampleRespHeader(ctx context.Context, arg UpdateExampleRespHeaderParams) error {
	_, err := q.exec(ctx, q.updateExampleRespHeaderStmt, updateExampleRespHeader, arg.HeaderKey, arg.Value, arg.ID)
	return err
}

const updateFile = `-- name: UpdateFile :exec
UPDATE files 
SET workspace_id = ?, folder_id = ?, content_id = ?, content_kind = ?, name = ?, display_order = ?, updated_at = ?
WHERE id = ?
`

type UpdateFileParams struct {
	WorkspaceID  idwrap.IDWrap
	FolderID     *idwrap.IDWrap
	ContentID    *idwrap.IDWrap
	ContentKind  int8
	Name         string
	DisplayOrder float64
	UpdatedAt    int64
	ID           idwrap.IDWrap
}

// Update an existing file
func (q *Queries) UpdateFile(ctx context.Context, arg UpdateFileParams) error {
	_, err := q.exec(ctx, q.updateFileStmt, updateFile,
		arg.WorkspaceID,
		arg.FolderID,
		arg.ContentID,
		arg.ContentKind,
		arg.Name,
		arg.DisplayOrder,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateFlow = `-- name: UpdateFlow :exec
UPDATE flow
SET
  name = ?,
  duration = ?
WHERE
  id = ?
`

type UpdateFlowParams struct {
	Name     string
	Duration int32
	ID       idwrap.IDWrap
}

func (q *Queries) UpdateFlow(ctx context.Context, arg UpdateFlowParams) error {
	_, err := q.exec(ctx, q.updateFlowStmt, updateFlow, arg.Name, arg.Duration, arg.ID)
	return err
}

const updateFlowEdge = `-- name: UpdateFlowEdge :exec
UPDATE flow_edge
SET
  source_id = ?,
  target_id = ?,
  source_handle = ?,
  edge_kind = ?
WHERE
  id = ?
`

type UpdateFlowEdgeParams struct {
	SourceID     idwrap.IDWrap
	TargetID     idwrap.IDWrap
	SourceHandle int32
	EdgeKind     int32
	ID           idwrap.IDWrap
}

func (q *Queries) UpdateFlowEdge(ctx context.Context, arg UpdateFlowEdgeParams) error {
	_, err := q.exec(ctx, q.updateFlowEdgeStmt, updateFlowEdge,
		arg.SourceID,
		arg.TargetID,
		arg.SourceHandle,
		arg.EdgeKind,
		arg.ID,
	)
	return err
}

const updateFlowNode = `-- name: UpdateFlowNode :exec
UPDATE flow_node
SET
  name = ?,
  position_x = ?,
  position_y = ?
WHERE
  id = ?
`

type UpdateFlowNodeParams struct {
	Name      string
	PositionX float64
	PositionY float64
	ID        idwrap.IDWrap
}

func (q *Queries) UpdateFlowNode(ctx context.Context, arg UpdateFlowNodeParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeStmt, updateFlowNode,
		arg.Name,
		arg.PositionX,
		arg.PositionY,
		arg.ID,
	)
	return err
}

const updateFlowNodeCondition = `-- name: UpdateFlowNodeCondition :exec
UPDATE flow_node_condition
SET
  expression = ?
WHERE
  flow_node_id = ?
`

type UpdateFlowNodeConditionParams struct {
	Expression string
	FlowNodeID idwrap.IDWrap
}

func (q *Queries) UpdateFlowNodeCondition(ctx context.Context, arg UpdateFlowNodeConditionParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeConditionStmt, updateFlowNodeCondition, arg.Expression, arg.FlowNodeID)
	return err
}

const updateFlowNodeFor = `-- name: UpdateFlowNodeFor :exec
UPDATE flow_node_for
SET
  iter_count = ?,
  error_handling = ?,
  expression = ?
WHERE
  flow_node_id = ?
`

type UpdateFlowNodeForParams struct {
	IterCount     int64
	ErrorHandling int8
	Expression    string
	FlowNodeID    idwrap.IDWrap
}

func (q *Queries) UpdateFlowNodeFor(ctx context.Context, arg UpdateFlowNodeForParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeForStmt, updateFlowNodeFor,
		arg.IterCount,
		arg.ErrorHandling,
		arg.Expression,
		arg.FlowNodeID,
	)
	return err
}

const updateFlowNodeForEach = `-- name: UpdateFlowNodeForEach :exec
UPDATE flow_node_for_each
SET
  iter_expression = ?,
  error_handling = ?,
  expression = ?
WHERE
  flow_node_id = ?
`

type UpdateFlowNodeForEachParams struct {
	IterExpression string
	ErrorHandling  int8
	Expression     string
	FlowNodeID     idwrap.IDWrap
}

func (q *Queries) UpdateFlowNodeForEach(ctx context.Context, arg UpdateFlowNodeForEachParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeForEachStmt, updateFlowNodeForEach,
		arg.IterExpression,
		arg.ErrorHandling,
		arg.Expression,
		arg.FlowNodeID,
	)
	return err
}

const updateFlowNodeJs = `-- name: UpdateFlowNodeJs :exec
UPDATE flow_node_js
SET
  code = ?,
  code_compress_type = ?
WHERE
  flow_node_id = ?
`

type UpdateFlowNodeJsParams struct {
	Code             []byte
	CodeCompressType int8
	FlowNodeID       idwrap.IDWrap
}

func (q *Queries) UpdateFlowNodeJs(ctx context.Context, arg UpdateFlowNodeJsParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeJsStmt, updateFlowNodeJs, arg.Code, arg.CodeCompressType, arg.FlowNodeID)
	return err
}

const updateFlowNodeRequest = `-- name: UpdateFlowNodeRequest :exec
UPDATE flow_node_request
SET
  endpoint_id = ?,
  example_id = ?,
  delta_example_id = ?,
  delta_endpoint_id = ?,
  has_request_config = ?
WHERE
  flow_node_id = ?
`

type UpdateFlowNodeRequestParams struct {
	EndpointID       *idwrap.IDWrap
	ExampleID        *idwrap.IDWrap
	DeltaExampleID   *idwrap.IDWrap
	DeltaEndpointID  *idwrap.IDWrap
	HasRequestConfig bool
	FlowNodeID       idwrap.IDWrap
}

func (q *Queries) UpdateFlowNodeRequest(ctx context.Context, arg UpdateFlowNodeRequestParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeRequestStmt, updateFlowNodeRequest,
		arg.EndpointID,
		arg.ExampleID,
		arg.DeltaExampleID,
		arg.DeltaEndpointID,
		arg.HasRequestConfig,
		arg.FlowNodeID,
	)
	return err
}

const updateFlowVariable = `-- name: UpdateFlowVariable :exec
UPDATE flow_variable
SET
  key = ?,
  value = ?,
  enabled = ?,
  description = ?
WHERE
  id = ?
`

type UpdateFlowVariableParams struct {
	Key         string
	Value       string
	Enabled     bool
	Description string
	ID          idwrap.IDWrap
}

func (q *Queries) UpdateFlowVariable(ctx context.Context, arg UpdateFlowVariableParams) error {
	_, err := q.exec(ctx, q.updateFlowVariableStmt, updateFlowVariable,
		arg.Key,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.ID,
	)
	return err
}

const updateFlowVariableNext = `-- name: UpdateFlowVariableNext :exec
UPDATE flow_variable
SET
  next = ?
WHERE
  id = ? AND
  flow_id = ?
`

type UpdateFlowVariableNextParams struct {
	Next   *idwrap.IDWrap
	ID     idwrap.IDWrap
	FlowID idwrap.IDWrap
}

// Update only the next pointer for a flow variable (used in deletion)
func (q *Queries) UpdateFlowVariableNext(ctx context.Context, arg UpdateFlowVariableNextParams) error {
	_, err := q.exec(ctx, q.updateFlowVariableNextStmt, updateFlowVariableNext, arg.Next, arg.ID, arg.FlowID)
	return err
}

const updateFlowVariableOrder = `-- name: UpdateFlowVariableOrder :exec
UPDATE flow_variable
SET
  prev = ?,
  next = ?
WHERE
  id = ? AND
  flow_id = ?
`

type UpdateFlowVariableOrderParams struct {
	Prev   *idwrap.IDWrap
	Next   *idwrap.IDWrap
	ID     idwrap.IDWrap
	FlowID idwrap.IDWrap
}

// Update the prev/next pointers for a single flow variable
// Used for moving flow variables within the linked list
func (q *Queries) UpdateFlowVariableOrder(ctx context.Context, arg UpdateFlowVariableOrderParams) error {
	_, err := q.exec(ctx, q.updateFlowVariableOrderStmt, updateFlowVariableOrder,
		arg.Prev,
		arg.Next,
		arg.ID,
		arg.FlowID,
	)
	return err
}

const updateFlowVariablePrev = `-- name: UpdateFlowVariablePrev :exec
UPDATE flow_variable
SET
  prev = ?
WHERE
  id = ? AND
  flow_id = ?
`

type UpdateFlowVariablePrevParams struct {
	Prev   *idwrap.IDWrap
	ID     idwrap.IDWrap
	FlowID idwrap.IDWrap
}

// Update only the prev pointer for a flow variable (used in deletion)
func (q *Queries) UpdateFlowVariablePrev(ctx context.Context, arg UpdateFlowVariablePrevParams) error {
	_, err := q.exec(ctx, q.updateFlowVariablePrevStmt, updateFlowVariablePrev, arg.Prev, arg.ID, arg.FlowID)
	return err
}

const updateHTTP = `-- name: UpdateHTTP :exec
UPDATE http
SET
  folder_id = ?,
  name = ?,
  url = ?,
  method = ?,
  description = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPParams struct {
	FolderID    *idwrap.IDWrap
	Name        string
	Url         string
	Method      string
	Description string
	ID          idwrap.IDWrap
}

func (q *Queries) UpdateHTTP(ctx context.Context, arg UpdateHTTPParams) error {
	_, err := q.exec(ctx, q.updateHTTPStmt, updateHTTP,
		arg.FolderID,
		arg.Name,
		arg.Url,
		arg.Method,
		arg.Description,
		arg.ID,
	)
	return err
}

const updateHTTPAssert = `-- name: UpdateHTTPAssert :exec
UPDATE http_assert
SET
  key = ?,
  value = ?,
  enabled = ?,
  description = ?,
  "order" = ?,
  delta_key = ?,
  delta_value = ?,
  delta_enabled = ?,
  delta_description = ?,
  delta_order = ?,
  updated_at = ?
WHERE id = ?
`

type UpdateHTTPAssertParams struct {
	Key              string
	Value            string
	Enabled          bool
	Description      string
	Order            float64
	DeltaKey         sql.NullString
	DeltaValue       sql.NullString
	DeltaEnabled     *bool
	DeltaDescription sql.NullString
	DeltaOrder       sql.NullFloat64
	UpdatedAt        int64
	ID               idwrap.IDWrap
}

func (q *Queries) UpdateHTTPAssert(ctx context.Context, arg UpdateHTTPAssertParams) error {
	_, err := q.exec(ctx, q.updateHTTPAssertStmt, updateHTTPAssert,
		arg.Key,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.Order,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaEnabled,
		arg.DeltaDescription,
		arg.DeltaOrder,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateHTTPAssertDelta = `-- name: UpdateHTTPAssertDelta :exec
UPDATE http_assert
SET
  delta_key = ?,
  delta_value = ?,
  delta_enabled = ?,
  delta_description = ?,
  delta_order = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPAssertDeltaParams struct {
	DeltaKey         sql.NullString
	DeltaValue       sql.NullString
	DeltaEnabled     *bool
	DeltaDescription sql.NullString
	DeltaOrder       sql.NullFloat64
	ID               idwrap.IDWrap
}

func (q *Queries) UpdateHTTPAssertDelta(ctx context.Context, arg UpdateHTTPAssertDeltaParams) error {
	_, err := q.exec(ctx, q.updateHTTPAssertDeltaStmt, updateHTTPAssertDelta,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaEnabled,
		arg.DeltaDescription,
		arg.DeltaOrder,
		arg.ID,
	)
	return err
}

const updateHTTPBodyForm = `-- name: UpdateHTTPBodyForm :exec
UPDATE http_body_form
SET
  key = ?,
  value = ?,
  description = ?,
  enabled = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPBodyFormParams struct {
	Key         string
	Value       string
	Description string
	Enabled     bool
	ID          idwrap.IDWrap
}

func (q *Queries) UpdateHTTPBodyForm(ctx context.Context, arg UpdateHTTPBodyFormParams) error {
	_, err := q.exec(ctx, q.updateHTTPBodyFormStmt, updateHTTPBodyForm,
		arg.Key,
		arg.Value,
		arg.Description,
		arg.Enabled,
		arg.ID,
	)
	return err
}

const updateHTTPBodyFormDelta = `-- name: UpdateHTTPBodyFormDelta :exec
UPDATE http_body_form
SET
  delta_key = ?,
  delta_value = ?,
  delta_description = ?,
  delta_enabled = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPBodyFormDeltaParams struct {
	DeltaKey         sql.NullString
	DeltaValue       sql.NullString
	DeltaDescription *string
	DeltaEnabled     *bool
	ID               idwrap.IDWrap
}

func (q *Queries) UpdateHTTPBodyFormDelta(ctx context.Context, arg UpdateHTTPBodyFormDeltaParams) error {
	_, err := q.exec(ctx, q.updateHTTPBodyFormDeltaStmt, updateHTTPBodyFormDelta,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaDescription,
		arg.DeltaEnabled,
		arg.ID,
	)
	return err
}

const updateHTTPBodyFormOrder = `-- name: UpdateHTTPBodyFormOrder :exec
UPDATE http_body_form
SET "order" = ?
WHERE id = ? AND http_id = ?
`

type UpdateHTTPBodyFormOrderParams struct {
	Order  float64
	ID     idwrap.IDWrap
	HttpID idwrap.IDWrap
}

func (q *Queries) UpdateHTTPBodyFormOrder(ctx context.Context, arg UpdateHTTPBodyFormOrderParams) error {
	_, err := q.exec(ctx, q.updateHTTPBodyFormOrderStmt, updateHTTPBodyFormOrder, arg.Order, arg.ID, arg.HttpID)
	return err
}

const updateHTTPBodyUrlEncoded = `-- name: UpdateHTTPBodyUrlEncoded :exec
UPDATE http_body_urlencoded
SET
  key = ?,
  value = ?,
  enabled = ?,
  description = ?,
  "order" = ?,
  delta_key = ?,
  delta_value = ?,
  delta_enabled = ?,
  delta_description = ?,
  delta_order = ?,
  updated_at = ?
WHERE id = ?
`

type UpdateHTTPBodyUrlEncodedParams struct {
	Key              string
	Value            string
	Enabled          bool
	Description      string
	Order            float64
	DeltaKey         sql.NullString
	DeltaValue       sql.NullString
	DeltaEnabled     *bool
	DeltaDescription *string
	DeltaOrder       sql.NullFloat64
	UpdatedAt        int64
	ID               idwrap.IDWrap
}

func (q *Queries) UpdateHTTPBodyUrlEncoded(ctx context.Context, arg UpdateHTTPBodyUrlEncodedParams) error {
	_, err := q.exec(ctx, q.updateHTTPBodyUrlEncodedStmt, updateHTTPBodyUrlEncoded,
		arg.Key,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.Order,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaEnabled,
		arg.DeltaDescription,
		arg.DeltaOrder,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateHTTPBodyUrlEncodedDelta = `-- name: UpdateHTTPBodyUrlEncodedDelta :exec
UPDATE http_body_urlencoded
SET
  delta_key = ?,
  delta_value = ?,
  delta_enabled = ?,
  delta_description = ?,
  delta_order = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPBodyUrlEncodedDeltaParams struct {
	DeltaKey         sql.NullString
	DeltaValue       sql.NullString
	DeltaEnabled     *bool
	DeltaDescription *string
	DeltaOrder       sql.NullFloat64
	ID               idwrap.IDWrap
}

func (q *Queries) UpdateHTTPBodyUrlEncodedDelta(ctx context.Context, arg UpdateHTTPBodyUrlEncodedDeltaParams) error {
	_, err := q.exec(ctx, q.updateHTTPBodyUrlEncodedDeltaStmt, updateHTTPBodyUrlEncodedDelta,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaEnabled,
		arg.DeltaDescription,
		arg.DeltaOrder,
		arg.ID,
	)
	return err
}

const updateHTTPDelta = `-- name: UpdateHTTPDelta :exec
UPDATE http
SET
  delta_name = ?,
  delta_url = ?,
  delta_method = ?,
  delta_description = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPDeltaParams struct {
	DeltaName        *string
	DeltaUrl         *string
	DeltaMethod      *string
	DeltaDescription *string
	ID               idwrap.IDWrap
}

func (q *Queries) UpdateHTTPDelta(ctx context.Context, arg UpdateHTTPDeltaParams) error {
	_, err := q.exec(ctx, q.updateHTTPDeltaStmt, updateHTTPDelta,
		arg.DeltaName,
		arg.DeltaUrl,
		arg.DeltaMethod,
		arg.DeltaDescription,
		arg.ID,
	)
	return err
}

const updateHTTPHeader = `-- name: UpdateHTTPHeader :exec
UPDATE http_header
SET
  header_key = ?,
  header_value = ?,
  description = ?,
  enabled = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPHeaderParams struct {
	HeaderKey   string
	HeaderValue string
	Description string
	Enabled     bool
	ID          idwrap.IDWrap
}

func (q *Queries) UpdateHTTPHeader(ctx context.Context, arg UpdateHTTPHeaderParams) error {
	_, err := q.exec(ctx, q.updateHTTPHeaderStmt, updateHTTPHeader,
		arg.HeaderKey,
		arg.HeaderValue,
		arg.Description,
		arg.Enabled,
		arg.ID,
	)
	return err
}

const updateHTTPHeaderDelta = `-- name: UpdateHTTPHeaderDelta :exec
UPDATE http_header
SET
  delta_header_key = ?,
  delta_header_value = ?,
  delta_description = ?,
  delta_enabled = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPHeaderDeltaParams struct {
	DeltaHeaderKey   *string
	DeltaHeaderValue *string
	DeltaDescription *string
	DeltaEnabled     *bool
	ID               idwrap.IDWrap
}

func (q *Queries) UpdateHTTPHeaderDelta(ctx context.Context, arg UpdateHTTPHeaderDeltaParams) error {
	_, err := q.exec(ctx, q.updateHTTPHeaderDeltaStmt, updateHTTPHeaderDelta,
		arg.DeltaHeaderKey,
		arg.DeltaHeaderValue,
		arg.DeltaDescription,
		arg.DeltaEnabled,
		arg.ID,
	)
	return err
}

const updateHTTPHeaderOrder = `-- name: UpdateHTTPHeaderOrder :exec
UPDATE http_header
SET prev = ?, next = ?
WHERE id = ? AND http_id = ?
`

type UpdateHTTPHeaderOrderParams struct {
	Prev   *idwrap.IDWrap
	Next   *idwrap.IDWrap
	ID     idwrap.IDWrap
	HttpID idwrap.IDWrap
}

func (q *Queries) UpdateHTTPHeaderOrder(ctx context.Context, arg UpdateHTTPHeaderOrderParams) error {
	_, err := q.exec(ctx, q.updateHTTPHeaderOrderStmt, updateHTTPHeaderOrder,
		arg.Prev,
		arg.Next,
		arg.ID,
		arg.HttpID,
	)
	return err
}

const updateHTTPResponse = `-- name: UpdateHTTPResponse :exec
UPDATE http_response
SET
  status = ?,
  body = ?,
  time = ?,
  duration = ?,
  size = ?
WHERE id = ?
`

type UpdateHTTPResponseParams struct {
	Status   interface{}
	Body     []byte
	Time     time.Time
	Duration interface{}
	Size     interface{}
	ID       idwrap.IDWrap
}

func (q *Queries) UpdateHTTPResponse(ctx context.Context, arg UpdateHTTPResponseParams) error {
	_, err := q.exec(ctx, q.updateHTTPResponseStmt, updateHTTPResponse,
		arg.Status,
		arg.Body,
		arg.Time,
		arg.Duration,
		arg.Size,
		arg.ID,
	)
	return err
}

const updateHTTPResponseAssert = `-- name: UpdateHTTPResponseAssert :exec
UPDATE http_response_assert
SET
  value = ?,
  success = ?
WHERE id = ?
`

type UpdateHTTPResponseAssertParams struct {
	Value   string
	Success bool
	ID      []byte
}

func (q *Queries) UpdateHTTPResponseAssert(ctx context.Context, arg UpdateHTTPResponseAssertParams) error {
	_, err := q.exec(ctx, q.updateHTTPResponseAssertStmt, updateHTTPResponseAssert, arg.Value, arg.Success, arg.ID)
	return err
}

const updateHTTPResponseHeader = `-- name: UpdateHTTPResponseHeader :exec
UPDATE http_response_header
SET
  key = ?,
  value = ?
WHERE id = ?
`

type UpdateHTTPResponseHeaderParams struct {
	Key   string
	Value string
	ID    idwrap.IDWrap
}

func (q *Queries) UpdateHTTPResponseHeader(ctx context.Context, arg UpdateHTTPResponseHeaderParams) error {
	_, err := q.exec(ctx, q.updateHTTPResponseHeaderStmt, updateHTTPResponseHeader, arg.Key, arg.Value, arg.ID)
	return err
}

const updateHTTPSearchParam = `-- name: UpdateHTTPSearchParam :exec
UPDATE http_search_param
SET
  key = ?,
  value = ?,
  description = ?,
  enabled = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPSearchParamParams struct {
	Key         string
	Value       string
	Description string
	Enabled     bool
	ID          idwrap.IDWrap
}

func (q *Queries) UpdateHTTPSearchParam(ctx context.Context, arg UpdateHTTPSearchParamParams) error {
	_, err := q.exec(ctx, q.updateHTTPSearchParamStmt, updateHTTPSearchParam,
		arg.Key,
		arg.Value,
		arg.Description,
		arg.Enabled,
		arg.ID,
	)
	return err
}

const updateHTTPSearchParamDelta = `-- name: UpdateHTTPSearchParamDelta :exec
UPDATE http_search_param
SET
  delta_key = ?,
  delta_value = ?,
  delta_description = ?,
  delta_enabled = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPSearchParamDeltaParams struct {
	DeltaKey         sql.NullString
	DeltaValue       sql.NullString
	DeltaDescription *string
	DeltaEnabled     *bool
	ID               idwrap.IDWrap
}

func (q *Queries) UpdateHTTPSearchParamDelta(ctx context.Context, arg UpdateHTTPSearchParamDeltaParams) error {
	_, err := q.exec(ctx, q.updateHTTPSearchParamDeltaStmt, updateHTTPSearchParamDelta,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaDescription,
		arg.DeltaEnabled,
		arg.ID,
	)
	return err
}

const updateHTTPSearchParamOrder = `-- name: UpdateHTTPSearchParamOrder :exec
UPDATE http_search_param
SET "order" = ?
WHERE id = ? AND http_id = ?
`

type UpdateHTTPSearchParamOrderParams struct {
	Order  float64
	ID     idwrap.IDWrap
	HttpID idwrap.IDWrap
}

func (q *Queries) UpdateHTTPSearchParamOrder(ctx context.Context, arg UpdateHTTPSearchParamOrderParams) error {
	_, err := q.exec(ctx, q.updateHTTPSearchParamOrderStmt, updateHTTPSearchParamOrder, arg.Order, arg.ID, arg.HttpID)
	return err
}

const updateHeader = `-- name: UpdateHeader :exec
UPDATE example_header
SET
  header_key = ?,
  enable = ?,
  description = ?,
  value = ?
WHERE
  id = ?
`

type UpdateHeaderParams struct {
	HeaderKey   string
	Enable      bool
	Description string
	Value       string
	ID          idwrap.IDWrap
}

func (q *Queries) UpdateHeader(ctx context.Context, arg UpdateHeaderParams) error {
	_, err := q.exec(ctx, q.updateHeaderStmt, updateHeader,
		arg.HeaderKey,
		arg.Enable,
		arg.Description,
		arg.Value,
		arg.ID,
	)
	return err
}

const updateHeaderNext = `-- name: UpdateHeaderNext :exec
UPDATE example_header
SET
  next = ?
WHERE
  id = ? AND
  example_id = ?
`

type UpdateHeaderNextParams struct {
	Next      *idwrap.IDWrap
	ID        idwrap.IDWrap
	ExampleID idwrap.IDWrap
}

// Update only the next pointer for a header with example validation (used in deletion)
func (q *Queries) UpdateHeaderNext(ctx context.Context, arg UpdateHeaderNextParams) error {
	_, err := q.exec(ctx, q.updateHeaderNextStmt, updateHeaderNext, arg.Next, arg.ID, arg.ExampleID)
	return err
}

const updateHeaderOrder = `-- name: UpdateHeaderOrder :exec
UPDATE example_header
SET
  prev = ?,
  next = ?
WHERE
  id = ? AND
  example_id = ?
`

type UpdateHeaderOrderParams struct {
	Prev      *idwrap.IDWrap
	Next      *idwrap.IDWrap
	ID        idwrap.IDWrap
	ExampleID idwrap.IDWrap
}

// Update the prev/next pointers for a single header with example validation
// Used for moving headers within the example's linked list
func (q *Queries) UpdateHeaderOrder(ctx context.Context, arg UpdateHeaderOrderParams) error {
	_, err := q.exec(ctx, q.updateHeaderOrderStmt, updateHeaderOrder,
		arg.Prev,
		arg.Next,
		arg.ID,
		arg.ExampleID,
	)
	return err
}

const updateHeaderPrev = `-- name: UpdateHeaderPrev :exec
UPDATE example_header
SET
  prev = ?
WHERE
  id = ? AND
  example_id = ?
`

type UpdateHeaderPrevParams struct {
	Prev      *idwrap.IDWrap
	ID        idwrap.IDWrap
	ExampleID idwrap.IDWrap
}

// Update only the prev pointer for a header with example validation (used in deletion)
func (q *Queries) UpdateHeaderPrev(ctx context.Context, arg UpdateHeaderPrevParams) error {
	_, err := q.exec(ctx, q.updateHeaderPrevStmt, updateHeaderPrev, arg.Prev, arg.ID, arg.ExampleID)
	return err
}

const updateItemApi = `-- name: UpdateItemApi :exec
UPDATE item_api
SET
  folder_id = ?,
  name = ?,
  url = ?,
  method = ?,
  hidden = ?
WHERE
  id = ?
`

type UpdateItemApiParams struct {
	FolderID *idwrap.IDWrap
	Name     string
	Url      string
	Method   string
	Hidden   bool
	ID       idwrap.IDWrap
}

func (q *Queries) UpdateItemApi(ctx context.Context, arg UpdateItemApiParams) error {
	_, err := q.exec(ctx, q.updateItemApiStmt, updateItemApi,
		arg.FolderID,
		arg.Name,
		arg.Url,
		arg.Method,
		arg.Hidden,
		arg.ID,
	)
	return err
}

const updateItemApiExample = `-- name: UpdateItemApiExample :exec
UPDATE item_api_example
SET
  name = ?,
  body_type = ?
WHERE
  id = ?
`

type UpdateItemApiExampleParams struct {
	Name     string
	BodyType int8
	ID       idwrap.IDWrap
}

func (q *Queries) UpdateItemApiExample(ctx context.Context, arg UpdateItemApiExampleParams) error {
	_, err := q.exec(ctx, q.updateItemApiExampleStmt, updateItemApiExample, arg.Name, arg.BodyType, arg.ID)
	return err
}

const updateItemApiExampleOrder = `-- name: UpdateItemApiExampleOrder :exec
UPDATE item_api_example
SET
  prev = ?,
  next = ?
WHERE
  id = ?
`

type UpdateItemApiExampleOrderParams struct {
	Prev *idwrap.IDWrap
	Next *idwrap.IDWrap
	ID   idwrap.IDWrap
}

func (q *Queries) UpdateItemApiExampleOrder(ctx context.Context, arg UpdateItemApiExampleOrderParams) error {
	_, err := q.exec(ctx, q.updateItemApiExampleOrderStmt, updateItemApiExampleOrder, arg.Prev, arg.Next, arg.ID)
	return err
}

const updateItemApiOrder = `-- name: UpdateItemApiOrder :exec
UPDATE item_api
SET
  next = ?,
  prev = ?
WHERE
  id = ?
`

type UpdateItemApiOrderParams struct {
	Next *idwrap.IDWrap
	Prev *idwrap.IDWrap
	ID   idwrap.IDWrap
}

func (q *Queries) UpdateItemApiOrder(ctx context.Context, arg UpdateItemApiOrderParams) error {
	_, err := q.exec(ctx, q.updateItemApiOrderStmt, updateItemApiOrder, arg.Next, arg.Prev, arg.ID)
	return err
}

const updateItemFolder = `-- name: UpdateItemFolder :exec
UPDATE item_folder
SET
  name = ?,
  parent_id = ?
WHERE
  id = ?
`

type UpdateItemFolderParams struct {
	Name     string
	ParentID *idwrap.IDWrap
	ID       idwrap.IDWrap
}

func (q *Queries) UpdateItemFolder(ctx context.Context, arg UpdateItemFolderParams) error {
	_, err := q.exec(ctx, q.updateItemFolderStmt, updateItemFolder, arg.Name, arg.ParentID, arg.ID)
	return err
}

const updateItemFolderOrder = `-- name: UpdateItemFolderOrder :exec
UPDATE item_folder
SET
  prev = ?,
  next = ?
WHERE
  id = ?
`

type UpdateItemFolderOrderParams struct {
	Prev *idwrap.IDWrap
	Next *idwrap.IDWrap
	ID   idwrap.IDWrap
}

func (q *Queries) UpdateItemFolderOrder(ctx context.Context, arg UpdateItemFolderOrderParams) error {
	_, err := q.exec(ctx, q.updateItemFolderOrderStmt, updateItemFolderOrder, arg.Prev, arg.Next, arg.ID)
	return err
}

const updateNodeExecution = `-- name: UpdateNodeExecution :one
UPDATE node_execution
SET state = ?, error = ?, output_data = ?, 
    output_data_compress_type = ?, response_id = ?, completed_at = ?
WHERE id = ?
RETURNING id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, response_id, completed_at
`

type UpdateNodeExecutionParams struct {
	State                  int8
	Error                  sql.NullString
	OutputData             []byte
	OutputDataCompressType int8
	ResponseID             []byte
	CompletedAt            sql.NullInt64
	ID                     idwrap.IDWrap
}

func (q *Queries) UpdateNodeExecution(ctx context.Context, arg UpdateNodeExecutionParams) (NodeExecution, error) {
	row := q.queryRow(ctx, q.updateNodeExecutionStmt, updateNodeExecution,
		arg.State,
		arg.Error,
		arg.OutputData,
		arg.OutputDataCompressType,
		arg.ResponseID,
		arg.CompletedAt,
		arg.ID,
	)
	var i NodeExecution
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Name,
		&i.State,
		&i.Error,
		&i.InputData,
		&i.InputDataCompressType,
		&i.OutputData,
		&i.OutputDataCompressType,
		&i.ResponseID,
		&i.CompletedAt,
	)
	return i, err
}

const updateQuery = `-- name: UpdateQuery :exec
UPDATE example_query
SET
  query_key = ?,
  enable = ?,
  description = ?,
  value = ?
WHERE
  id = ?
`

type UpdateQueryParams struct {
	QueryKey    string
	Enable      bool
	Description string
	Value       string
	ID          idwrap.IDWrap
}

func (q *Queries) UpdateQuery(ctx context.Context, arg UpdateQueryParams) error {
	_, err := q.exec(ctx, q.updateQueryStmt, updateQuery,
		arg.QueryKey,
		arg.Enable,
		arg.Description,
		arg.Value,
		arg.ID,
	)
	return err
}

const updateTag = `-- name: UpdateTag :exec
UPDATE tag
SET
  name = ?,
  color = ?
WHERE
  id = ?
`

type UpdateTagParams struct {
	Name  string
	Color int8
	ID    idwrap.IDWrap
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) error {
	_, err := q.exec(ctx, q.updateTagStmt, updateTag, arg.Name, arg.Color, arg.ID)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET
  email = ?,
  password_hash = ?
WHERE
  id = ?
`

type UpdateUserParams struct {
	Email        string
	PasswordHash []byte
	ID           idwrap.IDWrap
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.exec(ctx, q.updateUserStmt, updateUser, arg.Email, arg.PasswordHash, arg.ID)
	return err
}

const updateVariable = `-- name: UpdateVariable :exec
UPDATE variable
SET
  var_key = ?,
  value = ?,
  enabled = ?,
  description = ?,
  display_order = ?
WHERE
  id = ?
`

type UpdateVariableParams struct {
	VarKey       string
	Value        string
	Enabled      bool
	Description  string
	DisplayOrder float64
	ID           idwrap.IDWrap
}

func (q *Queries) UpdateVariable(ctx context.Context, arg UpdateVariableParams) error {
	_, err := q.exec(ctx, q.updateVariableStmt, updateVariable,
		arg.VarKey,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.DisplayOrder,
		arg.ID,
	)
	return err
}

const updateVisualizeMode = `-- name: UpdateVisualizeMode :exec
UPDATE example_body_raw
SET visualize_mode = ?
WHERE
  id = ?
`

type UpdateVisualizeModeParams struct {
	VisualizeMode int8
	ID            idwrap.IDWrap
}

func (q *Queries) UpdateVisualizeMode(ctx context.Context, arg UpdateVisualizeModeParams) error {
	_, err := q.exec(ctx, q.updateVisualizeModeStmt, updateVisualizeMode, arg.VisualizeMode, arg.ID)
	return err
}

const updateWorkspace = `-- name: UpdateWorkspace :exec
UPDATE workspaces
SET
  name = ?,
  collection_count = ?,
  flow_count = ?,
  updated = ?,
  active_env = ?
WHERE
  id = ?
`

type UpdateWorkspaceParams struct {
	Name            string
	CollectionCount int32
	FlowCount       int32
	Updated         int64
	ActiveEnv       idwrap.IDWrap
	ID              idwrap.IDWrap
}

func (q *Queries) UpdateWorkspace(ctx context.Context, arg UpdateWorkspaceParams) error {
	_, err := q.exec(ctx, q.updateWorkspaceStmt, updateWorkspace,
		arg.Name,
		arg.CollectionCount,
		arg.FlowCount,
		arg.Updated,
		arg.ActiveEnv,
		arg.ID,
	)
	return err
}

const updateWorkspaceNext = `-- name: UpdateWorkspaceNext :exec
UPDATE workspaces
SET
  next = ?
WHERE
  workspaces.id = ? AND
  workspaces.id IN (
    SELECT wu.workspace_id 
    FROM workspaces_users wu
    WHERE wu.user_id = ?
  )
`

type UpdateWorkspaceNextParams struct {
	Next   *idwrap.IDWrap
	ID     idwrap.IDWrap
	UserID idwrap.IDWrap
}

// Update only the next pointer for a workspace with user validation (used in deletion)
func (q *Queries) UpdateWorkspaceNext(ctx context.Context, arg UpdateWorkspaceNextParams) error {
	_, err := q.exec(ctx, q.updateWorkspaceNextStmt, updateWorkspaceNext, arg.Next, arg.ID, arg.UserID)
	return err
}

const updateWorkspaceOrder = `-- name: UpdateWorkspaceOrder :exec
UPDATE workspaces
SET
  prev = ?,
  next = ?
WHERE
  workspaces.id = ? AND
  workspaces.id IN (
    SELECT wu.workspace_id 
    FROM workspaces_users wu
    WHERE wu.user_id = ?
  )
`

type UpdateWorkspaceOrderParams struct {
	Prev   *idwrap.IDWrap
	Next   *idwrap.IDWrap
	ID     idwrap.IDWrap
	UserID idwrap.IDWrap
}

// Update the prev/next pointers for a single workspace with user validation
// Used for moving workspaces within the user's linked list
func (q *Queries) UpdateWorkspaceOrder(ctx context.Context, arg UpdateWorkspaceOrderParams) error {
	_, err := q.exec(ctx, q.updateWorkspaceOrderStmt, updateWorkspaceOrder,
		arg.Prev,
		arg.Next,
		arg.ID,
		arg.UserID,
	)
	return err
}

const updateWorkspacePrev = `-- name: UpdateWorkspacePrev :exec
UPDATE workspaces
SET
  prev = ?
WHERE
  workspaces.id = ? AND
  workspaces.id IN (
    SELECT wu.workspace_id 
    FROM workspaces_users wu
    WHERE wu.user_id = ?
  )
`

type UpdateWorkspacePrevParams struct {
	Prev   *idwrap.IDWrap
	ID     idwrap.IDWrap
	UserID idwrap.IDWrap
}

// Update only the prev pointer for a workspace with user validation (used in deletion)
func (q *Queries) UpdateWorkspacePrev(ctx context.Context, arg UpdateWorkspacePrevParams) error {
	_, err := q.exec(ctx, q.updateWorkspacePrevStmt, updateWorkspacePrev, arg.Prev, arg.ID, arg.UserID)
	return err
}

const updateWorkspaceUpdatedTime = `-- name: UpdateWorkspaceUpdatedTime :exec
UPDATE workspaces
SET
  updated = ?
WHERE
  id = ?
`

type UpdateWorkspaceUpdatedTimeParams struct {
	Updated int64
	ID      idwrap.IDWrap
}

func (q *Queries) UpdateWorkspaceUpdatedTime(ctx context.Context, arg UpdateWorkspaceUpdatedTimeParams) error {
	_, err := q.exec(ctx, q.updateWorkspaceUpdatedTimeStmt, updateWorkspaceUpdatedTime, arg.Updated, arg.ID)
	return err
}

const updateWorkspaceUser = `-- name: UpdateWorkspaceUser :exec
UPDATE workspaces_users
SET
  workspace_id = ?,
  user_id = ?,
  role = ?
WHERE
  id = ?
`

type UpdateWorkspaceUserParams struct {
	WorkspaceID idwrap.IDWrap
	UserID      idwrap.IDWrap
	Role        int8
	ID          idwrap.IDWrap
}

func (q *Queries) UpdateWorkspaceUser(ctx context.Context, arg UpdateWorkspaceUserParams) error {
	_, err := q.exec(ctx, q.updateWorkspaceUserStmt, updateWorkspaceUser,
		arg.WorkspaceID,
		arg.UserID,
		arg.Role,
		arg.ID,
	)
	return err
}

const upsertNodeExecution = `-- name: UpsertNodeExecution :one
INSERT INTO node_execution (
  id, node_id, name, state, error, input_data, input_data_compress_type,
  output_data, output_data_compress_type, response_id, completed_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
  state = excluded.state,
  error = excluded.error, 
  input_data = excluded.input_data,
  input_data_compress_type = excluded.input_data_compress_type,
  output_data = excluded.output_data,
  output_data_compress_type = excluded.output_data_compress_type,
  response_id = excluded.response_id,
  completed_at = excluded.completed_at
RETURNING id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, response_id, completed_at
`

type UpsertNodeExecutionParams struct {
	ID                     idwrap.IDWrap
	NodeID                 idwrap.IDWrap
	Name                   string
	State                  int8
	Error                  sql.NullString
	InputData              []byte
	InputDataCompressType  int8
	OutputData             []byte
	OutputDataCompressType int8
	ResponseID             []byte
	CompletedAt            sql.NullInt64
}

func (q *Queries) UpsertNodeExecution(ctx context.Context, arg UpsertNodeExecutionParams) (NodeExecution, error) {
	row := q.queryRow(ctx, q.upsertNodeExecutionStmt, upsertNodeExecution,
		arg.ID,
		arg.NodeID,
		arg.Name,
		arg.State,
		arg.Error,
		arg.InputData,
		arg.InputDataCompressType,
		arg.OutputData,
		arg.OutputDataCompressType,
		arg.ResponseID,
		arg.CompletedAt,
	)
	var i NodeExecution
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Name,
		&i.State,
		&i.Error,
		&i.InputData,
		&i.InputDataCompressType,
		&i.OutputData,
		&i.OutputDataCompressType,
		&i.ResponseID,
		&i.CompletedAt,
	)
	return i, err
}
