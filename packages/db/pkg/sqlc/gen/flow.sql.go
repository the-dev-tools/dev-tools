// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: flow.sql

package gen

import (
	"context"
	"database/sql"
	"strings"

	idwrap "the-dev-tools/server/pkg/idwrap"
)

const cleanupOrphanedFlowEdges = `-- name: CleanupOrphanedFlowEdges :exec
DELETE FROM flow_edge WHERE source_id NOT IN (SELECT id FROM flow_node) OR target_id NOT IN (SELECT id FROM flow_node)
`

func (q *Queries) CleanupOrphanedFlowEdges(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanupOrphanedFlowEdgesStmt, cleanupOrphanedFlowEdges)
	return err
}

const cleanupOrphanedFlowNodeCondition = `-- name: CleanupOrphanedFlowNodeCondition :exec
DELETE FROM flow_node_condition WHERE flow_node_id NOT IN (SELECT id FROM flow_node)
`

func (q *Queries) CleanupOrphanedFlowNodeCondition(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanupOrphanedFlowNodeConditionStmt, cleanupOrphanedFlowNodeCondition)
	return err
}

const cleanupOrphanedFlowNodeFor = `-- name: CleanupOrphanedFlowNodeFor :exec

DELETE FROM flow_node_for WHERE flow_node_id NOT IN (SELECT id FROM flow_node)
`

// Cleanup queries for orphaned flow_node sub-table records
// (used when FK constraints are removed for flexible insert ordering)
func (q *Queries) CleanupOrphanedFlowNodeFor(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanupOrphanedFlowNodeForStmt, cleanupOrphanedFlowNodeFor)
	return err
}

const cleanupOrphanedFlowNodeForEach = `-- name: CleanupOrphanedFlowNodeForEach :exec
DELETE FROM flow_node_for_each WHERE flow_node_id NOT IN (SELECT id FROM flow_node)
`

func (q *Queries) CleanupOrphanedFlowNodeForEach(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanupOrphanedFlowNodeForEachStmt, cleanupOrphanedFlowNodeForEach)
	return err
}

const cleanupOrphanedFlowNodeHttp = `-- name: CleanupOrphanedFlowNodeHttp :exec
DELETE FROM flow_node_http WHERE flow_node_id NOT IN (SELECT id FROM flow_node)
`

func (q *Queries) CleanupOrphanedFlowNodeHttp(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanupOrphanedFlowNodeHttpStmt, cleanupOrphanedFlowNodeHttp)
	return err
}

const cleanupOrphanedFlowNodeJs = `-- name: CleanupOrphanedFlowNodeJs :exec
DELETE FROM flow_node_js WHERE flow_node_id NOT IN (SELECT id FROM flow_node)
`

func (q *Queries) CleanupOrphanedFlowNodeJs(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanupOrphanedFlowNodeJsStmt, cleanupOrphanedFlowNodeJs)
	return err
}

const cleanupOrphanedFlowNodeNoop = `-- name: CleanupOrphanedFlowNodeNoop :exec
DELETE FROM flow_node_noop WHERE flow_node_id NOT IN (SELECT id FROM flow_node)
`

func (q *Queries) CleanupOrphanedFlowNodeNoop(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanupOrphanedFlowNodeNoopStmt, cleanupOrphanedFlowNodeNoop)
	return err
}

const cleanupOrphanedNodeExecutions = `-- name: CleanupOrphanedNodeExecutions :exec
DELETE FROM node_execution WHERE node_id NOT IN (SELECT id FROM flow_node)
`

func (q *Queries) CleanupOrphanedNodeExecutions(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanupOrphanedNodeExecutionsStmt, cleanupOrphanedNodeExecutions)
	return err
}

const createFlow = `-- name: CreateFlow :exec
INSERT INTO
  flow (id, workspace_id, version_parent_id, name, duration, running)
VALUES
  (?, ?, ?, ?, ?, ?)
`

type CreateFlowParams struct {
	ID              idwrap.IDWrap
	WorkspaceID     idwrap.IDWrap
	VersionParentID *idwrap.IDWrap
	Name            string
	Duration        int32
	Running         bool
}

func (q *Queries) CreateFlow(ctx context.Context, arg CreateFlowParams) error {
	_, err := q.exec(ctx, q.createFlowStmt, createFlow,
		arg.ID,
		arg.WorkspaceID,
		arg.VersionParentID,
		arg.Name,
		arg.Duration,
		arg.Running,
	)
	return err
}

const createFlowEdge = `-- name: CreateFlowEdge :exec
INSERT INTO
  flow_edge (id, flow_id, source_id, target_id, source_handle, edge_kind)
VALUES
  (?, ?, ?, ?, ?, ?)
`

type CreateFlowEdgeParams struct {
	ID           idwrap.IDWrap
	FlowID       idwrap.IDWrap
	SourceID     idwrap.IDWrap
	TargetID     idwrap.IDWrap
	SourceHandle int32
	EdgeKind     int32
}

func (q *Queries) CreateFlowEdge(ctx context.Context, arg CreateFlowEdgeParams) error {
	_, err := q.exec(ctx, q.createFlowEdgeStmt, createFlowEdge,
		arg.ID,
		arg.FlowID,
		arg.SourceID,
		arg.TargetID,
		arg.SourceHandle,
		arg.EdgeKind,
	)
	return err
}

const createFlowNode = `-- name: CreateFlowNode :exec
INSERT INTO
  flow_node (id, flow_id, name, node_kind, position_x, position_y)
VALUES
  (?, ?, ?, ?, ?, ?)
`

type CreateFlowNodeParams struct {
	ID        idwrap.IDWrap
	FlowID    idwrap.IDWrap
	Name      string
	NodeKind  int32
	PositionX float64
	PositionY float64
}

func (q *Queries) CreateFlowNode(ctx context.Context, arg CreateFlowNodeParams) error {
	_, err := q.exec(ctx, q.createFlowNodeStmt, createFlowNode,
		arg.ID,
		arg.FlowID,
		arg.Name,
		arg.NodeKind,
		arg.PositionX,
		arg.PositionY,
	)
	return err
}

const createFlowNodeCondition = `-- name: CreateFlowNodeCondition :exec
INSERT INTO
  flow_node_condition (flow_node_id, expression)
VALUES
  (?, ?)
`

type CreateFlowNodeConditionParams struct {
	FlowNodeID idwrap.IDWrap
	Expression string
}

func (q *Queries) CreateFlowNodeCondition(ctx context.Context, arg CreateFlowNodeConditionParams) error {
	_, err := q.exec(ctx, q.createFlowNodeConditionStmt, createFlowNodeCondition, arg.FlowNodeID, arg.Expression)
	return err
}

const createFlowNodeFor = `-- name: CreateFlowNodeFor :exec
INSERT INTO
  flow_node_for (flow_node_id, iter_count, error_handling, expression)
VALUES
  (?, ?, ?, ?)
`

type CreateFlowNodeForParams struct {
	FlowNodeID    idwrap.IDWrap
	IterCount     int64
	ErrorHandling int8
	Expression    string
}

func (q *Queries) CreateFlowNodeFor(ctx context.Context, arg CreateFlowNodeForParams) error {
	_, err := q.exec(ctx, q.createFlowNodeForStmt, createFlowNodeFor,
		arg.FlowNodeID,
		arg.IterCount,
		arg.ErrorHandling,
		arg.Expression,
	)
	return err
}

const createFlowNodeForEach = `-- name: CreateFlowNodeForEach :exec
INSERT INTO
  flow_node_for_each (flow_node_id, iter_expression, error_handling, expression)
VALUES
  (?, ?, ?, ?)
`

type CreateFlowNodeForEachParams struct {
	FlowNodeID     idwrap.IDWrap
	IterExpression string
	ErrorHandling  int8
	Expression     string
}

func (q *Queries) CreateFlowNodeForEach(ctx context.Context, arg CreateFlowNodeForEachParams) error {
	_, err := q.exec(ctx, q.createFlowNodeForEachStmt, createFlowNodeForEach,
		arg.FlowNodeID,
		arg.IterExpression,
		arg.ErrorHandling,
		arg.Expression,
	)
	return err
}

const createFlowNodeHTTP = `-- name: CreateFlowNodeHTTP :exec
INSERT INTO
  flow_node_http (
    flow_node_id,
    http_id,
    delta_http_id
  )
VALUES
  (?, ?, ?)
`

type CreateFlowNodeHTTPParams struct {
	FlowNodeID  idwrap.IDWrap
	HttpID      idwrap.IDWrap
	DeltaHttpID []byte
}

func (q *Queries) CreateFlowNodeHTTP(ctx context.Context, arg CreateFlowNodeHTTPParams) error {
	_, err := q.exec(ctx, q.createFlowNodeHTTPStmt, createFlowNodeHTTP, arg.FlowNodeID, arg.HttpID, arg.DeltaHttpID)
	return err
}

const createFlowNodeJs = `-- name: CreateFlowNodeJs :exec
INSERT INTO
  flow_node_js (flow_node_id, code, code_compress_type)
VALUES
  (?, ?, ?)
`

type CreateFlowNodeJsParams struct {
	FlowNodeID       idwrap.IDWrap
	Code             []byte
	CodeCompressType int8
}

func (q *Queries) CreateFlowNodeJs(ctx context.Context, arg CreateFlowNodeJsParams) error {
	_, err := q.exec(ctx, q.createFlowNodeJsStmt, createFlowNodeJs, arg.FlowNodeID, arg.Code, arg.CodeCompressType)
	return err
}

const createFlowNodeNoop = `-- name: CreateFlowNodeNoop :exec
INSERT INTO
  flow_node_noop (flow_node_id, node_type)
VALUES
  (?, ?)
`

type CreateFlowNodeNoopParams struct {
	FlowNodeID idwrap.IDWrap
	NodeType   int16
}

func (q *Queries) CreateFlowNodeNoop(ctx context.Context, arg CreateFlowNodeNoopParams) error {
	_, err := q.exec(ctx, q.createFlowNodeNoopStmt, createFlowNodeNoop, arg.FlowNodeID, arg.NodeType)
	return err
}

const createFlowTag = `-- name: CreateFlowTag :exec
INSERT INTO
  flow_tag (id, flow_id, tag_id)
VALUES
  (?, ?, ?)
`

type CreateFlowTagParams struct {
	ID     idwrap.IDWrap
	FlowID idwrap.IDWrap
	TagID  idwrap.IDWrap
}

func (q *Queries) CreateFlowTag(ctx context.Context, arg CreateFlowTagParams) error {
	_, err := q.exec(ctx, q.createFlowTagStmt, createFlowTag, arg.ID, arg.FlowID, arg.TagID)
	return err
}

const createFlowVariable = `-- name: CreateFlowVariable :exec
INSERT INTO
  flow_variable (id, flow_id, key, value, enabled, description, prev, next)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateFlowVariableParams struct {
	ID          idwrap.IDWrap
	FlowID      idwrap.IDWrap
	Key         string
	Value       string
	Enabled     bool
	Description string
	Prev        *idwrap.IDWrap
	Next        *idwrap.IDWrap
}

func (q *Queries) CreateFlowVariable(ctx context.Context, arg CreateFlowVariableParams) error {
	_, err := q.exec(ctx, q.createFlowVariableStmt, createFlowVariable,
		arg.ID,
		arg.FlowID,
		arg.Key,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.Prev,
		arg.Next,
	)
	return err
}

const createFlowVariableBulk = `-- name: CreateFlowVariableBulk :exec
INSERT INTO
  flow_variable (id, flow_id, key, value, enabled, description, prev, next)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateFlowVariableBulkParams struct {
	ID             idwrap.IDWrap
	FlowID         idwrap.IDWrap
	Key            string
	Value          string
	Enabled        bool
	Description    string
	Prev           *idwrap.IDWrap
	Next           *idwrap.IDWrap
	ID_2           idwrap.IDWrap
	FlowID_2       idwrap.IDWrap
	Key_2          string
	Value_2        string
	Enabled_2      bool
	Description_2  string
	Prev_2         *idwrap.IDWrap
	Next_2         *idwrap.IDWrap
	ID_3           idwrap.IDWrap
	FlowID_3       idwrap.IDWrap
	Key_3          string
	Value_3        string
	Enabled_3      bool
	Description_3  string
	Prev_3         *idwrap.IDWrap
	Next_3         *idwrap.IDWrap
	ID_4           idwrap.IDWrap
	FlowID_4       idwrap.IDWrap
	Key_4          string
	Value_4        string
	Enabled_4      bool
	Description_4  string
	Prev_4         *idwrap.IDWrap
	Next_4         *idwrap.IDWrap
	ID_5           idwrap.IDWrap
	FlowID_5       idwrap.IDWrap
	Key_5          string
	Value_5        string
	Enabled_5      bool
	Description_5  string
	Prev_5         *idwrap.IDWrap
	Next_5         *idwrap.IDWrap
	ID_6           idwrap.IDWrap
	FlowID_6       idwrap.IDWrap
	Key_6          string
	Value_6        string
	Enabled_6      bool
	Description_6  string
	Prev_6         *idwrap.IDWrap
	Next_6         *idwrap.IDWrap
	ID_7           idwrap.IDWrap
	FlowID_7       idwrap.IDWrap
	Key_7          string
	Value_7        string
	Enabled_7      bool
	Description_7  string
	Prev_7         *idwrap.IDWrap
	Next_7         *idwrap.IDWrap
	ID_8           idwrap.IDWrap
	FlowID_8       idwrap.IDWrap
	Key_8          string
	Value_8        string
	Enabled_8      bool
	Description_8  string
	Prev_8         *idwrap.IDWrap
	Next_8         *idwrap.IDWrap
	ID_9           idwrap.IDWrap
	FlowID_9       idwrap.IDWrap
	Key_9          string
	Value_9        string
	Enabled_9      bool
	Description_9  string
	Prev_9         *idwrap.IDWrap
	Next_9         *idwrap.IDWrap
	ID_10          idwrap.IDWrap
	FlowID_10      idwrap.IDWrap
	Key_10         string
	Value_10       string
	Enabled_10     bool
	Description_10 string
	Prev_10        *idwrap.IDWrap
	Next_10        *idwrap.IDWrap
}

func (q *Queries) CreateFlowVariableBulk(ctx context.Context, arg CreateFlowVariableBulkParams) error {
	_, err := q.exec(ctx, q.createFlowVariableBulkStmt, createFlowVariableBulk,
		arg.ID,
		arg.FlowID,
		arg.Key,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.Prev,
		arg.Next,
		arg.ID_2,
		arg.FlowID_2,
		arg.Key_2,
		arg.Value_2,
		arg.Enabled_2,
		arg.Description_2,
		arg.Prev_2,
		arg.Next_2,
		arg.ID_3,
		arg.FlowID_3,
		arg.Key_3,
		arg.Value_3,
		arg.Enabled_3,
		arg.Description_3,
		arg.Prev_3,
		arg.Next_3,
		arg.ID_4,
		arg.FlowID_4,
		arg.Key_4,
		arg.Value_4,
		arg.Enabled_4,
		arg.Description_4,
		arg.Prev_4,
		arg.Next_4,
		arg.ID_5,
		arg.FlowID_5,
		arg.Key_5,
		arg.Value_5,
		arg.Enabled_5,
		arg.Description_5,
		arg.Prev_5,
		arg.Next_5,
		arg.ID_6,
		arg.FlowID_6,
		arg.Key_6,
		arg.Value_6,
		arg.Enabled_6,
		arg.Description_6,
		arg.Prev_6,
		arg.Next_6,
		arg.ID_7,
		arg.FlowID_7,
		arg.Key_7,
		arg.Value_7,
		arg.Enabled_7,
		arg.Description_7,
		arg.Prev_7,
		arg.Next_7,
		arg.ID_8,
		arg.FlowID_8,
		arg.Key_8,
		arg.Value_8,
		arg.Enabled_8,
		arg.Description_8,
		arg.Prev_8,
		arg.Next_8,
		arg.ID_9,
		arg.FlowID_9,
		arg.Key_9,
		arg.Value_9,
		arg.Enabled_9,
		arg.Description_9,
		arg.Prev_9,
		arg.Next_9,
		arg.ID_10,
		arg.FlowID_10,
		arg.Key_10,
		arg.Value_10,
		arg.Enabled_10,
		arg.Description_10,
		arg.Prev_10,
		arg.Next_10,
	)
	return err
}

const createMigration = `-- name: CreateMigration :exec
INSERT INTO
  migration (id, version, description, apply_at)
VALUES
  (?, ?, ?, ?)
`

type CreateMigrationParams struct {
	ID          []byte
	Version     int32
	Description string
	ApplyAt     int64
}

func (q *Queries) CreateMigration(ctx context.Context, arg CreateMigrationParams) error {
	_, err := q.exec(ctx, q.createMigrationStmt, createMigration,
		arg.ID,
		arg.Version,
		arg.Description,
		arg.ApplyAt,
	)
	return err
}

const createNodeExecution = `-- name: CreateNodeExecution :one
INSERT INTO node_execution (
  id, node_id, name, state, error, input_data, input_data_compress_type,
  output_data, output_data_compress_type, http_response_id, completed_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, http_response_id, completed_at
`

type CreateNodeExecutionParams struct {
	ID                     idwrap.IDWrap
	NodeID                 idwrap.IDWrap
	Name                   string
	State                  int8
	Error                  sql.NullString
	InputData              []byte
	InputDataCompressType  int8
	OutputData             []byte
	OutputDataCompressType int8
	HttpResponseID         *idwrap.IDWrap
	CompletedAt            sql.NullInt64
}

func (q *Queries) CreateNodeExecution(ctx context.Context, arg CreateNodeExecutionParams) (NodeExecution, error) {
	row := q.queryRow(ctx, q.createNodeExecutionStmt, createNodeExecution,
		arg.ID,
		arg.NodeID,
		arg.Name,
		arg.State,
		arg.Error,
		arg.InputData,
		arg.InputDataCompressType,
		arg.OutputData,
		arg.OutputDataCompressType,
		arg.HttpResponseID,
		arg.CompletedAt,
	)
	var i NodeExecution
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Name,
		&i.State,
		&i.Error,
		&i.InputData,
		&i.InputDataCompressType,
		&i.OutputData,
		&i.OutputDataCompressType,
		&i.HttpResponseID,
		&i.CompletedAt,
	)
	return i, err
}

const createTag = `-- name: CreateTag :exec
INSERT INTO
  tag (id, workspace_id, name, color)
VALUES
  (?, ?, ?, ?)
`

type CreateTagParams struct {
	ID          idwrap.IDWrap
	WorkspaceID idwrap.IDWrap
	Name        string
	Color       int8
}

func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) error {
	_, err := q.exec(ctx, q.createTagStmt, createTag,
		arg.ID,
		arg.WorkspaceID,
		arg.Name,
		arg.Color,
	)
	return err
}

const deleteFlow = `-- name: DeleteFlow :exec
DELETE FROM flow
WHERE
  id = ?
`

func (q *Queries) DeleteFlow(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowStmt, deleteFlow, id)
	return err
}

const deleteFlowEdge = `-- name: DeleteFlowEdge :exec
DELETE FROM
  flow_edge
WHERE
  id = ?
`

func (q *Queries) DeleteFlowEdge(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowEdgeStmt, deleteFlowEdge, id)
	return err
}

const deleteFlowNode = `-- name: DeleteFlowNode :exec
DELETE FROM flow_node
WHERE
  id = ?
`

func (q *Queries) DeleteFlowNode(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeStmt, deleteFlowNode, id)
	return err
}

const deleteFlowNodeCondition = `-- name: DeleteFlowNodeCondition :exec
DELETE FROM flow_node_condition
WHERE
  flow_node_id = ?
`

func (q *Queries) DeleteFlowNodeCondition(ctx context.Context, flowNodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeConditionStmt, deleteFlowNodeCondition, flowNodeID)
	return err
}

const deleteFlowNodeFor = `-- name: DeleteFlowNodeFor :exec
DELETE FROM flow_node_for
WHERE
  flow_node_id = ?
`

func (q *Queries) DeleteFlowNodeFor(ctx context.Context, flowNodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeForStmt, deleteFlowNodeFor, flowNodeID)
	return err
}

const deleteFlowNodeForEach = `-- name: DeleteFlowNodeForEach :exec
DELETE FROM flow_node_for_each
WHERE
  flow_node_id = ?
`

func (q *Queries) DeleteFlowNodeForEach(ctx context.Context, flowNodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeForEachStmt, deleteFlowNodeForEach, flowNodeID)
	return err
}

const deleteFlowNodeHTTP = `-- name: DeleteFlowNodeHTTP :exec
DELETE FROM flow_node_http
WHERE
  flow_node_id = ?
`

func (q *Queries) DeleteFlowNodeHTTP(ctx context.Context, flowNodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeHTTPStmt, deleteFlowNodeHTTP, flowNodeID)
	return err
}

const deleteFlowNodeJs = `-- name: DeleteFlowNodeJs :exec
DELETE FROM flow_node_js
WHERE
  flow_node_id = ?
`

func (q *Queries) DeleteFlowNodeJs(ctx context.Context, flowNodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeJsStmt, deleteFlowNodeJs, flowNodeID)
	return err
}

const deleteFlowNodeNoop = `-- name: DeleteFlowNodeNoop :exec
DELETE from flow_node_noop
WHERE
  flow_node_id = ?
`

func (q *Queries) DeleteFlowNodeNoop(ctx context.Context, flowNodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeNoopStmt, deleteFlowNodeNoop, flowNodeID)
	return err
}

const deleteFlowTag = `-- name: DeleteFlowTag :exec
DELETE FROM flow_tag
WHERE
  id = ?
`

func (q *Queries) DeleteFlowTag(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowTagStmt, deleteFlowTag, id)
	return err
}

const deleteFlowVariable = `-- name: DeleteFlowVariable :exec
DELETE FROM flow_variable
WHERE
  id = ?
`

func (q *Queries) DeleteFlowVariable(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowVariableStmt, deleteFlowVariable, id)
	return err
}

const deleteMigration = `-- name: DeleteMigration :exec
DELETE FROM migration
WHERE
  id = ?
`

func (q *Queries) DeleteMigration(ctx context.Context, id []byte) error {
	_, err := q.exec(ctx, q.deleteMigrationStmt, deleteMigration, id)
	return err
}

const deleteNodeExecutionsByNodeID = `-- name: DeleteNodeExecutionsByNodeID :exec
DELETE FROM node_execution WHERE node_id = ?
`

func (q *Queries) DeleteNodeExecutionsByNodeID(ctx context.Context, nodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteNodeExecutionsByNodeIDStmt, deleteNodeExecutionsByNodeID, nodeID)
	return err
}

const deleteNodeExecutionsByNodeIDs = `-- name: DeleteNodeExecutionsByNodeIDs :exec
DELETE FROM node_execution WHERE node_id IN (/*SLICE:node_ids*/?)
`

func (q *Queries) DeleteNodeExecutionsByNodeIDs(ctx context.Context, nodeIds []idwrap.IDWrap) error {
	query := deleteNodeExecutionsByNodeIDs
	var queryParams []interface{}
	if len(nodeIds) > 0 {
		for _, v := range nodeIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:node_ids*/?", strings.Repeat(",?", len(nodeIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:node_ids*/?", "NULL", 1)
	}
	_, err := q.exec(ctx, nil, query, queryParams...)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tag
WHERE
  id = ?
`

func (q *Queries) DeleteTag(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteTagStmt, deleteTag, id)
	return err
}

const getFlow = `-- name: GetFlow :one
SELECT
  id,
  workspace_id,
  version_parent_id,
  name,
  duration,
  running
FROM
  flow
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetFlow(ctx context.Context, id idwrap.IDWrap) (Flow, error) {
	row := q.queryRow(ctx, q.getFlowStmt, getFlow, id)
	var i Flow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.VersionParentID,
		&i.Name,
		&i.Duration,
		&i.Running,
	)
	return i, err
}

const getFlowEdge = `-- name: GetFlowEdge :one
SELECT
  id,
  flow_id,
  source_id,
  target_id,
  source_handle,
  edge_kind
FROM
  flow_edge
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetFlowEdge(ctx context.Context, id idwrap.IDWrap) (FlowEdge, error) {
	row := q.queryRow(ctx, q.getFlowEdgeStmt, getFlowEdge, id)
	var i FlowEdge
	err := row.Scan(
		&i.ID,
		&i.FlowID,
		&i.SourceID,
		&i.TargetID,
		&i.SourceHandle,
		&i.EdgeKind,
	)
	return i, err
}

const getFlowEdgesByFlowID = `-- name: GetFlowEdgesByFlowID :many
SELECT
  id,
  flow_id,
  source_id,
  target_id,
  source_handle,
  edge_kind
FROM
  flow_edge
WHERE
  flow_id = ?
`

func (q *Queries) GetFlowEdgesByFlowID(ctx context.Context, flowID idwrap.IDWrap) ([]FlowEdge, error) {
	rows, err := q.query(ctx, q.getFlowEdgesByFlowIDStmt, getFlowEdgesByFlowID, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowEdge{}
	for rows.Next() {
		var i FlowEdge
		if err := rows.Scan(
			&i.ID,
			&i.FlowID,
			&i.SourceID,
			&i.TargetID,
			&i.SourceHandle,
			&i.EdgeKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowNode = `-- name: GetFlowNode :one
SELECT
  id,
  flow_id,
  name,
  node_kind,
  position_x,
  position_y
FROM
  flow_node
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetFlowNode(ctx context.Context, id idwrap.IDWrap) (FlowNode, error) {
	row := q.queryRow(ctx, q.getFlowNodeStmt, getFlowNode, id)
	var i FlowNode
	err := row.Scan(
		&i.ID,
		&i.FlowID,
		&i.Name,
		&i.NodeKind,
		&i.PositionX,
		&i.PositionY,
	)
	return i, err
}

const getFlowNodeCondition = `-- name: GetFlowNodeCondition :one
SELECT
  flow_node_id,
  expression
FROM
  flow_node_condition
WHERE
  flow_node_id = ?
LIMIT 1
`

func (q *Queries) GetFlowNodeCondition(ctx context.Context, flowNodeID idwrap.IDWrap) (FlowNodeCondition, error) {
	row := q.queryRow(ctx, q.getFlowNodeConditionStmt, getFlowNodeCondition, flowNodeID)
	var i FlowNodeCondition
	err := row.Scan(&i.FlowNodeID, &i.Expression)
	return i, err
}

const getFlowNodeFor = `-- name: GetFlowNodeFor :one
SELECT
  flow_node_id,
  iter_count,
  error_handling,
  expression
FROM
  flow_node_for
WHERE
  flow_node_id = ?
LIMIT 1
`

func (q *Queries) GetFlowNodeFor(ctx context.Context, flowNodeID idwrap.IDWrap) (FlowNodeFor, error) {
	row := q.queryRow(ctx, q.getFlowNodeForStmt, getFlowNodeFor, flowNodeID)
	var i FlowNodeFor
	err := row.Scan(
		&i.FlowNodeID,
		&i.IterCount,
		&i.ErrorHandling,
		&i.Expression,
	)
	return i, err
}

const getFlowNodeForEach = `-- name: GetFlowNodeForEach :one
SELECT
  flow_node_id,
  iter_expression,
  error_handling,
  expression
FROM
  flow_node_for_each
WHERE
  flow_node_id = ?
LIMIT 1
`

func (q *Queries) GetFlowNodeForEach(ctx context.Context, flowNodeID idwrap.IDWrap) (FlowNodeForEach, error) {
	row := q.queryRow(ctx, q.getFlowNodeForEachStmt, getFlowNodeForEach, flowNodeID)
	var i FlowNodeForEach
	err := row.Scan(
		&i.FlowNodeID,
		&i.IterExpression,
		&i.ErrorHandling,
		&i.Expression,
	)
	return i, err
}

const getFlowNodeHTTP = `-- name: GetFlowNodeHTTP :one
SELECT
  flow_node_id,
  http_id,
  delta_http_id
FROM
  flow_node_http
WHERE
  flow_node_id = ?
LIMIT 1
`

func (q *Queries) GetFlowNodeHTTP(ctx context.Context, flowNodeID idwrap.IDWrap) (FlowNodeHttp, error) {
	row := q.queryRow(ctx, q.getFlowNodeHTTPStmt, getFlowNodeHTTP, flowNodeID)
	var i FlowNodeHttp
	err := row.Scan(&i.FlowNodeID, &i.HttpID, &i.DeltaHttpID)
	return i, err
}

const getFlowNodeJs = `-- name: GetFlowNodeJs :one
SELECT
  flow_node_id,
  code,
  code_compress_type
FROM
  flow_node_js
WHERE
  flow_node_id = ?
LIMIT 1
`

func (q *Queries) GetFlowNodeJs(ctx context.Context, flowNodeID idwrap.IDWrap) (FlowNodeJ, error) {
	row := q.queryRow(ctx, q.getFlowNodeJsStmt, getFlowNodeJs, flowNodeID)
	var i FlowNodeJ
	err := row.Scan(&i.FlowNodeID, &i.Code, &i.CodeCompressType)
	return i, err
}

const getFlowNodeNoop = `-- name: GetFlowNodeNoop :one
SELECT
  flow_node_id,
  node_type
FROM
  flow_node_noop
where
  flow_node_id = ?
LIMIT 1
`

func (q *Queries) GetFlowNodeNoop(ctx context.Context, flowNodeID idwrap.IDWrap) (FlowNodeNoop, error) {
	row := q.queryRow(ctx, q.getFlowNodeNoopStmt, getFlowNodeNoop, flowNodeID)
	var i FlowNodeNoop
	err := row.Scan(&i.FlowNodeID, &i.NodeType)
	return i, err
}

const getFlowNodesByFlowID = `-- name: GetFlowNodesByFlowID :many
SELECT
  id,
  flow_id,
  name,
  node_kind,
  position_x,
  position_y
FROM
  flow_node
WHERE
  flow_id = ?
`

func (q *Queries) GetFlowNodesByFlowID(ctx context.Context, flowID idwrap.IDWrap) ([]FlowNode, error) {
	rows, err := q.query(ctx, q.getFlowNodesByFlowIDStmt, getFlowNodesByFlowID, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowNode{}
	for rows.Next() {
		var i FlowNode
		if err := rows.Scan(
			&i.ID,
			&i.FlowID,
			&i.Name,
			&i.NodeKind,
			&i.PositionX,
			&i.PositionY,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowTag = `-- name: GetFlowTag :one
SELECT
  id,
  flow_id,
  tag_id
FROM flow_tag
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetFlowTag(ctx context.Context, id idwrap.IDWrap) (FlowTag, error) {
	row := q.queryRow(ctx, q.getFlowTagStmt, getFlowTag, id)
	var i FlowTag
	err := row.Scan(&i.ID, &i.FlowID, &i.TagID)
	return i, err
}

const getFlowTagsByFlowID = `-- name: GetFlowTagsByFlowID :many
SELECT
  id,
  flow_id,
  tag_id
FROM
  flow_tag
WHERE
  flow_id = ?
`

func (q *Queries) GetFlowTagsByFlowID(ctx context.Context, flowID idwrap.IDWrap) ([]FlowTag, error) {
	rows, err := q.query(ctx, q.getFlowTagsByFlowIDStmt, getFlowTagsByFlowID, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowTag{}
	for rows.Next() {
		var i FlowTag
		if err := rows.Scan(&i.ID, &i.FlowID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowTagsByTagID = `-- name: GetFlowTagsByTagID :many
SELECT
  id,
  flow_id,
  tag_id
FROM
  flow_tag
WHERE
  tag_id = ?
`

func (q *Queries) GetFlowTagsByTagID(ctx context.Context, tagID idwrap.IDWrap) ([]FlowTag, error) {
	rows, err := q.query(ctx, q.getFlowTagsByTagIDStmt, getFlowTagsByTagID, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowTag{}
	for rows.Next() {
		var i FlowTag
		if err := rows.Scan(&i.ID, &i.FlowID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowVariable = `-- name: GetFlowVariable :one
SELECT
  id,
  flow_id,
  key,
  value,
  enabled,
  description,
  prev,
  next
FROM
  flow_variable
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetFlowVariable(ctx context.Context, id idwrap.IDWrap) (FlowVariable, error) {
	row := q.queryRow(ctx, q.getFlowVariableStmt, getFlowVariable, id)
	var i FlowVariable
	err := row.Scan(
		&i.ID,
		&i.FlowID,
		&i.Key,
		&i.Value,
		&i.Enabled,
		&i.Description,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getFlowVariablesByFlowID = `-- name: GetFlowVariablesByFlowID :many
SELECT
  id,
  flow_id,
  key,
  value,
  enabled,
  description,
  prev,
  next
FROM
  flow_variable
WHERE
  flow_id = ?
`

func (q *Queries) GetFlowVariablesByFlowID(ctx context.Context, flowID idwrap.IDWrap) ([]FlowVariable, error) {
	rows, err := q.query(ctx, q.getFlowVariablesByFlowIDStmt, getFlowVariablesByFlowID, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowVariable{}
	for rows.Next() {
		var i FlowVariable
		if err := rows.Scan(
			&i.ID,
			&i.FlowID,
			&i.Key,
			&i.Value,
			&i.Enabled,
			&i.Description,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowVariablesByFlowIDOrdered = `-- name: GetFlowVariablesByFlowIDOrdered :many
WITH RECURSIVE ordered_flow_variables AS (
  -- Base case: Find the head (prev IS NULL)
  SELECT
    fv.id,
    fv.flow_id,
    fv.key,
    fv.value,
    fv.enabled,
    fv.description,
    fv.prev,
    fv.next,
    0 as position
  FROM
    flow_variable fv
  WHERE
    fv.flow_id = ? AND
    fv.prev IS NULL
  
  UNION ALL
  
  -- Recursive case: Follow the next pointers
  SELECT
    fv.id,
    fv.flow_id,
    fv.key,
    fv.value,
    fv.enabled,
    fv.description,
    fv.prev,
    fv.next,
    ofv.position + 1
  FROM
    flow_variable fv
  INNER JOIN ordered_flow_variables ofv ON fv.prev = ofv.id
  WHERE
    fv.flow_id = ?
)
SELECT
  ofv.id,
  ofv.flow_id,
  ofv.key,
  ofv.value,
  ofv.enabled,
  ofv.description,
  ofv.prev,
  ofv.next,
  ofv.position
FROM
  ordered_flow_variables ofv
ORDER BY
  ofv.position
`

type GetFlowVariablesByFlowIDOrderedParams struct {
	FlowID   idwrap.IDWrap
	FlowID_2 idwrap.IDWrap
}

type GetFlowVariablesByFlowIDOrderedRow struct {
	ID          []byte
	FlowID      []byte
	Key         string
	Value       string
	Enabled     bool
	Description string
	Prev        []byte
	Next        []byte
	Position    int64
}

// Uses WITH RECURSIVE CTE to traverse linked list from head to tail
// Requires index on (flow_id, prev) for optimal performance
func (q *Queries) GetFlowVariablesByFlowIDOrdered(ctx context.Context, arg GetFlowVariablesByFlowIDOrderedParams) ([]GetFlowVariablesByFlowIDOrderedRow, error) {
	rows, err := q.query(ctx, q.getFlowVariablesByFlowIDOrderedStmt, getFlowVariablesByFlowIDOrdered, arg.FlowID, arg.FlowID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFlowVariablesByFlowIDOrderedRow{}
	for rows.Next() {
		var i GetFlowVariablesByFlowIDOrderedRow
		if err := rows.Scan(
			&i.ID,
			&i.FlowID,
			&i.Key,
			&i.Value,
			&i.Enabled,
			&i.Description,
			&i.Prev,
			&i.Next,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowsByVersionParentID = `-- name: GetFlowsByVersionParentID :many
SELECT
  id,
  workspace_id,
  version_parent_id,
  name,
  duration,
  running
FROM
  flow
WHERE
  version_parent_id is ?
`

func (q *Queries) GetFlowsByVersionParentID(ctx context.Context, versionParentID *idwrap.IDWrap) ([]Flow, error) {
	rows, err := q.query(ctx, q.getFlowsByVersionParentIDStmt, getFlowsByVersionParentID, versionParentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Flow{}
	for rows.Next() {
		var i Flow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.VersionParentID,
			&i.Name,
			&i.Duration,
			&i.Running,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowsByWorkspaceID = `-- name: GetFlowsByWorkspaceID :many
SELECT
  id,
  workspace_id,
  version_parent_id,
  name,
  duration,
  running
FROM
  flow
WHERE
  workspace_id = ? AND
  version_parent_id is NULL
`

func (q *Queries) GetFlowsByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]Flow, error) {
	rows, err := q.query(ctx, q.getFlowsByWorkspaceIDStmt, getFlowsByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Flow{}
	for rows.Next() {
		var i Flow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.VersionParentID,
			&i.Name,
			&i.Duration,
			&i.Running,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestNodeExecutionByNodeID = `-- name: GetLatestNodeExecutionByNodeID :one
SELECT id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, http_response_id, completed_at
FROM node_execution
WHERE node_id = ? AND completed_at IS NOT NULL
ORDER BY completed_at DESC, id DESC
LIMIT 1
`

func (q *Queries) GetLatestNodeExecutionByNodeID(ctx context.Context, nodeID idwrap.IDWrap) (NodeExecution, error) {
	row := q.queryRow(ctx, q.getLatestNodeExecutionByNodeIDStmt, getLatestNodeExecutionByNodeID, nodeID)
	var i NodeExecution
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Name,
		&i.State,
		&i.Error,
		&i.InputData,
		&i.InputDataCompressType,
		&i.OutputData,
		&i.OutputDataCompressType,
		&i.HttpResponseID,
		&i.CompletedAt,
	)
	return i, err
}

const getMigration = `-- name: GetMigration :one
SELECT
  id,
  version,
  description,
  apply_at
FROM
  migration
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetMigration(ctx context.Context, id []byte) (Migration, error) {
	row := q.queryRow(ctx, q.getMigrationStmt, getMigration, id)
	var i Migration
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.Description,
		&i.ApplyAt,
	)
	return i, err
}

const getMigrations = `-- name: GetMigrations :many
SELECT
  id,
  version,
  description,
  apply_at
FROM
  migration
`

func (q *Queries) GetMigrations(ctx context.Context) ([]Migration, error) {
	rows, err := q.query(ctx, q.getMigrationsStmt, getMigrations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Migration{}
	for rows.Next() {
		var i Migration
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Description,
			&i.ApplyAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeExecution = `-- name: GetNodeExecution :one
SELECT id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, http_response_id, completed_at FROM node_execution
WHERE id = ?
`

// Node Execution
func (q *Queries) GetNodeExecution(ctx context.Context, id idwrap.IDWrap) (NodeExecution, error) {
	row := q.queryRow(ctx, q.getNodeExecutionStmt, getNodeExecution, id)
	var i NodeExecution
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Name,
		&i.State,
		&i.Error,
		&i.InputData,
		&i.InputDataCompressType,
		&i.OutputData,
		&i.OutputDataCompressType,
		&i.HttpResponseID,
		&i.CompletedAt,
	)
	return i, err
}

const getNodeExecutionsByNodeID = `-- name: GetNodeExecutionsByNodeID :many
SELECT id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, http_response_id, completed_at
FROM node_execution
WHERE node_id = ? AND completed_at IS NOT NULL
ORDER BY completed_at DESC, id DESC
`

func (q *Queries) GetNodeExecutionsByNodeID(ctx context.Context, nodeID idwrap.IDWrap) ([]NodeExecution, error) {
	rows, err := q.query(ctx, q.getNodeExecutionsByNodeIDStmt, getNodeExecutionsByNodeID, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NodeExecution{}
	for rows.Next() {
		var i NodeExecution
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.Name,
			&i.State,
			&i.Error,
			&i.InputData,
			&i.InputDataCompressType,
			&i.OutputData,
			&i.OutputDataCompressType,
			&i.HttpResponseID,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTag = `-- name: GetTag :one
SELECT
  id,
  workspace_id,
  name,
  color
FROM
  tag
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetTag(ctx context.Context, id idwrap.IDWrap) (Tag, error) {
	row := q.queryRow(ctx, q.getTagStmt, getTag, id)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Name,
		&i.Color,
	)
	return i, err
}

const getTagsByWorkspaceID = `-- name: GetTagsByWorkspaceID :many
SELECT
  id,
  workspace_id,
  name,
  color
FROM
  tag
WHERE
  workspace_id = ?
`

func (q *Queries) GetTagsByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]Tag, error) {
	rows, err := q.query(ctx, q.getTagsByWorkspaceIDStmt, getTagsByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodeExecutions = `-- name: ListNodeExecutions :many
SELECT id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, http_response_id, completed_at FROM node_execution
WHERE node_id = ?
ORDER BY completed_at DESC
LIMIT ? OFFSET ?
`

type ListNodeExecutionsParams struct {
	NodeID idwrap.IDWrap
	Limit  int64
	Offset int64
}

func (q *Queries) ListNodeExecutions(ctx context.Context, arg ListNodeExecutionsParams) ([]NodeExecution, error) {
	rows, err := q.query(ctx, q.listNodeExecutionsStmt, listNodeExecutions, arg.NodeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NodeExecution{}
	for rows.Next() {
		var i NodeExecution
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.Name,
			&i.State,
			&i.Error,
			&i.InputData,
			&i.InputDataCompressType,
			&i.OutputData,
			&i.OutputDataCompressType,
			&i.HttpResponseID,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodeExecutionsByFlowRun = `-- name: ListNodeExecutionsByFlowRun :many
SELECT ne.id, ne.node_id, ne.name, ne.state, ne.error, ne.input_data, ne.input_data_compress_type, ne.output_data, ne.output_data_compress_type, ne.http_response_id, ne.completed_at FROM node_execution ne
JOIN flow_node fn ON ne.node_id = fn.id
WHERE fn.flow_id = ?
ORDER BY ne.completed_at DESC
`

func (q *Queries) ListNodeExecutionsByFlowRun(ctx context.Context, flowID idwrap.IDWrap) ([]NodeExecution, error) {
	rows, err := q.query(ctx, q.listNodeExecutionsByFlowRunStmt, listNodeExecutionsByFlowRun, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NodeExecution{}
	for rows.Next() {
		var i NodeExecution
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.Name,
			&i.State,
			&i.Error,
			&i.InputData,
			&i.InputDataCompressType,
			&i.OutputData,
			&i.OutputDataCompressType,
			&i.HttpResponseID,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodeExecutionsByState = `-- name: ListNodeExecutionsByState :many
SELECT id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, http_response_id, completed_at FROM node_execution
WHERE node_id = ? AND state = ?
ORDER BY completed_at DESC
LIMIT ? OFFSET ?
`

type ListNodeExecutionsByStateParams struct {
	NodeID idwrap.IDWrap
	State  int8
	Limit  int64
	Offset int64
}

func (q *Queries) ListNodeExecutionsByState(ctx context.Context, arg ListNodeExecutionsByStateParams) ([]NodeExecution, error) {
	rows, err := q.query(ctx, q.listNodeExecutionsByStateStmt, listNodeExecutionsByState,
		arg.NodeID,
		arg.State,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NodeExecution{}
	for rows.Next() {
		var i NodeExecution
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.Name,
			&i.State,
			&i.Error,
			&i.InputData,
			&i.InputDataCompressType,
			&i.OutputData,
			&i.OutputDataCompressType,
			&i.HttpResponseID,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFlow = `-- name: UpdateFlow :exec
UPDATE flow
SET
  name = ?,
  duration = ?,
  running = ?
WHERE
  id = ?
`

type UpdateFlowParams struct {
	Name     string
	Duration int32
	Running  bool
	ID       idwrap.IDWrap
}

func (q *Queries) UpdateFlow(ctx context.Context, arg UpdateFlowParams) error {
	_, err := q.exec(ctx, q.updateFlowStmt, updateFlow,
		arg.Name,
		arg.Duration,
		arg.Running,
		arg.ID,
	)
	return err
}

const updateFlowEdge = `-- name: UpdateFlowEdge :exec
UPDATE flow_edge
SET
  source_id = ?,
  target_id = ?,
  source_handle = ?,
  edge_kind = ?
WHERE
  id = ?
`

type UpdateFlowEdgeParams struct {
	SourceID     idwrap.IDWrap
	TargetID     idwrap.IDWrap
	SourceHandle int32
	EdgeKind     int32
	ID           idwrap.IDWrap
}

func (q *Queries) UpdateFlowEdge(ctx context.Context, arg UpdateFlowEdgeParams) error {
	_, err := q.exec(ctx, q.updateFlowEdgeStmt, updateFlowEdge,
		arg.SourceID,
		arg.TargetID,
		arg.SourceHandle,
		arg.EdgeKind,
		arg.ID,
	)
	return err
}

const updateFlowNode = `-- name: UpdateFlowNode :exec
UPDATE flow_node
SET
  name = ?,
  position_x = ?,
  position_y = ?
WHERE
  id = ?
`

type UpdateFlowNodeParams struct {
	Name      string
	PositionX float64
	PositionY float64
	ID        idwrap.IDWrap
}

func (q *Queries) UpdateFlowNode(ctx context.Context, arg UpdateFlowNodeParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeStmt, updateFlowNode,
		arg.Name,
		arg.PositionX,
		arg.PositionY,
		arg.ID,
	)
	return err
}

const updateFlowNodeCondition = `-- name: UpdateFlowNodeCondition :exec
UPDATE flow_node_condition
SET
  expression = ?
WHERE
  flow_node_id = ?
`

type UpdateFlowNodeConditionParams struct {
	Expression string
	FlowNodeID idwrap.IDWrap
}

func (q *Queries) UpdateFlowNodeCondition(ctx context.Context, arg UpdateFlowNodeConditionParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeConditionStmt, updateFlowNodeCondition, arg.Expression, arg.FlowNodeID)
	return err
}

const updateFlowNodeFor = `-- name: UpdateFlowNodeFor :exec
UPDATE flow_node_for
SET
  iter_count = ?,
  error_handling = ?,
  expression = ?
WHERE
  flow_node_id = ?
`

type UpdateFlowNodeForParams struct {
	IterCount     int64
	ErrorHandling int8
	Expression    string
	FlowNodeID    idwrap.IDWrap
}

func (q *Queries) UpdateFlowNodeFor(ctx context.Context, arg UpdateFlowNodeForParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeForStmt, updateFlowNodeFor,
		arg.IterCount,
		arg.ErrorHandling,
		arg.Expression,
		arg.FlowNodeID,
	)
	return err
}

const updateFlowNodeForEach = `-- name: UpdateFlowNodeForEach :exec
UPDATE flow_node_for_each
SET
  iter_expression = ?,
  error_handling = ?,
  expression = ?
WHERE
  flow_node_id = ?
`

type UpdateFlowNodeForEachParams struct {
	IterExpression string
	ErrorHandling  int8
	Expression     string
	FlowNodeID     idwrap.IDWrap
}

func (q *Queries) UpdateFlowNodeForEach(ctx context.Context, arg UpdateFlowNodeForEachParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeForEachStmt, updateFlowNodeForEach,
		arg.IterExpression,
		arg.ErrorHandling,
		arg.Expression,
		arg.FlowNodeID,
	)
	return err
}

const updateFlowNodeHTTP = `-- name: UpdateFlowNodeHTTP :exec
INSERT INTO flow_node_http (
    flow_node_id,
    http_id,
    delta_http_id
)
VALUES
    (?, ?, ?)
ON CONFLICT(flow_node_id) DO UPDATE SET
    http_id = excluded.http_id,
    delta_http_id = excluded.delta_http_id
`

type UpdateFlowNodeHTTPParams struct {
	FlowNodeID  idwrap.IDWrap
	HttpID      idwrap.IDWrap
	DeltaHttpID []byte
}

func (q *Queries) UpdateFlowNodeHTTP(ctx context.Context, arg UpdateFlowNodeHTTPParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeHTTPStmt, updateFlowNodeHTTP, arg.FlowNodeID, arg.HttpID, arg.DeltaHttpID)
	return err
}

const updateFlowNodeJs = `-- name: UpdateFlowNodeJs :exec
UPDATE flow_node_js
SET
  code = ?,
  code_compress_type = ?
WHERE
  flow_node_id = ?
`

type UpdateFlowNodeJsParams struct {
	Code             []byte
	CodeCompressType int8
	FlowNodeID       idwrap.IDWrap
}

func (q *Queries) UpdateFlowNodeJs(ctx context.Context, arg UpdateFlowNodeJsParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeJsStmt, updateFlowNodeJs, arg.Code, arg.CodeCompressType, arg.FlowNodeID)
	return err
}

const updateFlowVariable = `-- name: UpdateFlowVariable :exec
UPDATE flow_variable
SET
  key = ?,
  value = ?,
  enabled = ?,
  description = ?
WHERE
  id = ?
`

type UpdateFlowVariableParams struct {
	Key         string
	Value       string
	Enabled     bool
	Description string
	ID          idwrap.IDWrap
}

func (q *Queries) UpdateFlowVariable(ctx context.Context, arg UpdateFlowVariableParams) error {
	_, err := q.exec(ctx, q.updateFlowVariableStmt, updateFlowVariable,
		arg.Key,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.ID,
	)
	return err
}

const updateFlowVariableNext = `-- name: UpdateFlowVariableNext :exec
UPDATE flow_variable
SET
  next = ?
WHERE
  id = ? AND
  flow_id = ?
`

type UpdateFlowVariableNextParams struct {
	Next   *idwrap.IDWrap
	ID     idwrap.IDWrap
	FlowID idwrap.IDWrap
}

// Update only the next pointer for a flow variable (used in deletion)
func (q *Queries) UpdateFlowVariableNext(ctx context.Context, arg UpdateFlowVariableNextParams) error {
	_, err := q.exec(ctx, q.updateFlowVariableNextStmt, updateFlowVariableNext, arg.Next, arg.ID, arg.FlowID)
	return err
}

const updateFlowVariableOrder = `-- name: UpdateFlowVariableOrder :exec
UPDATE flow_variable
SET
  prev = ?,
  next = ?
WHERE
  id = ? AND
  flow_id = ?
`

type UpdateFlowVariableOrderParams struct {
	Prev   *idwrap.IDWrap
	Next   *idwrap.IDWrap
	ID     idwrap.IDWrap
	FlowID idwrap.IDWrap
}

// Update the prev/next pointers for a single flow variable
// Used for moving flow variables within the linked list
func (q *Queries) UpdateFlowVariableOrder(ctx context.Context, arg UpdateFlowVariableOrderParams) error {
	_, err := q.exec(ctx, q.updateFlowVariableOrderStmt, updateFlowVariableOrder,
		arg.Prev,
		arg.Next,
		arg.ID,
		arg.FlowID,
	)
	return err
}

const updateFlowVariablePrev = `-- name: UpdateFlowVariablePrev :exec
UPDATE flow_variable
SET
  prev = ?
WHERE
  id = ? AND
  flow_id = ?
`

type UpdateFlowVariablePrevParams struct {
	Prev   *idwrap.IDWrap
	ID     idwrap.IDWrap
	FlowID idwrap.IDWrap
}

// Update only the prev pointer for a flow variable (used in deletion)
func (q *Queries) UpdateFlowVariablePrev(ctx context.Context, arg UpdateFlowVariablePrevParams) error {
	_, err := q.exec(ctx, q.updateFlowVariablePrevStmt, updateFlowVariablePrev, arg.Prev, arg.ID, arg.FlowID)
	return err
}

const updateNodeExecution = `-- name: UpdateNodeExecution :one
UPDATE node_execution
SET state = ?, error = ?, output_data = ?, 
    output_data_compress_type = ?, http_response_id = ?, completed_at = ?
WHERE id = ?
RETURNING id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, http_response_id, completed_at
`

type UpdateNodeExecutionParams struct {
	State                  int8
	Error                  sql.NullString
	OutputData             []byte
	OutputDataCompressType int8
	HttpResponseID         *idwrap.IDWrap
	CompletedAt            sql.NullInt64
	ID                     idwrap.IDWrap
}

func (q *Queries) UpdateNodeExecution(ctx context.Context, arg UpdateNodeExecutionParams) (NodeExecution, error) {
	row := q.queryRow(ctx, q.updateNodeExecutionStmt, updateNodeExecution,
		arg.State,
		arg.Error,
		arg.OutputData,
		arg.OutputDataCompressType,
		arg.HttpResponseID,
		arg.CompletedAt,
		arg.ID,
	)
	var i NodeExecution
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Name,
		&i.State,
		&i.Error,
		&i.InputData,
		&i.InputDataCompressType,
		&i.OutputData,
		&i.OutputDataCompressType,
		&i.HttpResponseID,
		&i.CompletedAt,
	)
	return i, err
}

const updateTag = `-- name: UpdateTag :exec
UPDATE tag
SET
  name = ?,
  color = ?
WHERE
  id = ?
`

type UpdateTagParams struct {
	Name  string
	Color int8
	ID    idwrap.IDWrap
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) error {
	_, err := q.exec(ctx, q.updateTagStmt, updateTag, arg.Name, arg.Color, arg.ID)
	return err
}

const upsertNodeExecution = `-- name: UpsertNodeExecution :one
INSERT INTO node_execution (
  id, node_id, name, state, error, input_data, input_data_compress_type,
  output_data, output_data_compress_type, http_response_id, completed_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
  state = excluded.state,
  error = excluded.error, 
  input_data = excluded.input_data,
  input_data_compress_type = excluded.input_data_compress_type,
  output_data = excluded.output_data,
  output_data_compress_type = excluded.output_data_compress_type,
  http_response_id = excluded.http_response_id,
  completed_at = excluded.completed_at
RETURNING id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, http_response_id, completed_at
`

type UpsertNodeExecutionParams struct {
	ID                     idwrap.IDWrap
	NodeID                 idwrap.IDWrap
	Name                   string
	State                  int8
	Error                  sql.NullString
	InputData              []byte
	InputDataCompressType  int8
	OutputData             []byte
	OutputDataCompressType int8
	HttpResponseID         *idwrap.IDWrap
	CompletedAt            sql.NullInt64
}

func (q *Queries) UpsertNodeExecution(ctx context.Context, arg UpsertNodeExecutionParams) (NodeExecution, error) {
	row := q.queryRow(ctx, q.upsertNodeExecutionStmt, upsertNodeExecution,
		arg.ID,
		arg.NodeID,
		arg.Name,
		arg.State,
		arg.Error,
		arg.InputData,
		arg.InputDataCompressType,
		arg.OutputData,
		arg.OutputDataCompressType,
		arg.HttpResponseID,
		arg.CompletedAt,
	)
	var i NodeExecution
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Name,
		&i.State,
		&i.Error,
		&i.InputData,
		&i.InputDataCompressType,
		&i.OutputData,
		&i.OutputDataCompressType,
		&i.HttpResponseID,
		&i.CompletedAt,
	)
	return i, err
}
