package rimportv2

import (
	"context"
	"fmt"
	"sort"
	"sync"

	"the-dev-tools/server/pkg/contenthash"
	"the-dev-tools/server/pkg/idwrap"
	"the-dev-tools/server/pkg/model/mfile"
	"the-dev-tools/server/pkg/model/mhttp"
	"the-dev-tools/server/pkg/service/sfile"
	"the-dev-tools/server/pkg/service/shttp"
)

// --- Hashable Representations (Content Only) ---

// HashableHTTP represents the significant content of an HTTP request for deduplication.
// Excludes: ID, WorkspaceID, ParentID (handled by identity hash logic), CreatedAt, UpdatedAt.
type HashableHTTP struct {
	Method       string           `json:"method"`
	URL          string           `json:"url"`
	Headers      []HashableHeader `json:"headers"`
	Params       []HashableParam  `json:"params"`
	BodyKind     int8             `json:"body_kind"`
	BodyRaw      *HashableBodyRaw `json:"body_raw,omitempty"`
	Description  string           `json:"description,omitempty"`
	ParentHttpID string           `json:"parent_http_id,omitempty"`
	IsDelta      bool             `json:"is_delta"`
}

type HashableHeader struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type HashableParam struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type HashableBodyRaw struct {
	Data            string `json:"data"`
	CompressionType string `json:"compression_type"`
}

// --- The Deduplication Service ---

type Deduplicator struct {
	httpService shttp.HTTPService
	fileService sfile.FileService
	hasher      *contenthash.Hasher
	globalMu    *sync.Mutex // Shared mutex from RPC layer to prevent DB deadlocks

	// In-memory caches for the duration of the import (Single Import Scope)
	// Avoids DB hits for the same folder referenced 50 times in one HAR.
	pathCache map[string]idwrap.IDWrap
	mu        sync.RWMutex
}

func NewDeduplicator(httpService shttp.HTTPService, fileService sfile.FileService, globalMu *sync.Mutex) *Deduplicator {
	return &Deduplicator{
		httpService: httpService,
		fileService: fileService,
		hasher:      contenthash.New(),
		globalMu:    globalMu,
		pathCache:   make(map[string]idwrap.IDWrap),
	}
}

// FindHTTP checks if an identical HTTP request already exists.
// Returns the existing ID if found, its content hash, and an error if hashing fails.
func (d *Deduplicator) FindHTTP(
	ctx context.Context,
	req *mhttp.HTTP,
	headers []mhttp.HTTPHeader,
	params []mhttp.HTTPSearchParam,
	bodyRaw *mhttp.HTTPBodyRaw,
	bodyForms []mhttp.HTTPBodyForm,
	bodyUrlEncoded []mhttp.HTTPBodyUrlencoded,
	parentContentHash string,
) (idwrap.IDWrap, string, error) {
	// 1. Calculate Content Hash
	hashable := toHashableHTTP(req, headers, params, bodyRaw, bodyForms, bodyUrlEncoded, parentContentHash)
	contentHash, err := d.hasher.HashStruct(hashable)
	if err != nil {
		return idwrap.IDWrap{}, "", err
	}

	// 2. O(1) DB Check (Index Lookup) using Reader (Read-only)
	existingID, err := d.httpService.Reader().FindHTTPByContentHash(ctx, req.WorkspaceID, contentHash)
	if err == nil && existingID.Compare(idwrap.IDWrap{}) != 0 {
		return existingID, contentHash, nil
	}

	return idwrap.IDWrap{}, contentHash, nil
}

// ResolveHTTP ensures the HTTP request exists.
// Returns the ID of the existing (or newly created) request and a boolean indicating if it was newly created.
func (d *Deduplicator) ResolveHTTP(
	ctx context.Context,
	req *mhttp.HTTP,
	headers []mhttp.HTTPHeader,
	params []mhttp.HTTPSearchParam,
	bodyRaw *mhttp.HTTPBodyRaw,
	bodyForms []mhttp.HTTPBodyForm,
	bodyUrlEncoded []mhttp.HTTPBodyUrlencoded,
	parentContentHash string,
) (idwrap.IDWrap, bool, string, error) {
	if d.globalMu != nil {
		d.globalMu.Lock()
		defer d.globalMu.Unlock()
	}
	d.mu.Lock()
	defer d.mu.Unlock()

	// 1. Check if it exists
	existingID, contentHash, err := d.FindHTTP(ctx, req, headers, params, bodyRaw, bodyForms, bodyUrlEncoded, parentContentHash)
	if err != nil {
		return idwrap.IDWrap{}, false, "", err
	}
	req.ContentHash = &contentHash

	if existingID.Compare(idwrap.IDWrap{}) != 0 {
		// FOUND! Return existing ID. Zero writes.
		return existingID, false, contentHash, nil
	}

	// 2. Not Found -> Create New
	// We preserve the ID generated by the importer (req.ID)
	if err := d.httpService.Create(ctx, req); err != nil {
		return idwrap.IDWrap{}, false, "", err
	}

	return req.ID, true, contentHash, nil
}

// FindFile checks if a file with the same path already exists.
func (d *Deduplicator) FindFile(ctx context.Context, file *mfile.File, logicalPath string) (idwrap.IDWrap, string, error) {
	// 1. Calculate Path Hash (Workspace + Path)
	fullPathKey := fmt.Sprintf("%s:%s", file.WorkspaceID.String(), logicalPath)
	pathHash := d.hasher.HashString(fullPathKey)

	// 2. Check Memory Cache (Fastest)
	d.mu.RLock()
	cachedID, ok := d.pathCache[pathHash]
	d.mu.RUnlock()
	if ok {
		return cachedID, pathHash, nil
	}

	// 3. O(1) DB Check (Index Lookup) using Reader
	existingID, err := d.fileService.Reader().FindFileByPathHash(ctx, file.WorkspaceID, pathHash)
	if err == nil && existingID.Compare(idwrap.IDWrap{}) != 0 {
		return existingID, pathHash, nil
	}

	return idwrap.IDWrap{}, pathHash, nil
}

// ResolveFile ensures the file/folder structure exists.
// logicalPath example: "/com/example/api/users/GET_Users.request"
// Returns the ID and a boolean indicating if it was newly created.
func (d *Deduplicator) ResolveFile(ctx context.Context, file *mfile.File, logicalPath string) (idwrap.IDWrap, bool, error) {
	if d.globalMu != nil {
		d.globalMu.Lock()
		defer d.globalMu.Unlock()
	}
	d.mu.Lock()
	defer d.mu.Unlock()

	// 1. Check if it exists
	existingID, pathHash, err := d.FindFile(ctx, file, logicalPath)
	if err != nil {
		return idwrap.IDWrap{}, false, err
	}
	file.PathHash = &pathHash

	if existingID.Compare(idwrap.IDWrap{}) != 0 {
		// Found in DB or cache, ensure it's in cache and return
		d.pathCache[pathHash] = existingID
		return existingID, false, nil
	}

	// 2. Not Found -> Create New
	if err := d.fileService.CreateFile(ctx, file); err != nil {
		return idwrap.IDWrap{}, false, err
	}

	// Cache the new file ID
	d.pathCache[pathHash] = file.ID

	return file.ID, true, nil
}

// --- Helpers ---

func toHashableHTTP(
	req *mhttp.HTTP,
	headers []mhttp.HTTPHeader,
	params []mhttp.HTTPSearchParam,
	bodyRaw *mhttp.HTTPBodyRaw,
	bodyForms []mhttp.HTTPBodyForm,
	bodyUrlEncoded []mhttp.HTTPBodyUrlencoded,
	parentContentHash string,
) HashableHTTP {
	parentRef := parentContentHash
	if parentRef == "" && req.ParentHttpID != nil {
		parentRef = req.ParentHttpID.String()
	}

	hashable := HashableHTTP{
		Method:       req.Method,
		URL:          req.Url,
		BodyKind:     int8(req.BodyKind),
		Description:  req.Description,
		ParentHttpID: parentRef,
		IsDelta:      req.IsDelta,
	}

	for _, h := range headers {
		if h.Enabled {
			hashable.Headers = append(hashable.Headers, HashableHeader{
				Key:   h.Key,
				Value: h.Value,
			})
		}
	}
	sort.Slice(hashable.Headers, func(i, j int) bool {
		return hashable.Headers[i].Key < hashable.Headers[j].Key
	})

	for _, p := range params {
		if p.Enabled {
			hashable.Params = append(hashable.Params, HashableParam{
				Key:   p.Key,
				Value: p.Value,
			})
		}
	}
	sort.Slice(hashable.Params, func(i, j int) bool {
		return hashable.Params[i].Key < hashable.Params[j].Key
	})

	for _, f := range bodyForms {
		if f.Enabled {
			// We use Params for hashing since they are KV pairs too
			hashable.Params = append(hashable.Params, HashableParam{
				Key:   f.Key,
				Value: f.Value,
			})
		}
	}

	for _, u := range bodyUrlEncoded {
		if u.Enabled {
			hashable.Params = append(hashable.Params, HashableParam{
				Key:   u.Key,
				Value: u.Value,
			})
		}
	}
	// Re-sort Params after adding forms/urlencoded
	sort.Slice(hashable.Params, func(i, j int) bool {
		if hashable.Params[i].Key == hashable.Params[j].Key {
			return hashable.Params[i].Value < hashable.Params[j].Value
		}
		return hashable.Params[i].Key < hashable.Params[j].Key
	})

	if bodyRaw != nil {
		hashable.BodyRaw = &HashableBodyRaw{
			Data:            string(bodyRaw.RawData),
			CompressionType: fmt.Sprintf("%d", bodyRaw.CompressionType),
		}
	}

	return hashable
}
