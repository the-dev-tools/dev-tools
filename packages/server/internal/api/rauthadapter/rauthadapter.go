// Package rauthadapter implements the AuthAdapterService ConnectRPC handler,
// bridging BetterAuth JSON adapter calls to the authadapter package.
//
// # BetterAuth schema
//
// The following models and fields are defined by the BetterAuth schema and
// must be honoured by every RPC method. Fields marked required must be present
// in Create payloads; optional fields are omitted or null. Date fields are
// transmitted as Unix timestamps (int64 / float64).
//
// ## user (order 1)
//
//	Field          Type     Required  Unique  Sortable  Notes
//	─────────────────────────────────────────────────────────
//	id             string   auto                        ULID generated by adapter
//	name           string   yes               yes
//	email          string   yes       yes     yes
//	emailVerified  boolean  yes                         default false; input: false
//	image          string   no
//	createdAt      date     yes
//	updatedAt      date     yes
//
// Supported where fields for Find:    id, email
// Supported where fields for Update:  id
// Supported where fields for Delete:  id
//
// ## session (order 2)
//
//	Field      Type    Required  Unique  Notes
//	────────────────────────────────────────────────────────────────
//	id         string  auto
//	expiresAt  date    yes
//	token      string  yes       yes
//	createdAt  date    yes
//	updatedAt  date    yes
//	ipAddress  string  no
//	userAgent  string  no
//	userId     string  yes               FK → user.id, onDelete cascade, indexed
//
// Supported where fields for Find:       id, token
// Supported where fields for FindMany:   userId (eq)
// Supported where fields for Update:     id
// Supported where fields for Delete:     id, token
// Supported where fields for DeleteMany: userId (eq) | expiresAt (lt)
//
// ## account (order 3)
//
//	Field                  Type    Required  Notes
//	──────────────────────────────────────────────────────────────────────
//	id                     string  auto
//	accountId              string  yes
//	providerId             string  yes
//	userId                 string  yes       FK → user.id, onDelete cascade, indexed
//	accessToken            string  no        returned: false
//	refreshToken           string  no        returned: false
//	idToken                string  no        returned: false
//	accessTokenExpiresAt   date    no        returned: false
//	refreshTokenExpiresAt  date    no        returned: false
//	scope                  string  no
//	password               string  no        returned: false (credential provider)
//	createdAt              date    yes
//	updatedAt              date    yes
//
// Supported where fields for Find:       id | (providerId + accountId) (both eq)
// Supported where fields for FindMany:   userId (eq)
// Supported where fields for Update:     id
// Supported where fields for Delete:     id
// Supported where fields for DeleteMany: userId (eq)
//
// ## verification (order 4)
//
//	Field       Type    Required  Notes
//	────────────────────────────────────────
//	id          string  auto
//	identifier  string  yes       indexed
//	value       string  yes
//	expiresAt   date    yes
//	createdAt   date    yes
//	updatedAt   date    yes
//
// Supported where fields for Find:       id, identifier
// Supported where fields for Delete:     id
// Supported where fields for DeleteMany: expiresAt (lt)
//
// ## jwks
//
//	Field      Type    Required
//	───────────────────────────
//	publicKey  string  yes
//	privateKey string  yes
//	createdAt  date    yes
//	expiresAt  date    no
//
// Supported operations: Create, FindMany, Delete (by id).
package rauthadapter

import (
	"context"
	"encoding/json"
	"errors"

	"connectrpc.com/connect"
	"google.golang.org/protobuf/types/known/emptypb"
	"google.golang.org/protobuf/types/known/structpb"

	"github.com/the-dev-tools/dev-tools/packages/server/internal/api"
	"github.com/the-dev-tools/dev-tools/packages/server/pkg/authadapter"
	auth_adapterv1 "github.com/the-dev-tools/dev-tools/packages/spec/dist/buf/go/api/private/auth_adapter/v1"
	"github.com/the-dev-tools/dev-tools/packages/spec/dist/buf/go/api/private/auth_adapter/v1/auth_adapterv1connect"
)

// AuthAdapterRPC implements AuthAdapterServiceHandler.
type AuthAdapterRPC struct {
	auth_adapterv1connect.UnimplementedAuthAdapterServiceHandler

	adapter *authadapter.Adapter
}

// AuthAdapterRPCDeps holds dependencies for the handler.
type AuthAdapterRPCDeps struct {
	Adapter *authadapter.Adapter
}

// New creates an AuthAdapterRPC handler.
func New(deps AuthAdapterRPCDeps) AuthAdapterRPC {
	return AuthAdapterRPC{adapter: deps.Adapter}
}

// CreateService registers the handler and returns an api.Service.
func CreateService(h AuthAdapterRPC, opts []connect.HandlerOption) (*api.Service, error) {
	path, handler := auth_adapterv1connect.NewAuthAdapterServiceHandler(h, opts...)
	return &api.Service{Path: path, Handler: handler}, nil
}

// --- proto → adapter conversion helpers ---

func operatorToString(op auth_adapterv1.Operator) string {
	switch op {
	case auth_adapterv1.Operator_OPERATOR_EQUAL:
		return "eq"
	case auth_adapterv1.Operator_OPERATOR_NOT_EQUAL:
		return "ne"
	case auth_adapterv1.Operator_OPERATOR_LESS_THAN:
		return "lt"
	case auth_adapterv1.Operator_OPERATOR_LESS_OR_EQUAL:
		return "lte"
	case auth_adapterv1.Operator_OPERATOR_GREATER_THAN:
		return "gt"
	case auth_adapterv1.Operator_OPERATOR_GREATER_OR_EQUAL:
		return "gte"
	case auth_adapterv1.Operator_OPERATOR_IN:
		return "in"
	case auth_adapterv1.Operator_OPERATOR_NOT_IN:
		return "not_in"
	case auth_adapterv1.Operator_OPERATOR_CONTAINS:
		return "contains"
	case auth_adapterv1.Operator_OPERATOR_STARTS_WITH:
		return "starts_with"
	case auth_adapterv1.Operator_OPERATOR_ENDS_WITH:
		return "ends_with"
	default:
		return "eq"
	}
}

func connectorToString(c auth_adapterv1.Connector) string {
	if c == auth_adapterv1.Connector_CONNECTOR_OR {
		return "OR"
	}
	return "AND"
}

func directionToString(d auth_adapterv1.Direction) string {
	if d == auth_adapterv1.Direction_DIRECTION_DESCENDING {
		return "desc"
	}
	return "asc"
}

// protoValueToRaw marshals a *structpb.Value to json.RawMessage.
func protoValueToRaw(v *structpb.Value) (json.RawMessage, error) {
	if v == nil {
		return json.RawMessage("null"), nil
	}
	b, err := v.MarshalJSON()
	if err != nil {
		return nil, err
	}
	return json.RawMessage(b), nil
}

// protoStructToMap converts a *structpb.Value (struct/object kind) to map[string]json.RawMessage.
func protoStructToMap(v *structpb.Value) (map[string]json.RawMessage, error) {
	if v == nil {
		return map[string]json.RawMessage{}, nil
	}
	b, err := v.MarshalJSON()
	if err != nil {
		return nil, err
	}
	var m map[string]json.RawMessage
	if err := json.Unmarshal(b, &m); err != nil {
		return nil, err
	}
	return m, nil
}

// protoMapToData converts map[string]*structpb.Value to map[string]json.RawMessage.
func protoMapToData(m map[string]*structpb.Value) (map[string]json.RawMessage, error) {
	result := make(map[string]json.RawMessage, len(m))
	for k, v := range m {
		raw, err := protoValueToRaw(v)
		if err != nil {
			return nil, err
		}
		result[k] = raw
	}
	return result, nil
}

// mapToProtoValue converts map[string]any to *structpb.Value.
func mapToProtoValue(m map[string]any) (*structpb.Value, error) {
	if m == nil {
		return structpb.NewNullValue(), nil
	}
	b, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}
	var v structpb.Value
	if err := v.UnmarshalJSON(b); err != nil {
		return nil, err
	}
	return &v, nil
}

// mapAnyToProtoMap converts map[string]any to map[string]*structpb.Value.
func mapAnyToProtoMap(m map[string]any) (map[string]*structpb.Value, error) {
	if m == nil {
		return nil, nil
	}
	result := make(map[string]*structpb.Value, len(m))
	for k, v := range m {
		b, err := json.Marshal(v)
		if err != nil {
			return nil, err
		}
		var sv structpb.Value
		if err := sv.UnmarshalJSON(b); err != nil {
			return nil, err
		}
		result[k] = &sv
	}
	return result, nil
}

// convertWhere converts proto Where slice to []authadapter.WhereClause.
func convertWhere(where []*auth_adapterv1.Where) ([]authadapter.WhereClause, error) {
	result := make([]authadapter.WhereClause, 0, len(where))
	for _, w := range where {
		raw, err := protoValueToRaw(w.GetValue())
		if err != nil {
			return nil, err
		}
		result = append(result, authadapter.WhereClause{
			Field:     w.GetField(),
			Operator:  operatorToString(w.GetOperator()),
			Value:     raw,
			Connector: connectorToString(w.GetConnector()),
		})
	}
	return result, nil
}

// adapterErr maps authadapter sentinel errors to Connect codes.
func adapterErr(err error) error {
	if errors.Is(err, authadapter.ErrUnsupportedModel) || errors.Is(err, authadapter.ErrUnsupportedWhere) {
		return connect.NewError(connect.CodeInvalidArgument, err)
	}
	return connect.NewError(connect.CodeInternal, err)
}

// --- RPC handlers ---

func (h AuthAdapterRPC) Create(ctx context.Context, req *connect.Request[auth_adapterv1.CreateRequest]) (*connect.Response[auth_adapterv1.CreateResponse], error) {
	data, err := protoMapToData(req.Msg.GetData())
	if err != nil {
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}
	result, err := h.adapter.Create(ctx, req.Msg.GetModel(), data)
	if err != nil {
		return nil, adapterErr(err)
	}
	v, err := mapAnyToProtoMap(result)
	if err != nil {
		return nil, connect.NewError(connect.CodeInternal, err)
	}
	return connect.NewResponse(&auth_adapterv1.CreateResponse{Data: v}), nil
}

func (h AuthAdapterRPC) Find(ctx context.Context, req *connect.Request[auth_adapterv1.FindRequest]) (*connect.Response[auth_adapterv1.FindResponse], error) {
	where, err := convertWhere(req.Msg.GetWhere())
	if err != nil {
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}
	result, err := h.adapter.FindOne(ctx, req.Msg.GetModel(), where)
	if err != nil {
		return nil, adapterErr(err)
	}
	if result == nil {
		return connect.NewResponse(&auth_adapterv1.FindResponse{}), nil
	}
	v, err := mapToProtoValue(result)
	if err != nil {
		return nil, connect.NewError(connect.CodeInternal, err)
	}
	return connect.NewResponse(&auth_adapterv1.FindResponse{Data: v}), nil
}

func (h AuthAdapterRPC) FindMany(ctx context.Context, req *connect.Request[auth_adapterv1.FindManyRequest]) (*connect.Response[auth_adapterv1.FindManyResponse], error) {
	where, err := convertWhere(req.Msg.GetWhere())
	if err != nil {
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}
	opts := authadapter.FindManyOpts{
		Limit:  req.Msg.GetLimit(),
		Offset: req.Msg.GetOffset(),
	}
	if sb := req.Msg.GetSortBy(); sb != nil {
		opts.SortBy = &authadapter.SortBy{
			Field:     sb.GetField(),
			Direction: directionToString(sb.GetDirection()),
		}
	}
	results, err := h.adapter.FindMany(ctx, req.Msg.GetModel(), where, opts)
	if err != nil {
		return nil, adapterErr(err)
	}
	items := make([]*structpb.Value, 0, len(results))
	for _, r := range results {
		v, err := mapToProtoValue(r)
		if err != nil {
			return nil, connect.NewError(connect.CodeInternal, err)
		}
		items = append(items, v)
	}
	return connect.NewResponse(&auth_adapterv1.FindManyResponse{Items: items}), nil
}

func (h AuthAdapterRPC) Update(ctx context.Context, req *connect.Request[auth_adapterv1.UpdateRequest]) (*connect.Response[auth_adapterv1.UpdateResponse], error) {
	where, err := convertWhere(req.Msg.GetWhere())
	if err != nil {
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}
	data, err := protoStructToMap(req.Msg.GetUpdate())
	if err != nil {
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}
	result, err := h.adapter.Update(ctx, req.Msg.GetModel(), where, data)
	if err != nil {
		return nil, adapterErr(err)
	}
	if result == nil {
		return connect.NewResponse(&auth_adapterv1.UpdateResponse{}), nil
	}
	v, err := mapToProtoValue(result)
	if err != nil {
		return nil, connect.NewError(connect.CodeInternal, err)
	}
	return connect.NewResponse(&auth_adapterv1.UpdateResponse{Data: v}), nil
}

func (h AuthAdapterRPC) UpdateMany(ctx context.Context, req *connect.Request[auth_adapterv1.UpdateManyRequest]) (*connect.Response[auth_adapterv1.UpdateManyResponse], error) {
	where, err := convertWhere(req.Msg.GetWhere())
	if err != nil {
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}
	data, err := protoMapToData(req.Msg.GetUpdate())
	if err != nil {
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}
	count, err := h.adapter.UpdateMany(ctx, req.Msg.GetModel(), where, data)
	if err != nil {
		return nil, adapterErr(err)
	}
	return connect.NewResponse(&auth_adapterv1.UpdateManyResponse{Count: int32(count)}), nil //nolint:gosec
}

func (h AuthAdapterRPC) Delete(ctx context.Context, req *connect.Request[auth_adapterv1.DeleteRequest]) (*connect.Response[emptypb.Empty], error) {
	where, err := convertWhere(req.Msg.GetWhere())
	if err != nil {
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}
	if err := h.adapter.Delete(ctx, req.Msg.GetModel(), where); err != nil {
		return nil, adapterErr(err)
	}
	return connect.NewResponse(&emptypb.Empty{}), nil
}

func (h AuthAdapterRPC) DeleteMany(ctx context.Context, req *connect.Request[auth_adapterv1.DeleteManyRequest]) (*connect.Response[auth_adapterv1.DeleteManyResponse], error) {
	where, err := convertWhere(req.Msg.GetWhere())
	if err != nil {
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}
	if err := h.adapter.DeleteMany(ctx, req.Msg.GetModel(), where); err != nil {
		return nil, adapterErr(err)
	}
	return connect.NewResponse(&auth_adapterv1.DeleteManyResponse{}), nil
}

func (h AuthAdapterRPC) Count(ctx context.Context, req *connect.Request[auth_adapterv1.CountRequest]) (*connect.Response[auth_adapterv1.CountResponse], error) {
	n, err := h.adapter.Count(ctx, req.Msg.GetModel())
	if err != nil {
		return nil, adapterErr(err)
	}
	return connect.NewResponse(&auth_adapterv1.CountResponse{Count: int32(n)}), nil //nolint:gosec
}
