// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: flow.sql

package gen

import (
	"context"
	"database/sql"
	"strings"

	idwrap "github.com/the-dev-tools/dev-tools/packages/server/pkg/idwrap"
)

const cleanupOrphanedFlowEdges = `-- name: CleanupOrphanedFlowEdges :exec
DELETE FROM flow_edge WHERE source_id NOT IN (SELECT id FROM flow_node) OR target_id NOT IN (SELECT id FROM flow_node)
`

func (q *Queries) CleanupOrphanedFlowEdges(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanupOrphanedFlowEdgesStmt, cleanupOrphanedFlowEdges)
	return err
}

const cleanupOrphanedFlowNodeCondition = `-- name: CleanupOrphanedFlowNodeCondition :exec
DELETE FROM flow_node_condition WHERE flow_node_id NOT IN (SELECT id FROM flow_node)
`

func (q *Queries) CleanupOrphanedFlowNodeCondition(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanupOrphanedFlowNodeConditionStmt, cleanupOrphanedFlowNodeCondition)
	return err
}

const cleanupOrphanedFlowNodeFor = `-- name: CleanupOrphanedFlowNodeFor :exec

DELETE FROM flow_node_for WHERE flow_node_id NOT IN (SELECT id FROM flow_node)
`

// Cleanup queries for orphaned flow_node sub-table records
// (used when FK constraints are removed for flexible insert ordering)
func (q *Queries) CleanupOrphanedFlowNodeFor(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanupOrphanedFlowNodeForStmt, cleanupOrphanedFlowNodeFor)
	return err
}

const cleanupOrphanedFlowNodeForEach = `-- name: CleanupOrphanedFlowNodeForEach :exec
DELETE FROM flow_node_for_each WHERE flow_node_id NOT IN (SELECT id FROM flow_node)
`

func (q *Queries) CleanupOrphanedFlowNodeForEach(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanupOrphanedFlowNodeForEachStmt, cleanupOrphanedFlowNodeForEach)
	return err
}

const cleanupOrphanedFlowNodeHttp = `-- name: CleanupOrphanedFlowNodeHttp :exec
DELETE FROM flow_node_http WHERE flow_node_id NOT IN (SELECT id FROM flow_node)
`

func (q *Queries) CleanupOrphanedFlowNodeHttp(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanupOrphanedFlowNodeHttpStmt, cleanupOrphanedFlowNodeHttp)
	return err
}

const cleanupOrphanedFlowNodeJs = `-- name: CleanupOrphanedFlowNodeJs :exec
DELETE FROM flow_node_js WHERE flow_node_id NOT IN (SELECT id FROM flow_node)
`

func (q *Queries) CleanupOrphanedFlowNodeJs(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanupOrphanedFlowNodeJsStmt, cleanupOrphanedFlowNodeJs)
	return err
}

const cleanupOrphanedNodeExecutions = `-- name: CleanupOrphanedNodeExecutions :exec
DELETE FROM node_execution WHERE node_id NOT IN (SELECT id FROM flow_node)
`

func (q *Queries) CleanupOrphanedNodeExecutions(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanupOrphanedNodeExecutionsStmt, cleanupOrphanedNodeExecutions)
	return err
}

const createFlow = `-- name: CreateFlow :exec
INSERT INTO
  flow (id, workspace_id, version_parent_id, name, duration, running, node_id_mapping)
VALUES
  (?, ?, ?, ?, ?, ?, ?)
`

type CreateFlowParams struct {
	ID              idwrap.IDWrap
	WorkspaceID     idwrap.IDWrap
	VersionParentID *idwrap.IDWrap
	Name            string
	Duration        int32
	Running         bool
	NodeIDMapping   []byte
}

func (q *Queries) CreateFlow(ctx context.Context, arg CreateFlowParams) error {
	_, err := q.exec(ctx, q.createFlowStmt, createFlow,
		arg.ID,
		arg.WorkspaceID,
		arg.VersionParentID,
		arg.Name,
		arg.Duration,
		arg.Running,
		arg.NodeIDMapping,
	)
	return err
}

const createFlowEdge = `-- name: CreateFlowEdge :exec
INSERT INTO
  flow_edge (id, flow_id, source_id, target_id, source_handle, state)
VALUES
  (?, ?, ?, ?, ?, 0)
`

type CreateFlowEdgeParams struct {
	ID           idwrap.IDWrap
	FlowID       idwrap.IDWrap
	SourceID     idwrap.IDWrap
	TargetID     idwrap.IDWrap
	SourceHandle int32
}

func (q *Queries) CreateFlowEdge(ctx context.Context, arg CreateFlowEdgeParams) error {
	_, err := q.exec(ctx, q.createFlowEdgeStmt, createFlowEdge,
		arg.ID,
		arg.FlowID,
		arg.SourceID,
		arg.TargetID,
		arg.SourceHandle,
	)
	return err
}

const createFlowNode = `-- name: CreateFlowNode :exec
INSERT INTO
  flow_node (id, flow_id, name, node_kind, position_x, position_y, state)
VALUES
  (?, ?, ?, ?, ?, ?, 0)
`

type CreateFlowNodeParams struct {
	ID        idwrap.IDWrap
	FlowID    idwrap.IDWrap
	Name      string
	NodeKind  int32
	PositionX float64
	PositionY float64
}

func (q *Queries) CreateFlowNode(ctx context.Context, arg CreateFlowNodeParams) error {
	_, err := q.exec(ctx, q.createFlowNodeStmt, createFlowNode,
		arg.ID,
		arg.FlowID,
		arg.Name,
		arg.NodeKind,
		arg.PositionX,
		arg.PositionY,
	)
	return err
}

const createFlowNodeCondition = `-- name: CreateFlowNodeCondition :exec
INSERT INTO
  flow_node_condition (flow_node_id, expression)
VALUES
  (?, ?)
`

type CreateFlowNodeConditionParams struct {
	FlowNodeID idwrap.IDWrap
	Expression string
}

func (q *Queries) CreateFlowNodeCondition(ctx context.Context, arg CreateFlowNodeConditionParams) error {
	_, err := q.exec(ctx, q.createFlowNodeConditionStmt, createFlowNodeCondition, arg.FlowNodeID, arg.Expression)
	return err
}

const createFlowNodeFor = `-- name: CreateFlowNodeFor :exec
INSERT INTO
  flow_node_for (flow_node_id, iter_count, error_handling, expression)
VALUES
  (?, ?, ?, ?)
`

type CreateFlowNodeForParams struct {
	FlowNodeID    idwrap.IDWrap
	IterCount     int64
	ErrorHandling int8
	Expression    string
}

func (q *Queries) CreateFlowNodeFor(ctx context.Context, arg CreateFlowNodeForParams) error {
	_, err := q.exec(ctx, q.createFlowNodeForStmt, createFlowNodeFor,
		arg.FlowNodeID,
		arg.IterCount,
		arg.ErrorHandling,
		arg.Expression,
	)
	return err
}

const createFlowNodeForEach = `-- name: CreateFlowNodeForEach :exec
INSERT INTO
  flow_node_for_each (flow_node_id, iter_expression, error_handling, expression)
VALUES
  (?, ?, ?, ?)
`

type CreateFlowNodeForEachParams struct {
	FlowNodeID     idwrap.IDWrap
	IterExpression string
	ErrorHandling  int8
	Expression     string
}

func (q *Queries) CreateFlowNodeForEach(ctx context.Context, arg CreateFlowNodeForEachParams) error {
	_, err := q.exec(ctx, q.createFlowNodeForEachStmt, createFlowNodeForEach,
		arg.FlowNodeID,
		arg.IterExpression,
		arg.ErrorHandling,
		arg.Expression,
	)
	return err
}

const createFlowNodeHTTP = `-- name: CreateFlowNodeHTTP :exec
INSERT INTO
  flow_node_http (
    flow_node_id,
    http_id,
    delta_http_id
  )
VALUES
  (?, ?, ?)
`

type CreateFlowNodeHTTPParams struct {
	FlowNodeID  idwrap.IDWrap
	HttpID      idwrap.IDWrap
	DeltaHttpID []byte
}

func (q *Queries) CreateFlowNodeHTTP(ctx context.Context, arg CreateFlowNodeHTTPParams) error {
	_, err := q.exec(ctx, q.createFlowNodeHTTPStmt, createFlowNodeHTTP, arg.FlowNodeID, arg.HttpID, arg.DeltaHttpID)
	return err
}

const createFlowNodeJs = `-- name: CreateFlowNodeJs :exec
INSERT INTO
  flow_node_js (flow_node_id, code, code_compress_type)
VALUES
  (?, ?, ?)
`

type CreateFlowNodeJsParams struct {
	FlowNodeID       idwrap.IDWrap
	Code             []byte
	CodeCompressType int8
}

func (q *Queries) CreateFlowNodeJs(ctx context.Context, arg CreateFlowNodeJsParams) error {
	_, err := q.exec(ctx, q.createFlowNodeJsStmt, createFlowNodeJs, arg.FlowNodeID, arg.Code, arg.CodeCompressType)
	return err
}

const createFlowNodesBulk = `-- name: CreateFlowNodesBulk :exec
INSERT INTO
  flow_node (id, flow_id, name, node_kind, position_x, position_y, state)
VALUES
  (?, ?, ?, ?, ?, ?, 0),
  (?, ?, ?, ?, ?, ?, 0),
  (?, ?, ?, ?, ?, ?, 0),
  (?, ?, ?, ?, ?, ?, 0),
  (?, ?, ?, ?, ?, ?, 0),
  (?, ?, ?, ?, ?, ?, 0),
  (?, ?, ?, ?, ?, ?, 0),
  (?, ?, ?, ?, ?, ?, 0),
  (?, ?, ?, ?, ?, ?, 0),
  (?, ?, ?, ?, ?, ?, 0)
`

type CreateFlowNodesBulkParams struct {
	ID           idwrap.IDWrap
	FlowID       idwrap.IDWrap
	Name         string
	NodeKind     int32
	PositionX    float64
	PositionY    float64
	ID_2         idwrap.IDWrap
	FlowID_2     idwrap.IDWrap
	Name_2       string
	NodeKind_2   int32
	PositionX_2  float64
	PositionY_2  float64
	ID_3         idwrap.IDWrap
	FlowID_3     idwrap.IDWrap
	Name_3       string
	NodeKind_3   int32
	PositionX_3  float64
	PositionY_3  float64
	ID_4         idwrap.IDWrap
	FlowID_4     idwrap.IDWrap
	Name_4       string
	NodeKind_4   int32
	PositionX_4  float64
	PositionY_4  float64
	ID_5         idwrap.IDWrap
	FlowID_5     idwrap.IDWrap
	Name_5       string
	NodeKind_5   int32
	PositionX_5  float64
	PositionY_5  float64
	ID_6         idwrap.IDWrap
	FlowID_6     idwrap.IDWrap
	Name_6       string
	NodeKind_6   int32
	PositionX_6  float64
	PositionY_6  float64
	ID_7         idwrap.IDWrap
	FlowID_7     idwrap.IDWrap
	Name_7       string
	NodeKind_7   int32
	PositionX_7  float64
	PositionY_7  float64
	ID_8         idwrap.IDWrap
	FlowID_8     idwrap.IDWrap
	Name_8       string
	NodeKind_8   int32
	PositionX_8  float64
	PositionY_8  float64
	ID_9         idwrap.IDWrap
	FlowID_9     idwrap.IDWrap
	Name_9       string
	NodeKind_9   int32
	PositionX_9  float64
	PositionY_9  float64
	ID_10        idwrap.IDWrap
	FlowID_10    idwrap.IDWrap
	Name_10      string
	NodeKind_10  int32
	PositionX_10 float64
	PositionY_10 float64
}

func (q *Queries) CreateFlowNodesBulk(ctx context.Context, arg CreateFlowNodesBulkParams) error {
	_, err := q.exec(ctx, q.createFlowNodesBulkStmt, createFlowNodesBulk,
		arg.ID,
		arg.FlowID,
		arg.Name,
		arg.NodeKind,
		arg.PositionX,
		arg.PositionY,
		arg.ID_2,
		arg.FlowID_2,
		arg.Name_2,
		arg.NodeKind_2,
		arg.PositionX_2,
		arg.PositionY_2,
		arg.ID_3,
		arg.FlowID_3,
		arg.Name_3,
		arg.NodeKind_3,
		arg.PositionX_3,
		arg.PositionY_3,
		arg.ID_4,
		arg.FlowID_4,
		arg.Name_4,
		arg.NodeKind_4,
		arg.PositionX_4,
		arg.PositionY_4,
		arg.ID_5,
		arg.FlowID_5,
		arg.Name_5,
		arg.NodeKind_5,
		arg.PositionX_5,
		arg.PositionY_5,
		arg.ID_6,
		arg.FlowID_6,
		arg.Name_6,
		arg.NodeKind_6,
		arg.PositionX_6,
		arg.PositionY_6,
		arg.ID_7,
		arg.FlowID_7,
		arg.Name_7,
		arg.NodeKind_7,
		arg.PositionX_7,
		arg.PositionY_7,
		arg.ID_8,
		arg.FlowID_8,
		arg.Name_8,
		arg.NodeKind_8,
		arg.PositionX_8,
		arg.PositionY_8,
		arg.ID_9,
		arg.FlowID_9,
		arg.Name_9,
		arg.NodeKind_9,
		arg.PositionX_9,
		arg.PositionY_9,
		arg.ID_10,
		arg.FlowID_10,
		arg.Name_10,
		arg.NodeKind_10,
		arg.PositionX_10,
		arg.PositionY_10,
	)
	return err
}

const createFlowTag = `-- name: CreateFlowTag :exec
INSERT INTO
  flow_tag (id, flow_id, tag_id)
VALUES
  (?, ?, ?)
`

type CreateFlowTagParams struct {
	ID     idwrap.IDWrap
	FlowID idwrap.IDWrap
	TagID  idwrap.IDWrap
}

func (q *Queries) CreateFlowTag(ctx context.Context, arg CreateFlowTagParams) error {
	_, err := q.exec(ctx, q.createFlowTagStmt, createFlowTag, arg.ID, arg.FlowID, arg.TagID)
	return err
}

const createFlowVariable = `-- name: CreateFlowVariable :exec
INSERT INTO
  flow_variable (id, flow_id, key, value, enabled, description, display_order)
VALUES
  (?, ?, ?, ?, ?, ?, ?)
`

type CreateFlowVariableParams struct {
	ID           idwrap.IDWrap
	FlowID       idwrap.IDWrap
	Key          string
	Value        string
	Enabled      bool
	Description  string
	DisplayOrder float64
}

func (q *Queries) CreateFlowVariable(ctx context.Context, arg CreateFlowVariableParams) error {
	_, err := q.exec(ctx, q.createFlowVariableStmt, createFlowVariable,
		arg.ID,
		arg.FlowID,
		arg.Key,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.DisplayOrder,
	)
	return err
}

const createFlowVariableBulk = `-- name: CreateFlowVariableBulk :exec
INSERT INTO
  flow_variable (id, flow_id, key, value, enabled, description, display_order)
VALUES
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?)
`

type CreateFlowVariableBulkParams struct {
	ID              idwrap.IDWrap
	FlowID          idwrap.IDWrap
	Key             string
	Value           string
	Enabled         bool
	Description     string
	DisplayOrder    float64
	ID_2            idwrap.IDWrap
	FlowID_2        idwrap.IDWrap
	Key_2           string
	Value_2         string
	Enabled_2       bool
	Description_2   string
	DisplayOrder_2  float64
	ID_3            idwrap.IDWrap
	FlowID_3        idwrap.IDWrap
	Key_3           string
	Value_3         string
	Enabled_3       bool
	Description_3   string
	DisplayOrder_3  float64
	ID_4            idwrap.IDWrap
	FlowID_4        idwrap.IDWrap
	Key_4           string
	Value_4         string
	Enabled_4       bool
	Description_4   string
	DisplayOrder_4  float64
	ID_5            idwrap.IDWrap
	FlowID_5        idwrap.IDWrap
	Key_5           string
	Value_5         string
	Enabled_5       bool
	Description_5   string
	DisplayOrder_5  float64
	ID_6            idwrap.IDWrap
	FlowID_6        idwrap.IDWrap
	Key_6           string
	Value_6         string
	Enabled_6       bool
	Description_6   string
	DisplayOrder_6  float64
	ID_7            idwrap.IDWrap
	FlowID_7        idwrap.IDWrap
	Key_7           string
	Value_7         string
	Enabled_7       bool
	Description_7   string
	DisplayOrder_7  float64
	ID_8            idwrap.IDWrap
	FlowID_8        idwrap.IDWrap
	Key_8           string
	Value_8         string
	Enabled_8       bool
	Description_8   string
	DisplayOrder_8  float64
	ID_9            idwrap.IDWrap
	FlowID_9        idwrap.IDWrap
	Key_9           string
	Value_9         string
	Enabled_9       bool
	Description_9   string
	DisplayOrder_9  float64
	ID_10           idwrap.IDWrap
	FlowID_10       idwrap.IDWrap
	Key_10          string
	Value_10        string
	Enabled_10      bool
	Description_10  string
	DisplayOrder_10 float64
}

func (q *Queries) CreateFlowVariableBulk(ctx context.Context, arg CreateFlowVariableBulkParams) error {
	_, err := q.exec(ctx, q.createFlowVariableBulkStmt, createFlowVariableBulk,
		arg.ID,
		arg.FlowID,
		arg.Key,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.DisplayOrder,
		arg.ID_2,
		arg.FlowID_2,
		arg.Key_2,
		arg.Value_2,
		arg.Enabled_2,
		arg.Description_2,
		arg.DisplayOrder_2,
		arg.ID_3,
		arg.FlowID_3,
		arg.Key_3,
		arg.Value_3,
		arg.Enabled_3,
		arg.Description_3,
		arg.DisplayOrder_3,
		arg.ID_4,
		arg.FlowID_4,
		arg.Key_4,
		arg.Value_4,
		arg.Enabled_4,
		arg.Description_4,
		arg.DisplayOrder_4,
		arg.ID_5,
		arg.FlowID_5,
		arg.Key_5,
		arg.Value_5,
		arg.Enabled_5,
		arg.Description_5,
		arg.DisplayOrder_5,
		arg.ID_6,
		arg.FlowID_6,
		arg.Key_6,
		arg.Value_6,
		arg.Enabled_6,
		arg.Description_6,
		arg.DisplayOrder_6,
		arg.ID_7,
		arg.FlowID_7,
		arg.Key_7,
		arg.Value_7,
		arg.Enabled_7,
		arg.Description_7,
		arg.DisplayOrder_7,
		arg.ID_8,
		arg.FlowID_8,
		arg.Key_8,
		arg.Value_8,
		arg.Enabled_8,
		arg.Description_8,
		arg.DisplayOrder_8,
		arg.ID_9,
		arg.FlowID_9,
		arg.Key_9,
		arg.Value_9,
		arg.Enabled_9,
		arg.Description_9,
		arg.DisplayOrder_9,
		arg.ID_10,
		arg.FlowID_10,
		arg.Key_10,
		arg.Value_10,
		arg.Enabled_10,
		arg.Description_10,
		arg.DisplayOrder_10,
	)
	return err
}

const createFlowsBulk = `-- name: CreateFlowsBulk :exec
INSERT INTO
  flow (id, workspace_id, version_parent_id, name, duration, running, node_id_mapping)
VALUES
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?)
`

type CreateFlowsBulkParams struct {
	ID                 idwrap.IDWrap
	WorkspaceID        idwrap.IDWrap
	VersionParentID    *idwrap.IDWrap
	Name               string
	Duration           int32
	Running            bool
	NodeIDMapping      []byte
	ID_2               idwrap.IDWrap
	WorkspaceID_2      idwrap.IDWrap
	VersionParentID_2  *idwrap.IDWrap
	Name_2             string
	Duration_2         int32
	Running_2          bool
	NodeIDMapping_2    []byte
	ID_3               idwrap.IDWrap
	WorkspaceID_3      idwrap.IDWrap
	VersionParentID_3  *idwrap.IDWrap
	Name_3             string
	Duration_3         int32
	Running_3          bool
	NodeIDMapping_3    []byte
	ID_4               idwrap.IDWrap
	WorkspaceID_4      idwrap.IDWrap
	VersionParentID_4  *idwrap.IDWrap
	Name_4             string
	Duration_4         int32
	Running_4          bool
	NodeIDMapping_4    []byte
	ID_5               idwrap.IDWrap
	WorkspaceID_5      idwrap.IDWrap
	VersionParentID_5  *idwrap.IDWrap
	Name_5             string
	Duration_5         int32
	Running_5          bool
	NodeIDMapping_5    []byte
	ID_6               idwrap.IDWrap
	WorkspaceID_6      idwrap.IDWrap
	VersionParentID_6  *idwrap.IDWrap
	Name_6             string
	Duration_6         int32
	Running_6          bool
	NodeIDMapping_6    []byte
	ID_7               idwrap.IDWrap
	WorkspaceID_7      idwrap.IDWrap
	VersionParentID_7  *idwrap.IDWrap
	Name_7             string
	Duration_7         int32
	Running_7          bool
	NodeIDMapping_7    []byte
	ID_8               idwrap.IDWrap
	WorkspaceID_8      idwrap.IDWrap
	VersionParentID_8  *idwrap.IDWrap
	Name_8             string
	Duration_8         int32
	Running_8          bool
	NodeIDMapping_8    []byte
	ID_9               idwrap.IDWrap
	WorkspaceID_9      idwrap.IDWrap
	VersionParentID_9  *idwrap.IDWrap
	Name_9             string
	Duration_9         int32
	Running_9          bool
	NodeIDMapping_9    []byte
	ID_10              idwrap.IDWrap
	WorkspaceID_10     idwrap.IDWrap
	VersionParentID_10 *idwrap.IDWrap
	Name_10            string
	Duration_10        int32
	Running_10         bool
	NodeIDMapping_10   []byte
}

func (q *Queries) CreateFlowsBulk(ctx context.Context, arg CreateFlowsBulkParams) error {
	_, err := q.exec(ctx, q.createFlowsBulkStmt, createFlowsBulk,
		arg.ID,
		arg.WorkspaceID,
		arg.VersionParentID,
		arg.Name,
		arg.Duration,
		arg.Running,
		arg.NodeIDMapping,
		arg.ID_2,
		arg.WorkspaceID_2,
		arg.VersionParentID_2,
		arg.Name_2,
		arg.Duration_2,
		arg.Running_2,
		arg.NodeIDMapping_2,
		arg.ID_3,
		arg.WorkspaceID_3,
		arg.VersionParentID_3,
		arg.Name_3,
		arg.Duration_3,
		arg.Running_3,
		arg.NodeIDMapping_3,
		arg.ID_4,
		arg.WorkspaceID_4,
		arg.VersionParentID_4,
		arg.Name_4,
		arg.Duration_4,
		arg.Running_4,
		arg.NodeIDMapping_4,
		arg.ID_5,
		arg.WorkspaceID_5,
		arg.VersionParentID_5,
		arg.Name_5,
		arg.Duration_5,
		arg.Running_5,
		arg.NodeIDMapping_5,
		arg.ID_6,
		arg.WorkspaceID_6,
		arg.VersionParentID_6,
		arg.Name_6,
		arg.Duration_6,
		arg.Running_6,
		arg.NodeIDMapping_6,
		arg.ID_7,
		arg.WorkspaceID_7,
		arg.VersionParentID_7,
		arg.Name_7,
		arg.Duration_7,
		arg.Running_7,
		arg.NodeIDMapping_7,
		arg.ID_8,
		arg.WorkspaceID_8,
		arg.VersionParentID_8,
		arg.Name_8,
		arg.Duration_8,
		arg.Running_8,
		arg.NodeIDMapping_8,
		arg.ID_9,
		arg.WorkspaceID_9,
		arg.VersionParentID_9,
		arg.Name_9,
		arg.Duration_9,
		arg.Running_9,
		arg.NodeIDMapping_9,
		arg.ID_10,
		arg.WorkspaceID_10,
		arg.VersionParentID_10,
		arg.Name_10,
		arg.Duration_10,
		arg.Running_10,
		arg.NodeIDMapping_10,
	)
	return err
}

const createMigration = `-- name: CreateMigration :exec
INSERT INTO
  migration (id, version, description, apply_at)
VALUES
  (?, ?, ?, ?)
`

type CreateMigrationParams struct {
	ID          []byte
	Version     int32
	Description string
	ApplyAt     int64
}

func (q *Queries) CreateMigration(ctx context.Context, arg CreateMigrationParams) error {
	_, err := q.exec(ctx, q.createMigrationStmt, createMigration,
		arg.ID,
		arg.Version,
		arg.Description,
		arg.ApplyAt,
	)
	return err
}

const createNodeExecution = `-- name: CreateNodeExecution :one
INSERT INTO node_execution (
  id, node_id, name, state, error, input_data, input_data_compress_type,
  output_data, output_data_compress_type, http_response_id, completed_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, http_response_id, completed_at
`

type CreateNodeExecutionParams struct {
	ID                     idwrap.IDWrap
	NodeID                 idwrap.IDWrap
	Name                   string
	State                  int8
	Error                  sql.NullString
	InputData              []byte
	InputDataCompressType  int8
	OutputData             []byte
	OutputDataCompressType int8
	HttpResponseID         *idwrap.IDWrap
	CompletedAt            sql.NullInt64
}

func (q *Queries) CreateNodeExecution(ctx context.Context, arg CreateNodeExecutionParams) (NodeExecution, error) {
	row := q.queryRow(ctx, q.createNodeExecutionStmt, createNodeExecution,
		arg.ID,
		arg.NodeID,
		arg.Name,
		arg.State,
		arg.Error,
		arg.InputData,
		arg.InputDataCompressType,
		arg.OutputData,
		arg.OutputDataCompressType,
		arg.HttpResponseID,
		arg.CompletedAt,
	)
	var i NodeExecution
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Name,
		&i.State,
		&i.Error,
		&i.InputData,
		&i.InputDataCompressType,
		&i.OutputData,
		&i.OutputDataCompressType,
		&i.HttpResponseID,
		&i.CompletedAt,
	)
	return i, err
}

const createTag = `-- name: CreateTag :exec
INSERT INTO
  tag (id, workspace_id, name, color)
VALUES
  (?, ?, ?, ?)
`

type CreateTagParams struct {
	ID          idwrap.IDWrap
	WorkspaceID idwrap.IDWrap
	Name        string
	Color       int8
}

func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) error {
	_, err := q.exec(ctx, q.createTagStmt, createTag,
		arg.ID,
		arg.WorkspaceID,
		arg.Name,
		arg.Color,
	)
	return err
}

const deleteFlow = `-- name: DeleteFlow :exec
DELETE FROM flow
WHERE
  id = ?
`

func (q *Queries) DeleteFlow(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowStmt, deleteFlow, id)
	return err
}

const deleteFlowEdge = `-- name: DeleteFlowEdge :exec
DELETE FROM
  flow_edge
WHERE
  id = ?
`

func (q *Queries) DeleteFlowEdge(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowEdgeStmt, deleteFlowEdge, id)
	return err
}

const deleteFlowNode = `-- name: DeleteFlowNode :exec
DELETE FROM flow_node
WHERE
  id = ?
`

func (q *Queries) DeleteFlowNode(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeStmt, deleteFlowNode, id)
	return err
}

const deleteFlowNodeCondition = `-- name: DeleteFlowNodeCondition :exec
DELETE FROM flow_node_condition
WHERE
  flow_node_id = ?
`

func (q *Queries) DeleteFlowNodeCondition(ctx context.Context, flowNodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeConditionStmt, deleteFlowNodeCondition, flowNodeID)
	return err
}

const deleteFlowNodeFor = `-- name: DeleteFlowNodeFor :exec
DELETE FROM flow_node_for
WHERE
  flow_node_id = ?
`

func (q *Queries) DeleteFlowNodeFor(ctx context.Context, flowNodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeForStmt, deleteFlowNodeFor, flowNodeID)
	return err
}

const deleteFlowNodeForEach = `-- name: DeleteFlowNodeForEach :exec
DELETE FROM flow_node_for_each
WHERE
  flow_node_id = ?
`

func (q *Queries) DeleteFlowNodeForEach(ctx context.Context, flowNodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeForEachStmt, deleteFlowNodeForEach, flowNodeID)
	return err
}

const deleteFlowNodeHTTP = `-- name: DeleteFlowNodeHTTP :exec
DELETE FROM flow_node_http
WHERE
  flow_node_id = ?
`

func (q *Queries) DeleteFlowNodeHTTP(ctx context.Context, flowNodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeHTTPStmt, deleteFlowNodeHTTP, flowNodeID)
	return err
}

const deleteFlowNodeJs = `-- name: DeleteFlowNodeJs :exec
DELETE FROM flow_node_js
WHERE
  flow_node_id = ?
`

func (q *Queries) DeleteFlowNodeJs(ctx context.Context, flowNodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowNodeJsStmt, deleteFlowNodeJs, flowNodeID)
	return err
}

const deleteFlowTag = `-- name: DeleteFlowTag :exec
DELETE FROM flow_tag
WHERE
  id = ?
`

func (q *Queries) DeleteFlowTag(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowTagStmt, deleteFlowTag, id)
	return err
}

const deleteFlowVariable = `-- name: DeleteFlowVariable :exec
DELETE FROM flow_variable
WHERE
  id = ?
`

func (q *Queries) DeleteFlowVariable(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFlowVariableStmt, deleteFlowVariable, id)
	return err
}

const deleteMigration = `-- name: DeleteMigration :exec
DELETE FROM migration
WHERE
  id = ?
`

func (q *Queries) DeleteMigration(ctx context.Context, id []byte) error {
	_, err := q.exec(ctx, q.deleteMigrationStmt, deleteMigration, id)
	return err
}

const deleteNodeExecutionsByNodeID = `-- name: DeleteNodeExecutionsByNodeID :exec
DELETE FROM node_execution WHERE node_id = ?
`

func (q *Queries) DeleteNodeExecutionsByNodeID(ctx context.Context, nodeID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteNodeExecutionsByNodeIDStmt, deleteNodeExecutionsByNodeID, nodeID)
	return err
}

const deleteNodeExecutionsByNodeIDs = `-- name: DeleteNodeExecutionsByNodeIDs :exec
DELETE FROM node_execution WHERE node_id IN (/*SLICE:node_ids*/?)
`

func (q *Queries) DeleteNodeExecutionsByNodeIDs(ctx context.Context, nodeIds []idwrap.IDWrap) error {
	query := deleteNodeExecutionsByNodeIDs
	var queryParams []interface{}
	if len(nodeIds) > 0 {
		for _, v := range nodeIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:node_ids*/?", strings.Repeat(",?", len(nodeIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:node_ids*/?", "NULL", 1)
	}
	_, err := q.exec(ctx, nil, query, queryParams...)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tag
WHERE
  id = ?
`

func (q *Queries) DeleteTag(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteTagStmt, deleteTag, id)
	return err
}

const getAllFlowsByWorkspaceID = `-- name: GetAllFlowsByWorkspaceID :many
SELECT
  id,
  workspace_id,
  version_parent_id,
  name,
  duration,
  running,
  node_id_mapping
FROM
  flow
WHERE
  workspace_id = ?
`

// Returns all flows including versions for TanStack DB sync
func (q *Queries) GetAllFlowsByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]Flow, error) {
	rows, err := q.query(ctx, q.getAllFlowsByWorkspaceIDStmt, getAllFlowsByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Flow{}
	for rows.Next() {
		var i Flow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.VersionParentID,
			&i.Name,
			&i.Duration,
			&i.Running,
			&i.NodeIDMapping,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlow = `-- name: GetFlow :one
SELECT
  id,
  workspace_id,
  version_parent_id,
  name,
  duration,
  running,
  node_id_mapping
FROM
  flow
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetFlow(ctx context.Context, id idwrap.IDWrap) (Flow, error) {
	row := q.queryRow(ctx, q.getFlowStmt, getFlow, id)
	var i Flow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.VersionParentID,
		&i.Name,
		&i.Duration,
		&i.Running,
		&i.NodeIDMapping,
	)
	return i, err
}

const getFlowEdge = `-- name: GetFlowEdge :one
SELECT
  id,
  flow_id,
  source_id,
  target_id,
  source_handle,
  state
FROM
  flow_edge
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetFlowEdge(ctx context.Context, id idwrap.IDWrap) (FlowEdge, error) {
	row := q.queryRow(ctx, q.getFlowEdgeStmt, getFlowEdge, id)
	var i FlowEdge
	err := row.Scan(
		&i.ID,
		&i.FlowID,
		&i.SourceID,
		&i.TargetID,
		&i.SourceHandle,
		&i.State,
	)
	return i, err
}

const getFlowEdgesByFlowID = `-- name: GetFlowEdgesByFlowID :many
SELECT
  id,
  flow_id,
  source_id,
  target_id,
  source_handle,
  state
FROM
  flow_edge
WHERE
  flow_id = ?
`

func (q *Queries) GetFlowEdgesByFlowID(ctx context.Context, flowID idwrap.IDWrap) ([]FlowEdge, error) {
	rows, err := q.query(ctx, q.getFlowEdgesByFlowIDStmt, getFlowEdgesByFlowID, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowEdge{}
	for rows.Next() {
		var i FlowEdge
		if err := rows.Scan(
			&i.ID,
			&i.FlowID,
			&i.SourceID,
			&i.TargetID,
			&i.SourceHandle,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowEdgesByFlowIDs = `-- name: GetFlowEdgesByFlowIDs :many
SELECT id, flow_id
FROM flow_edge
WHERE flow_id IN (/*SLICE:flow_ids*/?)
`

type GetFlowEdgesByFlowIDsRow struct {
	ID     idwrap.IDWrap
	FlowID idwrap.IDWrap
}

// Batch query for cascade collection - fetches all edges for multiple flows
func (q *Queries) GetFlowEdgesByFlowIDs(ctx context.Context, flowIds []idwrap.IDWrap) ([]GetFlowEdgesByFlowIDsRow, error) {
	query := getFlowEdgesByFlowIDs
	var queryParams []interface{}
	if len(flowIds) > 0 {
		for _, v := range flowIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:flow_ids*/?", strings.Repeat(",?", len(flowIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:flow_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFlowEdgesByFlowIDsRow{}
	for rows.Next() {
		var i GetFlowEdgesByFlowIDsRow
		if err := rows.Scan(&i.ID, &i.FlowID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowNode = `-- name: GetFlowNode :one
SELECT
  id,
  flow_id,
  name,
  node_kind,
  position_x,
  position_y,
  state
FROM
  flow_node
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetFlowNode(ctx context.Context, id idwrap.IDWrap) (FlowNode, error) {
	row := q.queryRow(ctx, q.getFlowNodeStmt, getFlowNode, id)
	var i FlowNode
	err := row.Scan(
		&i.ID,
		&i.FlowID,
		&i.Name,
		&i.NodeKind,
		&i.PositionX,
		&i.PositionY,
		&i.State,
	)
	return i, err
}

const getFlowNodeCondition = `-- name: GetFlowNodeCondition :one
SELECT
  flow_node_id,
  expression
FROM
  flow_node_condition
WHERE
  flow_node_id = ?
LIMIT 1
`

func (q *Queries) GetFlowNodeCondition(ctx context.Context, flowNodeID idwrap.IDWrap) (FlowNodeCondition, error) {
	row := q.queryRow(ctx, q.getFlowNodeConditionStmt, getFlowNodeCondition, flowNodeID)
	var i FlowNodeCondition
	err := row.Scan(&i.FlowNodeID, &i.Expression)
	return i, err
}

const getFlowNodeFor = `-- name: GetFlowNodeFor :one
SELECT
  flow_node_id,
  iter_count,
  error_handling,
  expression
FROM
  flow_node_for
WHERE
  flow_node_id = ?
LIMIT 1
`

func (q *Queries) GetFlowNodeFor(ctx context.Context, flowNodeID idwrap.IDWrap) (FlowNodeFor, error) {
	row := q.queryRow(ctx, q.getFlowNodeForStmt, getFlowNodeFor, flowNodeID)
	var i FlowNodeFor
	err := row.Scan(
		&i.FlowNodeID,
		&i.IterCount,
		&i.ErrorHandling,
		&i.Expression,
	)
	return i, err
}

const getFlowNodeForEach = `-- name: GetFlowNodeForEach :one
SELECT
  flow_node_id,
  iter_expression,
  error_handling,
  expression
FROM
  flow_node_for_each
WHERE
  flow_node_id = ?
LIMIT 1
`

func (q *Queries) GetFlowNodeForEach(ctx context.Context, flowNodeID idwrap.IDWrap) (FlowNodeForEach, error) {
	row := q.queryRow(ctx, q.getFlowNodeForEachStmt, getFlowNodeForEach, flowNodeID)
	var i FlowNodeForEach
	err := row.Scan(
		&i.FlowNodeID,
		&i.IterExpression,
		&i.ErrorHandling,
		&i.Expression,
	)
	return i, err
}

const getFlowNodeHTTP = `-- name: GetFlowNodeHTTP :one
SELECT
  flow_node_id,
  http_id,
  delta_http_id
FROM
  flow_node_http
WHERE
  flow_node_id = ?
LIMIT 1
`

func (q *Queries) GetFlowNodeHTTP(ctx context.Context, flowNodeID idwrap.IDWrap) (FlowNodeHttp, error) {
	row := q.queryRow(ctx, q.getFlowNodeHTTPStmt, getFlowNodeHTTP, flowNodeID)
	var i FlowNodeHttp
	err := row.Scan(&i.FlowNodeID, &i.HttpID, &i.DeltaHttpID)
	return i, err
}

const getFlowNodeJs = `-- name: GetFlowNodeJs :one
SELECT
  flow_node_id,
  code,
  code_compress_type
FROM
  flow_node_js
WHERE
  flow_node_id = ?
LIMIT 1
`

func (q *Queries) GetFlowNodeJs(ctx context.Context, flowNodeID idwrap.IDWrap) (FlowNodeJ, error) {
	row := q.queryRow(ctx, q.getFlowNodeJsStmt, getFlowNodeJs, flowNodeID)
	var i FlowNodeJ
	err := row.Scan(&i.FlowNodeID, &i.Code, &i.CodeCompressType)
	return i, err
}

const getFlowNodesByFlowID = `-- name: GetFlowNodesByFlowID :many
SELECT
  id,
  flow_id,
  name,
  node_kind,
  position_x,
  position_y,
  state
FROM
  flow_node
WHERE
  flow_id = ?
`

func (q *Queries) GetFlowNodesByFlowID(ctx context.Context, flowID idwrap.IDWrap) ([]FlowNode, error) {
	rows, err := q.query(ctx, q.getFlowNodesByFlowIDStmt, getFlowNodesByFlowID, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowNode{}
	for rows.Next() {
		var i FlowNode
		if err := rows.Scan(
			&i.ID,
			&i.FlowID,
			&i.Name,
			&i.NodeKind,
			&i.PositionX,
			&i.PositionY,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowNodesByFlowIDs = `-- name: GetFlowNodesByFlowIDs :many
SELECT id, flow_id
FROM flow_node
WHERE flow_id IN (/*SLICE:flow_ids*/?)
`

type GetFlowNodesByFlowIDsRow struct {
	ID     idwrap.IDWrap
	FlowID idwrap.IDWrap
}

// Batch query for cascade collection - fetches all nodes for multiple flows
func (q *Queries) GetFlowNodesByFlowIDs(ctx context.Context, flowIds []idwrap.IDWrap) ([]GetFlowNodesByFlowIDsRow, error) {
	query := getFlowNodesByFlowIDs
	var queryParams []interface{}
	if len(flowIds) > 0 {
		for _, v := range flowIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:flow_ids*/?", strings.Repeat(",?", len(flowIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:flow_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFlowNodesByFlowIDsRow{}
	for rows.Next() {
		var i GetFlowNodesByFlowIDsRow
		if err := rows.Scan(&i.ID, &i.FlowID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowTag = `-- name: GetFlowTag :one
SELECT
  id,
  flow_id,
  tag_id
FROM flow_tag
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetFlowTag(ctx context.Context, id idwrap.IDWrap) (FlowTag, error) {
	row := q.queryRow(ctx, q.getFlowTagStmt, getFlowTag, id)
	var i FlowTag
	err := row.Scan(&i.ID, &i.FlowID, &i.TagID)
	return i, err
}

const getFlowTagsByFlowID = `-- name: GetFlowTagsByFlowID :many
SELECT
  id,
  flow_id,
  tag_id
FROM
  flow_tag
WHERE
  flow_id = ?
`

func (q *Queries) GetFlowTagsByFlowID(ctx context.Context, flowID idwrap.IDWrap) ([]FlowTag, error) {
	rows, err := q.query(ctx, q.getFlowTagsByFlowIDStmt, getFlowTagsByFlowID, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowTag{}
	for rows.Next() {
		var i FlowTag
		if err := rows.Scan(&i.ID, &i.FlowID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowTagsByTagID = `-- name: GetFlowTagsByTagID :many
SELECT
  id,
  flow_id,
  tag_id
FROM
  flow_tag
WHERE
  tag_id = ?
`

func (q *Queries) GetFlowTagsByTagID(ctx context.Context, tagID idwrap.IDWrap) ([]FlowTag, error) {
	rows, err := q.query(ctx, q.getFlowTagsByTagIDStmt, getFlowTagsByTagID, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowTag{}
	for rows.Next() {
		var i FlowTag
		if err := rows.Scan(&i.ID, &i.FlowID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowVariable = `-- name: GetFlowVariable :one
SELECT
  id,
  flow_id,
  key,
  value,
  enabled,
  description,
  display_order
FROM
  flow_variable
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetFlowVariable(ctx context.Context, id idwrap.IDWrap) (FlowVariable, error) {
	row := q.queryRow(ctx, q.getFlowVariableStmt, getFlowVariable, id)
	var i FlowVariable
	err := row.Scan(
		&i.ID,
		&i.FlowID,
		&i.Key,
		&i.Value,
		&i.Enabled,
		&i.Description,
		&i.DisplayOrder,
	)
	return i, err
}

const getFlowVariablesByFlowID = `-- name: GetFlowVariablesByFlowID :many
SELECT
  id,
  flow_id,
  key,
  value,
  enabled,
  description,
  display_order
FROM
  flow_variable
WHERE
  flow_id = ?
`

func (q *Queries) GetFlowVariablesByFlowID(ctx context.Context, flowID idwrap.IDWrap) ([]FlowVariable, error) {
	rows, err := q.query(ctx, q.getFlowVariablesByFlowIDStmt, getFlowVariablesByFlowID, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowVariable{}
	for rows.Next() {
		var i FlowVariable
		if err := rows.Scan(
			&i.ID,
			&i.FlowID,
			&i.Key,
			&i.Value,
			&i.Enabled,
			&i.Description,
			&i.DisplayOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowVariablesByFlowIDOrdered = `-- name: GetFlowVariablesByFlowIDOrdered :many
SELECT
  id,
  flow_id,
  key,
  value,
  enabled,
  description,
  display_order
FROM
  flow_variable
WHERE
  flow_id = ?
ORDER BY
  display_order
`

func (q *Queries) GetFlowVariablesByFlowIDOrdered(ctx context.Context, flowID idwrap.IDWrap) ([]FlowVariable, error) {
	rows, err := q.query(ctx, q.getFlowVariablesByFlowIDOrderedStmt, getFlowVariablesByFlowIDOrdered, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowVariable{}
	for rows.Next() {
		var i FlowVariable
		if err := rows.Scan(
			&i.ID,
			&i.FlowID,
			&i.Key,
			&i.Value,
			&i.Enabled,
			&i.Description,
			&i.DisplayOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowVariablesByFlowIDs = `-- name: GetFlowVariablesByFlowIDs :many
SELECT id, flow_id
FROM flow_variable
WHERE flow_id IN (/*SLICE:flow_ids*/?)
`

type GetFlowVariablesByFlowIDsRow struct {
	ID     idwrap.IDWrap
	FlowID idwrap.IDWrap
}

// Batch query for cascade collection - fetches all variables for multiple flows
func (q *Queries) GetFlowVariablesByFlowIDs(ctx context.Context, flowIds []idwrap.IDWrap) ([]GetFlowVariablesByFlowIDsRow, error) {
	query := getFlowVariablesByFlowIDs
	var queryParams []interface{}
	if len(flowIds) > 0 {
		for _, v := range flowIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:flow_ids*/?", strings.Repeat(",?", len(flowIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:flow_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFlowVariablesByFlowIDsRow{}
	for rows.Next() {
		var i GetFlowVariablesByFlowIDsRow
		if err := rows.Scan(&i.ID, &i.FlowID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowsByVersionParentID = `-- name: GetFlowsByVersionParentID :many
SELECT
  id,
  workspace_id,
  version_parent_id,
  name,
  duration,
  running,
  node_id_mapping
FROM
  flow
WHERE
  version_parent_id is ?
`

func (q *Queries) GetFlowsByVersionParentID(ctx context.Context, versionParentID *idwrap.IDWrap) ([]Flow, error) {
	rows, err := q.query(ctx, q.getFlowsByVersionParentIDStmt, getFlowsByVersionParentID, versionParentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Flow{}
	for rows.Next() {
		var i Flow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.VersionParentID,
			&i.Name,
			&i.Duration,
			&i.Running,
			&i.NodeIDMapping,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowsByWorkspaceID = `-- name: GetFlowsByWorkspaceID :many
SELECT
  id,
  workspace_id,
  version_parent_id,
  name,
  duration,
  running,
  node_id_mapping
FROM
  flow
WHERE
  workspace_id = ? AND
  version_parent_id is NULL
`

func (q *Queries) GetFlowsByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]Flow, error) {
	rows, err := q.query(ctx, q.getFlowsByWorkspaceIDStmt, getFlowsByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Flow{}
	for rows.Next() {
		var i Flow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.VersionParentID,
			&i.Name,
			&i.Duration,
			&i.Running,
			&i.NodeIDMapping,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestNodeExecutionByNodeID = `-- name: GetLatestNodeExecutionByNodeID :one
SELECT id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, http_response_id, completed_at
FROM node_execution
WHERE node_id = ? AND completed_at IS NOT NULL
ORDER BY completed_at DESC, id DESC
LIMIT 1
`

func (q *Queries) GetLatestNodeExecutionByNodeID(ctx context.Context, nodeID idwrap.IDWrap) (NodeExecution, error) {
	row := q.queryRow(ctx, q.getLatestNodeExecutionByNodeIDStmt, getLatestNodeExecutionByNodeID, nodeID)
	var i NodeExecution
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Name,
		&i.State,
		&i.Error,
		&i.InputData,
		&i.InputDataCompressType,
		&i.OutputData,
		&i.OutputDataCompressType,
		&i.HttpResponseID,
		&i.CompletedAt,
	)
	return i, err
}

const getLatestVersionByParentID = `-- name: GetLatestVersionByParentID :one
SELECT
  id,
  workspace_id,
  version_parent_id,
  name,
  duration,
  running,
  node_id_mapping
FROM
  flow
WHERE
  version_parent_id = ?
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) GetLatestVersionByParentID(ctx context.Context, versionParentID *idwrap.IDWrap) (Flow, error) {
	row := q.queryRow(ctx, q.getLatestVersionByParentIDStmt, getLatestVersionByParentID, versionParentID)
	var i Flow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.VersionParentID,
		&i.Name,
		&i.Duration,
		&i.Running,
		&i.NodeIDMapping,
	)
	return i, err
}

const getMigration = `-- name: GetMigration :one
SELECT
  id,
  version,
  description,
  apply_at
FROM
  migration
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetMigration(ctx context.Context, id []byte) (Migration, error) {
	row := q.queryRow(ctx, q.getMigrationStmt, getMigration, id)
	var i Migration
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.Description,
		&i.ApplyAt,
	)
	return i, err
}

const getMigrations = `-- name: GetMigrations :many
SELECT
  id,
  version,
  description,
  apply_at
FROM
  migration
`

func (q *Queries) GetMigrations(ctx context.Context) ([]Migration, error) {
	rows, err := q.query(ctx, q.getMigrationsStmt, getMigrations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Migration{}
	for rows.Next() {
		var i Migration
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.Description,
			&i.ApplyAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeExecution = `-- name: GetNodeExecution :one
SELECT id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, http_response_id, completed_at FROM node_execution
WHERE id = ?
`

// Node Execution
func (q *Queries) GetNodeExecution(ctx context.Context, id idwrap.IDWrap) (NodeExecution, error) {
	row := q.queryRow(ctx, q.getNodeExecutionStmt, getNodeExecution, id)
	var i NodeExecution
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Name,
		&i.State,
		&i.Error,
		&i.InputData,
		&i.InputDataCompressType,
		&i.OutputData,
		&i.OutputDataCompressType,
		&i.HttpResponseID,
		&i.CompletedAt,
	)
	return i, err
}

const getNodeExecutionsByNodeID = `-- name: GetNodeExecutionsByNodeID :many
SELECT id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, http_response_id, completed_at
FROM node_execution
WHERE node_id = ? AND completed_at IS NOT NULL
ORDER BY completed_at DESC, id DESC
`

func (q *Queries) GetNodeExecutionsByNodeID(ctx context.Context, nodeID idwrap.IDWrap) ([]NodeExecution, error) {
	rows, err := q.query(ctx, q.getNodeExecutionsByNodeIDStmt, getNodeExecutionsByNodeID, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NodeExecution{}
	for rows.Next() {
		var i NodeExecution
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.Name,
			&i.State,
			&i.Error,
			&i.InputData,
			&i.InputDataCompressType,
			&i.OutputData,
			&i.OutputDataCompressType,
			&i.HttpResponseID,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTag = `-- name: GetTag :one
SELECT
  id,
  workspace_id,
  name,
  color
FROM
  tag
WHERE
  id = ?
LIMIT 1
`

func (q *Queries) GetTag(ctx context.Context, id idwrap.IDWrap) (Tag, error) {
	row := q.queryRow(ctx, q.getTagStmt, getTag, id)
	var i Tag
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Name,
		&i.Color,
	)
	return i, err
}

const getTagsByWorkspaceID = `-- name: GetTagsByWorkspaceID :many
SELECT
  id,
  workspace_id,
  name,
  color
FROM
  tag
WHERE
  workspace_id = ?
`

func (q *Queries) GetTagsByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]Tag, error) {
	rows, err := q.query(ctx, q.getTagsByWorkspaceIDStmt, getTagsByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.Color,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodeExecutions = `-- name: ListNodeExecutions :many
SELECT id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, http_response_id, completed_at FROM node_execution
WHERE node_id = ?
ORDER BY completed_at DESC, id DESC
LIMIT ? OFFSET ?
`

type ListNodeExecutionsParams struct {
	NodeID idwrap.IDWrap
	Limit  int64
	Offset int64
}

func (q *Queries) ListNodeExecutions(ctx context.Context, arg ListNodeExecutionsParams) ([]NodeExecution, error) {
	rows, err := q.query(ctx, q.listNodeExecutionsStmt, listNodeExecutions, arg.NodeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NodeExecution{}
	for rows.Next() {
		var i NodeExecution
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.Name,
			&i.State,
			&i.Error,
			&i.InputData,
			&i.InputDataCompressType,
			&i.OutputData,
			&i.OutputDataCompressType,
			&i.HttpResponseID,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodeExecutionsByFlowRun = `-- name: ListNodeExecutionsByFlowRun :many
SELECT ne.id, ne.node_id, ne.name, ne.state, ne.error, ne.input_data, ne.input_data_compress_type, ne.output_data, ne.output_data_compress_type, ne.http_response_id, ne.completed_at FROM node_execution ne
JOIN flow_node fn ON ne.node_id = fn.id
WHERE fn.flow_id = ?
ORDER BY ne.completed_at DESC, ne.id DESC
`

func (q *Queries) ListNodeExecutionsByFlowRun(ctx context.Context, flowID idwrap.IDWrap) ([]NodeExecution, error) {
	rows, err := q.query(ctx, q.listNodeExecutionsByFlowRunStmt, listNodeExecutionsByFlowRun, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NodeExecution{}
	for rows.Next() {
		var i NodeExecution
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.Name,
			&i.State,
			&i.Error,
			&i.InputData,
			&i.InputDataCompressType,
			&i.OutputData,
			&i.OutputDataCompressType,
			&i.HttpResponseID,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNodeExecutionsByState = `-- name: ListNodeExecutionsByState :many
SELECT id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, http_response_id, completed_at FROM node_execution
WHERE node_id = ? AND state = ?
ORDER BY completed_at DESC, id DESC
LIMIT ? OFFSET ?
`

type ListNodeExecutionsByStateParams struct {
	NodeID idwrap.IDWrap
	State  int8
	Limit  int64
	Offset int64
}

func (q *Queries) ListNodeExecutionsByState(ctx context.Context, arg ListNodeExecutionsByStateParams) ([]NodeExecution, error) {
	rows, err := q.query(ctx, q.listNodeExecutionsByStateStmt, listNodeExecutionsByState,
		arg.NodeID,
		arg.State,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NodeExecution{}
	for rows.Next() {
		var i NodeExecution
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.Name,
			&i.State,
			&i.Error,
			&i.InputData,
			&i.InputDataCompressType,
			&i.OutputData,
			&i.OutputDataCompressType,
			&i.HttpResponseID,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFlow = `-- name: UpdateFlow :exec
UPDATE flow
SET
  name = ?,
  duration = ?,
  running = ?
WHERE
  id = ?
`

type UpdateFlowParams struct {
	Name     string
	Duration int32
	Running  bool
	ID       idwrap.IDWrap
}

func (q *Queries) UpdateFlow(ctx context.Context, arg UpdateFlowParams) error {
	_, err := q.exec(ctx, q.updateFlowStmt, updateFlow,
		arg.Name,
		arg.Duration,
		arg.Running,
		arg.ID,
	)
	return err
}

const updateFlowEdge = `-- name: UpdateFlowEdge :exec
UPDATE flow_edge
SET
  source_id = ?,
  target_id = ?,
  source_handle = ?
WHERE
  id = ?
`

type UpdateFlowEdgeParams struct {
	SourceID     idwrap.IDWrap
	TargetID     idwrap.IDWrap
	SourceHandle int32
	ID           idwrap.IDWrap
}

func (q *Queries) UpdateFlowEdge(ctx context.Context, arg UpdateFlowEdgeParams) error {
	_, err := q.exec(ctx, q.updateFlowEdgeStmt, updateFlowEdge,
		arg.SourceID,
		arg.TargetID,
		arg.SourceHandle,
		arg.ID,
	)
	return err
}

const updateFlowEdgeState = `-- name: UpdateFlowEdgeState :exec
UPDATE flow_edge
SET
  state = ?
WHERE
  id = ?
`

type UpdateFlowEdgeStateParams struct {
	State int8
	ID    idwrap.IDWrap
}

func (q *Queries) UpdateFlowEdgeState(ctx context.Context, arg UpdateFlowEdgeStateParams) error {
	_, err := q.exec(ctx, q.updateFlowEdgeStateStmt, updateFlowEdgeState, arg.State, arg.ID)
	return err
}

const updateFlowNode = `-- name: UpdateFlowNode :exec
UPDATE flow_node
SET
  name = ?,
  position_x = ?,
  position_y = ?
WHERE
  id = ?
`

type UpdateFlowNodeParams struct {
	Name      string
	PositionX float64
	PositionY float64
	ID        idwrap.IDWrap
}

func (q *Queries) UpdateFlowNode(ctx context.Context, arg UpdateFlowNodeParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeStmt, updateFlowNode,
		arg.Name,
		arg.PositionX,
		arg.PositionY,
		arg.ID,
	)
	return err
}

const updateFlowNodeCondition = `-- name: UpdateFlowNodeCondition :exec
UPDATE flow_node_condition
SET
  expression = ?
WHERE
  flow_node_id = ?
`

type UpdateFlowNodeConditionParams struct {
	Expression string
	FlowNodeID idwrap.IDWrap
}

func (q *Queries) UpdateFlowNodeCondition(ctx context.Context, arg UpdateFlowNodeConditionParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeConditionStmt, updateFlowNodeCondition, arg.Expression, arg.FlowNodeID)
	return err
}

const updateFlowNodeFor = `-- name: UpdateFlowNodeFor :exec
UPDATE flow_node_for
SET
  iter_count = ?,
  error_handling = ?,
  expression = ?
WHERE
  flow_node_id = ?
`

type UpdateFlowNodeForParams struct {
	IterCount     int64
	ErrorHandling int8
	Expression    string
	FlowNodeID    idwrap.IDWrap
}

func (q *Queries) UpdateFlowNodeFor(ctx context.Context, arg UpdateFlowNodeForParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeForStmt, updateFlowNodeFor,
		arg.IterCount,
		arg.ErrorHandling,
		arg.Expression,
		arg.FlowNodeID,
	)
	return err
}

const updateFlowNodeForEach = `-- name: UpdateFlowNodeForEach :exec
UPDATE flow_node_for_each
SET
  iter_expression = ?,
  error_handling = ?,
  expression = ?
WHERE
  flow_node_id = ?
`

type UpdateFlowNodeForEachParams struct {
	IterExpression string
	ErrorHandling  int8
	Expression     string
	FlowNodeID     idwrap.IDWrap
}

func (q *Queries) UpdateFlowNodeForEach(ctx context.Context, arg UpdateFlowNodeForEachParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeForEachStmt, updateFlowNodeForEach,
		arg.IterExpression,
		arg.ErrorHandling,
		arg.Expression,
		arg.FlowNodeID,
	)
	return err
}

const updateFlowNodeHTTP = `-- name: UpdateFlowNodeHTTP :exec
INSERT INTO flow_node_http (
    flow_node_id,
    http_id,
    delta_http_id
)
VALUES
    (?, ?, ?)
ON CONFLICT(flow_node_id) DO UPDATE SET
    http_id = excluded.http_id,
    delta_http_id = excluded.delta_http_id
`

type UpdateFlowNodeHTTPParams struct {
	FlowNodeID  idwrap.IDWrap
	HttpID      idwrap.IDWrap
	DeltaHttpID []byte
}

func (q *Queries) UpdateFlowNodeHTTP(ctx context.Context, arg UpdateFlowNodeHTTPParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeHTTPStmt, updateFlowNodeHTTP, arg.FlowNodeID, arg.HttpID, arg.DeltaHttpID)
	return err
}

const updateFlowNodeIDMapping = `-- name: UpdateFlowNodeIDMapping :exec
UPDATE flow
SET node_id_mapping = ?
WHERE id = ?
`

type UpdateFlowNodeIDMappingParams struct {
	NodeIDMapping []byte
	ID            idwrap.IDWrap
}

func (q *Queries) UpdateFlowNodeIDMapping(ctx context.Context, arg UpdateFlowNodeIDMappingParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeIDMappingStmt, updateFlowNodeIDMapping, arg.NodeIDMapping, arg.ID)
	return err
}

const updateFlowNodeJs = `-- name: UpdateFlowNodeJs :exec
UPDATE flow_node_js
SET
  code = ?,
  code_compress_type = ?
WHERE
  flow_node_id = ?
`

type UpdateFlowNodeJsParams struct {
	Code             []byte
	CodeCompressType int8
	FlowNodeID       idwrap.IDWrap
}

func (q *Queries) UpdateFlowNodeJs(ctx context.Context, arg UpdateFlowNodeJsParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeJsStmt, updateFlowNodeJs, arg.Code, arg.CodeCompressType, arg.FlowNodeID)
	return err
}

const updateFlowNodeState = `-- name: UpdateFlowNodeState :exec
UPDATE flow_node
SET
  state = ?
WHERE
  id = ?
`

type UpdateFlowNodeStateParams struct {
	State int8
	ID    idwrap.IDWrap
}

func (q *Queries) UpdateFlowNodeState(ctx context.Context, arg UpdateFlowNodeStateParams) error {
	_, err := q.exec(ctx, q.updateFlowNodeStateStmt, updateFlowNodeState, arg.State, arg.ID)
	return err
}

const updateFlowVariable = `-- name: UpdateFlowVariable :exec
UPDATE flow_variable
SET
  key = ?,
  value = ?,
  enabled = ?,
  description = ?
WHERE
  id = ?
`

type UpdateFlowVariableParams struct {
	Key         string
	Value       string
	Enabled     bool
	Description string
	ID          idwrap.IDWrap
}

func (q *Queries) UpdateFlowVariable(ctx context.Context, arg UpdateFlowVariableParams) error {
	_, err := q.exec(ctx, q.updateFlowVariableStmt, updateFlowVariable,
		arg.Key,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.ID,
	)
	return err
}

const updateFlowVariableOrder = `-- name: UpdateFlowVariableOrder :exec
UPDATE flow_variable
SET
  display_order = ?
WHERE
  id = ?
`

type UpdateFlowVariableOrderParams struct {
	DisplayOrder float64
	ID           idwrap.IDWrap
}

func (q *Queries) UpdateFlowVariableOrder(ctx context.Context, arg UpdateFlowVariableOrderParams) error {
	_, err := q.exec(ctx, q.updateFlowVariableOrderStmt, updateFlowVariableOrder, arg.DisplayOrder, arg.ID)
	return err
}

const updateNodeExecution = `-- name: UpdateNodeExecution :one
UPDATE node_execution
SET state = ?, error = ?, output_data = ?, 
    output_data_compress_type = ?, http_response_id = ?, completed_at = ?
WHERE id = ?
RETURNING id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, http_response_id, completed_at
`

type UpdateNodeExecutionParams struct {
	State                  int8
	Error                  sql.NullString
	OutputData             []byte
	OutputDataCompressType int8
	HttpResponseID         *idwrap.IDWrap
	CompletedAt            sql.NullInt64
	ID                     idwrap.IDWrap
}

func (q *Queries) UpdateNodeExecution(ctx context.Context, arg UpdateNodeExecutionParams) (NodeExecution, error) {
	row := q.queryRow(ctx, q.updateNodeExecutionStmt, updateNodeExecution,
		arg.State,
		arg.Error,
		arg.OutputData,
		arg.OutputDataCompressType,
		arg.HttpResponseID,
		arg.CompletedAt,
		arg.ID,
	)
	var i NodeExecution
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Name,
		&i.State,
		&i.Error,
		&i.InputData,
		&i.InputDataCompressType,
		&i.OutputData,
		&i.OutputDataCompressType,
		&i.HttpResponseID,
		&i.CompletedAt,
	)
	return i, err
}

const updateNodeExecutionNodeID = `-- name: UpdateNodeExecutionNodeID :exec
UPDATE node_execution
SET node_id = ?
WHERE id = ?
`

type UpdateNodeExecutionNodeIDParams struct {
	NodeID idwrap.IDWrap
	ID     idwrap.IDWrap
}

func (q *Queries) UpdateNodeExecutionNodeID(ctx context.Context, arg UpdateNodeExecutionNodeIDParams) error {
	_, err := q.exec(ctx, q.updateNodeExecutionNodeIDStmt, updateNodeExecutionNodeID, arg.NodeID, arg.ID)
	return err
}

const updateTag = `-- name: UpdateTag :exec
UPDATE tag
SET
  name = ?,
  color = ?
WHERE
  id = ?
`

type UpdateTagParams struct {
	Name  string
	Color int8
	ID    idwrap.IDWrap
}

func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) error {
	_, err := q.exec(ctx, q.updateTagStmt, updateTag, arg.Name, arg.Color, arg.ID)
	return err
}

const upsertNodeExecution = `-- name: UpsertNodeExecution :one
INSERT INTO node_execution (
  id, node_id, name, state, error, input_data, input_data_compress_type,
  output_data, output_data_compress_type, http_response_id, completed_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
  state = excluded.state,
  error = excluded.error, 
  input_data = excluded.input_data,
  input_data_compress_type = excluded.input_data_compress_type,
  output_data = excluded.output_data,
  output_data_compress_type = excluded.output_data_compress_type,
  http_response_id = excluded.http_response_id,
  completed_at = excluded.completed_at
RETURNING id, node_id, name, state, error, input_data, input_data_compress_type, output_data, output_data_compress_type, http_response_id, completed_at
`

type UpsertNodeExecutionParams struct {
	ID                     idwrap.IDWrap
	NodeID                 idwrap.IDWrap
	Name                   string
	State                  int8
	Error                  sql.NullString
	InputData              []byte
	InputDataCompressType  int8
	OutputData             []byte
	OutputDataCompressType int8
	HttpResponseID         *idwrap.IDWrap
	CompletedAt            sql.NullInt64
}

func (q *Queries) UpsertNodeExecution(ctx context.Context, arg UpsertNodeExecutionParams) (NodeExecution, error) {
	row := q.queryRow(ctx, q.upsertNodeExecutionStmt, upsertNodeExecution,
		arg.ID,
		arg.NodeID,
		arg.Name,
		arg.State,
		arg.Error,
		arg.InputData,
		arg.InputDataCompressType,
		arg.OutputData,
		arg.OutputDataCompressType,
		arg.HttpResponseID,
		arg.CompletedAt,
	)
	var i NodeExecution
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.Name,
		&i.State,
		&i.Error,
		&i.InputData,
		&i.InputDataCompressType,
		&i.OutputData,
		&i.OutputDataCompressType,
		&i.HttpResponseID,
		&i.CompletedAt,
	)
	return i, err
}
