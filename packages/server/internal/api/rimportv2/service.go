package rimportv2

import (
	"context"
	"log/slog"

	"the-dev-tools/server/pkg/idwrap"
	"the-dev-tools/server/pkg/model/mfile"
	"the-dev-tools/server/pkg/model/mflow"
	"the-dev-tools/server/pkg/model/mhttp"
)

// Service implements the main business logic for HAR import
type Service struct {
	translator     HARTranslator
	storage        StorageManager
	flowGen        FlowGenerator
	validator      Validator
	logger         *slog.Logger
}

// NewService creates a new Service with dependency injection
func NewService(translator HARTranslator, storage StorageManager, flowGen FlowGenerator, validator Validator, logger *slog.Logger) *Service {
	return &Service{
		translator: translator,
		storage:    storage,
		flowGen:    flowGen,
		validator:  validator,
		logger:     logger,
	}
}

// Import processes a HAR file and stores the results using modern models
func (s *Service) Import(ctx context.Context, req *ImportRequest) (*ImportResponse, error) {
	s.logger.Info("Starting HAR import",
		"workspace_id", req.WorkspaceID,
		"name", req.Name,
		"data_size", len(req.Data))

	// Validate the import request
	if err := s.validator.ValidateImportRequest(ctx, req); err != nil {
		s.logger.Error("Import request validation failed", "error", err)
		return nil, err
	}

	// Validate workspace access
	if err := s.validator.ValidateWorkspaceAccess(ctx, req.WorkspaceID); err != nil {
		s.logger.Error("Workspace access validation failed", "workspace_id", req.WorkspaceID, "error", err)
		return nil, err
	}

	// Process HAR data using modern translator
	harResolved, err := s.translator.ConvertHAR(ctx, req.Data, req.WorkspaceID)
	if err != nil {
		s.logger.Error("HAR translation failed", "error", err)
		return nil, NewHARProcessingError("convert_har", err)
	}

	s.logger.Info("HAR translation completed",
		"http_requests", len(harResolved.HTTPRequests),
		"files", len(harResolved.Files))

	// Create flow from imported HTTP requests
	httpReqsPtr := make([]*mhttp.HTTP, len(harResolved.HTTPRequests))
	for i, req := range harResolved.HTTPRequests {
		httpReqsPtr[i] = &req
	}

	flow, err := s.flowGen.CreateFlow(ctx, req.WorkspaceID, req.Name, httpReqsPtr)
	if err != nil {
		s.logger.Error("Flow generation failed", "error", err)
		return nil, NewHARProcessingError("create_flow", err)
	}

	s.logger.Info("Flow generation completed", "flow_id", flow.ID)

	// Prepare import results for storage
	filesPtr := make([]*mfile.File, len(harResolved.Files))
	for i, file := range harResolved.Files {
		filesPtr[i] = &file
	}

	results := &ImportResults{
		Flow:        &harResolved.Flow,
		HTTPReqs:    httpReqsPtr,
		Files:       filesPtr,
		Domains:     []string{}, // TODO: Extract domains from HTTP requests if needed
		WorkspaceID: req.WorkspaceID,
	}

	// Store all results atomically
	if err := s.storage.StoreImportResults(ctx, results); err != nil {
		s.logger.Error("Storage failed", "error", err)
		return nil, NewStorageError("store_import_results", "all", err)
	}

	s.logger.Info("Import completed successfully",
		"flow_id", flow.ID,
		"http_requests", len(harResolved.HTTPRequests),
		"files", len(harResolved.Files))

	// Build response
	response := &ImportResponse{
		MissingData: ImportMissingDataKind_UNSPECIFIED,
		Domains:     []string{}, // TODO: Extract domains from HTTP requests if needed
	}

	// Check if domain data is missing and inform the user
	// TODO: Implement domain extraction from HTTP requests
	if len(req.DomainData) == 0 {
		// For now, assume no missing domain data until we implement domain extraction
		response.MissingData = ImportMissingDataKind_UNSPECIFIED
	}

	return response, nil
}

// ImportWithTextData processes HAR data from text format
func (s *Service) ImportWithTextData(ctx context.Context, req *ImportRequest) (*ImportResponse, error) {
	// Convert text data to bytes if provided
	if len(req.Data) == 0 && req.TextData != "" {
		req.Data = []byte(req.TextData)
	}

	return s.Import(ctx, req)
}

// SimpleFlowGenerator implements a basic FlowGenerator for the service
type SimpleFlowGenerator struct{}

// NewSimpleFlowGenerator creates a new SimpleFlowGenerator
func NewSimpleFlowGenerator() *SimpleFlowGenerator {
	return &SimpleFlowGenerator{}
}

// CreateFlow creates a flow from HTTP requests using the resolved data from harv2
func (fg *SimpleFlowGenerator) CreateFlow(ctx context.Context, workspaceID idwrap.IDWrap, name string, httpReqs []*mhttp.HTTP) (*mflow.Flow, error) {
	// Use the flow that was already generated by harv2
	// harv2 already creates flow graphs with sophisticated algorithms
	// We can extract it from the harv2.HarResolved if available, or create a simple one

	flow := &mflow.Flow{
		ID:          idwrap.NewNow(),
		WorkspaceID: workspaceID,
		Name:        name,
	}

	return flow, nil
}

// DefaultFlowGenerator uses the flow from harv2 translation
type DefaultFlowGenerator struct{}

// NewDefaultFlowGenerator creates a new DefaultFlowGenerator
func NewDefaultFlowGenerator() *DefaultFlowGenerator {
	return &DefaultFlowGenerator{}
}

// CreateFlow extracts the flow that was already created by harv2 during HAR processing
func (fg *DefaultFlowGenerator) CreateFlow(ctx context.Context, workspaceID idwrap.IDWrap, name string, httpReqs []*mhttp.HTTP) (*mflow.Flow, error) {
	// Since harv2 already generates sophisticated flow graphs with all the
	// complex algorithms (timestamp sequencing, dependency edges, transitive reduction),
	// we can create a simple flow that references the HTTP requests
	// In a more sophisticated implementation, we might extract flow data from harv2

	flow := &mflow.Flow{
		ID:          idwrap.NewNow(),
		WorkspaceID: workspaceID,
		Name:        name,
	}

	return flow, nil
}