// Code generated by @the-dev-tools/spec-lib/tanstack-db-go. DO NOT EDIT.

package renv

import (
	"context"
	"errors"
	"fmt"

	"connectrpc.com/connect"
	"google.golang.org/protobuf/types/known/emptypb"

	idwrap "the-dev-tools/server/pkg/idwrap"
	environmentv1 "the-dev-tools/spec/dist/buf/go/api/environment/v1"
)

var (
	errEnvironmentHooksMissing      = errors.New("environment hooks not configured")
	errEnvironmentPrincipalProvider = errors.New("environment principal provider not configured")
)

type EnvironmentPrincipal struct {
	UserID idwrap.IDWrap
}

type EnvironmentPrincipalProvider func(context.Context) (EnvironmentPrincipal, error)

type EnvironmentHooks interface {
	OnEnvironmentCollection(ctx context.Context, principal EnvironmentPrincipal) (*environmentv1.EnvironmentCollectionResponse, error)
	OnEnvironmentCreate(ctx context.Context, principal EnvironmentPrincipal, items []EnvironmentCreateInput) error
	OnEnvironmentUpdate(ctx context.Context, principal EnvironmentPrincipal, items []EnvironmentUpdateInput) error
	OnEnvironmentDelete(ctx context.Context, principal EnvironmentPrincipal, items []EnvironmentDeleteInput) error
}

type EnvironmentHandler struct {
	Hooks     EnvironmentHooks
	Principal EnvironmentPrincipalProvider
}

func NewEnvironmentHandler(hooks EnvironmentHooks, principal EnvironmentPrincipalProvider) EnvironmentHandler {
	return EnvironmentHandler{
		Hooks:     hooks,
		Principal: principal,
	}
}

func (h EnvironmentHandler) principal(ctx context.Context) (EnvironmentPrincipal, error) {
	if h.Principal == nil {
		return EnvironmentPrincipal{}, connect.NewError(connect.CodeInternal, errEnvironmentPrincipalProvider)
	}
	return h.Principal(ctx)
}

func (h EnvironmentHandler) ensureHooks() error {
	if h.Hooks == nil {
		return connect.NewError(connect.CodeInternal, errEnvironmentHooksMissing)
	}
	return nil
}

type EnvironmentCreateInput struct {
	WorkspaceID idwrap.IDWrap
	Name        string
	Description string
}

func DecodeEnvironmentCreateItems(items []*environmentv1.EnvironmentCreate) ([]EnvironmentCreateInput, error) {
	result := make([]EnvironmentCreateInput, len(items))
	for i, item := range items {
		workspaceID, err := idwrap.NewFromBytes(item.GetWorkspaceId())
		if err != nil {
			return nil, fmt.Errorf("environment[%d]: invalid workspace_id: %w", i, err)
		}

		result[i] = EnvironmentCreateInput{
			WorkspaceID: workspaceID,
			Name:        item.GetName(),
			Description: item.GetDescription(),
		}
	}

	return result, nil
}

type EnvironmentUpdateInput struct {
	EnvironmentID idwrap.IDWrap
	Name          *string
	Description   *string
}

func DecodeEnvironmentUpdateItems(items []*environmentv1.EnvironmentUpdate) ([]EnvironmentUpdateInput, error) {
	result := make([]EnvironmentUpdateInput, len(items))
	for i, item := range items {
		environmentID, err := idwrap.NewFromBytes(item.GetEnvironmentId())
		if err != nil {
			return nil, fmt.Errorf("environment[%d]: invalid environment_id: %w", i, err)
		}

		result[i] = EnvironmentUpdateInput{
			EnvironmentID: environmentID,
			Name:          item.Name,
			Description:   item.Description,
		}
	}

	return result, nil
}

type EnvironmentDeleteInput struct {
	EnvironmentID idwrap.IDWrap
}

func DecodeEnvironmentDeleteItems(items []*environmentv1.EnvironmentDelete) ([]EnvironmentDeleteInput, error) {
	result := make([]EnvironmentDeleteInput, len(items))
	for i, item := range items {
		environmentID, err := idwrap.NewFromBytes(item.GetEnvironmentId())
		if err != nil {
			return nil, fmt.Errorf("environment[%d]: invalid environment_id: %w", i, err)
		}

		result[i] = EnvironmentDeleteInput{
			EnvironmentID: environmentID,
		}
	}

	return result, nil
}

func (h EnvironmentHandler) EnvironmentCollection(ctx context.Context, req *connect.Request[emptypb.Empty]) (*connect.Response[environmentv1.EnvironmentCollectionResponse], error) {
	if err := h.ensureHooks(); err != nil {
		return nil, err
	}

	principal, err := h.principal(ctx)
	if err != nil {
		return nil, err
	}

	resp, err := h.Hooks.OnEnvironmentCollection(ctx, principal)
	if err != nil {
		return nil, err
	}
	if resp == nil {
		resp = &environmentv1.EnvironmentCollectionResponse{}
	}
	return connect.NewResponse(resp), nil
}

func (h EnvironmentHandler) EnvironmentCreate(ctx context.Context, req *connect.Request[environmentv1.EnvironmentCreateRequest]) (*connect.Response[emptypb.Empty], error) {
	if err := h.ensureHooks(); err != nil {
		return nil, err
	}
	if len(req.Msg.Items) == 0 {
		return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("at least one environment must be provided"))
	}

	items, err := DecodeEnvironmentCreateItems(req.Msg.Items)
	if err != nil {
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}

	principal, err := h.principal(ctx)
	if err != nil {
		return nil, err
	}

	if err := h.Hooks.OnEnvironmentCreate(ctx, principal, items); err != nil {
		return nil, err
	}

	return connect.NewResponse(&emptypb.Empty{}), nil
}

func (h EnvironmentHandler) EnvironmentUpdate(ctx context.Context, req *connect.Request[environmentv1.EnvironmentUpdateRequest]) (*connect.Response[emptypb.Empty], error) {
	if err := h.ensureHooks(); err != nil {
		return nil, err
	}
	if len(req.Msg.Items) == 0 {
		return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("at least one environment must be provided"))
	}

	items, err := DecodeEnvironmentUpdateItems(req.Msg.Items)
	if err != nil {
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}

	principal, err := h.principal(ctx)
	if err != nil {
		return nil, err
	}

	if err := h.Hooks.OnEnvironmentUpdate(ctx, principal, items); err != nil {
		return nil, err
	}

	return connect.NewResponse(&emptypb.Empty{}), nil
}

func (h EnvironmentHandler) EnvironmentDelete(ctx context.Context, req *connect.Request[environmentv1.EnvironmentDeleteRequest]) (*connect.Response[emptypb.Empty], error) {
	if err := h.ensureHooks(); err != nil {
		return nil, err
	}
	if len(req.Msg.Items) == 0 {
		return nil, connect.NewError(connect.CodeInvalidArgument, errors.New("at least one environment must be provided"))
	}

	items, err := DecodeEnvironmentDeleteItems(req.Msg.Items)
	if err != nil {
		return nil, connect.NewError(connect.CodeInvalidArgument, err)
	}

	principal, err := h.principal(ctx)
	if err != nil {
		return nil, err
	}

	if err := h.Hooks.OnEnvironmentDelete(ctx, principal, items); err != nil {
		return nil, err
	}

	return connect.NewResponse(&emptypb.Empty{}), nil
}
