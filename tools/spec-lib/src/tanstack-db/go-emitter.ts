import { createTypeSpecLibrary, EmitContext, Program } from '@typespec/compiler';
import { mkdir, writeFile } from 'node:fs/promises';
import { dirname, join, resolve } from 'node:path/posix';

export const $lib = createTypeSpecLibrary({
  diagnostics: {},
  name: '@the-dev-tools/spec-lib/tanstack-db-go',
});

const GENERATED_HEADER = '// Code generated by @the-dev-tools/spec-lib/tanstack-db-go. DO NOT EDIT.\n';

const ENVIRONMENT_MODEL_FQN = 'Api.Environment.Environment';

interface TargetConfig {
  model: string;
  output: string;
  package: string;
  pbImportAlias: string;
  pbImportPath: string;
}

interface GeneratorOptions {
  baseOutputDir: string;
  idwrapImportPath: string;
  targets: TargetConfig[];
}

const DEFAULT_OPTIONS: GeneratorOptions = {
  baseOutputDir: 'packages/server/internal/api',
  idwrapImportPath: 'the-dev-tools/server/pkg/idwrap',
  targets: [
    {
      model: ENVIRONMENT_MODEL_FQN,
      output: 'renv/renv_gen.go',
      package: 'renv',
      pbImportAlias: 'environmentv1',
      pbImportPath: 'the-dev-tools/spec/dist/buf/go/api/environment/v1',
    },
  ],
};

const buildEnvironmentFile = (options: GeneratorOptions, target: TargetConfig) => {
  return [
    GENERATED_HEADER,
    `package ${target.package}`,
    '',
    'import (',
    '\t"fmt"',
    '',
    `\t${target.pbImportAlias} "${target.pbImportPath}"`,
    `\tidwrap "${options.idwrapImportPath}"`,
    ')',
    '',
    'type EnvironmentCreateInput struct {',
    '\tWorkspaceID idwrap.IDWrap',
    '\tName        string',
    '\tDescription string',
    '}',
    '',
    'func DecodeEnvironmentCreateItems(items []*' + target.pbImportAlias + '.EnvironmentCreate) ([]EnvironmentCreateInput, error) {',
    '\tresult := make([]EnvironmentCreateInput, len(items))',
    '\tfor i, item := range items {',
    '\t\tworkspaceID, err := idwrap.NewFromBytes(item.GetWorkspaceId())',
    '\t\tif err != nil {',
    '\t\t\treturn nil, fmt.Errorf("environment[%d]: invalid workspace_id: %w", i, err)',
    '\t\t}',
    '',
    '\t\tresult[i] = EnvironmentCreateInput{',
    '\t\t\tWorkspaceID: workspaceID,',
    '\t\t\tName:        item.GetName(),',
    '\t\t\tDescription: item.GetDescription(),',
    '\t\t}',
    '\t}',
    '',
    '\treturn result, nil',
    '}',
    '',
    'type EnvironmentUpdateInput struct {',
    '\tEnvironmentID idwrap.IDWrap',
    '\tName          *string',
    '\tDescription   *string',
    '}',
    '',
    'func DecodeEnvironmentUpdateItems(items []*' + target.pbImportAlias + '.EnvironmentUpdate) ([]EnvironmentUpdateInput, error) {',
    '\tresult := make([]EnvironmentUpdateInput, len(items))',
    '\tfor i, item := range items {',
    '\t\tenvironmentID, err := idwrap.NewFromBytes(item.GetEnvironmentId())',
    '\t\tif err != nil {',
    '\t\t\treturn nil, fmt.Errorf("environment[%d]: invalid environment_id: %w", i, err)',
    '\t\t}',
    '',
    '\t\tresult[i] = EnvironmentUpdateInput{',
    '\t\t\tEnvironmentID: environmentID,',
    '\t\t\tName:          item.Name,',
    '\t\t\tDescription:   item.Description,',
    '\t\t}',
    '\t}',
    '',
    '\treturn result, nil',
    '}',
    '',
    'type EnvironmentDeleteInput struct {',
    '\tEnvironmentID idwrap.IDWrap',
    '}',
    '',
    'func DecodeEnvironmentDeleteItems(items []*' + target.pbImportAlias + '.EnvironmentDelete) ([]EnvironmentDeleteInput, error) {',
    '\tresult := make([]EnvironmentDeleteInput, len(items))',
    '\tfor i, item := range items {',
    '\t\tenvironmentID, err := idwrap.NewFromBytes(item.GetEnvironmentId())',
    '\t\tif err != nil {',
    '\t\t\treturn nil, fmt.Errorf("environment[%d]: invalid environment_id: %w", i, err)',
    '\t\t}',
    '',
    '\t\tresult[i] = EnvironmentDeleteInput{',
    '\t\t\tEnvironmentID: environmentID,',
    '\t\t}',
    '\t}',
    '',
    '\treturn result, nil',
    '}',
    '',
  ].join('\n');
};

const ensureDirectory = async (path: string) => {
  await mkdir(path, { recursive: true });
};

const writeTargetFile = async (_program: Program, path: string, content: string) => {
  await ensureDirectory(dirname(path));
  await writeFile(path, content);
};

export const $onEmit = async (context: EmitContext<Record<string, unknown>>) => {
  const { emitterOutputDir, program } = context;
  const options = DEFAULT_OPTIONS;

  if (program.compilerOptions.noEmit) return;

  for (const target of options.targets) {
    const repoRoot = resolve(emitterOutputDir, '../../..');
    const outputPath = join(repoRoot, options.baseOutputDir, target.output);

    if (target.model === ENVIRONMENT_MODEL_FQN) {
      const content = buildEnvironmentFile(options, target);
      await writeTargetFile(program, outputPath, content);
    }
  }
};
