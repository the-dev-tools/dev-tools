// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: workspaces.sql

package gen

import (
	"context"

	idwrap "the-dev-tools/server/pkg/idwrap"
)

const checkIFWorkspaceUserExists = `-- name: CheckIFWorkspaceUserExists :one
SELECT
  cast(
  EXISTS (
    SELECT
      1
    FROM
      workspaces_users
    WHERE
      workspace_id = ?
      AND user_id = ?
    LIMIT
      1
) AS boolean
)
`

type CheckIFWorkspaceUserExistsParams struct {
	WorkspaceID idwrap.IDWrap
	UserID      idwrap.IDWrap
}

// WorkspaceUsers
func (q *Queries) CheckIFWorkspaceUserExists(ctx context.Context, arg CheckIFWorkspaceUserExistsParams) (bool, error) {
	row := q.queryRow(ctx, q.checkIFWorkspaceUserExistsStmt, checkIFWorkspaceUserExists, arg.WorkspaceID, arg.UserID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const createWorkspace = `-- name: CreateWorkspace :exec
INSERT INTO
  workspaces (id, name, updated, collection_count, flow_count, active_env, global_env, display_order)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateWorkspaceParams struct {
	ID              idwrap.IDWrap
	Name            string
	Updated         int64
	CollectionCount int32
	FlowCount       int32
	ActiveEnv       idwrap.IDWrap
	GlobalEnv       idwrap.IDWrap
	DisplayOrder    float64
}

func (q *Queries) CreateWorkspace(ctx context.Context, arg CreateWorkspaceParams) error {
	_, err := q.exec(ctx, q.createWorkspaceStmt, createWorkspace,
		arg.ID,
		arg.Name,
		arg.Updated,
		arg.CollectionCount,
		arg.FlowCount,
		arg.ActiveEnv,
		arg.GlobalEnv,
		arg.DisplayOrder,
	)
	return err
}

const createWorkspaceUser = `-- name: CreateWorkspaceUser :exec
INSERT INTO
  workspaces_users (id, workspace_id, user_id, role)
VALUES
  (?, ?, ?, ?)
`

type CreateWorkspaceUserParams struct {
	ID          idwrap.IDWrap
	WorkspaceID idwrap.IDWrap
	UserID      idwrap.IDWrap
	Role        int8
}

func (q *Queries) CreateWorkspaceUser(ctx context.Context, arg CreateWorkspaceUserParams) error {
	_, err := q.exec(ctx, q.createWorkspaceUserStmt, createWorkspaceUser,
		arg.ID,
		arg.WorkspaceID,
		arg.UserID,
		arg.Role,
	)
	return err
}

const deleteWorkspace = `-- name: DeleteWorkspace :exec
DELETE FROM workspaces
WHERE
  id = ?
`

func (q *Queries) DeleteWorkspace(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteWorkspaceStmt, deleteWorkspace, id)
	return err
}

const deleteWorkspaceUser = `-- name: DeleteWorkspaceUser :exec
DELETE FROM workspaces_users
WHERE
  id = ?
`

func (q *Queries) DeleteWorkspaceUser(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteWorkspaceUserStmt, deleteWorkspaceUser, id)
	return err
}

const getAllWorkspacesByUserID = `-- name: GetAllWorkspacesByUserID :many
SELECT
  w.id,
  w.name,
  w.updated,
  w.collection_count,
  w.flow_count,
  w.active_env,
  w.global_env,
  w.display_order
FROM
  workspaces w
INNER JOIN workspaces_users wu ON w.id = wu.workspace_id
WHERE
  wu.user_id = ?
ORDER BY
  w.updated DESC
`

// Returns ALL workspaces for a user
func (q *Queries) GetAllWorkspacesByUserID(ctx context.Context, userID idwrap.IDWrap) ([]Workspace, error) {
	rows, err := q.query(ctx, q.getAllWorkspacesByUserIDStmt, getAllWorkspacesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workspace{}
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Updated,
			&i.CollectionCount,
			&i.FlowCount,
			&i.ActiveEnv,
			&i.GlobalEnv,
			&i.DisplayOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspace = `-- name: GetWorkspace :one
SELECT
  id,
  name,
  updated,
  collection_count,
  flow_count,
  active_env,
  global_env,
  display_order
FROM
  workspaces
WHERE
  id = ?
LIMIT
  1
`

// Workspaces
func (q *Queries) GetWorkspace(ctx context.Context, id idwrap.IDWrap) (Workspace, error) {
	row := q.queryRow(ctx, q.getWorkspaceStmt, getWorkspace, id)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Updated,
		&i.CollectionCount,
		&i.FlowCount,
		&i.ActiveEnv,
		&i.GlobalEnv,
		&i.DisplayOrder,
	)
	return i, err
}

const getWorkspaceByUserID = `-- name: GetWorkspaceByUserID :one
SELECT
  id,
  name,
  updated,
  collection_count,
  flow_count,
  active_env,
  global_env,
  display_order
FROM
  workspaces
WHERE
  id = (
    SELECT
      workspace_id
    FROM
      workspaces_users
    WHERE
      user_id = ?
    LIMIT
      1
  )
LIMIT
  1
`

func (q *Queries) GetWorkspaceByUserID(ctx context.Context, userID idwrap.IDWrap) (Workspace, error) {
	row := q.queryRow(ctx, q.getWorkspaceByUserIDStmt, getWorkspaceByUserID, userID)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Updated,
		&i.CollectionCount,
		&i.FlowCount,
		&i.ActiveEnv,
		&i.GlobalEnv,
		&i.DisplayOrder,
	)
	return i, err
}

const getWorkspaceByUserIDandWorkspaceID = `-- name: GetWorkspaceByUserIDandWorkspaceID :one
SELECT
  id,
  name,
  updated,
  collection_count,
  flow_count,
  active_env,
  global_env,
  display_order
FROM
  workspaces
WHERE
  id = (
    SELECT
      workspace_id
    FROM
      workspaces_users
    WHERE
      workspace_id = ?
      AND user_id = ?
    LIMIT
      1
  )
LIMIT
  1
`

type GetWorkspaceByUserIDandWorkspaceIDParams struct {
	WorkspaceID idwrap.IDWrap
	UserID      idwrap.IDWrap
}

func (q *Queries) GetWorkspaceByUserIDandWorkspaceID(ctx context.Context, arg GetWorkspaceByUserIDandWorkspaceIDParams) (Workspace, error) {
	row := q.queryRow(ctx, q.getWorkspaceByUserIDandWorkspaceIDStmt, getWorkspaceByUserIDandWorkspaceID, arg.WorkspaceID, arg.UserID)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Updated,
		&i.CollectionCount,
		&i.FlowCount,
		&i.ActiveEnv,
		&i.GlobalEnv,
		&i.DisplayOrder,
	)
	return i, err
}

const getWorkspaceUser = `-- name: GetWorkspaceUser :one
SELECT
  id,
  workspace_id,
  user_id,
  role
FROM
  workspaces_users
WHERE
  id = ?
LIMIT
  1
`

func (q *Queries) GetWorkspaceUser(ctx context.Context, id idwrap.IDWrap) (WorkspacesUser, error) {
	row := q.queryRow(ctx, q.getWorkspaceUserStmt, getWorkspaceUser, id)
	var i WorkspacesUser
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.UserID,
		&i.Role,
	)
	return i, err
}

const getWorkspaceUserByUserID = `-- name: GetWorkspaceUserByUserID :many
SELECT
  id,
  workspace_id,
  user_id,
  role
FROM
  workspaces_users
WHERE
  user_id = ?
`

func (q *Queries) GetWorkspaceUserByUserID(ctx context.Context, userID idwrap.IDWrap) ([]WorkspacesUser, error) {
	rows, err := q.query(ctx, q.getWorkspaceUserByUserIDStmt, getWorkspaceUserByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WorkspacesUser{}
	for rows.Next() {
		var i WorkspacesUser
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.UserID,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspaceUserByWorkspaceID = `-- name: GetWorkspaceUserByWorkspaceID :many
SELECT
  id,
  workspace_id,
  user_id,
  role
FROM
  workspaces_users
WHERE
  workspace_id = ?
`

func (q *Queries) GetWorkspaceUserByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]WorkspacesUser, error) {
	rows, err := q.query(ctx, q.getWorkspaceUserByWorkspaceIDStmt, getWorkspaceUserByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WorkspacesUser{}
	for rows.Next() {
		var i WorkspacesUser
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.UserID,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspaceUserByWorkspaceIDAndUserID = `-- name: GetWorkspaceUserByWorkspaceIDAndUserID :one
SELECT
  id,
  workspace_id,
  user_id,
  role
FROM
  workspaces_users
WHERE
  workspace_id = ?
  AND user_id = ?
LIMIT
  1
`

type GetWorkspaceUserByWorkspaceIDAndUserIDParams struct {
	WorkspaceID idwrap.IDWrap
	UserID      idwrap.IDWrap
}

func (q *Queries) GetWorkspaceUserByWorkspaceIDAndUserID(ctx context.Context, arg GetWorkspaceUserByWorkspaceIDAndUserIDParams) (WorkspacesUser, error) {
	row := q.queryRow(ctx, q.getWorkspaceUserByWorkspaceIDAndUserIDStmt, getWorkspaceUserByWorkspaceIDAndUserID, arg.WorkspaceID, arg.UserID)
	var i WorkspacesUser
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.UserID,
		&i.Role,
	)
	return i, err
}

const getWorkspacesByUserID = `-- name: GetWorkspacesByUserID :many
SELECT
  id,
  name,
  updated,
  collection_count,
  flow_count,
  active_env,
  global_env,
  display_order
FROM
  workspaces
WHERE
  id IN (
    SELECT
      workspace_id
    FROM
      workspaces_users
    WHERE
      user_id = ?
  )
`

func (q *Queries) GetWorkspacesByUserID(ctx context.Context, userID idwrap.IDWrap) ([]Workspace, error) {
	rows, err := q.query(ctx, q.getWorkspacesByUserIDStmt, getWorkspacesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workspace{}
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Updated,
			&i.CollectionCount,
			&i.FlowCount,
			&i.ActiveEnv,
			&i.GlobalEnv,
			&i.DisplayOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspacesByUserIDOrdered = `-- name: GetWorkspacesByUserIDOrdered :many
SELECT
  w.id,
  w.name,
  w.updated,
  w.collection_count,
  w.flow_count,
  w.active_env,
  w.global_env,
  w.display_order
FROM
  workspaces w
INNER JOIN workspaces_users wu ON w.id = wu.workspace_id
WHERE
  wu.user_id = ?
ORDER BY
  w.display_order ASC
`

func (q *Queries) GetWorkspacesByUserIDOrdered(ctx context.Context, userID idwrap.IDWrap) ([]Workspace, error) {
	rows, err := q.query(ctx, q.getWorkspacesByUserIDOrderedStmt, getWorkspacesByUserIDOrdered, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workspace{}
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Updated,
			&i.CollectionCount,
			&i.FlowCount,
			&i.ActiveEnv,
			&i.GlobalEnv,
			&i.DisplayOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWorkspace = `-- name: UpdateWorkspace :exec
UPDATE workspaces
SET
  name = ?,
  collection_count = ?,
  flow_count = ?,
  updated = ?,
  active_env = ?,
  display_order = ?
WHERE
  id = ?
`

type UpdateWorkspaceParams struct {
	Name            string
	CollectionCount int32
	FlowCount       int32
	Updated         int64
	ActiveEnv       idwrap.IDWrap
	DisplayOrder    float64
	ID              idwrap.IDWrap
}

func (q *Queries) UpdateWorkspace(ctx context.Context, arg UpdateWorkspaceParams) error {
	_, err := q.exec(ctx, q.updateWorkspaceStmt, updateWorkspace,
		arg.Name,
		arg.CollectionCount,
		arg.FlowCount,
		arg.Updated,
		arg.ActiveEnv,
		arg.DisplayOrder,
		arg.ID,
	)
	return err
}

const updateWorkspaceUpdatedTime = `-- name: UpdateWorkspaceUpdatedTime :exec
UPDATE workspaces
SET
  updated = ?
WHERE
  id = ?
`

type UpdateWorkspaceUpdatedTimeParams struct {
	Updated int64
	ID      idwrap.IDWrap
}

func (q *Queries) UpdateWorkspaceUpdatedTime(ctx context.Context, arg UpdateWorkspaceUpdatedTimeParams) error {
	_, err := q.exec(ctx, q.updateWorkspaceUpdatedTimeStmt, updateWorkspaceUpdatedTime, arg.Updated, arg.ID)
	return err
}

const updateWorkspaceUser = `-- name: UpdateWorkspaceUser :exec
UPDATE workspaces_users
SET
  workspace_id = ?,
  user_id = ?,
  role = ?
WHERE
  id = ?
`

type UpdateWorkspaceUserParams struct {
	WorkspaceID idwrap.IDWrap
	UserID      idwrap.IDWrap
	Role        int8
	ID          idwrap.IDWrap
}

func (q *Queries) UpdateWorkspaceUser(ctx context.Context, arg UpdateWorkspaceUserParams) error {
	_, err := q.exec(ctx, q.updateWorkspaceUserStmt, updateWorkspaceUser,
		arg.WorkspaceID,
		arg.UserID,
		arg.Role,
		arg.ID,
	)
	return err
}
