// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: betterauth.sql

package gen

import (
	"context"
	"database/sql"

	idwrap "github.com/the-dev-tools/dev-tools/packages/server/pkg/idwrap"
)

const authCountUsers = `-- name: AuthCountUsers :one
SELECT
  COUNT(*)
FROM
  auth_user
`

func (q *Queries) AuthCountUsers(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.authCountUsersStmt, authCountUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const authCreateAccount = `-- name: AuthCreateAccount :exec
INSERT INTO
  auth_account (
    id,
    user_id,
    account_id,
    provider_id,
    access_token,
    refresh_token,
    access_token_expires_at,
    refresh_token_expires_at,
    scope,
    id_token,
    password,
    created_at,
    updated_at
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type AuthCreateAccountParams struct {
	ID                    idwrap.IDWrap
	UserID                idwrap.IDWrap
	AccountID             string
	ProviderID            string
	AccessToken           sql.NullString
	RefreshToken          sql.NullString
	AccessTokenExpiresAt  *int64
	RefreshTokenExpiresAt *int64
	Scope                 sql.NullString
	IDToken               sql.NullString
	Password              sql.NullString
	CreatedAt             int64
	UpdatedAt             int64
}

func (q *Queries) AuthCreateAccount(ctx context.Context, arg AuthCreateAccountParams) error {
	_, err := q.exec(ctx, q.authCreateAccountStmt, authCreateAccount,
		arg.ID,
		arg.UserID,
		arg.AccountID,
		arg.ProviderID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.AccessTokenExpiresAt,
		arg.RefreshTokenExpiresAt,
		arg.Scope,
		arg.IDToken,
		arg.Password,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const authCreateJwks = `-- name: AuthCreateJwks :exec

INSERT INTO
  auth_jwks (id, public_key, private_key, created_at, expires_at)
VALUES
  (?, ?, ?, ?, ?)
`

type AuthCreateJwksParams struct {
	ID         []byte
	PublicKey  string
	PrivateKey string
	CreatedAt  int64
	ExpiresAt  sql.NullInt64
}

// JWKS
func (q *Queries) AuthCreateJwks(ctx context.Context, arg AuthCreateJwksParams) error {
	_, err := q.exec(ctx, q.authCreateJwksStmt, authCreateJwks,
		arg.ID,
		arg.PublicKey,
		arg.PrivateKey,
		arg.CreatedAt,
		arg.ExpiresAt,
	)
	return err
}

const authCreateSession = `-- name: AuthCreateSession :exec
INSERT INTO
  auth_session (
    id,
    user_id,
    token,
    expires_at,
    ip_address,
    user_agent,
    created_at,
    updated_at
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?)
`

type AuthCreateSessionParams struct {
	ID        idwrap.IDWrap
	UserID    idwrap.IDWrap
	Token     string
	ExpiresAt int64
	IpAddress sql.NullString
	UserAgent sql.NullString
	CreatedAt int64
	UpdatedAt int64
}

func (q *Queries) AuthCreateSession(ctx context.Context, arg AuthCreateSessionParams) error {
	_, err := q.exec(ctx, q.authCreateSessionStmt, authCreateSession,
		arg.ID,
		arg.UserID,
		arg.Token,
		arg.ExpiresAt,
		arg.IpAddress,
		arg.UserAgent,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const authCreateUser = `-- name: AuthCreateUser :exec
INSERT INTO
  auth_user (id, name, email, email_verified, image, created_at, updated_at)
VALUES
  (?, ?, ?, ?, ?, ?, ?)
`

type AuthCreateUserParams struct {
	ID            idwrap.IDWrap
	Name          string
	Email         string
	EmailVerified int64
	Image         sql.NullString
	CreatedAt     int64
	UpdatedAt     int64
}

func (q *Queries) AuthCreateUser(ctx context.Context, arg AuthCreateUserParams) error {
	_, err := q.exec(ctx, q.authCreateUserStmt, authCreateUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.EmailVerified,
		arg.Image,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const authCreateVerification = `-- name: AuthCreateVerification :exec
INSERT INTO
  auth_verification (id, identifier, value, expires_at, created_at, updated_at)
VALUES
  (?, ?, ?, ?, ?, ?)
`

type AuthCreateVerificationParams struct {
	ID         idwrap.IDWrap
	Identifier string
	Value      string
	ExpiresAt  int64
	CreatedAt  int64
	UpdatedAt  int64
}

func (q *Queries) AuthCreateVerification(ctx context.Context, arg AuthCreateVerificationParams) error {
	_, err := q.exec(ctx, q.authCreateVerificationStmt, authCreateVerification,
		arg.ID,
		arg.Identifier,
		arg.Value,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const authDeleteAccount = `-- name: AuthDeleteAccount :exec
DELETE FROM auth_account
WHERE
  id = ?
`

func (q *Queries) AuthDeleteAccount(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.authDeleteAccountStmt, authDeleteAccount, id)
	return err
}

const authDeleteAccountsByUser = `-- name: AuthDeleteAccountsByUser :exec
DELETE FROM auth_account
WHERE
  user_id = ?
`

func (q *Queries) AuthDeleteAccountsByUser(ctx context.Context, userID idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.authDeleteAccountsByUserStmt, authDeleteAccountsByUser, userID)
	return err
}

const authDeleteExpiredSessions = `-- name: AuthDeleteExpiredSessions :exec
DELETE FROM auth_session
WHERE
  expires_at < ?
`

func (q *Queries) AuthDeleteExpiredSessions(ctx context.Context, expiresAt int64) error {
	_, err := q.exec(ctx, q.authDeleteExpiredSessionsStmt, authDeleteExpiredSessions, expiresAt)
	return err
}

const authDeleteExpiredVerifications = `-- name: AuthDeleteExpiredVerifications :exec
DELETE FROM auth_verification
WHERE
  expires_at < ?
`

func (q *Queries) AuthDeleteExpiredVerifications(ctx context.Context, expiresAt int64) error {
	_, err := q.exec(ctx, q.authDeleteExpiredVerificationsStmt, authDeleteExpiredVerifications, expiresAt)
	return err
}

const authDeleteJwks = `-- name: AuthDeleteJwks :exec
DELETE FROM auth_jwks
WHERE
  id = ?
`

func (q *Queries) AuthDeleteJwks(ctx context.Context, id []byte) error {
	_, err := q.exec(ctx, q.authDeleteJwksStmt, authDeleteJwks, id)
	return err
}

const authDeleteSession = `-- name: AuthDeleteSession :exec
DELETE FROM auth_session
WHERE
  id = ?
`

func (q *Queries) AuthDeleteSession(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.authDeleteSessionStmt, authDeleteSession, id)
	return err
}

const authDeleteSessionByToken = `-- name: AuthDeleteSessionByToken :exec
DELETE FROM auth_session
WHERE
  token = ?
`

func (q *Queries) AuthDeleteSessionByToken(ctx context.Context, token string) error {
	_, err := q.exec(ctx, q.authDeleteSessionByTokenStmt, authDeleteSessionByToken, token)
	return err
}

const authDeleteUser = `-- name: AuthDeleteUser :exec
DELETE FROM auth_user
WHERE
  id = ?
`

func (q *Queries) AuthDeleteUser(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.authDeleteUserStmt, authDeleteUser, id)
	return err
}

const authDeleteVerification = `-- name: AuthDeleteVerification :exec
DELETE FROM auth_verification
WHERE
  id = ?
`

func (q *Queries) AuthDeleteVerification(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.authDeleteVerificationStmt, authDeleteVerification, id)
	return err
}

const authGetAccount = `-- name: AuthGetAccount :one

SELECT
  id,
  user_id,
  account_id,
  provider_id,
  access_token,
  refresh_token,
  access_token_expires_at,
  refresh_token_expires_at,
  scope,
  id_token,
  password,
  created_at,
  updated_at
FROM
  auth_account
WHERE
  id = ?
LIMIT
  1
`

// Accounts
func (q *Queries) AuthGetAccount(ctx context.Context, id idwrap.IDWrap) (AuthAccount, error) {
	row := q.queryRow(ctx, q.authGetAccountStmt, authGetAccount, id)
	var i AuthAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.ProviderID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.IDToken,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const authGetAccountByProvider = `-- name: AuthGetAccountByProvider :one
SELECT
  id,
  user_id,
  account_id,
  provider_id,
  access_token,
  refresh_token,
  access_token_expires_at,
  refresh_token_expires_at,
  scope,
  id_token,
  password,
  created_at,
  updated_at
FROM
  auth_account
WHERE
  provider_id = ?
  AND account_id = ?
LIMIT
  1
`

type AuthGetAccountByProviderParams struct {
	ProviderID string
	AccountID  string
}

func (q *Queries) AuthGetAccountByProvider(ctx context.Context, arg AuthGetAccountByProviderParams) (AuthAccount, error) {
	row := q.queryRow(ctx, q.authGetAccountByProviderStmt, authGetAccountByProvider, arg.ProviderID, arg.AccountID)
	var i AuthAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountID,
		&i.ProviderID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshTokenExpiresAt,
		&i.Scope,
		&i.IDToken,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const authGetSession = `-- name: AuthGetSession :one

SELECT
  id,
  user_id,
  token,
  expires_at,
  ip_address,
  user_agent,
  created_at,
  updated_at
FROM
  auth_session
WHERE
  id = ?
LIMIT
  1
`

// Sessions
func (q *Queries) AuthGetSession(ctx context.Context, id idwrap.IDWrap) (AuthSession, error) {
	row := q.queryRow(ctx, q.authGetSessionStmt, authGetSession, id)
	var i AuthSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const authGetSessionByToken = `-- name: AuthGetSessionByToken :one
SELECT
  id,
  user_id,
  token,
  expires_at,
  ip_address,
  user_agent,
  created_at,
  updated_at
FROM
  auth_session
WHERE
  token = ?
LIMIT
  1
`

func (q *Queries) AuthGetSessionByToken(ctx context.Context, token string) (AuthSession, error) {
	row := q.queryRow(ctx, q.authGetSessionByTokenStmt, authGetSessionByToken, token)
	var i AuthSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const authGetUser = `-- name: AuthGetUser :one

SELECT
  id,
  name,
  email,
  email_verified,
  image,
  created_at,
  updated_at
FROM
  auth_user
WHERE
  id = ?
LIMIT
  1
`

// BetterAuth
func (q *Queries) AuthGetUser(ctx context.Context, id idwrap.IDWrap) (AuthUser, error) {
	row := q.queryRow(ctx, q.authGetUserStmt, authGetUser, id)
	var i AuthUser
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const authGetUserByEmail = `-- name: AuthGetUserByEmail :one
SELECT
  id,
  name,
  email,
  email_verified,
  image,
  created_at,
  updated_at
FROM
  auth_user
WHERE
  email = ?
LIMIT
  1
`

func (q *Queries) AuthGetUserByEmail(ctx context.Context, email string) (AuthUser, error) {
	row := q.queryRow(ctx, q.authGetUserByEmailStmt, authGetUserByEmail, email)
	var i AuthUser
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const authGetVerification = `-- name: AuthGetVerification :one

SELECT
  id,
  identifier,
  value,
  expires_at,
  created_at,
  updated_at
FROM
  auth_verification
WHERE
  id = ?
LIMIT
  1
`

// Verifications
func (q *Queries) AuthGetVerification(ctx context.Context, id idwrap.IDWrap) (AuthVerification, error) {
	row := q.queryRow(ctx, q.authGetVerificationStmt, authGetVerification, id)
	var i AuthVerification
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const authGetVerificationByIdentifier = `-- name: AuthGetVerificationByIdentifier :one
SELECT
  id,
  identifier,
  value,
  expires_at,
  created_at,
  updated_at
FROM
  auth_verification
WHERE
  identifier = ?
LIMIT
  1
`

func (q *Queries) AuthGetVerificationByIdentifier(ctx context.Context, identifier string) (AuthVerification, error) {
	row := q.queryRow(ctx, q.authGetVerificationByIdentifierStmt, authGetVerificationByIdentifier, identifier)
	var i AuthVerification
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.Value,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const authListAccountsByUser = `-- name: AuthListAccountsByUser :many
SELECT
  id,
  user_id,
  account_id,
  provider_id,
  access_token,
  refresh_token,
  access_token_expires_at,
  refresh_token_expires_at,
  scope,
  id_token,
  password,
  created_at,
  updated_at
FROM
  auth_account
WHERE
  user_id = ?
`

func (q *Queries) AuthListAccountsByUser(ctx context.Context, userID idwrap.IDWrap) ([]AuthAccount, error) {
	rows, err := q.query(ctx, q.authListAccountsByUserStmt, authListAccountsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuthAccount{}
	for rows.Next() {
		var i AuthAccount
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountID,
			&i.ProviderID,
			&i.AccessToken,
			&i.RefreshToken,
			&i.AccessTokenExpiresAt,
			&i.RefreshTokenExpiresAt,
			&i.Scope,
			&i.IDToken,
			&i.Password,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const authListJwks = `-- name: AuthListJwks :many
SELECT
  id,
  public_key,
  private_key,
  created_at,
  expires_at
FROM
  auth_jwks
ORDER BY
  created_at DESC
`

func (q *Queries) AuthListJwks(ctx context.Context) ([]AuthJwk, error) {
	rows, err := q.query(ctx, q.authListJwksStmt, authListJwks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuthJwk{}
	for rows.Next() {
		var i AuthJwk
		if err := rows.Scan(
			&i.ID,
			&i.PublicKey,
			&i.PrivateKey,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const authListSessionsByUser = `-- name: AuthListSessionsByUser :many
SELECT
  id,
  user_id,
  token,
  expires_at,
  ip_address,
  user_agent,
  created_at,
  updated_at
FROM
  auth_session
WHERE
  user_id = ?
`

func (q *Queries) AuthListSessionsByUser(ctx context.Context, userID idwrap.IDWrap) ([]AuthSession, error) {
	rows, err := q.query(ctx, q.authListSessionsByUserStmt, authListSessionsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuthSession{}
	for rows.Next() {
		var i AuthSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Token,
			&i.ExpiresAt,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const authUpdateAccount = `-- name: AuthUpdateAccount :exec
UPDATE auth_account
SET
  access_token = ?,
  refresh_token = ?,
  access_token_expires_at = ?,
  refresh_token_expires_at = ?,
  scope = ?,
  id_token = ?,
  password = ?,
  updated_at = ?
WHERE
  id = ?
`

type AuthUpdateAccountParams struct {
	AccessToken           sql.NullString
	RefreshToken          sql.NullString
	AccessTokenExpiresAt  *int64
	RefreshTokenExpiresAt *int64
	Scope                 sql.NullString
	IDToken               sql.NullString
	Password              sql.NullString
	UpdatedAt             int64
	ID                    idwrap.IDWrap
}

func (q *Queries) AuthUpdateAccount(ctx context.Context, arg AuthUpdateAccountParams) error {
	_, err := q.exec(ctx, q.authUpdateAccountStmt, authUpdateAccount,
		arg.AccessToken,
		arg.RefreshToken,
		arg.AccessTokenExpiresAt,
		arg.RefreshTokenExpiresAt,
		arg.Scope,
		arg.IDToken,
		arg.Password,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const authUpdateSession = `-- name: AuthUpdateSession :exec
UPDATE auth_session
SET
  expires_at = ?,
  ip_address = ?,
  user_agent = ?,
  updated_at = ?
WHERE
  id = ?
`

type AuthUpdateSessionParams struct {
	ExpiresAt int64
	IpAddress sql.NullString
	UserAgent sql.NullString
	UpdatedAt int64
	ID        idwrap.IDWrap
}

func (q *Queries) AuthUpdateSession(ctx context.Context, arg AuthUpdateSessionParams) error {
	_, err := q.exec(ctx, q.authUpdateSessionStmt, authUpdateSession,
		arg.ExpiresAt,
		arg.IpAddress,
		arg.UserAgent,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const authUpdateUser = `-- name: AuthUpdateUser :exec
UPDATE auth_user
SET
  name = ?,
  email = ?,
  email_verified = ?,
  image = ?,
  updated_at = ?
WHERE
  id = ?
`

type AuthUpdateUserParams struct {
	Name          string
	Email         string
	EmailVerified int64
	Image         sql.NullString
	UpdatedAt     int64
	ID            idwrap.IDWrap
}

func (q *Queries) AuthUpdateUser(ctx context.Context, arg AuthUpdateUserParams) error {
	_, err := q.exec(ctx, q.authUpdateUserStmt, authUpdateUser,
		arg.Name,
		arg.Email,
		arg.EmailVerified,
		arg.Image,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
