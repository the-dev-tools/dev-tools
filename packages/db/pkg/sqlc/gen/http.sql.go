// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: http.sql

package gen

import (
	"context"
	"database/sql"
	"strings"
	"time"

	idwrap "the-dev-tools/server/pkg/idwrap"
)

const createHTTP = `-- name: CreateHTTP :exec
INSERT INTO http (
  id, workspace_id, folder_id, name, url, method, body_kind, description,
  parent_http_id, is_delta, delta_name, delta_url, delta_method, delta_body_kind, delta_description,
  last_run_at, created_at, updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPParams struct {
	ID               idwrap.IDWrap
	WorkspaceID      idwrap.IDWrap
	FolderID         *idwrap.IDWrap
	Name             string
	Url              string
	Method           string
	BodyKind         int8
	Description      string
	ParentHttpID     *idwrap.IDWrap
	IsDelta          bool
	DeltaName        *string
	DeltaUrl         *string
	DeltaMethod      *string
	DeltaBodyKind    interface{}
	DeltaDescription *string
	LastRunAt        interface{}
	CreatedAt        int64
	UpdatedAt        int64
}

func (q *Queries) CreateHTTP(ctx context.Context, arg CreateHTTPParams) error {
	_, err := q.exec(ctx, q.createHTTPStmt, createHTTP,
		arg.ID,
		arg.WorkspaceID,
		arg.FolderID,
		arg.Name,
		arg.Url,
		arg.Method,
		arg.BodyKind,
		arg.Description,
		arg.ParentHttpID,
		arg.IsDelta,
		arg.DeltaName,
		arg.DeltaUrl,
		arg.DeltaMethod,
		arg.DeltaBodyKind,
		arg.DeltaDescription,
		arg.LastRunAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createHTTPAssert = `-- name: CreateHTTPAssert :exec
INSERT INTO http_assert (
  id, http_id, value, enabled, description, "order",
  parent_http_assert_id, is_delta, delta_value,
  delta_enabled, delta_description, delta_order, created_at, updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPAssertParams struct {
	ID                 idwrap.IDWrap
	HttpID             idwrap.IDWrap
	Value              string
	Enabled            bool
	Description        string
	Order              float64
	ParentHttpAssertID []byte
	IsDelta            bool
	DeltaValue         sql.NullString
	DeltaEnabled       *bool
	DeltaDescription   sql.NullString
	DeltaOrder         sql.NullFloat64
	CreatedAt          int64
	UpdatedAt          int64
}

func (q *Queries) CreateHTTPAssert(ctx context.Context, arg CreateHTTPAssertParams) error {
	_, err := q.exec(ctx, q.createHTTPAssertStmt, createHTTPAssert,
		arg.ID,
		arg.HttpID,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.Order,
		arg.ParentHttpAssertID,
		arg.IsDelta,
		arg.DeltaValue,
		arg.DeltaEnabled,
		arg.DeltaDescription,
		arg.DeltaOrder,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createHTTPAssertBulk = `-- name: CreateHTTPAssertBulk :exec
INSERT INTO http_assert (
  id, http_id, value, enabled, description, "order",
  parent_http_assert_id, is_delta, delta_value,
  delta_enabled, delta_description, delta_order, created_at, updated_at
)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPAssertBulkParams struct {
	ID                    idwrap.IDWrap
	HttpID                idwrap.IDWrap
	Value                 string
	Enabled               bool
	Description           string
	Order                 float64
	ParentHttpAssertID    []byte
	IsDelta               bool
	DeltaValue            sql.NullString
	DeltaEnabled          *bool
	DeltaDescription      sql.NullString
	DeltaOrder            sql.NullFloat64
	CreatedAt             int64
	UpdatedAt             int64
	ID_2                  idwrap.IDWrap
	HttpID_2              idwrap.IDWrap
	Value_2               string
	Enabled_2             bool
	Description_2         string
	Order_2               float64
	ParentHttpAssertID_2  []byte
	IsDelta_2             bool
	DeltaValue_2          sql.NullString
	DeltaEnabled_2        *bool
	DeltaDescription_2    sql.NullString
	DeltaOrder_2          sql.NullFloat64
	CreatedAt_2           int64
	UpdatedAt_2           int64
	ID_3                  idwrap.IDWrap
	HttpID_3              idwrap.IDWrap
	Value_3               string
	Enabled_3             bool
	Description_3         string
	Order_3               float64
	ParentHttpAssertID_3  []byte
	IsDelta_3             bool
	DeltaValue_3          sql.NullString
	DeltaEnabled_3        *bool
	DeltaDescription_3    sql.NullString
	DeltaOrder_3          sql.NullFloat64
	CreatedAt_3           int64
	UpdatedAt_3           int64
	ID_4                  idwrap.IDWrap
	HttpID_4              idwrap.IDWrap
	Value_4               string
	Enabled_4             bool
	Description_4         string
	Order_4               float64
	ParentHttpAssertID_4  []byte
	IsDelta_4             bool
	DeltaValue_4          sql.NullString
	DeltaEnabled_4        *bool
	DeltaDescription_4    sql.NullString
	DeltaOrder_4          sql.NullFloat64
	CreatedAt_4           int64
	UpdatedAt_4           int64
	ID_5                  idwrap.IDWrap
	HttpID_5              idwrap.IDWrap
	Value_5               string
	Enabled_5             bool
	Description_5         string
	Order_5               float64
	ParentHttpAssertID_5  []byte
	IsDelta_5             bool
	DeltaValue_5          sql.NullString
	DeltaEnabled_5        *bool
	DeltaDescription_5    sql.NullString
	DeltaOrder_5          sql.NullFloat64
	CreatedAt_5           int64
	UpdatedAt_5           int64
	ID_6                  idwrap.IDWrap
	HttpID_6              idwrap.IDWrap
	Value_6               string
	Enabled_6             bool
	Description_6         string
	Order_6               float64
	ParentHttpAssertID_6  []byte
	IsDelta_6             bool
	DeltaValue_6          sql.NullString
	DeltaEnabled_6        *bool
	DeltaDescription_6    sql.NullString
	DeltaOrder_6          sql.NullFloat64
	CreatedAt_6           int64
	UpdatedAt_6           int64
	ID_7                  idwrap.IDWrap
	HttpID_7              idwrap.IDWrap
	Value_7               string
	Enabled_7             bool
	Description_7         string
	Order_7               float64
	ParentHttpAssertID_7  []byte
	IsDelta_7             bool
	DeltaValue_7          sql.NullString
	DeltaEnabled_7        *bool
	DeltaDescription_7    sql.NullString
	DeltaOrder_7          sql.NullFloat64
	CreatedAt_7           int64
	UpdatedAt_7           int64
	ID_8                  idwrap.IDWrap
	HttpID_8              idwrap.IDWrap
	Value_8               string
	Enabled_8             bool
	Description_8         string
	Order_8               float64
	ParentHttpAssertID_8  []byte
	IsDelta_8             bool
	DeltaValue_8          sql.NullString
	DeltaEnabled_8        *bool
	DeltaDescription_8    sql.NullString
	DeltaOrder_8          sql.NullFloat64
	CreatedAt_8           int64
	UpdatedAt_8           int64
	ID_9                  idwrap.IDWrap
	HttpID_9              idwrap.IDWrap
	Value_9               string
	Enabled_9             bool
	Description_9         string
	Order_9               float64
	ParentHttpAssertID_9  []byte
	IsDelta_9             bool
	DeltaValue_9          sql.NullString
	DeltaEnabled_9        *bool
	DeltaDescription_9    sql.NullString
	DeltaOrder_9          sql.NullFloat64
	CreatedAt_9           int64
	UpdatedAt_9           int64
	ID_10                 idwrap.IDWrap
	HttpID_10             idwrap.IDWrap
	Value_10              string
	Enabled_10            bool
	Description_10        string
	Order_10              float64
	ParentHttpAssertID_10 []byte
	IsDelta_10            bool
	DeltaValue_10         sql.NullString
	DeltaEnabled_10       *bool
	DeltaDescription_10   sql.NullString
	DeltaOrder_10         sql.NullFloat64
	CreatedAt_10          int64
	UpdatedAt_10          int64
}

func (q *Queries) CreateHTTPAssertBulk(ctx context.Context, arg CreateHTTPAssertBulkParams) error {
	_, err := q.exec(ctx, q.createHTTPAssertBulkStmt, createHTTPAssertBulk,
		arg.ID,
		arg.HttpID,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.Order,
		arg.ParentHttpAssertID,
		arg.IsDelta,
		arg.DeltaValue,
		arg.DeltaEnabled,
		arg.DeltaDescription,
		arg.DeltaOrder,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ID_2,
		arg.HttpID_2,
		arg.Value_2,
		arg.Enabled_2,
		arg.Description_2,
		arg.Order_2,
		arg.ParentHttpAssertID_2,
		arg.IsDelta_2,
		arg.DeltaValue_2,
		arg.DeltaEnabled_2,
		arg.DeltaDescription_2,
		arg.DeltaOrder_2,
		arg.CreatedAt_2,
		arg.UpdatedAt_2,
		arg.ID_3,
		arg.HttpID_3,
		arg.Value_3,
		arg.Enabled_3,
		arg.Description_3,
		arg.Order_3,
		arg.ParentHttpAssertID_3,
		arg.IsDelta_3,
		arg.DeltaValue_3,
		arg.DeltaEnabled_3,
		arg.DeltaDescription_3,
		arg.DeltaOrder_3,
		arg.CreatedAt_3,
		arg.UpdatedAt_3,
		arg.ID_4,
		arg.HttpID_4,
		arg.Value_4,
		arg.Enabled_4,
		arg.Description_4,
		arg.Order_4,
		arg.ParentHttpAssertID_4,
		arg.IsDelta_4,
		arg.DeltaValue_4,
		arg.DeltaEnabled_4,
		arg.DeltaDescription_4,
		arg.DeltaOrder_4,
		arg.CreatedAt_4,
		arg.UpdatedAt_4,
		arg.ID_5,
		arg.HttpID_5,
		arg.Value_5,
		arg.Enabled_5,
		arg.Description_5,
		arg.Order_5,
		arg.ParentHttpAssertID_5,
		arg.IsDelta_5,
		arg.DeltaValue_5,
		arg.DeltaEnabled_5,
		arg.DeltaDescription_5,
		arg.DeltaOrder_5,
		arg.CreatedAt_5,
		arg.UpdatedAt_5,
		arg.ID_6,
		arg.HttpID_6,
		arg.Value_6,
		arg.Enabled_6,
		arg.Description_6,
		arg.Order_6,
		arg.ParentHttpAssertID_6,
		arg.IsDelta_6,
		arg.DeltaValue_6,
		arg.DeltaEnabled_6,
		arg.DeltaDescription_6,
		arg.DeltaOrder_6,
		arg.CreatedAt_6,
		arg.UpdatedAt_6,
		arg.ID_7,
		arg.HttpID_7,
		arg.Value_7,
		arg.Enabled_7,
		arg.Description_7,
		arg.Order_7,
		arg.ParentHttpAssertID_7,
		arg.IsDelta_7,
		arg.DeltaValue_7,
		arg.DeltaEnabled_7,
		arg.DeltaDescription_7,
		arg.DeltaOrder_7,
		arg.CreatedAt_7,
		arg.UpdatedAt_7,
		arg.ID_8,
		arg.HttpID_8,
		arg.Value_8,
		arg.Enabled_8,
		arg.Description_8,
		arg.Order_8,
		arg.ParentHttpAssertID_8,
		arg.IsDelta_8,
		arg.DeltaValue_8,
		arg.DeltaEnabled_8,
		arg.DeltaDescription_8,
		arg.DeltaOrder_8,
		arg.CreatedAt_8,
		arg.UpdatedAt_8,
		arg.ID_9,
		arg.HttpID_9,
		arg.Value_9,
		arg.Enabled_9,
		arg.Description_9,
		arg.Order_9,
		arg.ParentHttpAssertID_9,
		arg.IsDelta_9,
		arg.DeltaValue_9,
		arg.DeltaEnabled_9,
		arg.DeltaDescription_9,
		arg.DeltaOrder_9,
		arg.CreatedAt_9,
		arg.UpdatedAt_9,
		arg.ID_10,
		arg.HttpID_10,
		arg.Value_10,
		arg.Enabled_10,
		arg.Description_10,
		arg.Order_10,
		arg.ParentHttpAssertID_10,
		arg.IsDelta_10,
		arg.DeltaValue_10,
		arg.DeltaEnabled_10,
		arg.DeltaDescription_10,
		arg.DeltaOrder_10,
		arg.CreatedAt_10,
		arg.UpdatedAt_10,
	)
	return err
}

const createHTTPBodyForm = `-- name: CreateHTTPBodyForm :exec
INSERT INTO http_body_form (
  id, http_id, key, value, description, enabled, "order",
  parent_http_body_form_id, is_delta, delta_key, delta_value,
  delta_description, delta_enabled, created_at, updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPBodyFormParams struct {
	ID                   idwrap.IDWrap
	HttpID               idwrap.IDWrap
	Key                  string
	Value                string
	Description          string
	Enabled              bool
	Order                float64
	ParentHttpBodyFormID []byte
	IsDelta              bool
	DeltaKey             sql.NullString
	DeltaValue           sql.NullString
	DeltaDescription     *string
	DeltaEnabled         *bool
	CreatedAt            int64
	UpdatedAt            int64
}

func (q *Queries) CreateHTTPBodyForm(ctx context.Context, arg CreateHTTPBodyFormParams) error {
	_, err := q.exec(ctx, q.createHTTPBodyFormStmt, createHTTPBodyForm,
		arg.ID,
		arg.HttpID,
		arg.Key,
		arg.Value,
		arg.Description,
		arg.Enabled,
		arg.Order,
		arg.ParentHttpBodyFormID,
		arg.IsDelta,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaDescription,
		arg.DeltaEnabled,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createHTTPBodyRaw = `-- name: CreateHTTPBodyRaw :exec
INSERT INTO
  http_body_raw (
    id,
    http_id,
    raw_data,
    content_type,
    compression_type,
    parent_body_raw_id,
    is_delta,
    delta_raw_data,
    delta_content_type,
    delta_compression_type,
    created_at,
    updated_at
  )
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPBodyRawParams struct {
	ID                   idwrap.IDWrap
	HttpID               idwrap.IDWrap
	RawData              []byte
	ContentType          string
	CompressionType      int8
	ParentBodyRawID      *idwrap.IDWrap
	IsDelta              bool
	DeltaRawData         interface{}
	DeltaContentType     interface{}
	DeltaCompressionType interface{}
	CreatedAt            int64
	UpdatedAt            int64
}

func (q *Queries) CreateHTTPBodyRaw(ctx context.Context, arg CreateHTTPBodyRawParams) error {
	_, err := q.exec(ctx, q.createHTTPBodyRawStmt, createHTTPBodyRaw,
		arg.ID,
		arg.HttpID,
		arg.RawData,
		arg.ContentType,
		arg.CompressionType,
		arg.ParentBodyRawID,
		arg.IsDelta,
		arg.DeltaRawData,
		arg.DeltaContentType,
		arg.DeltaCompressionType,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createHTTPBodyUrlEncoded = `-- name: CreateHTTPBodyUrlEncoded :exec
INSERT INTO http_body_urlencoded (
  id, http_id, key, value, enabled, description, "order",
  parent_http_body_urlencoded_id, is_delta, delta_key, delta_value,
  delta_enabled, delta_description, delta_order, created_at, updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPBodyUrlEncodedParams struct {
	ID                         idwrap.IDWrap
	HttpID                     idwrap.IDWrap
	Key                        string
	Value                      string
	Enabled                    bool
	Description                string
	Order                      float64
	ParentHttpBodyUrlencodedID []byte
	IsDelta                    bool
	DeltaKey                   sql.NullString
	DeltaValue                 sql.NullString
	DeltaEnabled               *bool
	DeltaDescription           *string
	DeltaOrder                 sql.NullFloat64
	CreatedAt                  int64
	UpdatedAt                  int64
}

func (q *Queries) CreateHTTPBodyUrlEncoded(ctx context.Context, arg CreateHTTPBodyUrlEncodedParams) error {
	_, err := q.exec(ctx, q.createHTTPBodyUrlEncodedStmt, createHTTPBodyUrlEncoded,
		arg.ID,
		arg.HttpID,
		arg.Key,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.Order,
		arg.ParentHttpBodyUrlencodedID,
		arg.IsDelta,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaEnabled,
		arg.DeltaDescription,
		arg.DeltaOrder,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createHTTPBodyUrlEncodedBulk = `-- name: CreateHTTPBodyUrlEncodedBulk :exec
INSERT INTO http_body_urlencoded (
  id, http_id, key, value, enabled, description, "order",
  parent_http_body_urlencoded_id, is_delta, delta_key, delta_value,
  delta_enabled, delta_description, delta_order, created_at, updated_at
)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPBodyUrlEncodedBulkParams struct {
	ID                            idwrap.IDWrap
	HttpID                        idwrap.IDWrap
	Key                           string
	Value                         string
	Enabled                       bool
	Description                   string
	Order                         float64
	ParentHttpBodyUrlencodedID    []byte
	IsDelta                       bool
	DeltaKey                      sql.NullString
	DeltaValue                    sql.NullString
	DeltaEnabled                  *bool
	DeltaDescription              *string
	DeltaOrder                    sql.NullFloat64
	CreatedAt                     int64
	UpdatedAt                     int64
	ID_2                          idwrap.IDWrap
	HttpID_2                      idwrap.IDWrap
	Key_2                         string
	Value_2                       string
	Enabled_2                     bool
	Description_2                 string
	Order_2                       float64
	ParentHttpBodyUrlencodedID_2  []byte
	IsDelta_2                     bool
	DeltaKey_2                    sql.NullString
	DeltaValue_2                  sql.NullString
	DeltaEnabled_2                *bool
	DeltaDescription_2            *string
	DeltaOrder_2                  sql.NullFloat64
	CreatedAt_2                   int64
	UpdatedAt_2                   int64
	ID_3                          idwrap.IDWrap
	HttpID_3                      idwrap.IDWrap
	Key_3                         string
	Value_3                       string
	Enabled_3                     bool
	Description_3                 string
	Order_3                       float64
	ParentHttpBodyUrlencodedID_3  []byte
	IsDelta_3                     bool
	DeltaKey_3                    sql.NullString
	DeltaValue_3                  sql.NullString
	DeltaEnabled_3                *bool
	DeltaDescription_3            *string
	DeltaOrder_3                  sql.NullFloat64
	CreatedAt_3                   int64
	UpdatedAt_3                   int64
	ID_4                          idwrap.IDWrap
	HttpID_4                      idwrap.IDWrap
	Key_4                         string
	Value_4                       string
	Enabled_4                     bool
	Description_4                 string
	Order_4                       float64
	ParentHttpBodyUrlencodedID_4  []byte
	IsDelta_4                     bool
	DeltaKey_4                    sql.NullString
	DeltaValue_4                  sql.NullString
	DeltaEnabled_4                *bool
	DeltaDescription_4            *string
	DeltaOrder_4                  sql.NullFloat64
	CreatedAt_4                   int64
	UpdatedAt_4                   int64
	ID_5                          idwrap.IDWrap
	HttpID_5                      idwrap.IDWrap
	Key_5                         string
	Value_5                       string
	Enabled_5                     bool
	Description_5                 string
	Order_5                       float64
	ParentHttpBodyUrlencodedID_5  []byte
	IsDelta_5                     bool
	DeltaKey_5                    sql.NullString
	DeltaValue_5                  sql.NullString
	DeltaEnabled_5                *bool
	DeltaDescription_5            *string
	DeltaOrder_5                  sql.NullFloat64
	CreatedAt_5                   int64
	UpdatedAt_5                   int64
	ID_6                          idwrap.IDWrap
	HttpID_6                      idwrap.IDWrap
	Key_6                         string
	Value_6                       string
	Enabled_6                     bool
	Description_6                 string
	Order_6                       float64
	ParentHttpBodyUrlencodedID_6  []byte
	IsDelta_6                     bool
	DeltaKey_6                    sql.NullString
	DeltaValue_6                  sql.NullString
	DeltaEnabled_6                *bool
	DeltaDescription_6            *string
	DeltaOrder_6                  sql.NullFloat64
	CreatedAt_6                   int64
	UpdatedAt_6                   int64
	ID_7                          idwrap.IDWrap
	HttpID_7                      idwrap.IDWrap
	Key_7                         string
	Value_7                       string
	Enabled_7                     bool
	Description_7                 string
	Order_7                       float64
	ParentHttpBodyUrlencodedID_7  []byte
	IsDelta_7                     bool
	DeltaKey_7                    sql.NullString
	DeltaValue_7                  sql.NullString
	DeltaEnabled_7                *bool
	DeltaDescription_7            *string
	DeltaOrder_7                  sql.NullFloat64
	CreatedAt_7                   int64
	UpdatedAt_7                   int64
	ID_8                          idwrap.IDWrap
	HttpID_8                      idwrap.IDWrap
	Key_8                         string
	Value_8                       string
	Enabled_8                     bool
	Description_8                 string
	Order_8                       float64
	ParentHttpBodyUrlencodedID_8  []byte
	IsDelta_8                     bool
	DeltaKey_8                    sql.NullString
	DeltaValue_8                  sql.NullString
	DeltaEnabled_8                *bool
	DeltaDescription_8            *string
	DeltaOrder_8                  sql.NullFloat64
	CreatedAt_8                   int64
	UpdatedAt_8                   int64
	ID_9                          idwrap.IDWrap
	HttpID_9                      idwrap.IDWrap
	Key_9                         string
	Value_9                       string
	Enabled_9                     bool
	Description_9                 string
	Order_9                       float64
	ParentHttpBodyUrlencodedID_9  []byte
	IsDelta_9                     bool
	DeltaKey_9                    sql.NullString
	DeltaValue_9                  sql.NullString
	DeltaEnabled_9                *bool
	DeltaDescription_9            *string
	DeltaOrder_9                  sql.NullFloat64
	CreatedAt_9                   int64
	UpdatedAt_9                   int64
	ID_10                         idwrap.IDWrap
	HttpID_10                     idwrap.IDWrap
	Key_10                        string
	Value_10                      string
	Enabled_10                    bool
	Description_10                string
	Order_10                      float64
	ParentHttpBodyUrlencodedID_10 []byte
	IsDelta_10                    bool
	DeltaKey_10                   sql.NullString
	DeltaValue_10                 sql.NullString
	DeltaEnabled_10               *bool
	DeltaDescription_10           *string
	DeltaOrder_10                 sql.NullFloat64
	CreatedAt_10                  int64
	UpdatedAt_10                  int64
}

func (q *Queries) CreateHTTPBodyUrlEncodedBulk(ctx context.Context, arg CreateHTTPBodyUrlEncodedBulkParams) error {
	_, err := q.exec(ctx, q.createHTTPBodyUrlEncodedBulkStmt, createHTTPBodyUrlEncodedBulk,
		arg.ID,
		arg.HttpID,
		arg.Key,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.Order,
		arg.ParentHttpBodyUrlencodedID,
		arg.IsDelta,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaEnabled,
		arg.DeltaDescription,
		arg.DeltaOrder,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ID_2,
		arg.HttpID_2,
		arg.Key_2,
		arg.Value_2,
		arg.Enabled_2,
		arg.Description_2,
		arg.Order_2,
		arg.ParentHttpBodyUrlencodedID_2,
		arg.IsDelta_2,
		arg.DeltaKey_2,
		arg.DeltaValue_2,
		arg.DeltaEnabled_2,
		arg.DeltaDescription_2,
		arg.DeltaOrder_2,
		arg.CreatedAt_2,
		arg.UpdatedAt_2,
		arg.ID_3,
		arg.HttpID_3,
		arg.Key_3,
		arg.Value_3,
		arg.Enabled_3,
		arg.Description_3,
		arg.Order_3,
		arg.ParentHttpBodyUrlencodedID_3,
		arg.IsDelta_3,
		arg.DeltaKey_3,
		arg.DeltaValue_3,
		arg.DeltaEnabled_3,
		arg.DeltaDescription_3,
		arg.DeltaOrder_3,
		arg.CreatedAt_3,
		arg.UpdatedAt_3,
		arg.ID_4,
		arg.HttpID_4,
		arg.Key_4,
		arg.Value_4,
		arg.Enabled_4,
		arg.Description_4,
		arg.Order_4,
		arg.ParentHttpBodyUrlencodedID_4,
		arg.IsDelta_4,
		arg.DeltaKey_4,
		arg.DeltaValue_4,
		arg.DeltaEnabled_4,
		arg.DeltaDescription_4,
		arg.DeltaOrder_4,
		arg.CreatedAt_4,
		arg.UpdatedAt_4,
		arg.ID_5,
		arg.HttpID_5,
		arg.Key_5,
		arg.Value_5,
		arg.Enabled_5,
		arg.Description_5,
		arg.Order_5,
		arg.ParentHttpBodyUrlencodedID_5,
		arg.IsDelta_5,
		arg.DeltaKey_5,
		arg.DeltaValue_5,
		arg.DeltaEnabled_5,
		arg.DeltaDescription_5,
		arg.DeltaOrder_5,
		arg.CreatedAt_5,
		arg.UpdatedAt_5,
		arg.ID_6,
		arg.HttpID_6,
		arg.Key_6,
		arg.Value_6,
		arg.Enabled_6,
		arg.Description_6,
		arg.Order_6,
		arg.ParentHttpBodyUrlencodedID_6,
		arg.IsDelta_6,
		arg.DeltaKey_6,
		arg.DeltaValue_6,
		arg.DeltaEnabled_6,
		arg.DeltaDescription_6,
		arg.DeltaOrder_6,
		arg.CreatedAt_6,
		arg.UpdatedAt_6,
		arg.ID_7,
		arg.HttpID_7,
		arg.Key_7,
		arg.Value_7,
		arg.Enabled_7,
		arg.Description_7,
		arg.Order_7,
		arg.ParentHttpBodyUrlencodedID_7,
		arg.IsDelta_7,
		arg.DeltaKey_7,
		arg.DeltaValue_7,
		arg.DeltaEnabled_7,
		arg.DeltaDescription_7,
		arg.DeltaOrder_7,
		arg.CreatedAt_7,
		arg.UpdatedAt_7,
		arg.ID_8,
		arg.HttpID_8,
		arg.Key_8,
		arg.Value_8,
		arg.Enabled_8,
		arg.Description_8,
		arg.Order_8,
		arg.ParentHttpBodyUrlencodedID_8,
		arg.IsDelta_8,
		arg.DeltaKey_8,
		arg.DeltaValue_8,
		arg.DeltaEnabled_8,
		arg.DeltaDescription_8,
		arg.DeltaOrder_8,
		arg.CreatedAt_8,
		arg.UpdatedAt_8,
		arg.ID_9,
		arg.HttpID_9,
		arg.Key_9,
		arg.Value_9,
		arg.Enabled_9,
		arg.Description_9,
		arg.Order_9,
		arg.ParentHttpBodyUrlencodedID_9,
		arg.IsDelta_9,
		arg.DeltaKey_9,
		arg.DeltaValue_9,
		arg.DeltaEnabled_9,
		arg.DeltaDescription_9,
		arg.DeltaOrder_9,
		arg.CreatedAt_9,
		arg.UpdatedAt_9,
		arg.ID_10,
		arg.HttpID_10,
		arg.Key_10,
		arg.Value_10,
		arg.Enabled_10,
		arg.Description_10,
		arg.Order_10,
		arg.ParentHttpBodyUrlencodedID_10,
		arg.IsDelta_10,
		arg.DeltaKey_10,
		arg.DeltaValue_10,
		arg.DeltaEnabled_10,
		arg.DeltaDescription_10,
		arg.DeltaOrder_10,
		arg.CreatedAt_10,
		arg.UpdatedAt_10,
	)
	return err
}

const createHTTPHeader = `-- name: CreateHTTPHeader :exec
INSERT INTO http_header (
  id, http_id, header_key, header_value, description, enabled,
  parent_header_id, is_delta, delta_header_key, delta_header_value,
  delta_description, delta_enabled, delta_display_order, display_order, created_at, updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPHeaderParams struct {
	ID                idwrap.IDWrap
	HttpID            idwrap.IDWrap
	HeaderKey         string
	HeaderValue       string
	Description       string
	Enabled           bool
	ParentHeaderID    *idwrap.IDWrap
	IsDelta           bool
	DeltaHeaderKey    *string
	DeltaHeaderValue  *string
	DeltaDescription  *string
	DeltaEnabled      *bool
	DeltaDisplayOrder sql.NullFloat64
	DisplayOrder      float64
	CreatedAt         int64
	UpdatedAt         int64
}

func (q *Queries) CreateHTTPHeader(ctx context.Context, arg CreateHTTPHeaderParams) error {
	_, err := q.exec(ctx, q.createHTTPHeaderStmt, createHTTPHeader,
		arg.ID,
		arg.HttpID,
		arg.HeaderKey,
		arg.HeaderValue,
		arg.Description,
		arg.Enabled,
		arg.ParentHeaderID,
		arg.IsDelta,
		arg.DeltaHeaderKey,
		arg.DeltaHeaderValue,
		arg.DeltaDescription,
		arg.DeltaEnabled,
		arg.DeltaDisplayOrder,
		arg.DisplayOrder,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createHTTPResponse = `-- name: CreateHTTPResponse :exec
INSERT INTO http_response (
  id, http_id, status, body, time, duration, size, created_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPResponseParams struct {
	ID        idwrap.IDWrap
	HttpID    idwrap.IDWrap
	Status    interface{}
	Body      []byte
	Time      time.Time
	Duration  interface{}
	Size      interface{}
	CreatedAt int64
}

func (q *Queries) CreateHTTPResponse(ctx context.Context, arg CreateHTTPResponseParams) error {
	_, err := q.exec(ctx, q.createHTTPResponseStmt, createHTTPResponse,
		arg.ID,
		arg.HttpID,
		arg.Status,
		arg.Body,
		arg.Time,
		arg.Duration,
		arg.Size,
		arg.CreatedAt,
	)
	return err
}

const createHTTPResponseAssert = `-- name: CreateHTTPResponseAssert :exec
INSERT INTO http_response_assert (
  id, response_id, value, success, created_at
)
VALUES (?, ?, ?, ?, ?)
`

type CreateHTTPResponseAssertParams struct {
	ID         idwrap.IDWrap
	ResponseID idwrap.IDWrap
	Value      string
	Success    bool
	CreatedAt  int64
}

func (q *Queries) CreateHTTPResponseAssert(ctx context.Context, arg CreateHTTPResponseAssertParams) error {
	_, err := q.exec(ctx, q.createHTTPResponseAssertStmt, createHTTPResponseAssert,
		arg.ID,
		arg.ResponseID,
		arg.Value,
		arg.Success,
		arg.CreatedAt,
	)
	return err
}

const createHTTPResponseAssertBulk = `-- name: CreateHTTPResponseAssertBulk :exec
INSERT INTO http_response_assert (
  id, response_id, value, success, created_at
)
VALUES
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?)
`

type CreateHTTPResponseAssertBulkParams struct {
	ID            idwrap.IDWrap
	ResponseID    idwrap.IDWrap
	Value         string
	Success       bool
	CreatedAt     int64
	ID_2          idwrap.IDWrap
	ResponseID_2  idwrap.IDWrap
	Value_2       string
	Success_2     bool
	CreatedAt_2   int64
	ID_3          idwrap.IDWrap
	ResponseID_3  idwrap.IDWrap
	Value_3       string
	Success_3     bool
	CreatedAt_3   int64
	ID_4          idwrap.IDWrap
	ResponseID_4  idwrap.IDWrap
	Value_4       string
	Success_4     bool
	CreatedAt_4   int64
	ID_5          idwrap.IDWrap
	ResponseID_5  idwrap.IDWrap
	Value_5       string
	Success_5     bool
	CreatedAt_5   int64
	ID_6          idwrap.IDWrap
	ResponseID_6  idwrap.IDWrap
	Value_6       string
	Success_6     bool
	CreatedAt_6   int64
	ID_7          idwrap.IDWrap
	ResponseID_7  idwrap.IDWrap
	Value_7       string
	Success_7     bool
	CreatedAt_7   int64
	ID_8          idwrap.IDWrap
	ResponseID_8  idwrap.IDWrap
	Value_8       string
	Success_8     bool
	CreatedAt_8   int64
	ID_9          idwrap.IDWrap
	ResponseID_9  idwrap.IDWrap
	Value_9       string
	Success_9     bool
	CreatedAt_9   int64
	ID_10         idwrap.IDWrap
	ResponseID_10 idwrap.IDWrap
	Value_10      string
	Success_10    bool
	CreatedAt_10  int64
}

func (q *Queries) CreateHTTPResponseAssertBulk(ctx context.Context, arg CreateHTTPResponseAssertBulkParams) error {
	_, err := q.exec(ctx, q.createHTTPResponseAssertBulkStmt, createHTTPResponseAssertBulk,
		arg.ID,
		arg.ResponseID,
		arg.Value,
		arg.Success,
		arg.CreatedAt,
		arg.ID_2,
		arg.ResponseID_2,
		arg.Value_2,
		arg.Success_2,
		arg.CreatedAt_2,
		arg.ID_3,
		arg.ResponseID_3,
		arg.Value_3,
		arg.Success_3,
		arg.CreatedAt_3,
		arg.ID_4,
		arg.ResponseID_4,
		arg.Value_4,
		arg.Success_4,
		arg.CreatedAt_4,
		arg.ID_5,
		arg.ResponseID_5,
		arg.Value_5,
		arg.Success_5,
		arg.CreatedAt_5,
		arg.ID_6,
		arg.ResponseID_6,
		arg.Value_6,
		arg.Success_6,
		arg.CreatedAt_6,
		arg.ID_7,
		arg.ResponseID_7,
		arg.Value_7,
		arg.Success_7,
		arg.CreatedAt_7,
		arg.ID_8,
		arg.ResponseID_8,
		arg.Value_8,
		arg.Success_8,
		arg.CreatedAt_8,
		arg.ID_9,
		arg.ResponseID_9,
		arg.Value_9,
		arg.Success_9,
		arg.CreatedAt_9,
		arg.ID_10,
		arg.ResponseID_10,
		arg.Value_10,
		arg.Success_10,
		arg.CreatedAt_10,
	)
	return err
}

const createHTTPResponseBulk = `-- name: CreateHTTPResponseBulk :exec
INSERT INTO http_response (
  id, http_id, status, body, time, duration, size, created_at
)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPResponseBulkParams struct {
	ID           idwrap.IDWrap
	HttpID       idwrap.IDWrap
	Status       interface{}
	Body         []byte
	Time         time.Time
	Duration     interface{}
	Size         interface{}
	CreatedAt    int64
	ID_2         idwrap.IDWrap
	HttpID_2     idwrap.IDWrap
	Status_2     interface{}
	Body_2       []byte
	Time_2       time.Time
	Duration_2   interface{}
	Size_2       interface{}
	CreatedAt_2  int64
	ID_3         idwrap.IDWrap
	HttpID_3     idwrap.IDWrap
	Status_3     interface{}
	Body_3       []byte
	Time_3       time.Time
	Duration_3   interface{}
	Size_3       interface{}
	CreatedAt_3  int64
	ID_4         idwrap.IDWrap
	HttpID_4     idwrap.IDWrap
	Status_4     interface{}
	Body_4       []byte
	Time_4       time.Time
	Duration_4   interface{}
	Size_4       interface{}
	CreatedAt_4  int64
	ID_5         idwrap.IDWrap
	HttpID_5     idwrap.IDWrap
	Status_5     interface{}
	Body_5       []byte
	Time_5       time.Time
	Duration_5   interface{}
	Size_5       interface{}
	CreatedAt_5  int64
	ID_6         idwrap.IDWrap
	HttpID_6     idwrap.IDWrap
	Status_6     interface{}
	Body_6       []byte
	Time_6       time.Time
	Duration_6   interface{}
	Size_6       interface{}
	CreatedAt_6  int64
	ID_7         idwrap.IDWrap
	HttpID_7     idwrap.IDWrap
	Status_7     interface{}
	Body_7       []byte
	Time_7       time.Time
	Duration_7   interface{}
	Size_7       interface{}
	CreatedAt_7  int64
	ID_8         idwrap.IDWrap
	HttpID_8     idwrap.IDWrap
	Status_8     interface{}
	Body_8       []byte
	Time_8       time.Time
	Duration_8   interface{}
	Size_8       interface{}
	CreatedAt_8  int64
	ID_9         idwrap.IDWrap
	HttpID_9     idwrap.IDWrap
	Status_9     interface{}
	Body_9       []byte
	Time_9       time.Time
	Duration_9   interface{}
	Size_9       interface{}
	CreatedAt_9  int64
	ID_10        idwrap.IDWrap
	HttpID_10    idwrap.IDWrap
	Status_10    interface{}
	Body_10      []byte
	Time_10      time.Time
	Duration_10  interface{}
	Size_10      interface{}
	CreatedAt_10 int64
}

func (q *Queries) CreateHTTPResponseBulk(ctx context.Context, arg CreateHTTPResponseBulkParams) error {
	_, err := q.exec(ctx, q.createHTTPResponseBulkStmt, createHTTPResponseBulk,
		arg.ID,
		arg.HttpID,
		arg.Status,
		arg.Body,
		arg.Time,
		arg.Duration,
		arg.Size,
		arg.CreatedAt,
		arg.ID_2,
		arg.HttpID_2,
		arg.Status_2,
		arg.Body_2,
		arg.Time_2,
		arg.Duration_2,
		arg.Size_2,
		arg.CreatedAt_2,
		arg.ID_3,
		arg.HttpID_3,
		arg.Status_3,
		arg.Body_3,
		arg.Time_3,
		arg.Duration_3,
		arg.Size_3,
		arg.CreatedAt_3,
		arg.ID_4,
		arg.HttpID_4,
		arg.Status_4,
		arg.Body_4,
		arg.Time_4,
		arg.Duration_4,
		arg.Size_4,
		arg.CreatedAt_4,
		arg.ID_5,
		arg.HttpID_5,
		arg.Status_5,
		arg.Body_5,
		arg.Time_5,
		arg.Duration_5,
		arg.Size_5,
		arg.CreatedAt_5,
		arg.ID_6,
		arg.HttpID_6,
		arg.Status_6,
		arg.Body_6,
		arg.Time_6,
		arg.Duration_6,
		arg.Size_6,
		arg.CreatedAt_6,
		arg.ID_7,
		arg.HttpID_7,
		arg.Status_7,
		arg.Body_7,
		arg.Time_7,
		arg.Duration_7,
		arg.Size_7,
		arg.CreatedAt_7,
		arg.ID_8,
		arg.HttpID_8,
		arg.Status_8,
		arg.Body_8,
		arg.Time_8,
		arg.Duration_8,
		arg.Size_8,
		arg.CreatedAt_8,
		arg.ID_9,
		arg.HttpID_9,
		arg.Status_9,
		arg.Body_9,
		arg.Time_9,
		arg.Duration_9,
		arg.Size_9,
		arg.CreatedAt_9,
		arg.ID_10,
		arg.HttpID_10,
		arg.Status_10,
		arg.Body_10,
		arg.Time_10,
		arg.Duration_10,
		arg.Size_10,
		arg.CreatedAt_10,
	)
	return err
}

const createHTTPResponseHeader = `-- name: CreateHTTPResponseHeader :exec
INSERT INTO http_response_header (
  id, response_id, key, value, created_at
)
VALUES (?, ?, ?, ?, ?)
`

type CreateHTTPResponseHeaderParams struct {
	ID         idwrap.IDWrap
	ResponseID idwrap.IDWrap
	Key        string
	Value      string
	CreatedAt  int64
}

func (q *Queries) CreateHTTPResponseHeader(ctx context.Context, arg CreateHTTPResponseHeaderParams) error {
	_, err := q.exec(ctx, q.createHTTPResponseHeaderStmt, createHTTPResponseHeader,
		arg.ID,
		arg.ResponseID,
		arg.Key,
		arg.Value,
		arg.CreatedAt,
	)
	return err
}

const createHTTPResponseHeaderBulk = `-- name: CreateHTTPResponseHeaderBulk :exec
INSERT INTO http_response_header (
  id, response_id, key, value, created_at
)
VALUES
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?),
  (?, ?, ?, ?, ?)
`

type CreateHTTPResponseHeaderBulkParams struct {
	ID            idwrap.IDWrap
	ResponseID    idwrap.IDWrap
	Key           string
	Value         string
	CreatedAt     int64
	ID_2          idwrap.IDWrap
	ResponseID_2  idwrap.IDWrap
	Key_2         string
	Value_2       string
	CreatedAt_2   int64
	ID_3          idwrap.IDWrap
	ResponseID_3  idwrap.IDWrap
	Key_3         string
	Value_3       string
	CreatedAt_3   int64
	ID_4          idwrap.IDWrap
	ResponseID_4  idwrap.IDWrap
	Key_4         string
	Value_4       string
	CreatedAt_4   int64
	ID_5          idwrap.IDWrap
	ResponseID_5  idwrap.IDWrap
	Key_5         string
	Value_5       string
	CreatedAt_5   int64
	ID_6          idwrap.IDWrap
	ResponseID_6  idwrap.IDWrap
	Key_6         string
	Value_6       string
	CreatedAt_6   int64
	ID_7          idwrap.IDWrap
	ResponseID_7  idwrap.IDWrap
	Key_7         string
	Value_7       string
	CreatedAt_7   int64
	ID_8          idwrap.IDWrap
	ResponseID_8  idwrap.IDWrap
	Key_8         string
	Value_8       string
	CreatedAt_8   int64
	ID_9          idwrap.IDWrap
	ResponseID_9  idwrap.IDWrap
	Key_9         string
	Value_9       string
	CreatedAt_9   int64
	ID_10         idwrap.IDWrap
	ResponseID_10 idwrap.IDWrap
	Key_10        string
	Value_10      string
	CreatedAt_10  int64
}

func (q *Queries) CreateHTTPResponseHeaderBulk(ctx context.Context, arg CreateHTTPResponseHeaderBulkParams) error {
	_, err := q.exec(ctx, q.createHTTPResponseHeaderBulkStmt, createHTTPResponseHeaderBulk,
		arg.ID,
		arg.ResponseID,
		arg.Key,
		arg.Value,
		arg.CreatedAt,
		arg.ID_2,
		arg.ResponseID_2,
		arg.Key_2,
		arg.Value_2,
		arg.CreatedAt_2,
		arg.ID_3,
		arg.ResponseID_3,
		arg.Key_3,
		arg.Value_3,
		arg.CreatedAt_3,
		arg.ID_4,
		arg.ResponseID_4,
		arg.Key_4,
		arg.Value_4,
		arg.CreatedAt_4,
		arg.ID_5,
		arg.ResponseID_5,
		arg.Key_5,
		arg.Value_5,
		arg.CreatedAt_5,
		arg.ID_6,
		arg.ResponseID_6,
		arg.Key_6,
		arg.Value_6,
		arg.CreatedAt_6,
		arg.ID_7,
		arg.ResponseID_7,
		arg.Key_7,
		arg.Value_7,
		arg.CreatedAt_7,
		arg.ID_8,
		arg.ResponseID_8,
		arg.Key_8,
		arg.Value_8,
		arg.CreatedAt_8,
		arg.ID_9,
		arg.ResponseID_9,
		arg.Key_9,
		arg.Value_9,
		arg.CreatedAt_9,
		arg.ID_10,
		arg.ResponseID_10,
		arg.Key_10,
		arg.Value_10,
		arg.CreatedAt_10,
	)
	return err
}

const createHTTPSearchParam = `-- name: CreateHTTPSearchParam :exec
INSERT INTO http_search_param (
  id, http_id, key, value, description, enabled, "order",
  parent_http_search_param_id, is_delta, delta_key, delta_value,
  delta_description, delta_enabled, created_at, updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateHTTPSearchParamParams struct {
	ID                      idwrap.IDWrap
	HttpID                  idwrap.IDWrap
	Key                     string
	Value                   string
	Description             string
	Enabled                 bool
	Order                   float64
	ParentHttpSearchParamID []byte
	IsDelta                 bool
	DeltaKey                sql.NullString
	DeltaValue              sql.NullString
	DeltaDescription        *string
	DeltaEnabled            *bool
	CreatedAt               int64
	UpdatedAt               int64
}

func (q *Queries) CreateHTTPSearchParam(ctx context.Context, arg CreateHTTPSearchParamParams) error {
	_, err := q.exec(ctx, q.createHTTPSearchParamStmt, createHTTPSearchParam,
		arg.ID,
		arg.HttpID,
		arg.Key,
		arg.Value,
		arg.Description,
		arg.Enabled,
		arg.Order,
		arg.ParentHttpSearchParamID,
		arg.IsDelta,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaDescription,
		arg.DeltaEnabled,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createHttpVersion = `-- name: CreateHttpVersion :exec
INSERT INTO http_version (
  id, http_id, version_name, version_description, is_active, created_at, created_by
)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateHttpVersionParams struct {
	ID                 idwrap.IDWrap
	HttpID             idwrap.IDWrap
	VersionName        string
	VersionDescription string
	IsActive           bool
	CreatedAt          int64
	CreatedBy          *idwrap.IDWrap
}

func (q *Queries) CreateHttpVersion(ctx context.Context, arg CreateHttpVersionParams) error {
	_, err := q.exec(ctx, q.createHttpVersionStmt, createHttpVersion,
		arg.ID,
		arg.HttpID,
		arg.VersionName,
		arg.VersionDescription,
		arg.IsActive,
		arg.CreatedAt,
		arg.CreatedBy,
	)
	return err
}

const deleteHTTP = `-- name: DeleteHTTP :exec
DELETE FROM http
WHERE id = ?
`

func (q *Queries) DeleteHTTP(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHTTPStmt, deleteHTTP, id)
	return err
}

const deleteHTTPAssert = `-- name: DeleteHTTPAssert :exec
DELETE FROM http_assert WHERE id = ?
`

func (q *Queries) DeleteHTTPAssert(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHTTPAssertStmt, deleteHTTPAssert, id)
	return err
}

const deleteHTTPBodyForm = `-- name: DeleteHTTPBodyForm :exec
DELETE FROM http_body_form WHERE id = ?
`

func (q *Queries) DeleteHTTPBodyForm(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHTTPBodyFormStmt, deleteHTTPBodyForm, id)
	return err
}

const deleteHTTPBodyRaw = `-- name: DeleteHTTPBodyRaw :exec
DELETE FROM http_body_raw
WHERE
  id = ?
`

func (q *Queries) DeleteHTTPBodyRaw(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHTTPBodyRawStmt, deleteHTTPBodyRaw, id)
	return err
}

const deleteHTTPBodyUrlEncoded = `-- name: DeleteHTTPBodyUrlEncoded :exec
DELETE FROM http_body_urlencoded WHERE id = ?
`

func (q *Queries) DeleteHTTPBodyUrlEncoded(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHTTPBodyUrlEncodedStmt, deleteHTTPBodyUrlEncoded, id)
	return err
}

const deleteHTTPHeader = `-- name: DeleteHTTPHeader :exec
DELETE FROM http_header
WHERE id = ?
`

func (q *Queries) DeleteHTTPHeader(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHTTPHeaderStmt, deleteHTTPHeader, id)
	return err
}

const deleteHTTPResponse = `-- name: DeleteHTTPResponse :exec
DELETE FROM http_response WHERE id = ?
`

func (q *Queries) DeleteHTTPResponse(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHTTPResponseStmt, deleteHTTPResponse, id)
	return err
}

const deleteHTTPResponseAssert = `-- name: DeleteHTTPResponseAssert :exec
DELETE FROM http_response_assert WHERE id = ?
`

func (q *Queries) DeleteHTTPResponseAssert(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHTTPResponseAssertStmt, deleteHTTPResponseAssert, id)
	return err
}

const deleteHTTPResponseHeader = `-- name: DeleteHTTPResponseHeader :exec
DELETE FROM http_response_header WHERE id = ?
`

func (q *Queries) DeleteHTTPResponseHeader(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHTTPResponseHeaderStmt, deleteHTTPResponseHeader, id)
	return err
}

const deleteHTTPSearchParam = `-- name: DeleteHTTPSearchParam :exec
DELETE FROM http_search_param
WHERE id = ?
`

func (q *Queries) DeleteHTTPSearchParam(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteHTTPSearchParamStmt, deleteHTTPSearchParam, id)
	return err
}

const findHTTPByURLAndMethod = `-- name: FindHTTPByURLAndMethod :one
SELECT
  id,
  workspace_id,
  folder_id,
  name,
  url,
  method,
  body_kind,
  description,
  parent_http_id,
  is_delta,
  delta_name,
  delta_url,
  delta_method,
  delta_body_kind,
  delta_description,
  last_run_at,
  created_at,
  updated_at
FROM http
WHERE workspace_id = ?
  AND url = ?
  AND method = ?
  AND is_delta = FALSE
LIMIT 1
`

type FindHTTPByURLAndMethodParams struct {
	WorkspaceID idwrap.IDWrap
	Url         string
	Method      string
}

// Find existing HTTP request by URL, method, and workspace for overwrite detection
func (q *Queries) FindHTTPByURLAndMethod(ctx context.Context, arg FindHTTPByURLAndMethodParams) (Http, error) {
	row := q.queryRow(ctx, q.findHTTPByURLAndMethodStmt, findHTTPByURLAndMethod, arg.WorkspaceID, arg.Url, arg.Method)
	var i Http
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.FolderID,
		&i.Name,
		&i.Url,
		&i.Method,
		&i.BodyKind,
		&i.Description,
		&i.ParentHttpID,
		&i.IsDelta,
		&i.DeltaName,
		&i.DeltaUrl,
		&i.DeltaMethod,
		&i.DeltaBodyKind,
		&i.DeltaDescription,
		&i.LastRunAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHTTP = `-- name: GetHTTP :one


SELECT

  id,

  workspace_id,

  folder_id,

  name,

  url,

  method,

  body_kind,

  description,

  parent_http_id,

  is_delta,

  delta_name,

  delta_url,

  delta_method,

  delta_body_kind,

  delta_description,

  last_run_at,

  created_at,

  updated_at

FROM http

WHERE id = ? LIMIT 1
`

// HTTP Core Queries
func (q *Queries) GetHTTP(ctx context.Context, id idwrap.IDWrap) (Http, error) {
	row := q.queryRow(ctx, q.getHTTPStmt, getHTTP, id)
	var i Http
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.FolderID,
		&i.Name,
		&i.Url,
		&i.Method,
		&i.BodyKind,
		&i.Description,
		&i.ParentHttpID,
		&i.IsDelta,
		&i.DeltaName,
		&i.DeltaUrl,
		&i.DeltaMethod,
		&i.DeltaBodyKind,
		&i.DeltaDescription,
		&i.LastRunAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHTTPAssert = `-- name: GetHTTPAssert :one

SELECT
  id,
  http_id,
  value,
  enabled,
  description,
  "order",
  parent_http_assert_id,
  is_delta,
  delta_value,
  delta_enabled,
  delta_description,
  delta_order,
  created_at,
  updated_at
FROM http_assert
WHERE id = ?
LIMIT 1
`

// HTTP Assert Queries (TypeSpec-compliant)
func (q *Queries) GetHTTPAssert(ctx context.Context, id idwrap.IDWrap) (HttpAssert, error) {
	row := q.queryRow(ctx, q.getHTTPAssertStmt, getHTTPAssert, id)
	var i HttpAssert
	err := row.Scan(
		&i.ID,
		&i.HttpID,
		&i.Value,
		&i.Enabled,
		&i.Description,
		&i.Order,
		&i.ParentHttpAssertID,
		&i.IsDelta,
		&i.DeltaValue,
		&i.DeltaEnabled,
		&i.DeltaDescription,
		&i.DeltaOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHTTPAssertsByHttpID = `-- name: GetHTTPAssertsByHttpID :many
SELECT
  id,
  http_id,
  value,
  enabled,
  description,
  "order",
  parent_http_assert_id,
  is_delta,
  delta_value,
  delta_enabled,
  delta_description,
  delta_order,
  created_at,
  updated_at
FROM http_assert
WHERE http_id = ?
ORDER BY "order"
`

func (q *Queries) GetHTTPAssertsByHttpID(ctx context.Context, httpID idwrap.IDWrap) ([]HttpAssert, error) {
	rows, err := q.query(ctx, q.getHTTPAssertsByHttpIDStmt, getHTTPAssertsByHttpID, httpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpAssert{}
	for rows.Next() {
		var i HttpAssert
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Value,
			&i.Enabled,
			&i.Description,
			&i.Order,
			&i.ParentHttpAssertID,
			&i.IsDelta,
			&i.DeltaValue,
			&i.DeltaEnabled,
			&i.DeltaDescription,
			&i.DeltaOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPAssertsByIDs = `-- name: GetHTTPAssertsByIDs :many
SELECT
  id,
  http_id,
  value,
  enabled,
  description,
  "order",
  parent_http_assert_id,
  is_delta,
  delta_value,
  delta_enabled,
  delta_description,
  delta_order,
  created_at,
  updated_at
FROM http_assert
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) GetHTTPAssertsByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]HttpAssert, error) {
	query := getHTTPAssertsByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpAssert{}
	for rows.Next() {
		var i HttpAssert
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Value,
			&i.Enabled,
			&i.Description,
			&i.Order,
			&i.ParentHttpAssertID,
			&i.IsDelta,
			&i.DeltaValue,
			&i.DeltaEnabled,
			&i.DeltaDescription,
			&i.DeltaOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPBatchForStreaming = `-- name: GetHTTPBatchForStreaming :many
SELECT 
  h.id,
  h.workspace_id,
  h.folder_id,
  h.name,
  h.url,
  h.method,
  h.body_kind,
  h.description,
  h.parent_http_id,
  h.is_delta,
  h.delta_name,
  h.delta_url,
  h.delta_method,
  h.delta_body_kind,
  h.delta_description,
  h.created_at,
  h.updated_at
FROM http h
WHERE h.id IN (/*SLICE:http_ids*/?)
  AND h.updated_at <= ?
ORDER BY h.updated_at DESC
`

type GetHTTPBatchForStreamingParams struct {
	HttpIds   []idwrap.IDWrap
	UpdatedAt int64
}

type GetHTTPBatchForStreamingRow struct {
	ID               idwrap.IDWrap
	WorkspaceID      idwrap.IDWrap
	FolderID         *idwrap.IDWrap
	Name             string
	Url              string
	Method           string
	BodyKind         int8
	Description      string
	ParentHttpID     *idwrap.IDWrap
	IsDelta          bool
	DeltaName        *string
	DeltaUrl         *string
	DeltaMethod      *string
	DeltaBodyKind    interface{}
	DeltaDescription *string
	CreatedAt        int64
	UpdatedAt        int64
}

// HTTP Batch Operations for Streaming
// Batch query for processing multiple HTTP records efficiently
// Optimized for high-throughput streaming operations
func (q *Queries) GetHTTPBatchForStreaming(ctx context.Context, arg GetHTTPBatchForStreamingParams) ([]GetHTTPBatchForStreamingRow, error) {
	query := getHTTPBatchForStreaming
	var queryParams []interface{}
	if len(arg.HttpIds) > 0 {
		for _, v := range arg.HttpIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:http_ids*/?", strings.Repeat(",?", len(arg.HttpIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:http_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UpdatedAt)
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPBatchForStreamingRow{}
	for rows.Next() {
		var i GetHTTPBatchForStreamingRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.BodyKind,
			&i.Description,
			&i.ParentHttpID,
			&i.IsDelta,
			&i.DeltaName,
			&i.DeltaUrl,
			&i.DeltaMethod,
			&i.DeltaBodyKind,
			&i.DeltaDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPBodyFormStreaming = `-- name: GetHTTPBodyFormStreaming :many
SELECT 
  hbf.id,
  hbf.http_id,
  hbf.key,
  hbf.value,
  hbf.description,
  hbf.enabled,
  hbf.parent_http_body_form_id,
  hbf.is_delta,
  hbf.delta_key,
  hbf.delta_value,
  hbf.delta_description,
  hbf.delta_enabled,
  hbf.created_at,
  hbf.updated_at
FROM http_body_form hbf
WHERE hbf.http_id IN (/*SLICE:http_ids*/?)
  AND hbf.enabled = TRUE
  AND hbf.updated_at <= ?
ORDER BY hbf.http_id, hbf.updated_at DESC
`

type GetHTTPBodyFormStreamingParams struct {
	HttpIds   []idwrap.IDWrap
	UpdatedAt int64
}

type GetHTTPBodyFormStreamingRow struct {
	ID                   idwrap.IDWrap
	HttpID               idwrap.IDWrap
	Key                  string
	Value                string
	Description          string
	Enabled              bool
	ParentHttpBodyFormID []byte
	IsDelta              bool
	DeltaKey             sql.NullString
	DeltaValue           sql.NullString
	DeltaDescription     *string
	DeltaEnabled         *bool
	CreatedAt            int64
	UpdatedAt            int64
}

// Optimized form body query for streaming
func (q *Queries) GetHTTPBodyFormStreaming(ctx context.Context, arg GetHTTPBodyFormStreamingParams) ([]GetHTTPBodyFormStreamingRow, error) {
	query := getHTTPBodyFormStreaming
	var queryParams []interface{}
	if len(arg.HttpIds) > 0 {
		for _, v := range arg.HttpIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:http_ids*/?", strings.Repeat(",?", len(arg.HttpIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:http_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UpdatedAt)
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPBodyFormStreamingRow{}
	for rows.Next() {
		var i GetHTTPBodyFormStreamingRow
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.Enabled,
			&i.ParentHttpBodyFormID,
			&i.IsDelta,
			&i.DeltaKey,
			&i.DeltaValue,
			&i.DeltaDescription,
			&i.DeltaEnabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPBodyForms = `-- name: GetHTTPBodyForms :many

SELECT
  id,
  http_id,
  key,
  value,
  description,
  enabled,
  parent_http_body_form_id,
  is_delta,
  delta_key,
  delta_value,
  delta_description,
  delta_enabled,
  "order",
  created_at,
  updated_at
FROM http_body_form
WHERE http_id = ?
ORDER BY "order"
`

type GetHTTPBodyFormsRow struct {
	ID                   idwrap.IDWrap
	HttpID               idwrap.IDWrap
	Key                  string
	Value                string
	Description          string
	Enabled              bool
	ParentHttpBodyFormID []byte
	IsDelta              bool
	DeltaKey             sql.NullString
	DeltaValue           sql.NullString
	DeltaDescription     *string
	DeltaEnabled         *bool
	Order                float64
	CreatedAt            int64
	UpdatedAt            int64
}

// HTTP Body Form Queries
func (q *Queries) GetHTTPBodyForms(ctx context.Context, httpID idwrap.IDWrap) ([]GetHTTPBodyFormsRow, error) {
	rows, err := q.query(ctx, q.getHTTPBodyFormsStmt, getHTTPBodyForms, httpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPBodyFormsRow{}
	for rows.Next() {
		var i GetHTTPBodyFormsRow
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.Enabled,
			&i.ParentHttpBodyFormID,
			&i.IsDelta,
			&i.DeltaKey,
			&i.DeltaValue,
			&i.DeltaDescription,
			&i.DeltaEnabled,
			&i.Order,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPBodyFormsByIDs = `-- name: GetHTTPBodyFormsByIDs :many
SELECT
  id,
  http_id,
  key,
  value,
  description,
  enabled,
  parent_http_body_form_id,
  is_delta,
  delta_key,
  delta_value,
  delta_description,
  delta_enabled,
  "order",
  created_at,
  updated_at
FROM http_body_form
WHERE id IN (/*SLICE:ids*/?)
`

type GetHTTPBodyFormsByIDsRow struct {
	ID                   idwrap.IDWrap
	HttpID               idwrap.IDWrap
	Key                  string
	Value                string
	Description          string
	Enabled              bool
	ParentHttpBodyFormID []byte
	IsDelta              bool
	DeltaKey             sql.NullString
	DeltaValue           sql.NullString
	DeltaDescription     *string
	DeltaEnabled         *bool
	Order                float64
	CreatedAt            int64
	UpdatedAt            int64
}

func (q *Queries) GetHTTPBodyFormsByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]GetHTTPBodyFormsByIDsRow, error) {
	query := getHTTPBodyFormsByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPBodyFormsByIDsRow{}
	for rows.Next() {
		var i GetHTTPBodyFormsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.Enabled,
			&i.ParentHttpBodyFormID,
			&i.IsDelta,
			&i.DeltaKey,
			&i.DeltaValue,
			&i.DeltaDescription,
			&i.DeltaEnabled,
			&i.Order,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPBodyRaw = `-- name: GetHTTPBodyRaw :one
SELECT
  id,
  http_id,
  raw_data,
  content_type,
  compression_type,
  parent_body_raw_id,
  is_delta,
  delta_raw_data,
  delta_content_type,
  delta_compression_type,
  created_at,
  updated_at
FROM
  http_body_raw
WHERE
  http_id = ?
LIMIT 1
`

func (q *Queries) GetHTTPBodyRaw(ctx context.Context, httpID idwrap.IDWrap) (HttpBodyRaw, error) {
	row := q.queryRow(ctx, q.getHTTPBodyRawStmt, getHTTPBodyRaw, httpID)
	var i HttpBodyRaw
	err := row.Scan(
		&i.ID,
		&i.HttpID,
		&i.RawData,
		&i.ContentType,
		&i.CompressionType,
		&i.ParentBodyRawID,
		&i.IsDelta,
		&i.DeltaRawData,
		&i.DeltaContentType,
		&i.DeltaCompressionType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHTTPBodyRawByID = `-- name: GetHTTPBodyRawByID :one
SELECT
  id,
  http_id,
  raw_data,
  content_type,
  compression_type,
  parent_body_raw_id,
  is_delta,
  delta_raw_data,
  delta_content_type,
  delta_compression_type,
  created_at,
  updated_at
FROM
  http_body_raw
WHERE
  id = ?
LIMIT 1
`

// HTTP Body Raw queries
func (q *Queries) GetHTTPBodyRawByID(ctx context.Context, id idwrap.IDWrap) (HttpBodyRaw, error) {
	row := q.queryRow(ctx, q.getHTTPBodyRawByIDStmt, getHTTPBodyRawByID, id)
	var i HttpBodyRaw
	err := row.Scan(
		&i.ID,
		&i.HttpID,
		&i.RawData,
		&i.ContentType,
		&i.CompressionType,
		&i.ParentBodyRawID,
		&i.IsDelta,
		&i.DeltaRawData,
		&i.DeltaContentType,
		&i.DeltaCompressionType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHTTPBodyUrlEncoded = `-- name: GetHTTPBodyUrlEncoded :one

SELECT
  id,
  http_id,
  key,
  value,
  enabled,
  description,
  "order",
  parent_http_body_urlencoded_id,
  is_delta,
  delta_key,
  delta_value,
  delta_enabled,
  delta_description,
  delta_order,
  created_at,
  updated_at
FROM http_body_urlencoded
WHERE id = ?
LIMIT 1
`

// HTTP Body URL-Encoded Queries (TypeSpec-compliant)
func (q *Queries) GetHTTPBodyUrlEncoded(ctx context.Context, id idwrap.IDWrap) (HttpBodyUrlencoded, error) {
	row := q.queryRow(ctx, q.getHTTPBodyUrlEncodedStmt, getHTTPBodyUrlEncoded, id)
	var i HttpBodyUrlencoded
	err := row.Scan(
		&i.ID,
		&i.HttpID,
		&i.Key,
		&i.Value,
		&i.Enabled,
		&i.Description,
		&i.Order,
		&i.ParentHttpBodyUrlencodedID,
		&i.IsDelta,
		&i.DeltaKey,
		&i.DeltaValue,
		&i.DeltaEnabled,
		&i.DeltaDescription,
		&i.DeltaOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHTTPBodyUrlEncodedByHttpID = `-- name: GetHTTPBodyUrlEncodedByHttpID :many
SELECT
  id,
  http_id,
  key,
  value,
  enabled,
  description,
  "order",
  parent_http_body_urlencoded_id,
  is_delta,
  delta_key,
  delta_value,
  delta_enabled,
  delta_description,
  delta_order,
  created_at,
  updated_at
FROM http_body_urlencoded
WHERE http_id = ?
ORDER BY "order"
`

func (q *Queries) GetHTTPBodyUrlEncodedByHttpID(ctx context.Context, httpID idwrap.IDWrap) ([]HttpBodyUrlencoded, error) {
	rows, err := q.query(ctx, q.getHTTPBodyUrlEncodedByHttpIDStmt, getHTTPBodyUrlEncodedByHttpID, httpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpBodyUrlencoded{}
	for rows.Next() {
		var i HttpBodyUrlencoded
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.Enabled,
			&i.Description,
			&i.Order,
			&i.ParentHttpBodyUrlencodedID,
			&i.IsDelta,
			&i.DeltaKey,
			&i.DeltaValue,
			&i.DeltaEnabled,
			&i.DeltaDescription,
			&i.DeltaOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPBodyUrlEncodedsByIDs = `-- name: GetHTTPBodyUrlEncodedsByIDs :many
SELECT
  id,
  http_id,
  key,
  value,
  enabled,
  description,
  "order",
  parent_http_body_urlencoded_id,
  is_delta,
  delta_key,
  delta_value,
  delta_enabled,
  delta_description,
  delta_order,
  created_at,
  updated_at
FROM http_body_urlencoded
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) GetHTTPBodyUrlEncodedsByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]HttpBodyUrlencoded, error) {
	query := getHTTPBodyUrlEncodedsByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpBodyUrlencoded{}
	for rows.Next() {
		var i HttpBodyUrlencoded
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.Enabled,
			&i.Description,
			&i.Order,
			&i.ParentHttpBodyUrlencodedID,
			&i.IsDelta,
			&i.DeltaKey,
			&i.DeltaValue,
			&i.DeltaEnabled,
			&i.DeltaDescription,
			&i.DeltaOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPDeltasByParentID = `-- name: GetHTTPDeltasByParentID :many
SELECT
  id,
  workspace_id,
  folder_id,
  name,
  url,
  method,
  body_kind,
  description,
  parent_http_id,
  is_delta,
  delta_name,
  delta_url,
  delta_method,
  delta_body_kind,
  delta_description,
  created_at,
  updated_at
FROM http
WHERE parent_http_id = ? AND is_delta = TRUE
ORDER BY created_at DESC
`

type GetHTTPDeltasByParentIDRow struct {
	ID               idwrap.IDWrap
	WorkspaceID      idwrap.IDWrap
	FolderID         *idwrap.IDWrap
	Name             string
	Url              string
	Method           string
	BodyKind         int8
	Description      string
	ParentHttpID     *idwrap.IDWrap
	IsDelta          bool
	DeltaName        *string
	DeltaUrl         *string
	DeltaMethod      *string
	DeltaBodyKind    interface{}
	DeltaDescription *string
	CreatedAt        int64
	UpdatedAt        int64
}

func (q *Queries) GetHTTPDeltasByParentID(ctx context.Context, parentHttpID *idwrap.IDWrap) ([]GetHTTPDeltasByParentIDRow, error) {
	rows, err := q.query(ctx, q.getHTTPDeltasByParentIDStmt, getHTTPDeltasByParentID, parentHttpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPDeltasByParentIDRow{}
	for rows.Next() {
		var i GetHTTPDeltasByParentIDRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.BodyKind,
			&i.Description,
			&i.ParentHttpID,
			&i.IsDelta,
			&i.DeltaName,
			&i.DeltaUrl,
			&i.DeltaMethod,
			&i.DeltaBodyKind,
			&i.DeltaDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPDeltasByWorkspaceID = `-- name: GetHTTPDeltasByWorkspaceID :many
SELECT
  id,
  workspace_id,
  folder_id,
  name,
  url,
  method,
  body_kind,
  description,
  parent_http_id,
  is_delta,
  delta_name,
  delta_url,
  delta_method,
  delta_body_kind,
  delta_description,
  last_run_at,
  created_at,
  updated_at
FROM http
WHERE workspace_id = ? AND is_delta = TRUE
ORDER BY updated_at DESC
`

func (q *Queries) GetHTTPDeltasByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]Http, error) {
	rows, err := q.query(ctx, q.getHTTPDeltasByWorkspaceIDStmt, getHTTPDeltasByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Http{}
	for rows.Next() {
		var i Http
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.BodyKind,
			&i.Description,
			&i.ParentHttpID,
			&i.IsDelta,
			&i.DeltaName,
			&i.DeltaUrl,
			&i.DeltaMethod,
			&i.DeltaBodyKind,
			&i.DeltaDescription,
			&i.LastRunAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPDeltasSince = `-- name: GetHTTPDeltasSince :many
SELECT 
  h.id,
  h.workspace_id,
  h.folder_id,
  h.name,
  h.url,
  h.method,
  h.body_kind,
  h.description,
  h.parent_http_id,
  h.is_delta,
  h.delta_name,
  h.delta_url,
  h.delta_method,
  h.delta_body_kind,
  h.delta_description,
  h.created_at,
  h.updated_at
FROM http h
WHERE h.parent_http_id IN (/*SLICE:parent_ids*/?)
  AND h.is_delta = TRUE
  AND h.updated_at > ?
  AND h.updated_at <= ?
ORDER BY h.parent_http_id, h.updated_at ASC
`

type GetHTTPDeltasSinceParams struct {
	ParentIds   []*idwrap.IDWrap
	UpdatedAt   int64
	UpdatedAt_2 int64
}

type GetHTTPDeltasSinceRow struct {
	ID               idwrap.IDWrap
	WorkspaceID      idwrap.IDWrap
	FolderID         *idwrap.IDWrap
	Name             string
	Url              string
	Method           string
	BodyKind         int8
	Description      string
	ParentHttpID     *idwrap.IDWrap
	IsDelta          bool
	DeltaName        *string
	DeltaUrl         *string
	DeltaMethod      *string
	DeltaBodyKind    interface{}
	DeltaDescription *string
	CreatedAt        int64
	UpdatedAt        int64
}

// Delta-specific streaming query for conflict resolution
// Uses delta resolution index for optimal performance
func (q *Queries) GetHTTPDeltasSince(ctx context.Context, arg GetHTTPDeltasSinceParams) ([]GetHTTPDeltasSinceRow, error) {
	query := getHTTPDeltasSince
	var queryParams []interface{}
	if len(arg.ParentIds) > 0 {
		for _, v := range arg.ParentIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:parent_ids*/?", strings.Repeat(",?", len(arg.ParentIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:parent_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UpdatedAt)
	queryParams = append(queryParams, arg.UpdatedAt_2)
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPDeltasSinceRow{}
	for rows.Next() {
		var i GetHTTPDeltasSinceRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.BodyKind,
			&i.Description,
			&i.ParentHttpID,
			&i.IsDelta,
			&i.DeltaName,
			&i.DeltaUrl,
			&i.DeltaMethod,
			&i.DeltaBodyKind,
			&i.DeltaDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPHeaders = `-- name: GetHTTPHeaders :many

SELECT
  id,
  http_id,
  header_key,
  header_value,
  description,
  enabled,
  parent_header_id,
  is_delta,
  delta_header_key,
  delta_header_value,
  delta_description,
  delta_enabled,
  delta_display_order,
  display_order,
  created_at,
  updated_at
FROM http_header
WHERE http_id = ?
ORDER BY display_order
`

// HTTP Header Queries
func (q *Queries) GetHTTPHeaders(ctx context.Context, httpID idwrap.IDWrap) ([]HttpHeader, error) {
	rows, err := q.query(ctx, q.getHTTPHeadersStmt, getHTTPHeaders, httpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpHeader{}
	for rows.Next() {
		var i HttpHeader
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.HeaderKey,
			&i.HeaderValue,
			&i.Description,
			&i.Enabled,
			&i.ParentHeaderID,
			&i.IsDelta,
			&i.DeltaHeaderKey,
			&i.DeltaHeaderValue,
			&i.DeltaDescription,
			&i.DeltaEnabled,
			&i.DeltaDisplayOrder,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPHeadersByIDs = `-- name: GetHTTPHeadersByIDs :many
SELECT
  id,
  http_id,
  header_key,
  header_value,
  description,
  enabled,
  parent_header_id,
  is_delta,
  delta_header_key,
  delta_header_value,
  delta_description,
  delta_enabled,
  delta_display_order,
  display_order,
  created_at,
  updated_at
FROM http_header
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) GetHTTPHeadersByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]HttpHeader, error) {
	query := getHTTPHeadersByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpHeader{}
	for rows.Next() {
		var i HttpHeader
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.HeaderKey,
			&i.HeaderValue,
			&i.Description,
			&i.Enabled,
			&i.ParentHeaderID,
			&i.IsDelta,
			&i.DeltaHeaderKey,
			&i.DeltaHeaderValue,
			&i.DeltaDescription,
			&i.DeltaEnabled,
			&i.DeltaDisplayOrder,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPHeadersStreaming = `-- name: GetHTTPHeadersStreaming :many
SELECT 
  hh.id,
  hh.http_id,
  hh.header_key,
  hh.header_value,
  hh.description,
  hh.enabled,
  hh.parent_header_id,
  hh.is_delta,
  hh.delta_header_key,
  hh.delta_header_value,
  hh.delta_description,
  hh.delta_enabled,
  hh.created_at,
  hh.updated_at
FROM http_header hh
WHERE hh.http_id IN (/*SLICE:http_ids*/?)
  AND hh.enabled = TRUE
  AND hh.updated_at <= ?
ORDER BY hh.http_id, hh.updated_at DESC
`

type GetHTTPHeadersStreamingParams struct {
	HttpIds   []idwrap.IDWrap
	UpdatedAt int64
}

type GetHTTPHeadersStreamingRow struct {
	ID               idwrap.IDWrap
	HttpID           idwrap.IDWrap
	HeaderKey        string
	HeaderValue      string
	Description      string
	Enabled          bool
	ParentHeaderID   *idwrap.IDWrap
	IsDelta          bool
	DeltaHeaderKey   *string
	DeltaHeaderValue *string
	DeltaDescription *string
	DeltaEnabled     *bool
	CreatedAt        int64
	UpdatedAt        int64
}

// HTTP Child Record Streaming Queries
// Optimized headers query for streaming with enabled filter
func (q *Queries) GetHTTPHeadersStreaming(ctx context.Context, arg GetHTTPHeadersStreamingParams) ([]GetHTTPHeadersStreamingRow, error) {
	query := getHTTPHeadersStreaming
	var queryParams []interface{}
	if len(arg.HttpIds) > 0 {
		for _, v := range arg.HttpIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:http_ids*/?", strings.Repeat(",?", len(arg.HttpIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:http_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UpdatedAt)
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPHeadersStreamingRow{}
	for rows.Next() {
		var i GetHTTPHeadersStreamingRow
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.HeaderKey,
			&i.HeaderValue,
			&i.Description,
			&i.Enabled,
			&i.ParentHeaderID,
			&i.IsDelta,
			&i.DeltaHeaderKey,
			&i.DeltaHeaderValue,
			&i.DeltaDescription,
			&i.DeltaEnabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPIncrementalUpdates = `-- name: GetHTTPIncrementalUpdates :many
SELECT 
  h.id,
  h.workspace_id,
  h.folder_id,
  h.name,
  h.url,
  h.method,
  h.body_kind,
  h.description,
  h.parent_http_id,
  h.is_delta,
  h.delta_name,
  h.delta_url,
  h.delta_method,
  h.delta_body_kind,
  h.delta_description,
  h.created_at,
  h.updated_at
FROM http h
WHERE h.workspace_id = ? 
  AND h.updated_at > ?
  AND h.updated_at <= ?
ORDER BY h.updated_at ASC, h.id
`

type GetHTTPIncrementalUpdatesParams struct {
	WorkspaceID idwrap.IDWrap
	UpdatedAt   int64
	UpdatedAt_2 int64
}

type GetHTTPIncrementalUpdatesRow struct {
	ID               idwrap.IDWrap
	WorkspaceID      idwrap.IDWrap
	FolderID         *idwrap.IDWrap
	Name             string
	Url              string
	Method           string
	BodyKind         int8
	Description      string
	ParentHttpID     *idwrap.IDWrap
	IsDelta          bool
	DeltaName        *string
	DeltaUrl         *string
	DeltaMethod      *string
	DeltaBodyKind    interface{}
	DeltaDescription *string
	CreatedAt        int64
	UpdatedAt        int64
}

// HTTP Incremental Streaming Queries
// Real-time streaming query for changes since last update
// Optimized with streaming indexes for minimal latency
func (q *Queries) GetHTTPIncrementalUpdates(ctx context.Context, arg GetHTTPIncrementalUpdatesParams) ([]GetHTTPIncrementalUpdatesRow, error) {
	rows, err := q.query(ctx, q.getHTTPIncrementalUpdatesStmt, getHTTPIncrementalUpdates, arg.WorkspaceID, arg.UpdatedAt, arg.UpdatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPIncrementalUpdatesRow{}
	for rows.Next() {
		var i GetHTTPIncrementalUpdatesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.BodyKind,
			&i.Description,
			&i.ParentHttpID,
			&i.IsDelta,
			&i.DeltaName,
			&i.DeltaUrl,
			&i.DeltaMethod,
			&i.DeltaBodyKind,
			&i.DeltaDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPResponse = `-- name: GetHTTPResponse :one

SELECT
  id,
  http_id,
  status,
  body,
  time,
  duration,
  size,
  created_at
FROM http_response
WHERE id = ?
LIMIT 1
`

// HTTP Response Queries (TypeSpec-compliant)
//
// HTTP Response Queries (TypeSpec-compliant)
func (q *Queries) GetHTTPResponse(ctx context.Context, id idwrap.IDWrap) (HttpResponse, error) {
	row := q.queryRow(ctx, q.getHTTPResponseStmt, getHTTPResponse, id)
	var i HttpResponse
	err := row.Scan(
		&i.ID,
		&i.HttpID,
		&i.Status,
		&i.Body,
		&i.Time,
		&i.Duration,
		&i.Size,
		&i.CreatedAt,
	)
	return i, err
}

const getHTTPResponseAssert = `-- name: GetHTTPResponseAssert :one

SELECT
  id,
  response_id,
  value,
  success,
  created_at
FROM http_response_assert
WHERE id = ?
LIMIT 1
`

// HTTP Response Assert Queries (TypeSpec-compliant)
func (q *Queries) GetHTTPResponseAssert(ctx context.Context, id idwrap.IDWrap) (HttpResponseAssert, error) {
	row := q.queryRow(ctx, q.getHTTPResponseAssertStmt, getHTTPResponseAssert, id)
	var i HttpResponseAssert
	err := row.Scan(
		&i.ID,
		&i.ResponseID,
		&i.Value,
		&i.Success,
		&i.CreatedAt,
	)
	return i, err
}

const getHTTPResponseAssertsByHttpID = `-- name: GetHTTPResponseAssertsByHttpID :many
SELECT hra.id, hra.response_id, hra.value, hra.success, hra.created_at
FROM http_response_assert hra
JOIN http_response hr ON hra.response_id = hr.id
WHERE hr.http_id = ?
ORDER BY hra.created_at DESC
`

func (q *Queries) GetHTTPResponseAssertsByHttpID(ctx context.Context, httpID idwrap.IDWrap) ([]HttpResponseAssert, error) {
	rows, err := q.query(ctx, q.getHTTPResponseAssertsByHttpIDStmt, getHTTPResponseAssertsByHttpID, httpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpResponseAssert{}
	for rows.Next() {
		var i HttpResponseAssert
		if err := rows.Scan(
			&i.ID,
			&i.ResponseID,
			&i.Value,
			&i.Success,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPResponseAssertsByIDs = `-- name: GetHTTPResponseAssertsByIDs :many
SELECT
  id,
  response_id,
  value,
  success,
  created_at
FROM http_response_assert
WHERE id IN (/*SLICE:ids*/?)
ORDER BY created_at DESC
`

func (q *Queries) GetHTTPResponseAssertsByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]HttpResponseAssert, error) {
	query := getHTTPResponseAssertsByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpResponseAssert{}
	for rows.Next() {
		var i HttpResponseAssert
		if err := rows.Scan(
			&i.ID,
			&i.ResponseID,
			&i.Value,
			&i.Success,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPResponseAssertsByResponseID = `-- name: GetHTTPResponseAssertsByResponseID :many
SELECT
  id,
  response_id,
  value,
  success,
  created_at
FROM http_response_assert
WHERE response_id = ?
ORDER BY created_at DESC
`

func (q *Queries) GetHTTPResponseAssertsByResponseID(ctx context.Context, responseID idwrap.IDWrap) ([]HttpResponseAssert, error) {
	rows, err := q.query(ctx, q.getHTTPResponseAssertsByResponseIDStmt, getHTTPResponseAssertsByResponseID, responseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpResponseAssert{}
	for rows.Next() {
		var i HttpResponseAssert
		if err := rows.Scan(
			&i.ID,
			&i.ResponseID,
			&i.Value,
			&i.Success,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPResponseHeader = `-- name: GetHTTPResponseHeader :one

SELECT
  id,
  response_id,
  key,
  value,
  created_at
FROM http_response_header
WHERE id = ?
LIMIT 1
`

// HTTP Response Header Queries (TypeSpec-compliant)
func (q *Queries) GetHTTPResponseHeader(ctx context.Context, id idwrap.IDWrap) (HttpResponseHeader, error) {
	row := q.queryRow(ctx, q.getHTTPResponseHeaderStmt, getHTTPResponseHeader, id)
	var i HttpResponseHeader
	err := row.Scan(
		&i.ID,
		&i.ResponseID,
		&i.Key,
		&i.Value,
		&i.CreatedAt,
	)
	return i, err
}

const getHTTPResponseHeadersByHttpID = `-- name: GetHTTPResponseHeadersByHttpID :many
SELECT hrh.id, hrh.response_id, hrh.key, hrh.value, hrh.created_at
FROM http_response_header hrh
JOIN http_response hr ON hrh.response_id = hr.id
WHERE hr.http_id = ?
ORDER BY hrh.created_at DESC
`

func (q *Queries) GetHTTPResponseHeadersByHttpID(ctx context.Context, httpID idwrap.IDWrap) ([]HttpResponseHeader, error) {
	rows, err := q.query(ctx, q.getHTTPResponseHeadersByHttpIDStmt, getHTTPResponseHeadersByHttpID, httpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpResponseHeader{}
	for rows.Next() {
		var i HttpResponseHeader
		if err := rows.Scan(
			&i.ID,
			&i.ResponseID,
			&i.Key,
			&i.Value,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPResponseHeadersByIDs = `-- name: GetHTTPResponseHeadersByIDs :many
SELECT
  id,
  response_id,
  key,
  value,
  created_at
FROM http_response_header
WHERE id IN (/*SLICE:ids*/?)
ORDER BY response_id, key
`

func (q *Queries) GetHTTPResponseHeadersByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]HttpResponseHeader, error) {
	query := getHTTPResponseHeadersByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpResponseHeader{}
	for rows.Next() {
		var i HttpResponseHeader
		if err := rows.Scan(
			&i.ID,
			&i.ResponseID,
			&i.Key,
			&i.Value,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPResponseHeadersByResponseID = `-- name: GetHTTPResponseHeadersByResponseID :many
SELECT
  id,
  response_id,
  key,
  value,
  created_at
FROM http_response_header
WHERE response_id = ?
ORDER BY key
`

func (q *Queries) GetHTTPResponseHeadersByResponseID(ctx context.Context, responseID idwrap.IDWrap) ([]HttpResponseHeader, error) {
	rows, err := q.query(ctx, q.getHTTPResponseHeadersByResponseIDStmt, getHTTPResponseHeadersByResponseID, responseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpResponseHeader{}
	for rows.Next() {
		var i HttpResponseHeader
		if err := rows.Scan(
			&i.ID,
			&i.ResponseID,
			&i.Key,
			&i.Value,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPResponsesByHttpID = `-- name: GetHTTPResponsesByHttpID :many
SELECT
  id,
  http_id,
  status,
  body,
  time,
  duration,
  size,
  created_at
FROM http_response
WHERE http_id = ?
ORDER BY time DESC
`

func (q *Queries) GetHTTPResponsesByHttpID(ctx context.Context, httpID idwrap.IDWrap) ([]HttpResponse, error) {
	rows, err := q.query(ctx, q.getHTTPResponsesByHttpIDStmt, getHTTPResponsesByHttpID, httpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpResponse{}
	for rows.Next() {
		var i HttpResponse
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Status,
			&i.Body,
			&i.Time,
			&i.Duration,
			&i.Size,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPResponsesByIDs = `-- name: GetHTTPResponsesByIDs :many
SELECT
  id,
  http_id,
  status,
  body,
  time,
  duration,
  size,
  created_at
FROM http_response
WHERE id IN (/*SLICE:ids*/?)
ORDER BY time DESC
`

func (q *Queries) GetHTTPResponsesByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]HttpResponse, error) {
	query := getHTTPResponsesByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpResponse{}
	for rows.Next() {
		var i HttpResponse
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Status,
			&i.Body,
			&i.Time,
			&i.Duration,
			&i.Size,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPSearchParams = `-- name: GetHTTPSearchParams :many

SELECT
  id,
  http_id,
  key,
  value,
  description,
  enabled,
  parent_http_search_param_id,
  is_delta,
  delta_key,
  delta_value,
  delta_description,
  delta_enabled,
  "order",
  created_at,
  updated_at
FROM http_search_param
WHERE http_id = ?
ORDER BY "order"
`

type GetHTTPSearchParamsRow struct {
	ID                      idwrap.IDWrap
	HttpID                  idwrap.IDWrap
	Key                     string
	Value                   string
	Description             string
	Enabled                 bool
	ParentHttpSearchParamID []byte
	IsDelta                 bool
	DeltaKey                sql.NullString
	DeltaValue              sql.NullString
	DeltaDescription        *string
	DeltaEnabled            *bool
	Order                   float64
	CreatedAt               int64
	UpdatedAt               int64
}

// HTTP Search Parameter Queries
func (q *Queries) GetHTTPSearchParams(ctx context.Context, httpID idwrap.IDWrap) ([]GetHTTPSearchParamsRow, error) {
	rows, err := q.query(ctx, q.getHTTPSearchParamsStmt, getHTTPSearchParams, httpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPSearchParamsRow{}
	for rows.Next() {
		var i GetHTTPSearchParamsRow
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.Enabled,
			&i.ParentHttpSearchParamID,
			&i.IsDelta,
			&i.DeltaKey,
			&i.DeltaValue,
			&i.DeltaDescription,
			&i.DeltaEnabled,
			&i.Order,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPSearchParamsByIDs = `-- name: GetHTTPSearchParamsByIDs :many
SELECT
  id,
  http_id,
  key,
  value,
  description,
  enabled,
  parent_http_search_param_id,
  is_delta,
  delta_key,
  delta_value,
  delta_description,
  delta_enabled,
  "order",
  created_at,
  updated_at
FROM http_search_param
WHERE id IN (/*SLICE:ids*/?)
`

type GetHTTPSearchParamsByIDsRow struct {
	ID                      idwrap.IDWrap
	HttpID                  idwrap.IDWrap
	Key                     string
	Value                   string
	Description             string
	Enabled                 bool
	ParentHttpSearchParamID []byte
	IsDelta                 bool
	DeltaKey                sql.NullString
	DeltaValue              sql.NullString
	DeltaDescription        *string
	DeltaEnabled            *bool
	Order                   float64
	CreatedAt               int64
	UpdatedAt               int64
}

func (q *Queries) GetHTTPSearchParamsByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]GetHTTPSearchParamsByIDsRow, error) {
	query := getHTTPSearchParamsByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPSearchParamsByIDsRow{}
	for rows.Next() {
		var i GetHTTPSearchParamsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.Enabled,
			&i.ParentHttpSearchParamID,
			&i.IsDelta,
			&i.DeltaKey,
			&i.DeltaValue,
			&i.DeltaDescription,
			&i.DeltaEnabled,
			&i.Order,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPSearchParamsStreaming = `-- name: GetHTTPSearchParamsStreaming :many
SELECT 
  hsp.id,
  hsp.http_id,
  hsp.key,
  hsp.value,
  hsp.description,
  hsp.enabled,
  hsp.parent_http_search_param_id,
  hsp.is_delta,
  hsp.delta_key,
  hsp.delta_value,
  hsp.delta_description,
  hsp.delta_enabled,
  hsp.created_at,
  hsp.updated_at
FROM http_search_param hsp
WHERE hsp.http_id IN (/*SLICE:http_ids*/?)
  AND hsp.enabled = TRUE
  AND hsp.updated_at <= ?
ORDER BY hsp.http_id, hsp.updated_at DESC
`

type GetHTTPSearchParamsStreamingParams struct {
	HttpIds   []idwrap.IDWrap
	UpdatedAt int64
}

type GetHTTPSearchParamsStreamingRow struct {
	ID                      idwrap.IDWrap
	HttpID                  idwrap.IDWrap
	Key                     string
	Value                   string
	Description             string
	Enabled                 bool
	ParentHttpSearchParamID []byte
	IsDelta                 bool
	DeltaKey                sql.NullString
	DeltaValue              sql.NullString
	DeltaDescription        *string
	DeltaEnabled            *bool
	CreatedAt               int64
	UpdatedAt               int64
}

// Optimized search parameters query for streaming
func (q *Queries) GetHTTPSearchParamsStreaming(ctx context.Context, arg GetHTTPSearchParamsStreamingParams) ([]GetHTTPSearchParamsStreamingRow, error) {
	query := getHTTPSearchParamsStreaming
	var queryParams []interface{}
	if len(arg.HttpIds) > 0 {
		for _, v := range arg.HttpIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:http_ids*/?", strings.Repeat(",?", len(arg.HttpIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:http_ids*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.UpdatedAt)
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPSearchParamsStreamingRow{}
	for rows.Next() {
		var i GetHTTPSearchParamsStreamingRow
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.Key,
			&i.Value,
			&i.Description,
			&i.Enabled,
			&i.ParentHttpSearchParamID,
			&i.IsDelta,
			&i.DeltaKey,
			&i.DeltaValue,
			&i.DeltaDescription,
			&i.DeltaEnabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPSnapshotCount = `-- name: GetHTTPSnapshotCount :one
SELECT COUNT(*) as total_count
FROM http h
WHERE h.workspace_id = ? 
  AND h.is_delta = FALSE
  AND h.updated_at <= ?
`

type GetHTTPSnapshotCountParams struct {
	WorkspaceID idwrap.IDWrap
	UpdatedAt   int64
}

// Count query for pagination progress tracking
func (q *Queries) GetHTTPSnapshotCount(ctx context.Context, arg GetHTTPSnapshotCountParams) (int64, error) {
	row := q.queryRow(ctx, q.getHTTPSnapshotCountStmt, getHTTPSnapshotCount, arg.WorkspaceID, arg.UpdatedAt)
	var total_count int64
	err := row.Scan(&total_count)
	return total_count, err
}

const getHTTPSnapshotPage = `-- name: GetHTTPSnapshotPage :many
/*
 *
 * HTTP STREAMING OPTIMIZATION QUERIES
 * High-performance queries for Phase 2a HTTP streaming implementation
 *
 */

SELECT 
  h.id,
  h.workspace_id,
  h.folder_id,
  h.name,
  h.url,
  h.method,
  h.body_kind,
  h.description,
  h.parent_http_id,
  h.is_delta,
  h.delta_name,
  h.delta_url,
  h.delta_method,
  h.delta_body_kind,
  h.delta_description,
  h.created_at,
  h.updated_at
FROM http h
WHERE h.workspace_id = ? 
  AND h.is_delta = FALSE
  AND h.updated_at <= ?
ORDER BY h.updated_at DESC, h.id
LIMIT ?
`

type GetHTTPSnapshotPageParams struct {
	WorkspaceID idwrap.IDWrap
	UpdatedAt   int64
	Limit       int64
}

type GetHTTPSnapshotPageRow struct {
	ID               idwrap.IDWrap
	WorkspaceID      idwrap.IDWrap
	FolderID         *idwrap.IDWrap
	Name             string
	Url              string
	Method           string
	BodyKind         int8
	Description      string
	ParentHttpID     *idwrap.IDWrap
	IsDelta          bool
	DeltaName        *string
	DeltaUrl         *string
	DeltaMethod      *string
	DeltaBodyKind    interface{}
	DeltaDescription *string
	CreatedAt        int64
	UpdatedAt        int64
}

// HTTP Snapshot Queries for Streaming
// High-performance paginated snapshot query for initial data load
// Uses optimized streaming indexes for fast workspace-scoped access
func (q *Queries) GetHTTPSnapshotPage(ctx context.Context, arg GetHTTPSnapshotPageParams) ([]GetHTTPSnapshotPageRow, error) {
	rows, err := q.query(ctx, q.getHTTPSnapshotPageStmt, getHTTPSnapshotPage, arg.WorkspaceID, arg.UpdatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPSnapshotPageRow{}
	for rows.Next() {
		var i GetHTTPSnapshotPageRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.BodyKind,
			&i.Description,
			&i.ParentHttpID,
			&i.IsDelta,
			&i.DeltaName,
			&i.DeltaUrl,
			&i.DeltaMethod,
			&i.DeltaBodyKind,
			&i.DeltaDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPStreamingMetrics = `-- name: GetHTTPStreamingMetrics :one
SELECT 
  COUNT(*) as total_http_records,
  COUNT(CASE WHEN is_delta = FALSE THEN 1 END) as base_records,
  COUNT(CASE WHEN is_delta = TRUE THEN 1 END) as delta_records,
  MAX(updated_at) as latest_update,
  MIN(updated_at) as earliest_update,
  COUNT(CASE WHEN updated_at > ? THEN 1 END) as recent_changes
FROM http 
WHERE workspace_id = ?
`

type GetHTTPStreamingMetricsParams struct {
	UpdatedAt   int64
	WorkspaceID idwrap.IDWrap
}

type GetHTTPStreamingMetricsRow struct {
	TotalHttpRecords int64
	BaseRecords      int64
	DeltaRecords     int64
	LatestUpdate     interface{}
	EarliestUpdate   interface{}
	RecentChanges    int64
}

// HTTP Performance Monitoring Queries
// Performance metrics query for monitoring streaming operations
func (q *Queries) GetHTTPStreamingMetrics(ctx context.Context, arg GetHTTPStreamingMetricsParams) (GetHTTPStreamingMetricsRow, error) {
	row := q.queryRow(ctx, q.getHTTPStreamingMetricsStmt, getHTTPStreamingMetrics, arg.UpdatedAt, arg.WorkspaceID)
	var i GetHTTPStreamingMetricsRow
	err := row.Scan(
		&i.TotalHttpRecords,
		&i.BaseRecords,
		&i.DeltaRecords,
		&i.LatestUpdate,
		&i.EarliestUpdate,
		&i.RecentChanges,
	)
	return i, err
}

const getHTTPWorkspaceActivity = `-- name: GetHTTPWorkspaceActivity :many
SELECT 
  DATE(updated_at, 'unixepoch') as activity_date,
  COUNT(*) as changes_count,
  COUNT(CASE WHEN is_delta = TRUE THEN 1 END) as delta_count,
  COUNT(CASE WHEN is_delta = FALSE THEN 1 END) as base_count
FROM http
WHERE workspace_id = ?
  AND updated_at >= ?
GROUP BY DATE(updated_at, 'unixepoch')
ORDER BY activity_date DESC
LIMIT 30
`

type GetHTTPWorkspaceActivityParams struct {
	WorkspaceID idwrap.IDWrap
	UpdatedAt   int64
}

type GetHTTPWorkspaceActivityRow struct {
	ActivityDate interface{}
	ChangesCount int64
	DeltaCount   int64
	BaseCount    int64
}

// Activity monitoring query for workspace streaming health
func (q *Queries) GetHTTPWorkspaceActivity(ctx context.Context, arg GetHTTPWorkspaceActivityParams) ([]GetHTTPWorkspaceActivityRow, error) {
	rows, err := q.query(ctx, q.getHTTPWorkspaceActivityStmt, getHTTPWorkspaceActivity, arg.WorkspaceID, arg.UpdatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPWorkspaceActivityRow{}
	for rows.Next() {
		var i GetHTTPWorkspaceActivityRow
		if err := rows.Scan(
			&i.ActivityDate,
			&i.ChangesCount,
			&i.DeltaCount,
			&i.BaseCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPWorkspaceID = `-- name: GetHTTPWorkspaceID :one
SELECT workspace_id
FROM http
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetHTTPWorkspaceID(ctx context.Context, id idwrap.IDWrap) (idwrap.IDWrap, error) {
	row := q.queryRow(ctx, q.getHTTPWorkspaceIDStmt, getHTTPWorkspaceID, id)
	var workspace_id idwrap.IDWrap
	err := row.Scan(&workspace_id)
	return workspace_id, err
}

const getHTTPsByFolderID = `-- name: GetHTTPsByFolderID :many
SELECT
  id,
  workspace_id,
  folder_id,
  name,
  url,
  method,
  body_kind,
  description,
  parent_http_id,
  is_delta,
  delta_name,
  delta_url,
  delta_method,
  delta_body_kind,
  delta_description,
  created_at,
  updated_at
FROM http
WHERE folder_id = ? AND is_delta = FALSE
ORDER BY updated_at DESC
`

type GetHTTPsByFolderIDRow struct {
	ID               idwrap.IDWrap
	WorkspaceID      idwrap.IDWrap
	FolderID         *idwrap.IDWrap
	Name             string
	Url              string
	Method           string
	BodyKind         int8
	Description      string
	ParentHttpID     *idwrap.IDWrap
	IsDelta          bool
	DeltaName        *string
	DeltaUrl         *string
	DeltaMethod      *string
	DeltaBodyKind    interface{}
	DeltaDescription *string
	CreatedAt        int64
	UpdatedAt        int64
}

func (q *Queries) GetHTTPsByFolderID(ctx context.Context, folderID *idwrap.IDWrap) ([]GetHTTPsByFolderIDRow, error) {
	rows, err := q.query(ctx, q.getHTTPsByFolderIDStmt, getHTTPsByFolderID, folderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPsByFolderIDRow{}
	for rows.Next() {
		var i GetHTTPsByFolderIDRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.BodyKind,
			&i.Description,
			&i.ParentHttpID,
			&i.IsDelta,
			&i.DeltaName,
			&i.DeltaUrl,
			&i.DeltaMethod,
			&i.DeltaBodyKind,
			&i.DeltaDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPsByIDs = `-- name: GetHTTPsByIDs :many
SELECT
  id,
  workspace_id,
  folder_id,
  name,
  url,
  method,
  body_kind,
  description,
  parent_http_id,
  is_delta,
  delta_name,
  delta_url,
  delta_method,
  delta_body_kind,
  delta_description,
  created_at,
  updated_at
FROM http
WHERE id IN (/*SLICE:ids*/?)
`

type GetHTTPsByIDsRow struct {
	ID               idwrap.IDWrap
	WorkspaceID      idwrap.IDWrap
	FolderID         *idwrap.IDWrap
	Name             string
	Url              string
	Method           string
	BodyKind         int8
	Description      string
	ParentHttpID     *idwrap.IDWrap
	IsDelta          bool
	DeltaName        *string
	DeltaUrl         *string
	DeltaMethod      *string
	DeltaBodyKind    interface{}
	DeltaDescription *string
	CreatedAt        int64
	UpdatedAt        int64
}

func (q *Queries) GetHTTPsByIDs(ctx context.Context, ids []idwrap.IDWrap) ([]GetHTTPsByIDsRow, error) {
	query := getHTTPsByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetHTTPsByIDsRow{}
	for rows.Next() {
		var i GetHTTPsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.BodyKind,
			&i.Description,
			&i.ParentHttpID,
			&i.IsDelta,
			&i.DeltaName,
			&i.DeltaUrl,
			&i.DeltaMethod,
			&i.DeltaBodyKind,
			&i.DeltaDescription,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHTTPsByWorkspaceID = `-- name: GetHTTPsByWorkspaceID :many
SELECT
  id,
  workspace_id,
  folder_id,
  name,
  url,
  method,
  body_kind,
  description,
  parent_http_id,
  is_delta,
  delta_name,
  delta_url,
  delta_method,
  delta_body_kind,
  delta_description,
  last_run_at,
  created_at,
  updated_at
FROM http
WHERE workspace_id = ? AND is_delta = FALSE
ORDER BY updated_at DESC
`

func (q *Queries) GetHTTPsByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]Http, error) {
	rows, err := q.query(ctx, q.getHTTPsByWorkspaceIDStmt, getHTTPsByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Http{}
	for rows.Next() {
		var i Http
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.FolderID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.BodyKind,
			&i.Description,
			&i.ParentHttpID,
			&i.IsDelta,
			&i.DeltaName,
			&i.DeltaUrl,
			&i.DeltaMethod,
			&i.DeltaBodyKind,
			&i.DeltaDescription,
			&i.LastRunAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHttpVersionsByHttpID = `-- name: GetHttpVersionsByHttpID :many
SELECT id, http_id, version_name, version_description, is_active, created_at, created_by
FROM http_version
WHERE http_id = ?
ORDER BY created_at DESC
`

func (q *Queries) GetHttpVersionsByHttpID(ctx context.Context, httpID idwrap.IDWrap) ([]HttpVersion, error) {
	rows, err := q.query(ctx, q.getHttpVersionsByHttpIDStmt, getHttpVersionsByHttpID, httpID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HttpVersion{}
	for rows.Next() {
		var i HttpVersion
		if err := rows.Scan(
			&i.ID,
			&i.HttpID,
			&i.VersionName,
			&i.VersionDescription,
			&i.IsActive,
			&i.CreatedAt,
			&i.CreatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetHTTPBodyFormDelta = `-- name: ResetHTTPBodyFormDelta :exec
UPDATE http_body_form
SET
  is_delta = false,
  parent_http_body_form_id = NULL,
  delta_key = NULL,
  delta_value = NULL,
  delta_description = NULL,
  delta_enabled = NULL,
  delta_order = NULL,
  updated_at = unixepoch()
WHERE id = ?
`

func (q *Queries) ResetHTTPBodyFormDelta(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.resetHTTPBodyFormDeltaStmt, resetHTTPBodyFormDelta, id)
	return err
}

const resolveHTTPWithDeltas = `-- name: ResolveHTTPWithDeltas :one
WITH RECURSIVE delta_chain AS (
  -- Base case: Start with the parent HTTP record
  SELECT 
    h.id,
    h.workspace_id,
    h.folder_id,
    h.name,
    h.url,
    h.method,
    h.body_kind,
    h.description,
    h.parent_http_id,
    h.is_delta,
    h.delta_name,
    h.delta_url,
    h.delta_method,
    h.delta_body_kind,
    h.delta_description,
    h.created_at,
    h.updated_at,
    0 as delta_level
  FROM http h
  WHERE h.id = ? AND h.is_delta = FALSE
  
  UNION ALL
  
  -- Recursive case: Apply deltas in chronological order
  SELECT 
    h.id,
    h.workspace_id,
    h.folder_id,
    COALESCE(h.delta_name, dc.name, dc.name) as name,
    COALESCE(h.delta_url, dc.url, dc.url) as url,
    COALESCE(h.delta_method, dc.method, dc.method) as method,
    COALESCE(h.delta_body_kind, dc.body_kind, dc.body_kind) as body_kind,
    COALESCE(h.delta_description, dc.description, dc.description) as description,
    h.parent_http_id,
    h.is_delta,
    h.delta_name,
    h.delta_url,
    h.delta_method,
    h.delta_body_kind,
    h.delta_description,
    h.created_at,
    h.updated_at,
    dc.delta_level + 1
  FROM http h
  INNER JOIN delta_chain dc ON h.parent_http_id = dc.id
  WHERE h.is_delta = TRUE
    AND h.updated_at <= ?
)
SELECT 
  id,
  workspace_id,
  folder_id,
  name,
  url,
  method,
  body_kind,
  description,
  parent_http_id,
  is_delta,
  delta_name,
  delta_url,
  delta_method,
  delta_body_kind,
  delta_description,
  created_at,
  updated_at
FROM delta_chain
ORDER BY delta_level DESC
LIMIT 1
`

type ResolveHTTPWithDeltasParams struct {
	ID        idwrap.IDWrap
	UpdatedAt int64
}

type ResolveHTTPWithDeltasRow struct {
	ID               []byte
	WorkspaceID      []byte
	FolderID         []byte
	Name             string
	Url              string
	Method           string
	BodyKind         int8
	Description      string
	ParentHttpID     []byte
	IsDelta          bool
	DeltaName        interface{}
	DeltaUrl         interface{}
	DeltaMethod      interface{}
	DeltaBodyKind    interface{}
	DeltaDescription interface{}
	CreatedAt        int64
	UpdatedAt        int64
}

// HTTP Delta Resolution Queries
// CTE-optimized query to resolve HTTP record with all applicable deltas
// Single query for complete delta resolution with minimal joins
func (q *Queries) ResolveHTTPWithDeltas(ctx context.Context, arg ResolveHTTPWithDeltasParams) (ResolveHTTPWithDeltasRow, error) {
	row := q.queryRow(ctx, q.resolveHTTPWithDeltasStmt, resolveHTTPWithDeltas, arg.ID, arg.UpdatedAt)
	var i ResolveHTTPWithDeltasRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.FolderID,
		&i.Name,
		&i.Url,
		&i.Method,
		&i.BodyKind,
		&i.Description,
		&i.ParentHttpID,
		&i.IsDelta,
		&i.DeltaName,
		&i.DeltaUrl,
		&i.DeltaMethod,
		&i.DeltaBodyKind,
		&i.DeltaDescription,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateHTTP = `-- name: UpdateHTTP :exec
UPDATE http
SET
  folder_id = ?,
  name = ?,
  url = ?,
  method = ?,
  body_kind = ?,
  description = ?,
  last_run_at = COALESCE(?, last_run_at),
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPParams struct {
	FolderID    *idwrap.IDWrap
	Name        string
	Url         string
	Method      string
	BodyKind    int8
	Description string
	LastRunAt   interface{}
	ID          idwrap.IDWrap
}

func (q *Queries) UpdateHTTP(ctx context.Context, arg UpdateHTTPParams) error {
	_, err := q.exec(ctx, q.updateHTTPStmt, updateHTTP,
		arg.FolderID,
		arg.Name,
		arg.Url,
		arg.Method,
		arg.BodyKind,
		arg.Description,
		arg.LastRunAt,
		arg.ID,
	)
	return err
}

const updateHTTPAssert = `-- name: UpdateHTTPAssert :exec
UPDATE http_assert
SET
  value = ?,
  enabled = ?,
  description = ?,
  "order" = ?,
  delta_value = ?,
  delta_enabled = ?,
  delta_description = ?,
  delta_order = ?,
  updated_at = ?
WHERE id = ?
`

type UpdateHTTPAssertParams struct {
	Value            string
	Enabled          bool
	Description      string
	Order            float64
	DeltaValue       sql.NullString
	DeltaEnabled     *bool
	DeltaDescription sql.NullString
	DeltaOrder       sql.NullFloat64
	UpdatedAt        int64
	ID               idwrap.IDWrap
}

func (q *Queries) UpdateHTTPAssert(ctx context.Context, arg UpdateHTTPAssertParams) error {
	_, err := q.exec(ctx, q.updateHTTPAssertStmt, updateHTTPAssert,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.Order,
		arg.DeltaValue,
		arg.DeltaEnabled,
		arg.DeltaDescription,
		arg.DeltaOrder,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateHTTPAssertDelta = `-- name: UpdateHTTPAssertDelta :exec
UPDATE http_assert
SET
  delta_value = ?,
  delta_enabled = ?,
  delta_description = ?,
  delta_order = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPAssertDeltaParams struct {
	DeltaValue       sql.NullString
	DeltaEnabled     *bool
	DeltaDescription sql.NullString
	DeltaOrder       sql.NullFloat64
	ID               idwrap.IDWrap
}

func (q *Queries) UpdateHTTPAssertDelta(ctx context.Context, arg UpdateHTTPAssertDeltaParams) error {
	_, err := q.exec(ctx, q.updateHTTPAssertDeltaStmt, updateHTTPAssertDelta,
		arg.DeltaValue,
		arg.DeltaEnabled,
		arg.DeltaDescription,
		arg.DeltaOrder,
		arg.ID,
	)
	return err
}

const updateHTTPBodyForm = `-- name: UpdateHTTPBodyForm :exec
UPDATE http_body_form
SET
  key = ?,
  value = ?,
  description = ?,
  enabled = ?,
  "order" = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPBodyFormParams struct {
	Key         string
	Value       string
	Description string
	Enabled     bool
	Order       float64
	ID          idwrap.IDWrap
}

func (q *Queries) UpdateHTTPBodyForm(ctx context.Context, arg UpdateHTTPBodyFormParams) error {
	_, err := q.exec(ctx, q.updateHTTPBodyFormStmt, updateHTTPBodyForm,
		arg.Key,
		arg.Value,
		arg.Description,
		arg.Enabled,
		arg.Order,
		arg.ID,
	)
	return err
}

const updateHTTPBodyFormDelta = `-- name: UpdateHTTPBodyFormDelta :exec
UPDATE http_body_form
SET
  delta_key = ?,
  delta_value = ?,
  delta_description = ?,
  delta_enabled = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPBodyFormDeltaParams struct {
	DeltaKey         sql.NullString
	DeltaValue       sql.NullString
	DeltaDescription *string
	DeltaEnabled     *bool
	ID               idwrap.IDWrap
}

func (q *Queries) UpdateHTTPBodyFormDelta(ctx context.Context, arg UpdateHTTPBodyFormDeltaParams) error {
	_, err := q.exec(ctx, q.updateHTTPBodyFormDeltaStmt, updateHTTPBodyFormDelta,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaDescription,
		arg.DeltaEnabled,
		arg.ID,
	)
	return err
}

const updateHTTPBodyFormOrder = `-- name: UpdateHTTPBodyFormOrder :exec
UPDATE http_body_form
SET "order" = ?
WHERE id = ? AND http_id = ?
`

type UpdateHTTPBodyFormOrderParams struct {
	Order  float64
	ID     idwrap.IDWrap
	HttpID idwrap.IDWrap
}

func (q *Queries) UpdateHTTPBodyFormOrder(ctx context.Context, arg UpdateHTTPBodyFormOrderParams) error {
	_, err := q.exec(ctx, q.updateHTTPBodyFormOrderStmt, updateHTTPBodyFormOrder, arg.Order, arg.ID, arg.HttpID)
	return err
}

const updateHTTPBodyRaw = `-- name: UpdateHTTPBodyRaw :exec
UPDATE http_body_raw
SET
  raw_data = ?,
  content_type = ?,
  compression_type = ?,
  updated_at = ?
WHERE
  id = ?
`

type UpdateHTTPBodyRawParams struct {
	RawData         []byte
	ContentType     string
	CompressionType int8
	UpdatedAt       int64
	ID              idwrap.IDWrap
}

func (q *Queries) UpdateHTTPBodyRaw(ctx context.Context, arg UpdateHTTPBodyRawParams) error {
	_, err := q.exec(ctx, q.updateHTTPBodyRawStmt, updateHTTPBodyRaw,
		arg.RawData,
		arg.ContentType,
		arg.CompressionType,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateHTTPBodyRawDelta = `-- name: UpdateHTTPBodyRawDelta :exec
UPDATE http_body_raw
SET
  delta_raw_data = ?,
  delta_content_type = ?,
  delta_compression_type = ?,
  updated_at = ?
WHERE
  id = ?
`

type UpdateHTTPBodyRawDeltaParams struct {
	DeltaRawData         interface{}
	DeltaContentType     interface{}
	DeltaCompressionType interface{}
	UpdatedAt            int64
	ID                   idwrap.IDWrap
}

func (q *Queries) UpdateHTTPBodyRawDelta(ctx context.Context, arg UpdateHTTPBodyRawDeltaParams) error {
	_, err := q.exec(ctx, q.updateHTTPBodyRawDeltaStmt, updateHTTPBodyRawDelta,
		arg.DeltaRawData,
		arg.DeltaContentType,
		arg.DeltaCompressionType,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateHTTPBodyUrlEncoded = `-- name: UpdateHTTPBodyUrlEncoded :exec
UPDATE http_body_urlencoded
SET
  key = ?,
  value = ?,
  enabled = ?,
  description = ?,
  "order" = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPBodyUrlEncodedParams struct {
	Key         string
	Value       string
	Enabled     bool
	Description string
	Order       float64
	ID          idwrap.IDWrap
}

func (q *Queries) UpdateHTTPBodyUrlEncoded(ctx context.Context, arg UpdateHTTPBodyUrlEncodedParams) error {
	_, err := q.exec(ctx, q.updateHTTPBodyUrlEncodedStmt, updateHTTPBodyUrlEncoded,
		arg.Key,
		arg.Value,
		arg.Enabled,
		arg.Description,
		arg.Order,
		arg.ID,
	)
	return err
}

const updateHTTPBodyUrlEncodedDelta = `-- name: UpdateHTTPBodyUrlEncodedDelta :exec
UPDATE http_body_urlencoded
SET
  delta_key = ?,
  delta_value = ?,
  delta_enabled = ?,
  delta_description = ?,
  delta_order = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPBodyUrlEncodedDeltaParams struct {
	DeltaKey         sql.NullString
	DeltaValue       sql.NullString
	DeltaEnabled     *bool
	DeltaDescription *string
	DeltaOrder       sql.NullFloat64
	ID               idwrap.IDWrap
}

func (q *Queries) UpdateHTTPBodyUrlEncodedDelta(ctx context.Context, arg UpdateHTTPBodyUrlEncodedDeltaParams) error {
	_, err := q.exec(ctx, q.updateHTTPBodyUrlEncodedDeltaStmt, updateHTTPBodyUrlEncodedDelta,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaEnabled,
		arg.DeltaDescription,
		arg.DeltaOrder,
		arg.ID,
	)
	return err
}

const updateHTTPDelta = `-- name: UpdateHTTPDelta :exec
UPDATE http
SET
  delta_name = ?,
  delta_url = ?,
  delta_method = ?,
  delta_body_kind = ?,
  delta_description = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPDeltaParams struct {
	DeltaName        *string
	DeltaUrl         *string
	DeltaMethod      *string
	DeltaBodyKind    interface{}
	DeltaDescription *string
	ID               idwrap.IDWrap
}

func (q *Queries) UpdateHTTPDelta(ctx context.Context, arg UpdateHTTPDeltaParams) error {
	_, err := q.exec(ctx, q.updateHTTPDeltaStmt, updateHTTPDelta,
		arg.DeltaName,
		arg.DeltaUrl,
		arg.DeltaMethod,
		arg.DeltaBodyKind,
		arg.DeltaDescription,
		arg.ID,
	)
	return err
}

const updateHTTPHeader = `-- name: UpdateHTTPHeader :exec
UPDATE http_header
SET
  header_key = ?,
  header_value = ?,
  description = ?,
  enabled = ?,
  display_order = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPHeaderParams struct {
	HeaderKey    string
	HeaderValue  string
	Description  string
	Enabled      bool
	DisplayOrder float64
	ID           idwrap.IDWrap
}

func (q *Queries) UpdateHTTPHeader(ctx context.Context, arg UpdateHTTPHeaderParams) error {
	_, err := q.exec(ctx, q.updateHTTPHeaderStmt, updateHTTPHeader,
		arg.HeaderKey,
		arg.HeaderValue,
		arg.Description,
		arg.Enabled,
		arg.DisplayOrder,
		arg.ID,
	)
	return err
}

const updateHTTPHeaderDelta = `-- name: UpdateHTTPHeaderDelta :exec
UPDATE http_header
SET
  delta_header_key = ?,
  delta_header_value = ?,
  delta_description = ?,
  delta_enabled = ?,
  delta_display_order = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPHeaderDeltaParams struct {
	DeltaHeaderKey    *string
	DeltaHeaderValue  *string
	DeltaDescription  *string
	DeltaEnabled      *bool
	DeltaDisplayOrder sql.NullFloat64
	ID                idwrap.IDWrap
}

func (q *Queries) UpdateHTTPHeaderDelta(ctx context.Context, arg UpdateHTTPHeaderDeltaParams) error {
	_, err := q.exec(ctx, q.updateHTTPHeaderDeltaStmt, updateHTTPHeaderDelta,
		arg.DeltaHeaderKey,
		arg.DeltaHeaderValue,
		arg.DeltaDescription,
		arg.DeltaEnabled,
		arg.DeltaDisplayOrder,
		arg.ID,
	)
	return err
}

const updateHTTPHeaderOrder = `-- name: UpdateHTTPHeaderOrder :exec
UPDATE http_header
SET display_order = ?
WHERE id = ? AND http_id = ?
`

type UpdateHTTPHeaderOrderParams struct {
	DisplayOrder float64
	ID           idwrap.IDWrap
	HttpID       idwrap.IDWrap
}

func (q *Queries) UpdateHTTPHeaderOrder(ctx context.Context, arg UpdateHTTPHeaderOrderParams) error {
	_, err := q.exec(ctx, q.updateHTTPHeaderOrderStmt, updateHTTPHeaderOrder, arg.DisplayOrder, arg.ID, arg.HttpID)
	return err
}

const updateHTTPResponse = `-- name: UpdateHTTPResponse :exec
UPDATE http_response
SET
  status = ?,
  body = ?,
  time = ?,
  duration = ?,
  size = ?
WHERE id = ?
`

type UpdateHTTPResponseParams struct {
	Status   interface{}
	Body     []byte
	Time     time.Time
	Duration interface{}
	Size     interface{}
	ID       idwrap.IDWrap
}

func (q *Queries) UpdateHTTPResponse(ctx context.Context, arg UpdateHTTPResponseParams) error {
	_, err := q.exec(ctx, q.updateHTTPResponseStmt, updateHTTPResponse,
		arg.Status,
		arg.Body,
		arg.Time,
		arg.Duration,
		arg.Size,
		arg.ID,
	)
	return err
}

const updateHTTPResponseAssert = `-- name: UpdateHTTPResponseAssert :exec
UPDATE http_response_assert
SET
  value = ?,
  success = ?
WHERE id = ?
`

type UpdateHTTPResponseAssertParams struct {
	Value   string
	Success bool
	ID      idwrap.IDWrap
}

func (q *Queries) UpdateHTTPResponseAssert(ctx context.Context, arg UpdateHTTPResponseAssertParams) error {
	_, err := q.exec(ctx, q.updateHTTPResponseAssertStmt, updateHTTPResponseAssert, arg.Value, arg.Success, arg.ID)
	return err
}

const updateHTTPResponseHeader = `-- name: UpdateHTTPResponseHeader :exec
UPDATE http_response_header
SET
  key = ?,
  value = ?
WHERE id = ?
`

type UpdateHTTPResponseHeaderParams struct {
	Key   string
	Value string
	ID    idwrap.IDWrap
}

func (q *Queries) UpdateHTTPResponseHeader(ctx context.Context, arg UpdateHTTPResponseHeaderParams) error {
	_, err := q.exec(ctx, q.updateHTTPResponseHeaderStmt, updateHTTPResponseHeader, arg.Key, arg.Value, arg.ID)
	return err
}

const updateHTTPSearchParam = `-- name: UpdateHTTPSearchParam :exec
UPDATE http_search_param
SET
  key = ?,
  value = ?,
  description = ?,
  enabled = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPSearchParamParams struct {
	Key         string
	Value       string
	Description string
	Enabled     bool
	ID          idwrap.IDWrap
}

func (q *Queries) UpdateHTTPSearchParam(ctx context.Context, arg UpdateHTTPSearchParamParams) error {
	_, err := q.exec(ctx, q.updateHTTPSearchParamStmt, updateHTTPSearchParam,
		arg.Key,
		arg.Value,
		arg.Description,
		arg.Enabled,
		arg.ID,
	)
	return err
}

const updateHTTPSearchParamDelta = `-- name: UpdateHTTPSearchParamDelta :exec
UPDATE http_search_param
SET
  delta_key = ?,
  delta_value = ?,
  delta_description = ?,
  delta_enabled = ?,
  updated_at = unixepoch()
WHERE id = ?
`

type UpdateHTTPSearchParamDeltaParams struct {
	DeltaKey         sql.NullString
	DeltaValue       sql.NullString
	DeltaDescription *string
	DeltaEnabled     *bool
	ID               idwrap.IDWrap
}

func (q *Queries) UpdateHTTPSearchParamDelta(ctx context.Context, arg UpdateHTTPSearchParamDeltaParams) error {
	_, err := q.exec(ctx, q.updateHTTPSearchParamDeltaStmt, updateHTTPSearchParamDelta,
		arg.DeltaKey,
		arg.DeltaValue,
		arg.DeltaDescription,
		arg.DeltaEnabled,
		arg.ID,
	)
	return err
}

const updateHTTPSearchParamOrder = `-- name: UpdateHTTPSearchParamOrder :exec
UPDATE http_search_param
SET "order" = ?
WHERE id = ? AND http_id = ?
`

type UpdateHTTPSearchParamOrderParams struct {
	Order  float64
	ID     idwrap.IDWrap
	HttpID idwrap.IDWrap
}

func (q *Queries) UpdateHTTPSearchParamOrder(ctx context.Context, arg UpdateHTTPSearchParamOrderParams) error {
	_, err := q.exec(ctx, q.updateHTTPSearchParamOrderStmt, updateHTTPSearchParamOrder, arg.Order, arg.ID, arg.HttpID)
	return err
}
