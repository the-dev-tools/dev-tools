// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: files.sql

package gen

import (
	"context"
	"database/sql"
	"strings"

	idwrap "github.com/the-dev-tools/dev-tools/packages/server/pkg/idwrap"
)

const createFile = `-- name: CreateFile :exec
INSERT INTO files (id, workspace_id, parent_id, content_id, content_kind, name, display_order, path_hash, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateFileParams struct {
	ID           idwrap.IDWrap
	WorkspaceID  idwrap.IDWrap
	ParentID     *idwrap.IDWrap
	ContentID    *idwrap.IDWrap
	ContentKind  int8
	Name         string
	DisplayOrder float64
	PathHash     sql.NullString
	UpdatedAt    int64
}

// Create a new file
func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) error {
	_, err := q.exec(ctx, q.createFileStmt, createFile,
		arg.ID,
		arg.WorkspaceID,
		arg.ParentID,
		arg.ContentID,
		arg.ContentKind,
		arg.Name,
		arg.DisplayOrder,
		arg.PathHash,
		arg.UpdatedAt,
	)
	return err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM files WHERE id = ?
`

// Delete a file by ID
func (q *Queries) DeleteFile(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteFileStmt, deleteFile, id)
	return err
}

const findFileByPathHash = `-- name: FindFileByPathHash :one
SELECT id
FROM files
WHERE workspace_id = ? AND path_hash = ?
LIMIT 1
`

type FindFileByPathHashParams struct {
	WorkspaceID idwrap.IDWrap
	PathHash    sql.NullString
}

// Find a file by its path hash and workspace ID
func (q *Queries) FindFileByPathHash(ctx context.Context, arg FindFileByPathHashParams) (idwrap.IDWrap, error) {
	row := q.queryRow(ctx, q.findFileByPathHashStmt, findFileByPathHash, arg.WorkspaceID, arg.PathHash)
	var id idwrap.IDWrap
	err := row.Scan(&id)
	return id, err
}

const getFile = `-- name: GetFile :one

SELECT id, workspace_id, parent_id, content_id, content_kind, name, display_order, path_hash, updated_at
FROM files
WHERE id = ?
`

// File System
//
// Get a single file by ID
func (q *Queries) GetFile(ctx context.Context, id idwrap.IDWrap) (File, error) {
	row := q.queryRow(ctx, q.getFileStmt, getFile, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ParentID,
		&i.ContentID,
		&i.ContentKind,
		&i.Name,
		&i.DisplayOrder,
		&i.PathHash,
		&i.UpdatedAt,
	)
	return i, err
}

const getFileByContentID = `-- name: GetFileByContentID :one
SELECT id, workspace_id, parent_id, content_id, content_kind, name, display_order, path_hash, updated_at
FROM files
WHERE content_id = ?
LIMIT 1
`

// Find file that references a specific content (HTTP, Flow, etc.)
func (q *Queries) GetFileByContentID(ctx context.Context, contentID *idwrap.IDWrap) (File, error) {
	row := q.queryRow(ctx, q.getFileByContentIDStmt, getFileByContentID, contentID)
	var i File
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ParentID,
		&i.ContentID,
		&i.ContentKind,
		&i.Name,
		&i.DisplayOrder,
		&i.PathHash,
		&i.UpdatedAt,
	)
	return i, err
}

const getFileWithContent = `-- name: GetFileWithContent :one
SELECT id, workspace_id, parent_id, content_id, content_kind, name, display_order, path_hash, updated_at
FROM files
WHERE id = ?
`

// Get a file with its content (two-query pattern for union types)
func (q *Queries) GetFileWithContent(ctx context.Context, id idwrap.IDWrap) (File, error) {
	row := q.queryRow(ctx, q.getFileWithContentStmt, getFileWithContent, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ParentID,
		&i.ContentID,
		&i.ContentKind,
		&i.Name,
		&i.DisplayOrder,
		&i.PathHash,
		&i.UpdatedAt,
	)
	return i, err
}

const getFileWorkspaceID = `-- name: GetFileWorkspaceID :one
SELECT workspace_id 
FROM files
WHERE id = ?
`

// Get the workspace_id for a file
func (q *Queries) GetFileWorkspaceID(ctx context.Context, id idwrap.IDWrap) (idwrap.IDWrap, error) {
	row := q.queryRow(ctx, q.getFileWorkspaceIDStmt, getFileWorkspaceID, id)
	var workspace_id idwrap.IDWrap
	err := row.Scan(&workspace_id)
	return workspace_id, err
}

const getFilesByContentIDs = `-- name: GetFilesByContentIDs :many
SELECT id, workspace_id, content_id, content_kind
FROM files
WHERE content_id IN (/*SLICE:content_ids*/?)
`

type GetFilesByContentIDsRow struct {
	ID          idwrap.IDWrap
	WorkspaceID idwrap.IDWrap
	ContentID   *idwrap.IDWrap
	ContentKind int8
}

// Batch query to find files that reference multiple content IDs
func (q *Queries) GetFilesByContentIDs(ctx context.Context, contentIds []*idwrap.IDWrap) ([]GetFilesByContentIDsRow, error) {
	query := getFilesByContentIDs
	var queryParams []interface{}
	if len(contentIds) > 0 {
		for _, v := range contentIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:content_ids*/?", strings.Repeat(",?", len(contentIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:content_ids*/?", "NULL", 1)
	}
	rows, err := q.query(ctx, nil, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFilesByContentIDsRow{}
	for rows.Next() {
		var i GetFilesByContentIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ContentID,
			&i.ContentKind,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesByParentID = `-- name: GetFilesByParentID :many
SELECT id, workspace_id, parent_id, content_id, content_kind, name, display_order, path_hash, updated_at
FROM files
WHERE parent_id = ?
`

// Get all files directly under a parent (unordered)
func (q *Queries) GetFilesByParentID(ctx context.Context, parentID *idwrap.IDWrap) ([]File, error) {
	rows, err := q.query(ctx, q.getFilesByParentIDStmt, getFilesByParentID, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ParentID,
			&i.ContentID,
			&i.ContentKind,
			&i.Name,
			&i.DisplayOrder,
			&i.PathHash,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesByParentIDOrdered = `-- name: GetFilesByParentIDOrdered :many
SELECT id, workspace_id, parent_id, content_id, content_kind, name, display_order, path_hash, updated_at
FROM files
WHERE parent_id = ?
ORDER BY display_order, id
`

// Get all files directly under a parent ordered by display_order
func (q *Queries) GetFilesByParentIDOrdered(ctx context.Context, parentID *idwrap.IDWrap) ([]File, error) {
	rows, err := q.query(ctx, q.getFilesByParentIDOrderedStmt, getFilesByParentIDOrdered, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ParentID,
			&i.ContentID,
			&i.ContentKind,
			&i.Name,
			&i.DisplayOrder,
			&i.PathHash,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesByWorkspaceID = `-- name: GetFilesByWorkspaceID :many
SELECT id, workspace_id, parent_id, content_id, content_kind, name, display_order, path_hash, updated_at
FROM files
WHERE workspace_id = ?
`

// Get all files in a workspace (unordered)
func (q *Queries) GetFilesByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]File, error) {
	rows, err := q.query(ctx, q.getFilesByWorkspaceIDStmt, getFilesByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ParentID,
			&i.ContentID,
			&i.ContentKind,
			&i.Name,
			&i.DisplayOrder,
			&i.PathHash,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFilesByWorkspaceIDOrdered = `-- name: GetFilesByWorkspaceIDOrdered :many
SELECT id, workspace_id, parent_id, content_id, content_kind, name, display_order, path_hash, updated_at
FROM files
WHERE workspace_id = ?
ORDER BY display_order, id
`

// Get all files in a workspace ordered by display_order
func (q *Queries) GetFilesByWorkspaceIDOrdered(ctx context.Context, workspaceID idwrap.IDWrap) ([]File, error) {
	rows, err := q.query(ctx, q.getFilesByWorkspaceIDOrderedStmt, getFilesByWorkspaceIDOrdered, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ParentID,
			&i.ContentID,
			&i.ContentKind,
			&i.Name,
			&i.DisplayOrder,
			&i.PathHash,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowContent = `-- name: GetFlowContent :one
SELECT id, name, duration
FROM flow
WHERE id = ?
`

type GetFlowContentRow struct {
	ID       idwrap.IDWrap
	Name     string
	Duration int32
}

// Get flow content by content_id (for union type resolution)
func (q *Queries) GetFlowContent(ctx context.Context, id idwrap.IDWrap) (GetFlowContentRow, error) {
	row := q.queryRow(ctx, q.getFlowContentStmt, getFlowContent, id)
	var i GetFlowContentRow
	err := row.Scan(&i.ID, &i.Name, &i.Duration)
	return i, err
}

const getRootFilesByWorkspaceID = `-- name: GetRootFilesByWorkspaceID :many
SELECT id, workspace_id, parent_id, content_id, content_kind, name, display_order, path_hash, updated_at
FROM files
WHERE workspace_id = ? AND parent_id IS NULL
ORDER BY display_order, id
`

// Get root-level files (no parent folder) in a workspace ordered by display_order
func (q *Queries) GetRootFilesByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]File, error) {
	rows, err := q.query(ctx, q.getRootFilesByWorkspaceIDStmt, getRootFilesByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []File{}
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ParentID,
			&i.ContentID,
			&i.ContentKind,
			&i.Name,
			&i.DisplayOrder,
			&i.PathHash,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFile = `-- name: UpdateFile :exec
UPDATE files 
SET workspace_id = ?, parent_id = ?, content_id = ?, content_kind = ?, name = ?, display_order = ?, path_hash = ?, updated_at = ?
WHERE id = ?
`

type UpdateFileParams struct {
	WorkspaceID  idwrap.IDWrap
	ParentID     *idwrap.IDWrap
	ContentID    *idwrap.IDWrap
	ContentKind  int8
	Name         string
	DisplayOrder float64
	PathHash     sql.NullString
	UpdatedAt    int64
	ID           idwrap.IDWrap
}

// Update an existing file
func (q *Queries) UpdateFile(ctx context.Context, arg UpdateFileParams) error {
	_, err := q.exec(ctx, q.updateFileStmt, updateFile,
		arg.WorkspaceID,
		arg.ParentID,
		arg.ContentID,
		arg.ContentKind,
		arg.Name,
		arg.DisplayOrder,
		arg.PathHash,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
