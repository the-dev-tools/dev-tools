// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: workspaces.sql

package gen

import (
	"context"

	idwrap "the-dev-tools/server/pkg/idwrap"
)

const checkIFWorkspaceUserExists = `-- name: CheckIFWorkspaceUserExists :one
SELECT
  cast(
  EXISTS (
    SELECT
      1
    FROM
      workspaces_users
    WHERE
      workspace_id = ?
      AND user_id = ?
    LIMIT
      1
) AS boolean
)
`

type CheckIFWorkspaceUserExistsParams struct {
	WorkspaceID idwrap.IDWrap
	UserID      idwrap.IDWrap
}

// WorkspaceUsers
func (q *Queries) CheckIFWorkspaceUserExists(ctx context.Context, arg CheckIFWorkspaceUserExistsParams) (bool, error) {
	row := q.queryRow(ctx, q.checkIFWorkspaceUserExistsStmt, checkIFWorkspaceUserExists, arg.WorkspaceID, arg.UserID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const createWorkspace = `-- name: CreateWorkspace :exec
INSERT INTO
  workspaces (id, name, updated, collection_count, flow_count, active_env, global_env, prev, next)
VALUES
  (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateWorkspaceParams struct {
	ID              idwrap.IDWrap
	Name            string
	Updated         int64
	CollectionCount int32
	FlowCount       int32
	ActiveEnv       idwrap.IDWrap
	GlobalEnv       idwrap.IDWrap
	Prev            *idwrap.IDWrap
	Next            *idwrap.IDWrap
}

func (q *Queries) CreateWorkspace(ctx context.Context, arg CreateWorkspaceParams) error {
	_, err := q.exec(ctx, q.createWorkspaceStmt, createWorkspace,
		arg.ID,
		arg.Name,
		arg.Updated,
		arg.CollectionCount,
		arg.FlowCount,
		arg.ActiveEnv,
		arg.GlobalEnv,
		arg.Prev,
		arg.Next,
	)
	return err
}

const createWorkspaceUser = `-- name: CreateWorkspaceUser :exec
INSERT INTO
  workspaces_users (id, workspace_id, user_id, role)
VALUES
  (?, ?, ?, ?)
`

type CreateWorkspaceUserParams struct {
	ID          idwrap.IDWrap
	WorkspaceID idwrap.IDWrap
	UserID      idwrap.IDWrap
	Role        int8
}

func (q *Queries) CreateWorkspaceUser(ctx context.Context, arg CreateWorkspaceUserParams) error {
	_, err := q.exec(ctx, q.createWorkspaceUserStmt, createWorkspaceUser,
		arg.ID,
		arg.WorkspaceID,
		arg.UserID,
		arg.Role,
	)
	return err
}

const deleteWorkspace = `-- name: DeleteWorkspace :exec
DELETE FROM workspaces
WHERE
  id = ?
`

func (q *Queries) DeleteWorkspace(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteWorkspaceStmt, deleteWorkspace, id)
	return err
}

const deleteWorkspaceUser = `-- name: DeleteWorkspaceUser :exec
DELETE FROM workspaces_users
WHERE
  id = ?
`

func (q *Queries) DeleteWorkspaceUser(ctx context.Context, id idwrap.IDWrap) error {
	_, err := q.exec(ctx, q.deleteWorkspaceUserStmt, deleteWorkspaceUser, id)
	return err
}

const getAllWorkspacesByUserID = `-- name: GetAllWorkspacesByUserID :many
SELECT
  w.id,
  w.name,
  w.updated,
  w.collection_count,
  w.flow_count,
  w.active_env,
  w.global_env,
  w.prev,
  w.next
FROM
  workspaces w
INNER JOIN workspaces_users wu ON w.id = wu.workspace_id
WHERE
  wu.user_id = ?
ORDER BY
  w.updated DESC
`

// Returns ALL workspaces for a user, including isolated ones (prev=NULL, next=NULL)
// Unlike GetWorkspacesByUserIDOrdered, this query finds workspaces regardless of linked-list state
// Essential for finding new workspaces that haven't been linked yet
func (q *Queries) GetAllWorkspacesByUserID(ctx context.Context, userID idwrap.IDWrap) ([]Workspace, error) {
	rows, err := q.query(ctx, q.getAllWorkspacesByUserIDStmt, getAllWorkspacesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workspace{}
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Updated,
			&i.CollectionCount,
			&i.FlowCount,
			&i.ActiveEnv,
			&i.GlobalEnv,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspace = `-- name: GetWorkspace :one
SELECT
  id,
  name,
  updated,
  collection_count,
  flow_count,
  active_env,
  global_env
FROM
  workspaces
WHERE
  id = ?
LIMIT
  1
`

type GetWorkspaceRow struct {
	ID              idwrap.IDWrap
	Name            string
	Updated         int64
	CollectionCount int32
	FlowCount       int32
	ActiveEnv       idwrap.IDWrap
	GlobalEnv       idwrap.IDWrap
}

// Workspaces
func (q *Queries) GetWorkspace(ctx context.Context, id idwrap.IDWrap) (GetWorkspaceRow, error) {
	row := q.queryRow(ctx, q.getWorkspaceStmt, getWorkspace, id)
	var i GetWorkspaceRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Updated,
		&i.CollectionCount,
		&i.FlowCount,
		&i.ActiveEnv,
		&i.GlobalEnv,
	)
	return i, err
}

const getWorkspaceByUserID = `-- name: GetWorkspaceByUserID :one
SELECT
  id,
  name,
  updated,
  collection_count,
  flow_count,
  active_env,
  global_env
FROM
  workspaces
WHERE
  id = (
    SELECT
      workspace_id
    FROM
      workspaces_users
    WHERE
      user_id = ?
    LIMIT
      1
  )
LIMIT
  1
`

type GetWorkspaceByUserIDRow struct {
	ID              idwrap.IDWrap
	Name            string
	Updated         int64
	CollectionCount int32
	FlowCount       int32
	ActiveEnv       idwrap.IDWrap
	GlobalEnv       idwrap.IDWrap
}

func (q *Queries) GetWorkspaceByUserID(ctx context.Context, userID idwrap.IDWrap) (GetWorkspaceByUserIDRow, error) {
	row := q.queryRow(ctx, q.getWorkspaceByUserIDStmt, getWorkspaceByUserID, userID)
	var i GetWorkspaceByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Updated,
		&i.CollectionCount,
		&i.FlowCount,
		&i.ActiveEnv,
		&i.GlobalEnv,
	)
	return i, err
}

const getWorkspaceByUserIDandWorkspaceID = `-- name: GetWorkspaceByUserIDandWorkspaceID :one
SELECT
  id,
  name,
  updated,
  collection_count,
  flow_count,
  active_env,
  global_env,
  prev,
  next
FROM
  workspaces
WHERE
  id = (
    SELECT
      workspace_id
    FROM
      workspaces_users
    WHERE
      workspace_id = ?
      AND user_id = ?
    LIMIT
      1
  )
LIMIT
  1
`

type GetWorkspaceByUserIDandWorkspaceIDParams struct {
	WorkspaceID idwrap.IDWrap
	UserID      idwrap.IDWrap
}

func (q *Queries) GetWorkspaceByUserIDandWorkspaceID(ctx context.Context, arg GetWorkspaceByUserIDandWorkspaceIDParams) (Workspace, error) {
	row := q.queryRow(ctx, q.getWorkspaceByUserIDandWorkspaceIDStmt, getWorkspaceByUserIDandWorkspaceID, arg.WorkspaceID, arg.UserID)
	var i Workspace
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Updated,
		&i.CollectionCount,
		&i.FlowCount,
		&i.ActiveEnv,
		&i.GlobalEnv,
		&i.Prev,
		&i.Next,
	)
	return i, err
}

const getWorkspaceUser = `-- name: GetWorkspaceUser :one
SELECT
  id,
  workspace_id,
  user_id,
  role
FROM
  workspaces_users
WHERE
  id = ?
LIMIT
  1
`

func (q *Queries) GetWorkspaceUser(ctx context.Context, id idwrap.IDWrap) (WorkspacesUser, error) {
	row := q.queryRow(ctx, q.getWorkspaceUserStmt, getWorkspaceUser, id)
	var i WorkspacesUser
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.UserID,
		&i.Role,
	)
	return i, err
}

const getWorkspaceUserByUserID = `-- name: GetWorkspaceUserByUserID :many
SELECT
  id,
  workspace_id,
  user_id,
  role
FROM
  workspaces_users
WHERE
  user_id = ?
`

func (q *Queries) GetWorkspaceUserByUserID(ctx context.Context, userID idwrap.IDWrap) ([]WorkspacesUser, error) {
	rows, err := q.query(ctx, q.getWorkspaceUserByUserIDStmt, getWorkspaceUserByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WorkspacesUser{}
	for rows.Next() {
		var i WorkspacesUser
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.UserID,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspaceUserByWorkspaceID = `-- name: GetWorkspaceUserByWorkspaceID :many
SELECT
  id,
  workspace_id,
  user_id,
  role
FROM
  workspaces_users
WHERE
  workspace_id = ?
`

func (q *Queries) GetWorkspaceUserByWorkspaceID(ctx context.Context, workspaceID idwrap.IDWrap) ([]WorkspacesUser, error) {
	rows, err := q.query(ctx, q.getWorkspaceUserByWorkspaceIDStmt, getWorkspaceUserByWorkspaceID, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WorkspacesUser{}
	for rows.Next() {
		var i WorkspacesUser
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.UserID,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspaceUserByWorkspaceIDAndUserID = `-- name: GetWorkspaceUserByWorkspaceIDAndUserID :one
SELECT
  id,
  workspace_id,
  user_id,
  role
FROM
  workspaces_users
WHERE
  workspace_id = ?
  AND user_id = ?
LIMIT
  1
`

type GetWorkspaceUserByWorkspaceIDAndUserIDParams struct {
	WorkspaceID idwrap.IDWrap
	UserID      idwrap.IDWrap
}

func (q *Queries) GetWorkspaceUserByWorkspaceIDAndUserID(ctx context.Context, arg GetWorkspaceUserByWorkspaceIDAndUserIDParams) (WorkspacesUser, error) {
	row := q.queryRow(ctx, q.getWorkspaceUserByWorkspaceIDAndUserIDStmt, getWorkspaceUserByWorkspaceIDAndUserID, arg.WorkspaceID, arg.UserID)
	var i WorkspacesUser
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.UserID,
		&i.Role,
	)
	return i, err
}

const getWorkspacesByUserID = `-- name: GetWorkspacesByUserID :many
SELECT
  id,
  name,
  updated,
  collection_count,
  flow_count,
  active_env,
  global_env,
  prev,
  next
FROM
  workspaces
WHERE
  id IN (
    SELECT
      workspace_id
    FROM
      workspaces_users
    WHERE
      user_id = ?
  )
`

func (q *Queries) GetWorkspacesByUserID(ctx context.Context, userID idwrap.IDWrap) ([]Workspace, error) {
	rows, err := q.query(ctx, q.getWorkspacesByUserIDStmt, getWorkspacesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Workspace{}
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Updated,
			&i.CollectionCount,
			&i.FlowCount,
			&i.ActiveEnv,
			&i.GlobalEnv,
			&i.Prev,
			&i.Next,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspacesByUserIDOrdered = `-- name: GetWorkspacesByUserIDOrdered :many
WITH RECURSIVE ordered_workspaces AS (
  -- Base case: Find the head (prev IS NULL) for this user
  SELECT
    w.id,
    w.name,
    w.updated,
    w.collection_count,
    w.flow_count,
    w.active_env,
    w.global_env,
    w.prev,
    w.next,
    0 as position
  FROM
    workspaces w
  INNER JOIN workspaces_users wu ON w.id = wu.workspace_id
  WHERE
    wu.user_id = ? AND
    w.prev IS NULL
  
  UNION ALL
  
  -- Recursive case: Follow the next pointers
  SELECT
    w.id,
    w.name,
    w.updated,
    w.collection_count,
    w.flow_count,
    w.active_env,
    w.global_env,
    w.prev,
    w.next,
    ow.position + 1
  FROM
    workspaces w
  INNER JOIN workspaces_users wu ON w.id = wu.workspace_id
  INNER JOIN ordered_workspaces ow ON w.prev = ow.id
  WHERE
    wu.user_id = ?
)
SELECT
  ow.id,
  ow.name,
  ow.updated,
  ow.collection_count,
  ow.flow_count,
  ow.active_env,
  ow.global_env,
  ow.prev,
  ow.next,
  ow.position
FROM
  ordered_workspaces ow
ORDER BY
  ow.position
`

type GetWorkspacesByUserIDOrderedParams struct {
	UserID   idwrap.IDWrap
	UserID_2 idwrap.IDWrap
}

type GetWorkspacesByUserIDOrderedRow struct {
	ID              []byte
	Name            string
	Updated         int64
	CollectionCount int32
	FlowCount       int32
	ActiveEnv       []byte
	GlobalEnv       []byte
	Prev            []byte
	Next            []byte
	Position        int64
}

// Uses WITH RECURSIVE CTE to traverse linked list from head to tail for user-scoped ordering
// Each user has their own workspace ordering maintained via workspaces_users table
func (q *Queries) GetWorkspacesByUserIDOrdered(ctx context.Context, arg GetWorkspacesByUserIDOrderedParams) ([]GetWorkspacesByUserIDOrderedRow, error) {
	rows, err := q.query(ctx, q.getWorkspacesByUserIDOrderedStmt, getWorkspacesByUserIDOrdered, arg.UserID, arg.UserID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWorkspacesByUserIDOrderedRow{}
	for rows.Next() {
		var i GetWorkspacesByUserIDOrderedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Updated,
			&i.CollectionCount,
			&i.FlowCount,
			&i.ActiveEnv,
			&i.GlobalEnv,
			&i.Prev,
			&i.Next,
			&i.Position,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWorkspace = `-- name: UpdateWorkspace :exec
UPDATE workspaces
SET
  name = ?,
  collection_count = ?,
  flow_count = ?,
  updated = ?,
  active_env = ?
WHERE
  id = ?
`

type UpdateWorkspaceParams struct {
	Name            string
	CollectionCount int32
	FlowCount       int32
	Updated         int64
	ActiveEnv       idwrap.IDWrap
	ID              idwrap.IDWrap
}

func (q *Queries) UpdateWorkspace(ctx context.Context, arg UpdateWorkspaceParams) error {
	_, err := q.exec(ctx, q.updateWorkspaceStmt, updateWorkspace,
		arg.Name,
		arg.CollectionCount,
		arg.FlowCount,
		arg.Updated,
		arg.ActiveEnv,
		arg.ID,
	)
	return err
}

const updateWorkspaceNext = `-- name: UpdateWorkspaceNext :exec
UPDATE workspaces
SET
  next = ?
WHERE
  workspaces.id = ? AND
  workspaces.id IN (
    SELECT wu.workspace_id 
    FROM workspaces_users wu
    WHERE wu.user_id = ?
  )
`

type UpdateWorkspaceNextParams struct {
	Next   *idwrap.IDWrap
	ID     idwrap.IDWrap
	UserID idwrap.IDWrap
}

// Update only the next pointer for a workspace with user validation (used in deletion)
func (q *Queries) UpdateWorkspaceNext(ctx context.Context, arg UpdateWorkspaceNextParams) error {
	_, err := q.exec(ctx, q.updateWorkspaceNextStmt, updateWorkspaceNext, arg.Next, arg.ID, arg.UserID)
	return err
}

const updateWorkspaceOrder = `-- name: UpdateWorkspaceOrder :exec
UPDATE workspaces
SET
  prev = ?,
  next = ?
WHERE
  workspaces.id = ? AND
  workspaces.id IN (
    SELECT wu.workspace_id 
    FROM workspaces_users wu
    WHERE wu.user_id = ?
  )
`

type UpdateWorkspaceOrderParams struct {
	Prev   *idwrap.IDWrap
	Next   *idwrap.IDWrap
	ID     idwrap.IDWrap
	UserID idwrap.IDWrap
}

// Update the prev/next pointers for a single workspace with user validation
// Used for moving workspaces within the user's linked list
func (q *Queries) UpdateWorkspaceOrder(ctx context.Context, arg UpdateWorkspaceOrderParams) error {
	_, err := q.exec(ctx, q.updateWorkspaceOrderStmt, updateWorkspaceOrder,
		arg.Prev,
		arg.Next,
		arg.ID,
		arg.UserID,
	)
	return err
}

const updateWorkspacePrev = `-- name: UpdateWorkspacePrev :exec
UPDATE workspaces
SET
  prev = ?
WHERE
  workspaces.id = ? AND
  workspaces.id IN (
    SELECT wu.workspace_id 
    FROM workspaces_users wu
    WHERE wu.user_id = ?
  )
`

type UpdateWorkspacePrevParams struct {
	Prev   *idwrap.IDWrap
	ID     idwrap.IDWrap
	UserID idwrap.IDWrap
}

// Update only the prev pointer for a workspace with user validation (used in deletion)
func (q *Queries) UpdateWorkspacePrev(ctx context.Context, arg UpdateWorkspacePrevParams) error {
	_, err := q.exec(ctx, q.updateWorkspacePrevStmt, updateWorkspacePrev, arg.Prev, arg.ID, arg.UserID)
	return err
}

const updateWorkspaceUpdatedTime = `-- name: UpdateWorkspaceUpdatedTime :exec
UPDATE workspaces
SET
  updated = ?
WHERE
  id = ?
`

type UpdateWorkspaceUpdatedTimeParams struct {
	Updated int64
	ID      idwrap.IDWrap
}

func (q *Queries) UpdateWorkspaceUpdatedTime(ctx context.Context, arg UpdateWorkspaceUpdatedTimeParams) error {
	_, err := q.exec(ctx, q.updateWorkspaceUpdatedTimeStmt, updateWorkspaceUpdatedTime, arg.Updated, arg.ID)
	return err
}

const updateWorkspaceUser = `-- name: UpdateWorkspaceUser :exec
UPDATE workspaces_users
SET
  workspace_id = ?,
  user_id = ?,
  role = ?
WHERE
  id = ?
`

type UpdateWorkspaceUserParams struct {
	WorkspaceID idwrap.IDWrap
	UserID      idwrap.IDWrap
	Role        int8
	ID          idwrap.IDWrap
}

func (q *Queries) UpdateWorkspaceUser(ctx context.Context, arg UpdateWorkspaceUserParams) error {
	_, err := q.exec(ctx, q.updateWorkspaceUserStmt, updateWorkspaceUser,
		arg.WorkspaceID,
		arg.UserID,
		arg.Role,
		arg.ID,
	)
	return err
}
